"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xmlhttprequest-ssl";
exports.ids = ["vendor-chunks/xmlhttprequest-ssl"];
exports.modules = {
  /***/ "(ssr)/../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js":
    /*!****************************************************************!*\
  !*** ../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js ***!
  \****************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      eval(
        '/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */ \nvar fs = __webpack_require__(/*! fs */ "fs");\nvar Url = __webpack_require__(/*! url */ "url");\nvar spawn = (__webpack_require__(/*! child_process */ "child_process").spawn);\n/**\n * Module exports.\n */ module.exports = XMLHttpRequest;\n// backwards-compat\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if \'undefined\', agent usage is disabled\n *\n * @param {Object} opts optional "options" object\n */ function XMLHttpRequest(opts) {\n    "use strict";\n    opts = opts || {};\n    /**\n   * Private variables\n   */ var self = this;\n    var http = __webpack_require__(/*! http */ "http");\n    var https = __webpack_require__(/*! https */ "https");\n    // Holds http.js objects\n    var request;\n    var response;\n    // Request settings\n    var settings = {};\n    // Disable header blacklist.\n    // Not part of XHR specs.\n    var disableHeaderCheck = false;\n    // Set some default headers\n    var defaultHeaders = {\n        "User-Agent": "node-XMLHttpRequest",\n        "Accept": "*/*"\n    };\n    var headers = Object.assign({}, defaultHeaders);\n    // These headers are not user setable.\n    // The following are allowed but banned in the spec:\n    // * user-agent\n    var forbiddenRequestHeaders = [\n        "accept-charset",\n        "accept-encoding",\n        "access-control-request-headers",\n        "access-control-request-method",\n        "connection",\n        "content-length",\n        "content-transfer-encoding",\n        "cookie",\n        "cookie2",\n        "date",\n        "expect",\n        "host",\n        "keep-alive",\n        "origin",\n        "referer",\n        "te",\n        "trailer",\n        "transfer-encoding",\n        "upgrade",\n        "via"\n    ];\n    // These request methods are not allowed\n    var forbiddenRequestMethods = [\n        "TRACE",\n        "TRACK",\n        "CONNECT"\n    ];\n    // Send flag\n    var sendFlag = false;\n    // Error flag, used when errors occur or abort is called\n    var errorFlag = false;\n    var abortedFlag = false;\n    // Event listeners\n    var listeners = {};\n    /**\n   * Constants\n   */ this.UNSENT = 0;\n    this.OPENED = 1;\n    this.HEADERS_RECEIVED = 2;\n    this.LOADING = 3;\n    this.DONE = 4;\n    /**\n   * Public vars\n   */ // Current state\n    this.readyState = this.UNSENT;\n    // default ready state change handler in case one is not set or is set late\n    this.onreadystatechange = null;\n    // Result & response\n    this.responseText = "";\n    this.responseXML = "";\n    this.status = null;\n    this.statusText = null;\n    /**\n   * Private methods\n   */ /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpHeader = function(header) {\n        return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n    };\n    /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpMethod = function(method) {\n        return method && forbiddenRequestMethods.indexOf(method) === -1;\n    };\n    /**\n   * Public methods\n   */ /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */ this.open = function(method, url, async, user, password) {\n        this.abort();\n        errorFlag = false;\n        abortedFlag = false;\n        // Check for valid request method\n        if (!isAllowedHttpMethod(method)) {\n            throw new Error("SecurityError: Request method not allowed");\n        }\n        settings = {\n            "method": method,\n            "url": url.toString(),\n            "async": typeof async !== "boolean" ? true : async,\n            "user": user || null,\n            "password": password || null\n        };\n        setState(this.OPENED);\n    };\n    /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */ this.setDisableHeaderCheck = function(state) {\n        disableHeaderCheck = state;\n    };\n    /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */ this.setRequestHeader = function(header, value) {\n        if (this.readyState != this.OPENED) {\n            throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");\n        }\n        if (!isAllowedHttpHeader(header)) {\n            console.warn(\'Refused to set unsafe header "\' + header + \'"\');\n            return false;\n        }\n        if (sendFlag) {\n            throw new Error("INVALID_STATE_ERR: send flag is true");\n        }\n        headers[header] = value;\n        return true;\n    };\n    /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn\'t exist.\n   */ this.getResponseHeader = function(header) {\n        if (typeof header === "string" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {\n            return response.headers[header.toLowerCase()];\n        }\n        return null;\n    };\n    /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */ this.getAllResponseHeaders = function() {\n        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n            return "";\n        }\n        var result = "";\n        for(var i in response.headers){\n            // Cookie headers are excluded\n            if (i !== "set-cookie" && i !== "set-cookie2") {\n                result += i + ": " + response.headers[i] + "\\r\\n";\n            }\n        }\n        return result.substr(0, result.length - 2);\n    };\n    /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */ this.getRequestHeader = function(name) {\n        // @TODO Make this case insensitive\n        if (typeof name === "string" && headers[name]) {\n            return headers[name];\n        }\n        return "";\n    };\n    /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */ this.send = function(data) {\n        if (this.readyState != this.OPENED) {\n            throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");\n        }\n        if (sendFlag) {\n            throw new Error("INVALID_STATE_ERR: send has already been called");\n        }\n        var ssl = false, local = false;\n        var url = Url.parse(settings.url);\n        var host;\n        // Determine the server\n        switch(url.protocol){\n            case "https:":\n                ssl = true;\n            // SSL & non-SSL both need host, no break here.\n            case "http:":\n                host = url.hostname;\n                break;\n            case "file:":\n                local = true;\n                break;\n            case undefined:\n            case "":\n                host = "localhost";\n                break;\n            default:\n                throw new Error("Protocol not supported.");\n        }\n        // Load files off the local filesystem (file://)\n        if (local) {\n            if (settings.method !== "GET") {\n                throw new Error("XMLHttpRequest: Only GET method is supported");\n            }\n            if (settings.async) {\n                fs.readFile(unescape(url.pathname), "utf8", function(error, data) {\n                    if (error) {\n                        self.handleError(error, error.errno || -1);\n                    } else {\n                        self.status = 200;\n                        self.responseText = data;\n                        setState(self.DONE);\n                    }\n                });\n            } else {\n                try {\n                    this.responseText = fs.readFileSync(unescape(url.pathname), "utf8");\n                    this.status = 200;\n                    setState(self.DONE);\n                } catch (e) {\n                    this.handleError(e, e.errno || -1);\n                }\n            }\n            return;\n        }\n        // Default to port 80. If accessing localhost on another port be sure\n        // to use http://localhost:port/path\n        var port = url.port || (ssl ? 443 : 80);\n        // Add query string if one is used\n        var uri = url.pathname + (url.search ? url.search : "");\n        // Set the Host header or the server may reject the request\n        headers["Host"] = host;\n        if (!(ssl && port === 443 || port === 80)) {\n            headers["Host"] += ":" + url.port;\n        }\n        // Set Basic Auth if necessary\n        if (settings.user) {\n            if (typeof settings.password == "undefined") {\n                settings.password = "";\n            }\n            var authBuf = new Buffer(settings.user + ":" + settings.password);\n            headers["Authorization"] = "Basic " + authBuf.toString("base64");\n        }\n        // Set content length header\n        if (settings.method === "GET" || settings.method === "HEAD") {\n            data = null;\n        } else if (data) {\n            headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n            if (!headers["Content-Type"]) {\n                headers["Content-Type"] = "text/plain;charset=UTF-8";\n            }\n        } else if (settings.method === "POST") {\n            // For a post with no data set Content-Length: 0.\n            // This is required by buggy servers that don\'t meet the specs.\n            headers["Content-Length"] = 0;\n        }\n        var agent = opts.agent || false;\n        var options = {\n            host: host,\n            port: port,\n            path: uri,\n            method: settings.method,\n            headers: headers,\n            agent: agent\n        };\n        if (ssl) {\n            options.pfx = opts.pfx;\n            options.key = opts.key;\n            options.passphrase = opts.passphrase;\n            options.cert = opts.cert;\n            options.ca = opts.ca;\n            options.ciphers = opts.ciphers;\n            options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n        }\n        // Reset error flag\n        errorFlag = false;\n        // Handle async requests\n        if (settings.async) {\n            // Use the proper protocol\n            var doRequest = ssl ? https.request : http.request;\n            // Request is being sent, set send flag\n            sendFlag = true;\n            // As per spec, this is called here for historical reasons.\n            self.dispatchEvent("readystatechange");\n            // Handler for the response\n            var responseHandler = function(resp) {\n                // Set response var to the response we got back\n                // This is so it remains accessable outside this scope\n                response = resp;\n                // Check for redirect\n                // @TODO Prevent looped redirects\n                if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n                    // Change URL to the redirect location\n                    settings.url = response.headers.location;\n                    var url = Url.parse(settings.url);\n                    // Set host var in case it\'s used later\n                    host = url.hostname;\n                    // Options for the new request\n                    var newOptions = {\n                        hostname: url.hostname,\n                        port: url.port,\n                        path: url.path,\n                        method: response.statusCode === 303 ? "GET" : settings.method,\n                        headers: headers\n                    };\n                    if (ssl) {\n                        newOptions.pfx = opts.pfx;\n                        newOptions.key = opts.key;\n                        newOptions.passphrase = opts.passphrase;\n                        newOptions.cert = opts.cert;\n                        newOptions.ca = opts.ca;\n                        newOptions.ciphers = opts.ciphers;\n                        newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n                    }\n                    // Issue the new request\n                    request = doRequest(newOptions, responseHandler).on("error", errorHandler);\n                    request.end();\n                    // @TODO Check if an XHR event needs to be fired here\n                    return;\n                }\n                if (response && response.setEncoding) {\n                    response.setEncoding("utf8");\n                }\n                setState(self.HEADERS_RECEIVED);\n                self.status = response.statusCode;\n                response.on("data", function(chunk) {\n                    // Make sure there\'s some data\n                    if (chunk) {\n                        self.responseText += chunk;\n                    }\n                    // Don\'t emit state changes if the connection has been aborted.\n                    if (sendFlag) {\n                        setState(self.LOADING);\n                    }\n                });\n                response.on("end", function() {\n                    if (sendFlag) {\n                        // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n                        // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n                        sendFlag = false;\n                        // Discard the \'end\' event if the connection has been aborted\n                        setState(self.DONE);\n                    }\n                });\n                response.on("error", function(error) {\n                    self.handleError(error);\n                });\n            };\n            // Error handler for the request\n            var errorHandler = function(error) {\n                self.handleError(error);\n            };\n            // Create the request\n            request = doRequest(options, responseHandler).on("error", errorHandler);\n            if (opts.autoUnref) {\n                request.on("socket", (socket)=>{\n                    socket.unref();\n                });\n            }\n            // Node 0.4 and later won\'t accept empty data. Make sure it\'s needed.\n            if (data) {\n                request.write(data);\n            }\n            request.end();\n            self.dispatchEvent("loadstart");\n        } else {\n            // Create a temporary file for communication with the other Node process\n            var contentFile = ".node-xmlhttprequest-content-" + process.pid;\n            var syncFile = ".node-xmlhttprequest-sync-" + process.pid;\n            fs.writeFileSync(syncFile, "", "utf8");\n            // The async request the other Node process executes\n            var execString = "var http = require(\'http\'), https = require(\'https\'), fs = require(\'fs\');" + "var doRequest = http" + (ssl ? "s" : "") + ".request;" + "var options = " + JSON.stringify(options) + ";" + "var responseText = \'\';" + "var req = doRequest(options, function(response) {" + "response.setEncoding(\'utf8\');" + "response.on(\'data\', function(chunk) {" + "  responseText += chunk;" + "});" + "response.on(\'end\', function() {" + "fs.writeFileSync(\'" + contentFile + "\', \'NODE-XMLHTTPREQUEST-STATUS:\' + response.statusCode + \',\' + responseText, \'utf8\');" + "fs.unlinkSync(\'" + syncFile + "\');" + "});" + "response.on(\'error\', function(error) {" + "fs.writeFileSync(\'" + contentFile + "\', \'NODE-XMLHTTPREQUEST-ERROR:\' + JSON.stringify(error), \'utf8\');" + "fs.unlinkSync(\'" + syncFile + "\');" + "});" + "}).on(\'error\', function(error) {" + "fs.writeFileSync(\'" + contentFile + "\', \'NODE-XMLHTTPREQUEST-ERROR:\' + JSON.stringify(error), \'utf8\');" + "fs.unlinkSync(\'" + syncFile + "\');" + "});" + (data ? "req.write(\'" + JSON.stringify(data).slice(1, -1).replace(/\'/g, "\\\\\'") + "\');" : "") + "req.end();";\n            // Start the other Node Process, executing this string\n            var syncProc = spawn(process.argv[0], [\n                "-e",\n                execString\n            ]);\n            var statusText;\n            while(fs.existsSync(syncFile)){\n            // Wait while the sync file is empty\n            }\n            self.responseText = fs.readFileSync(contentFile, "utf8");\n            // Kill the child process once the file has data\n            syncProc.stdin.end();\n            // Remove the temporary file\n            fs.unlinkSync(contentFile);\n            if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n                // If the file returned an error, handle it\n                var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");\n                self.handleError(errorObj, 503);\n            } else {\n                // If the file returned okay, parse its data and move to the DONE state\n                self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");\n                self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");\n                setState(self.DONE);\n            }\n        }\n    };\n    /**\n   * Called when an error is encountered to deal with it.\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\n   */ this.handleError = function(error, status) {\n        this.status = status || 0;\n        this.statusText = error;\n        this.responseText = error.stack;\n        errorFlag = true;\n        setState(this.DONE);\n    };\n    /**\n   * Aborts a request.\n   */ this.abort = function() {\n        if (request) {\n            request.abort();\n            request = null;\n        }\n        headers = Object.assign({}, defaultHeaders);\n        this.responseText = "";\n        this.responseXML = "";\n        errorFlag = abortedFlag = true;\n        if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n            sendFlag = false;\n            setState(this.DONE);\n        }\n        this.readyState = this.UNSENT;\n    };\n    /**\n   * Adds an event listener. Preferred method of binding to events.\n   */ this.addEventListener = function(event, callback) {\n        if (!(event in listeners)) {\n            listeners[event] = [];\n        }\n        // Currently allows duplicate callbacks. Should it?\n        listeners[event].push(callback);\n    };\n    /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */ this.removeEventListener = function(event, callback) {\n        if (event in listeners) {\n            // Filter will return a new array with the callback removed\n            listeners[event] = listeners[event].filter(function(ev) {\n                return ev !== callback;\n            });\n        }\n    };\n    /**\n   * Dispatch any events, including both "on" methods and events attached using addEventListener.\n   */ this.dispatchEvent = function(event) {\n        if (typeof self["on" + event] === "function") {\n            if (this.readyState === this.DONE) setImmediate(function() {\n                self["on" + event]();\n            });\n            else self["on" + event]();\n        }\n        if (event in listeners) {\n            for(let i = 0, len = listeners[event].length; i < len; i++){\n                if (this.readyState === this.DONE) setImmediate(function() {\n                    listeners[event][i].call(self);\n                });\n                else listeners[event][i].call(self);\n            }\n        }\n    };\n    /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */ var setState = function(state) {\n        if (self.readyState === state || self.readyState === self.UNSENT && abortedFlag) return;\n        self.readyState = state;\n        if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n            self.dispatchEvent("readystatechange");\n        }\n        if (self.readyState === self.DONE) {\n            let fire;\n            if (abortedFlag) fire = "abort";\n            else if (errorFlag) fire = "error";\n            else fire = "load";\n            self.dispatchEvent(fire);\n            // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n            self.dispatchEvent("loadend");\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3htbGh0dHByZXF1ZXN0LXNzbC9saWIvWE1MSHR0cFJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0NBV0M7QUFFRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNsQixJQUFJRSxRQUFRRixpRUFBOEI7QUFFMUM7O0NBRUMsR0FFREcsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixtQkFBbUI7QUFDbkJBLGVBQWVBLGNBQWMsR0FBR0E7QUFFaEM7Ozs7Ozs7O0NBUUMsR0FFRCxTQUFTQSxlQUFlQyxJQUFJO0lBQzFCO0lBRUFBLE9BQU9BLFFBQVEsQ0FBQztJQUVoQjs7R0FFQyxHQUNELElBQUlDLE9BQU8sSUFBSTtJQUNmLElBQUlDLE9BQU9SLG1CQUFPQSxDQUFDO0lBQ25CLElBQUlTLFFBQVFULG1CQUFPQSxDQUFDO0lBRXBCLHdCQUF3QjtJQUN4QixJQUFJVTtJQUNKLElBQUlDO0lBRUosbUJBQW1CO0lBQ25CLElBQUlDLFdBQVcsQ0FBQztJQUVoQiw0QkFBNEI7SUFDNUIseUJBQXlCO0lBQ3pCLElBQUlDLHFCQUFxQjtJQUV6QiwyQkFBMkI7SUFDM0IsSUFBSUMsaUJBQWlCO1FBQ25CLGNBQWM7UUFDZCxVQUFVO0lBQ1o7SUFFQSxJQUFJQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSDtJQUVoQyxzQ0FBc0M7SUFDdEMsb0RBQW9EO0lBQ3BELGVBQWU7SUFDZixJQUFJSSwwQkFBMEI7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsd0NBQXdDO0lBQ3hDLElBQUlDLDBCQUEwQjtRQUM1QjtRQUNBO1FBQ0E7S0FDRDtJQUVELFlBQVk7SUFDWixJQUFJQyxXQUFXO0lBQ2Ysd0RBQXdE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LE9BQU87aUJBQ0osSUFBSXpILFdBQ1B5SCxPQUFPO2lCQUVQQSxPQUFPO1lBRVR2SSxLQUFLNEYsYUFBYSxDQUFDMkM7WUFFbkIsZ0VBQWdFO1lBQ2hFdkksS0FBSzRGLGFBQWEsQ0FBQztRQUNyQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNraHViYi8uLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3Qtc3NsL2xpYi9YTUxIdHRwUmVxdWVzdC5qcz85MjFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV3JhcHBlciBmb3IgYnVpbHQtaW4gaHR0cC5qcyB0byBlbXVsYXRlIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcbiAqIGFsbG93IHRoZSB1c2Ugb2YgZXhpc3RpbmcgbGlicmFyaWVzLlxuICpcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxuICpcbiAqIEBhdXRob3IgRGFuIERlRmVsaXBwaSA8ZGFuQGRyaXZlcmRhbi5jb20+XG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgVXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcblxuLy8gYmFja3dhcmRzLWNvbXBhdFxuWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcblxuLyoqXG4gKiBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGZvciB0aGUgYG9wdHNgIG9iamVjdCBhcmU6XG4gKlxuICogIC0gYGFnZW50YDogQW4gaHR0cC5BZ2VudCBpbnN0YW5jZTsgaHR0cC5nbG9iYWxBZ2VudCBtYXkgYmUgdXNlZDsgaWYgJ3VuZGVmaW5lZCcsIGFnZW50IHVzYWdlIGlzIGRpc2FibGVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9uYWwgXCJvcHRpb25zXCIgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAvKipcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG4gIHZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXG4gIHZhciByZXF1ZXN0O1xuICB2YXIgcmVzcG9uc2U7XG5cbiAgLy8gUmVxdWVzdCBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSB7fTtcblxuICAvLyBEaXNhYmxlIGhlYWRlciBibGFja2xpc3QuXG4gIC8vIE5vdCBwYXJ0IG9mIFhIUiBzcGVjcy5cbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xuXG4gIC8vIFNldCBzb21lIGRlZmF1bHQgaGVhZGVyc1xuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJVc2VyLUFnZW50XCI6IFwibm9kZS1YTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiQWNjZXB0XCI6IFwiKi8qXCJcbiAgfTtcblxuICB2YXIgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIZWFkZXJzKTtcblxuICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBub3QgdXNlciBzZXRhYmxlLlxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSBhbGxvd2VkIGJ1dCBiYW5uZWQgaW4gdGhlIHNwZWM6XG4gIC8vICogdXNlci1hZ2VudFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ2aWFcIlxuICBdO1xuXG4gIC8vIFRoZXNlIHJlcXVlc3QgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWRcbiAgdmFyIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzID0gW1xuICAgIFwiVFJBQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJDT05ORUNUXCJcbiAgXTtcblxuICAvLyBTZW5kIGZsYWdcbiAgdmFyIHNlbmRGbGFnID0gZmFsc2U7XG4gIC8vIEVycm9yIGZsYWcsIHVzZWQgd2hlbiBlcnJvcnMgb2NjdXIgb3IgYWJvcnQgaXMgY2FsbGVkXG4gIHZhciBlcnJvckZsYWcgPSBmYWxzZTtcbiAgdmFyIGFib3J0ZWRGbGFnID0gZmFsc2U7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIHRoaXMuVU5TRU5UID0gMDtcbiAgdGhpcy5PUEVORUQgPSAxO1xuICB0aGlzLkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuICB0aGlzLkxPQURJTkcgPSAzO1xuICB0aGlzLkRPTkUgPSA0O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgdmFyc1xuICAgKi9cblxuICAvLyBDdXJyZW50IHN0YXRlXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UO1xuXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxuICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcbiAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcbiAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICB2YXIgaXNBbGxvd2VkSHR0cEhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHJldHVybiBkaXNhYmxlSGVhZGVyQ2hlY2sgfHwgKGhlYWRlciAmJiBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycy5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIG1ldGhvZCBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICB2YXIgaXNBbGxvd2VkSHR0cE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHJldHVybiAobWV0aG9kICYmIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogT3BlbiB0aGUgY29ubmVjdGlvbi4gQ3VycmVudGx5IHN1cHBvcnRzIGxvY2FsIHNlcnZlciByZXF1ZXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgQ29ubmVjdGlvbiBtZXRob2QgKGVnIEdFVCwgUE9TVClcbiAgICogQHBhcmFtIHN0cmluZyB1cmwgVVJMIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIGJvb2xlYW4gYXN5bmMgQXN5bmNocm9ub3VzIGNvbm5lY3Rpb24uIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHN0cmluZyB1c2VyIFVzZXJuYW1lIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBzdHJpbmcgcGFzc3dvcmQgUGFzc3dvcmQgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICovXG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgZXJyb3JGbGFnID0gZmFsc2U7XG4gICAgYWJvcnRlZEZsYWcgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciB2YWxpZCByZXF1ZXN0IG1ldGhvZFxuICAgIGlmICghaXNBbGxvd2VkSHR0cE1ldGhvZChtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZFwiKTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgIFwidXJsXCI6IHVybC50b1N0cmluZygpLFxuICAgICAgXCJhc3luY1wiOiAodHlwZW9mIGFzeW5jICE9PSBcImJvb2xlYW5cIiA/IHRydWUgOiBhc3luYyksXG4gICAgICBcInVzZXJcIjogdXNlciB8fCBudWxsLFxuICAgICAgXCJwYXNzd29yZFwiOiBwYXNzd29yZCB8fCBudWxsXG4gICAgfTtcblxuICAgIHNldFN0YXRlKHRoaXMuT1BFTkVEKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtIGJvb2xlYW4gc3RhdGUgRW5hYmxlIG9yIGRpc2FibGUgaGVhZGVyIGNoZWNraW5nLlxuICAgKi9cbiAgdGhpcy5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGRpc2FibGVIZWFkZXJDaGVjayA9IHN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHN0cmluZyB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAgICogQHJldHVybiBib29sZWFuIEhlYWRlciBhZGRlZFxuICAgKi9cbiAgdGhpcy5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZXRSZXF1ZXN0SGVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHN0YXRlIGlzIE9QRU5cIik7XG4gICAgfVxuICAgIGlmICghaXNBbGxvd2VkSHR0cEhlYWRlcihoZWFkZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXCInICsgaGVhZGVyICsgJ1wiJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgZmxhZyBpcyB0cnVlXCIpO1xuICAgIH1cbiAgICBoZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIE5hbWUgb2YgaGVhZGVyIHRvIGdldC5cbiAgICogQHJldHVybiBzdHJpbmcgVGV4dCBvZiB0aGUgaGVhZGVyIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGhlYWRlciA9PT0gXCJzdHJpbmdcIlxuICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlID4gdGhpcy5PUEVORURcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgICAmJiAhZXJyb3JGbGFnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxuICAgKi9cbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAvLyBDb29raWUgaGVhZGVycyBhcmUgZXhjbHVkZWRcbiAgICAgIGlmIChpICE9PSBcInNldC1jb29raWVcIiAmJiBpICE9PSBcInNldC1jb29raWUyXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIjogXCIgKyByZXNwb25zZS5oZWFkZXJzW2ldICsgXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBuYW1lIE5hbWUgb2YgaGVhZGVyIHRvIGdldFxuICAgKiBAcmV0dXJuIHN0cmluZyBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIC8vIEBUT0RPIE1ha2UgdGhpcyBjYXNlIGluc2Vuc2l0aXZlXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIGhlYWRlcnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGRhdGEgT3B0aW9uYWwgZGF0YSB0byBzZW5kIGFzIHJlcXVlc3QgYm9keS5cbiAgICovXG4gIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogY29ubmVjdGlvbiBtdXN0IGJlIG9wZW5lZCBiZWZvcmUgc2VuZCgpIGlzIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBzc2wgPSBmYWxzZSwgbG9jYWwgPSBmYWxzZTtcbiAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XG4gICAgdmFyIGhvc3Q7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzZXJ2ZXJcbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgc3NsID0gdHJ1ZTtcbiAgICAgICAgLy8gU1NMICYgbm9uLVNTTCBib3RoIG5lZWQgaG9zdCwgbm8gYnJlYWsgaGVyZS5cbiAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2ZpbGU6JzpcbiAgICAgICAgbG9jYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICcnOlxuICAgICAgICBob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cblxuICAgIC8vIExvYWQgZmlsZXMgb2ZmIHRoZSBsb2NhbCBmaWxlc3lzdGVtIChmaWxlOi8vKVxuICAgIGlmIChsb2NhbCkge1xuICAgICAgaWYgKHNldHRpbmdzLm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdDogT25seSBHRVQgbWV0aG9kIGlzIHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHVuZXNjYXBlKHVybC5wYXRobmFtZSksICd1dGY4JywgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IsIGVycm9yLmVycm5vIHx8IC0xKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IGRhdGE7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKHVuZXNjYXBlKHVybC5wYXRobmFtZSksICd1dGY4Jyk7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlLCBlLmVycm5vIHx8IC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBwb3J0IDgwLiBJZiBhY2Nlc3NpbmcgbG9jYWxob3N0IG9uIGFub3RoZXIgcG9ydCBiZSBzdXJlXG4gICAgLy8gdG8gdXNlIGh0dHA6Ly9sb2NhbGhvc3Q6cG9ydC9wYXRoXG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydCB8fCAoc3NsID8gNDQzIDogODApO1xuICAgIC8vIEFkZCBxdWVyeSBzdHJpbmcgaWYgb25lIGlzIHVzZWRcbiAgICB2YXIgdXJpID0gdXJsLnBhdGhuYW1lICsgKHVybC5zZWFyY2ggPyB1cmwuc2VhcmNoIDogJycpO1xuXG4gICAgLy8gU2V0IHRoZSBIb3N0IGhlYWRlciBvciB0aGUgc2VydmVyIG1heSByZWplY3QgdGhlIHJlcXVlc3RcbiAgICBoZWFkZXJzW1wiSG9zdFwiXSA9IGhvc3Q7XG4gICAgaWYgKCEoKHNzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xuICAgICAgaGVhZGVyc1tcIkhvc3RcIl0gKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgfVxuXG4gICAgLy8gU2V0IEJhc2ljIEF1dGggaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHNldHRpbmdzLnVzZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucGFzc3dvcmQgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXR0aW5ncy5wYXNzd29yZCA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgYXV0aEJ1ZiA9IG5ldyBCdWZmZXIoc2V0dGluZ3MudXNlciArIFwiOlwiICsgc2V0dGluZ3MucGFzc3dvcmQpO1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiICsgYXV0aEJ1Zi50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29udGVudCBsZW5ndGggaGVhZGVyXG4gICAgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBzZXR0aW5ncy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmICghaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkge1xuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICAgIC8vIEZvciBhIHBvc3Qgd2l0aCBubyBkYXRhIHNldCBDb250ZW50LUxlbmd0aDogMC5cbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgYnVnZ3kgc2VydmVycyB0aGF0IGRvbid0IG1lZXQgdGhlIHNwZWNzLlxuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gMDtcbiAgICB9XG5cbiAgICB2YXIgYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogaG9zdCxcbiAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICBwYXRoOiB1cmksXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogYWdlbnRcbiAgICB9O1xuXG4gICAgaWYgKHNzbCkge1xuICAgICAgb3B0aW9ucy5wZnggPSBvcHRzLnBmeDtcbiAgICAgIG9wdGlvbnMua2V5ID0gb3B0cy5rZXk7XG4gICAgICBvcHRpb25zLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gICAgICBvcHRpb25zLmNlcnQgPSBvcHRzLmNlcnQ7XG4gICAgICBvcHRpb25zLmNhID0gb3B0cy5jYTtcbiAgICAgIG9wdGlvbnMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcbiAgICAvLyBIYW5kbGUgYXN5bmMgcmVxdWVzdHNcbiAgICBpZiAoc2V0dGluZ3MuYXN5bmMpIHtcbiAgICAgIC8vIFVzZSB0aGUgcHJvcGVyIHByb3RvY29sXG4gICAgICB2YXIgZG9SZXF1ZXN0ID0gc3NsID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcblxuICAgICAgLy8gUmVxdWVzdCBpcyBiZWluZyBzZW50LCBzZXQgc2VuZCBmbGFnXG4gICAgICBzZW5kRmxhZyA9IHRydWU7XG5cbiAgICAgIC8vIEFzIHBlciBzcGVjLCB0aGlzIGlzIGNhbGxlZCBoZXJlIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuXG4gICAgICAvLyBIYW5kbGVyIGZvciB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXG4gICAgICAgIC8vIFRoaXMgaXMgc28gaXQgcmVtYWlucyBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBzY29wZVxuICAgICAgICByZXNwb25zZSA9IHJlc3A7XG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxuICAgICAgICAvLyBAVE9ETyBQcmV2ZW50IGxvb3BlZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA3KSB7XG4gICAgICAgICAgLy8gQ2hhbmdlIFVSTCB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb25cbiAgICAgICAgICBzZXR0aW5ncy51cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICAgICAgICAvLyBTZXQgaG9zdCB2YXIgaW4gY2FzZSBpdCdzIHVzZWQgbGF0ZXJcbiAgICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICAgIC8vIE9wdGlvbnMgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXG4gICAgICAgICAgICBtZXRob2Q6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMyA/ICdHRVQnIDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoc3NsKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zLnBmeCA9IG9wdHMucGZ4O1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5rZXkgPSBvcHRzLmtleTtcbiAgICAgICAgICAgIG5ld09wdGlvbnMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2VydCA9IG9wdHMuY2VydDtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2EgPSBvcHRzLmNhO1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChuZXdPcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiBhbiBYSFIgZXZlbnQgbmVlZHMgdG8gYmUgZmlyZWQgaGVyZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zZXRFbmNvZGluZykge1xuICAgICAgICAgIHJlc3BvbnNlLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFN0YXRlKHNlbGYuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgICAgICByZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlJ3Mgc29tZSBkYXRhXG4gICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCArPSBjaHVuaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRG9uJ3QgZW1pdCBzdGF0ZSBjaGFuZ2VzIGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkxPQURJTkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgLy8gVGhlIHNlbmRGbGFnIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgc2V0U3RhdGUgaXMgY2FsbGVkLiAgT3RoZXJ3aXNlIGlmIHdlIGFyZSBjaGFpbmluZyBjYWxsYmFja3NcbiAgICAgICAgICAgIC8vIHRoZXJlIGNhbiBiZSBhIHRpbWluZyBpc3N1ZSAodGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhbmQgYSBuZXcgY2FsbCBpcyBtYWRlIGJlZm9yZSB0aGUgZmxhZyBpcyByZXNldCkuXG4gICAgICAgICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXG4gICAgICBpZiAob3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgcmVxdWVzdC5vbignc29ja2V0JywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgIHNvY2tldC51bnJlZigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmVuZCgpO1xuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfSBlbHNlIHsgLy8gU3luY2hyb25vdXNcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG90aGVyIE5vZGUgcHJvY2Vzc1xuICAgICAgdmFyIGNvbnRlbnRGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1jb250ZW50LVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICB2YXIgc3luY0ZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LXN5bmMtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3luY0ZpbGUsIFwiXCIsIFwidXRmOFwiKTtcbiAgICAgIC8vIFRoZSBhc3luYyByZXF1ZXN0IHRoZSBvdGhlciBOb2RlIHByb2Nlc3MgZXhlY3V0ZXNcbiAgICAgIHZhciBleGVjU3RyaW5nID0gXCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKSwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XCJcbiAgICAgICAgKyBcInZhciBkb1JlcXVlc3QgPSBodHRwXCIgKyAoc3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcbiAgICAgICAgKyBcInZhciBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiXG4gICAgICAgICsgXCJ2YXIgcmVzcG9uc2VUZXh0ID0gJyc7XCJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxuICAgICAgICArIFwicmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1wiXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBjaHVuaztcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOicgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJywnICsgcmVzcG9uc2VUZXh0LCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwifSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6JyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgKGRhdGEgPyBcInJlcS53cml0ZSgnXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKS5zbGljZSgxLC0xKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikgKyBcIicpO1wiOlwiXCIpXG4gICAgICAgICsgXCJyZXEuZW5kKCk7XCI7XG4gICAgICAvLyBTdGFydCB0aGUgb3RoZXIgTm9kZSBQcm9jZXNzLCBleGVjdXRpbmcgdGhpcyBzdHJpbmdcbiAgICAgIHZhciBzeW5jUHJvYyA9IHNwYXduKHByb2Nlc3MuYXJndlswXSwgW1wiLWVcIiwgZXhlY1N0cmluZ10pO1xuICAgICAgdmFyIHN0YXR1c1RleHQ7XG4gICAgICB3aGlsZShmcy5leGlzdHNTeW5jKHN5bmNGaWxlKSkge1xuICAgICAgICAvLyBXYWl0IHdoaWxlIHRoZSBzeW5jIGZpbGUgaXMgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKGNvbnRlbnRGaWxlLCAndXRmOCcpO1xuICAgICAgLy8gS2lsbCB0aGUgY2hpbGQgcHJvY2VzcyBvbmNlIHRoZSBmaWxlIGhhcyBkYXRhXG4gICAgICBzeW5jUHJvYy5zdGRpbi5lbmQoKTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIGZzLnVubGlua1N5bmMoY29udGVudEZpbGUpO1xuICAgICAgaWYgKHNlbGYucmVzcG9uc2VUZXh0Lm1hdGNoKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovKSkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSByZXR1cm5lZCBhbiBlcnJvciwgaGFuZGxlIGl0XG4gICAgICAgIHZhciBlcnJvck9iaiA9IHNlbGYucmVzcG9uc2VUZXh0LnJlcGxhY2UoL15OT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOi8sIFwiXCIpO1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yT2JqLCA1MDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgcmV0dXJuZWQgb2theSwgcGFyc2UgaXRzIGRhdGEgYW5kIG1vdmUgdG8gdGhlIERPTkUgc3RhdGVcbiAgICAgICAgc2VsZi5zdGF0dXMgPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1TVEFUVVM6KFswLTldKiksLiovLCBcIiQxXCIpO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHNlbGYucmVzcG9uc2VUZXh0LnJlcGxhY2UoL15OT0RFLVhNTEhUVFBSRVFVRVNULVNUQVRVUzpbMC05XSosKC4qKS8sIFwiJDFcIik7XG4gICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB0byBkZWFsIHdpdGggaXQuXG4gICAqIEBwYXJhbSAgc3RhdHVzICB7bnVtYmVyfSAgICBIVFRQIHN0YXR1cyBjb2RlIHRvIHVzZSByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCAoMCkgZm9yIFhIUiBlcnJvcnMuXG4gICAqL1xuICB0aGlzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IsIHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzIHx8IDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gZXJyb3I7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBlcnJvci5zdGFjaztcbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuICAgIHNldFN0YXRlKHRoaXMuRE9ORSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QuXG4gICAqL1xuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGVhZGVycyk7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICAgIHRoaXMucmVzcG9uc2VYTUwgPSBcIlwiO1xuXG4gICAgZXJyb3JGbGFnID0gYWJvcnRlZEZsYWcgPSB0cnVlXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcbiAgICAgICAgJiYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQgfHwgc2VuZEZsYWcpXG4gICAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5ET05FKSB7XG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUodGhpcy5ET05FKTtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIuIFByZWZlcnJlZCBtZXRob2Qgb2YgYmluZGluZyB0byBldmVudHMuXG4gICAqL1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShldmVudCBpbiBsaXN0ZW5lcnMpKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIC8vIEN1cnJlbnRseSBhbGxvd3MgZHVwbGljYXRlIGNhbGxiYWNrcy4gU2hvdWxkIGl0P1xuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBjYWxsYmFjayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXG4gICAqIE9ubHkgd29ya3Mgb24gdGhlIG1hdGNoaW5nIGZ1bmNpdG9uLCBjYW5ub3QgYmUgYSBjb3B5LlxuICAgKi9cbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgLy8gRmlsdGVyIHdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGNhbGxiYWNrIHJlbW92ZWRcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbihldikge1xuICAgICAgICByZXR1cm4gZXYgIT09IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhbnkgZXZlbnRzLCBpbmNsdWRpbmcgYm90aCBcIm9uXCIgbWV0aG9kcyBhbmQgZXZlbnRzIGF0dGFjaGVkIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIuXG4gICAqL1xuICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZltcIm9uXCIgKyBldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKVxuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7IHNlbGZbXCJvblwiICsgZXZlbnRdKCkgfSlcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZltcIm9uXCIgKyBldmVudF0oKVxuICAgIH1cbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpXG4gICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkgeyBsaXN0ZW5lcnNbZXZlbnRdW2ldLmNhbGwoc2VsZikgfSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgc3RhdGUgTmV3IHN0YXRlXG4gICAqL1xuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICgoc2VsZi5yZWFkeVN0YXRlID09PSBzdGF0ZSkgfHwgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5VTlNFTlQgJiYgYWJvcnRlZEZsYWcpKVxuICAgICAgcmV0dXJuXG5cbiAgICBzZWxmLnJlYWR5U3RhdGUgPSBzdGF0ZTtcblxuICAgIGlmIChzZXR0aW5ncy5hc3luYyB8fCBzZWxmLnJlYWR5U3RhdGUgPCBzZWxmLk9QRU5FRCB8fCBzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuRE9ORSkge1xuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgIGxldCBmaXJlXG5cbiAgICAgIGlmIChhYm9ydGVkRmxhZylcbiAgICAgICAgZmlyZSA9IFwiYWJvcnRcIlxuICAgICAgZWxzZSBpZiAoZXJyb3JGbGFnKVxuICAgICAgICBmaXJlID0gXCJlcnJvclwiXG4gICAgICBlbHNlXG4gICAgICAgIGZpcmUgPSBcImxvYWRcIlxuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZmlyZSlcblxuICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZGVuZFwiKTtcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsIlVybCIsInNwYXduIiwibW9kdWxlIiwiZXhwb3J0cyIsIlhNTEh0dHBSZXF1ZXN0Iiwib3B0cyIsInNlbGYiLCJodHRwIiwiaHR0cHMiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJzZXR0aW5ncyIsImRpc2FibGVIZWFkZXJDaGVjayIsImRlZmF1bHRIZWFkZXJzIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsImZvcmJpZGRlblJlcXVlc3RIZWFkZXJzIiwiZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMiLCJzZW5kRmxhZyIsImVycm9yRmxhZyIsImFib3J0ZWRGbGFnIiwibGlzdGVuZXJzIiwiVU5TRU5UIiwiT1BFTkVEIiwiSEVBREVSU19SRUNFSVZFRCIsIkxPQURJTkciLCJET05FIiwicmVhZHlTdGF0ZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlWE1MIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImlzQWxsb3dlZEh0dHBIZWFkZXIiLCJoZWFkZXIiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJpc0FsbG93ZWRIdHRwTWV0aG9kIiwibWV0aG9kIiwib3BlbiIsInVybCIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwiYWJvcnQiLCJFcnJvciIsInRvU3RyaW5nIiwic2V0U3RhdGUiLCJzZXREaXNhYmxlSGVhZGVyQ2hlY2siLCJzdGF0ZSIsInNldFJlcXVlc3RIZWFkZXIiLCJ2YWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXN1bHQiLCJpIiwic3Vic3RyIiwibGVuZ3RoIiwiZ2V0UmVxdWVzdEhlYWRlciIsIm5hbWUiLCJzZW5kIiwiZGF0YSIsInNzbCIsImxvY2FsIiwicGFyc2UiLCJob3N0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInVuZGVmaW5lZCIsInJlYWRGaWxlIiwidW5lc2NhcGUiLCJwYXRobmFtZSIsImVycm9yIiwiaGFuZGxlRXJyb3IiLCJlcnJubyIsInJlYWRGaWxlU3luYyIsImUiLCJwb3J0IiwidXJpIiwic2VhcmNoIiwiYXV0aEJ1ZiIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImFnZW50Iiwib3B0aW9ucyIsInBhdGgiLCJwZngiLCJrZXkiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImRvUmVxdWVzdCIsImRpc3BhdGNoRXZlbnQiLCJyZXNwb25zZUhhbmRsZXIiLCJyZXNwIiwic3RhdHVzQ29kZSIsImxvY2F0aW9uIiwibmV3T3B0aW9ucyIsIm9uIiwiZXJyb3JIYW5kbGVyIiwiZW5kIiwic2V0RW5jb2RpbmciLCJjaHVuayIsImF1dG9VbnJlZiIsInNvY2tldCIsInVucmVmIiwid3JpdGUiLCJjb250ZW50RmlsZSIsInByb2Nlc3MiLCJwaWQiLCJzeW5jRmlsZSIsIndyaXRlRmlsZVN5bmMiLCJleGVjU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInNsaWNlIiwicmVwbGFjZSIsInN5bmNQcm9jIiwiYXJndiIsImV4aXN0c1N5bmMiLCJzdGRpbiIsInVubGlua1N5bmMiLCJtYXRjaCIsImVycm9yT2JqIiwic3RhY2siLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJjYWxsYmFjayIsInB1c2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmlsdGVyIiwiZXYiLCJzZXRJbW1lZGlhdGUiLCJsZW4iLCJjYWxsIiwiZmlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\n',
      );

      /***/
    },
};
