"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {
  /***/ "(ssr)/../node_modules/livekit-client/dist/livekit-client.esm.mjs":
    /*!******************************************************************!*\
  !*** ../node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \******************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RoomState: () => (/* binding */ RoomState),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== "default" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== "undefined" ? globalThis :  false ? 0 : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;\n}\nvar loglevel = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(module) {\n    (function(root, definition) {\n        if (module.exports) {\n            module.exports = definition();\n        } else {\n            root.log = definition();\n        }\n    })(commonjsGlobal, function() {\n        // Slightly dubious tricks to cut down minimized file size\n        var noop = function() {};\n        var undefinedType = "undefined";\n        var isIE = "undefined" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n        var logMethods = [\n            "trace",\n            "debug",\n            "info",\n            "warn",\n            "error"\n        ];\n        // Cross-browser bind equivalent that works at least back to IE6\n        function bindMethod(obj, methodName) {\n            var method = obj[methodName];\n            if (typeof method.bind === "function") {\n                return method.bind(obj);\n            } else {\n                try {\n                    return Function.prototype.bind.call(method, obj);\n                } catch (e) {\n                    // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                    return function() {\n                        return Function.prototype.apply.apply(method, [\n                            obj,\n                            arguments\n                        ]);\n                    };\n                }\n            }\n        }\n        // Trace() doesn\'t print the message in IE, so for that case we need to wrap it\n        function traceForIE() {\n            if (console.log) {\n                if (console.log.apply) {\n                    console.log.apply(console, arguments);\n                } else {\n                    // In old IE, native console methods themselves don\'t have apply().\n                    Function.prototype.apply.apply(console.log, [\n                        console,\n                        arguments\n                    ]);\n                }\n            }\n            if (console.trace) console.trace();\n        }\n        // Build the best logging method possible for this env\n        // Wherever possible we want to bind, not wrap, to preserve stack traces\n        function realMethod(methodName) {\n            if (methodName === "debug") {\n                methodName = "log";\n            }\n            if (typeof console === undefinedType) {\n                return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n            } else if (methodName === "trace" && isIE) {\n                return traceForIE;\n            } else if (console[methodName] !== undefined) {\n                return bindMethod(console, methodName);\n            } else if (console.log !== undefined) {\n                return bindMethod(console, "log");\n            } else {\n                return noop;\n            }\n        }\n        // These private functions always need `this` to be set properly\n        function replaceLoggingMethods(level, loggerName) {\n            /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n                var methodName = logMethods[i];\n                this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n            }\n            // Define log.log as an alias for log.debug\n            this.log = this.debug;\n        }\n        // In old IE versions, the console isn\'t present until you first open it.\n        // We build realMethod() replacements here that regenerate logging methods\n        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n            return function() {\n                if (typeof console !== undefinedType) {\n                    replaceLoggingMethods.call(this, level, loggerName);\n                    this[methodName].apply(this, arguments);\n                }\n            };\n        }\n        // By default, we use closely bound real methods wherever possible, and\n        // otherwise we wait for a console to appear, and then try again.\n        function defaultMethodFactory(methodName, level, loggerName) {\n            /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n        }\n        function Logger(name, defaultLevel, factory) {\n            var self1 = this;\n            var currentLevel;\n            defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;\n            var storageKey = "loglevel";\n            if (typeof name === "string") {\n                storageKey += ":" + name;\n            } else if (typeof name === "symbol") {\n                storageKey = undefined;\n            }\n            function persistLevelIfPossible(levelNum) {\n                var levelName = (logMethods[levelNum] || "silent").toUpperCase();\n                if ("undefined" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage[storageKey] = levelName;\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";\n                } catch (ignore) {}\n            }\n            function getPersistedLevel() {\n                var storedLevel;\n                if ("undefined" === undefinedType || !storageKey) return;\n                try {\n                    storedLevel = window.localStorage[storageKey];\n                } catch (ignore) {}\n                // Fallback to cookies if local storage gives us nothing\n                if (typeof storedLevel === undefinedType) {\n                    try {\n                        var cookie = window.document.cookie;\n                        var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");\n                        if (location !== -1) {\n                            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                        }\n                    } catch (ignore) {}\n                }\n                // If the stored level is not valid, treat it as if nothing was stored.\n                if (self1.levels[storedLevel] === undefined) {\n                    storedLevel = undefined;\n                }\n                return storedLevel;\n            }\n            function clearPersistedLevel() {\n                if ("undefined" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage.removeItem(storageKey);\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";\n                } catch (ignore) {}\n            }\n            /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self1.name = name;\n            self1.levels = {\n                "TRACE": 0,\n                "DEBUG": 1,\n                "INFO": 2,\n                "WARN": 3,\n                "ERROR": 4,\n                "SILENT": 5\n            };\n            self1.methodFactory = factory || defaultMethodFactory;\n            self1.getLevel = function() {\n                return currentLevel;\n            };\n            self1.setLevel = function(level, persist) {\n                if (typeof level === "string" && self1.levels[level.toUpperCase()] !== undefined) {\n                    level = self1.levels[level.toUpperCase()];\n                }\n                if (typeof level === "number" && level >= 0 && level <= self1.levels.SILENT) {\n                    currentLevel = level;\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(level);\n                    }\n                    replaceLoggingMethods.call(self1, level, name);\n                    if (typeof console === undefinedType && level < self1.levels.SILENT) {\n                        return "No console available for logging";\n                    }\n                } else {\n                    throw "log.setLevel() called with invalid level: " + level;\n                }\n            };\n            self1.setDefaultLevel = function(level) {\n                defaultLevel = level;\n                if (!getPersistedLevel()) {\n                    self1.setLevel(level, false);\n                }\n            };\n            self1.resetLevel = function() {\n                self1.setLevel(defaultLevel, false);\n                clearPersistedLevel();\n            };\n            self1.enableAll = function(persist) {\n                self1.setLevel(self1.levels.TRACE, persist);\n            };\n            self1.disableAll = function(persist) {\n                self1.setLevel(self1.levels.SILENT, persist);\n            };\n            // Initialize with the right level\n            var initialLevel = getPersistedLevel();\n            if (initialLevel == null) {\n                initialLevel = defaultLevel;\n            }\n            self1.setLevel(initialLevel, false);\n        }\n        /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n        var _loggersByName = {};\n        defaultLogger.getLogger = function getLogger(name) {\n            if (typeof name !== "symbol" && typeof name !== "string" || name === "") {\n                throw new TypeError("You must supply a name when creating a logger.");\n            }\n            var logger = _loggersByName[name];\n            if (!logger) {\n                logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n            }\n            return logger;\n        };\n        // Grab the current global log variable in case of overwrite\n        var _log = "undefined" !== undefinedType ? window.log : undefined;\n        defaultLogger.noConflict = function() {\n            if ("undefined" !== undefinedType && window.log === defaultLogger) {\n                window.log = _log;\n            }\n            return defaultLogger;\n        };\n        defaultLogger.getLoggers = function getLoggers() {\n            return _loggersByName;\n        };\n        // ES6 default export, for compatibility\n        defaultLogger["default"] = defaultLogger;\n        return defaultLogger;\n    });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel["trace"] = 0] = "trace";\n    LogLevel[LogLevel["debug"] = 1] = "debug";\n    LogLevel[LogLevel["info"] = 2] = "info";\n    LogLevel[LogLevel["warn"] = 3] = "warn";\n    LogLevel[LogLevel["error"] = 4] = "error";\n    LogLevel[LogLevel["silent"] = 5] = "silent";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames["Default"] = "livekit";\n    LoggerNames["Room"] = "livekit-room";\n    LoggerNames["Participant"] = "livekit-participant";\n    LoggerNames["Track"] = "livekit-track";\n    LoggerNames["Publication"] = "livekit-track-publication";\n    LoggerNames["Engine"] = "livekit-engine";\n    LoggerNames["Signal"] = "livekit-signal";\n    LoggerNames["PCManager"] = "livekit-pc-manager";\n    LoggerNames["PCTransport"] = "livekit-pc-transport";\n    LoggerNames["E2EE"] = "lk-e2ee";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger("livekit");\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    }\n    for (const logger of Object.entries(loglevelExports.getLoggers()).filter((_ref)=>{\n        let [logrName] = _ref;\n        return logrName.startsWith("livekit");\n    }).map((_ref2)=>{\n        let [, logr] = _ref2;\n        return logr;\n    })){\n        logger.setLevel(level);\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension) {\n    let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : livekitLogger;\n    const originalFactory = logger.methodFactory;\n    logger.methodFactory = (methodName, configLevel, loggerName)=>{\n        const rawMethod = originalFactory(methodName, configLevel, loggerName);\n        const logLevel = LogLevel[methodName];\n        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n        return (msg, context)=>{\n            if (context) rawMethod(msg, context);\n            else rawMethod(msg);\n            if (needLog) {\n                extension(logLevel, msg, context);\n            }\n        };\n    };\n    logger.setLevel(logger.getLevel()); // Be sure to call setLevel method in order to apply plugin\n}\nloglevelExports.getLogger("lk-e2ee");\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== "number") throw new Error("invalid int 32: " + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error("invalid int 32: " + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== "number") throw new Error("invalid uint 32: " + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error("invalid uint 32: " + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== "number") throw new Error("invalid float 32: " + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error("invalid float 32: " + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, "missing enum type on enum object");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if ("localName" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";\n    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType["INT64"] = 3] = "INT64";\n    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType["INT32"] = 5] = "INT32";\n    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";\n    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";\n    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";\n    ScalarType[ScalarType["STRING"] = 9] = "STRING";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";\n    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";\n    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";\n    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";\n    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType["BIGINT"] = 0] = "BIGINT";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType["STRING"] = 1] = "STRING";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error("invalid varint");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === "-";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we\'re converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number(\'\') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we\'re treating the input as a signed value and the high bit is set, do\n    // a manual two\'s complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? "-" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don\'t overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two\'s compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return "0000000".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error("invalid varint");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");\n    if (ok) {\n        const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == "bigint" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error("int64 invalid: ".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == "bigint" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error("uint64 invalid: ".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));\n    return {\n        zero: "0",\n        supported: false,\n        parse (value) {\n            if (typeof value != "string") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != "string") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != "string") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != "string") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType["Varint"] = 0] = "Varint";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType["Bit64"] = 1] = "Bit64";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType["StartGroup"] = 3] = "StartGroup";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType["EndGroup"] = 4] = "EndGroup";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType["Bit32"] = 5] = "Bit32";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error("invalid state, fork stack empty");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error("cant skip wire type " + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError("premature EOF");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    "google.protobuf.DoubleValue": ScalarType.DOUBLE,\n    "google.protobuf.FloatValue": ScalarType.FLOAT,\n    "google.protobuf.Int64Value": ScalarType.INT64,\n    "google.protobuf.UInt64Value": ScalarType.UINT64,\n    "google.protobuf.Int32Value": ScalarType.INT32,\n    "google.protobuf.UInt32Value": ScalarType.UINT32,\n    "google.protobuf.BoolValue": ScalarType.BOOL,\n    "google.protobuf.StringValue": ScalarType.STRING,\n    "google.protobuf.BytesValue": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and "0".\n            return a == b;\n    }\n    // Anything that hasn\'t been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it\'s covered by tests\n            return longType == 0 ? protoInt64.zero : "0";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return "";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and "0"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and "0"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and "0"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = "value";\n                }\n                switch(field.kind){\n                    case "scalar":\n                    case "enum":\n                        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it\'s covered by tests\n                        if (field.kind == "scalar" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case "message":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case "map":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case "scalar":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case "enum":\n                        val = reader.int32();\n                        break;\n                    case "message":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != "string" && typeof key != "number") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case "scalar":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case "enum":\n                val = 0;\n                break;\n            case "message":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == "bigint" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == "true" || key == "false");\n            keyValue = key == "true";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case "scalar":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case "enum":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case "message":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case "scalar":\n                    case "enum":\n                        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case "message":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case "map":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable["-".charCodeAt(0)] = encTable.indexOf("+");\ndecTable["_".charCodeAt(0)] = encTable.indexOf("/");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   "-" instead of "+",\n   *   "_" instead of "/",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == "=") es -= 2;\n        else if (base64Str[base64Str.length - 1] == "=") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case "=":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case "\\n":\n                    case "\\r":\n                    case "\t":\n                    case " ":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error("invalid base64 string.");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error("invalid base64 string.");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = "", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += "=";\n            if (groupPos == 1) base64 += "=";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != "object") {\n                throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(this.debug(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error("cannot decode message ".concat(type.typeName, \' from JSON: key "\').concat(jsonKey, \'" is unknown\'));\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == "scalar") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error("cannot decode message ".concat(type.typeName, \' from JSON: multiple keys for oneof "\').concat(field.oneof.name, \'" present: "\').concat(seen, \'", "\').concat(jsonKey, \'"\'));\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = "value";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error("cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonValue)));\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error("cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonItem)));\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- "map" is invalid for repeated fields\n                        switch(field.kind){\n                            case "message":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case "enum":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case "scalar":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = "cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonItem));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += ": ".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == "map") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != "object") {\n                        throw new Error("cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonValue)));\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error("cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: map value null"));\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case "message":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case "enum":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case "scalar":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = "cannot decode map value for field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonValue));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += ": ".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == "true" ? true : jsonMapKey == "false" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = "cannot decode map key for field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonValue));\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += ": ".concat(e.message);\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case "message":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {\n                                if (field.oneof) {\n                                    throw new Error("cannot decode field ".concat(type.typeName, ".").concat(field.name, \' from JSON: null is invalid for oneof field "\').concat(jsonKey, \'"\'));\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case "enum":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case "scalar":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = "cannot decode field ".concat(type.typeName, ".").concat(field.name, " from JSON: ").concat(this.debug(jsonValue));\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += ": ".concat(e.message);\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == "oneof") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw "oneof case not found: " + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? ": ".concat(r) : ""));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return "null";\n    }\n    switch(typeof json){\n        case "object":\n            return Array.isArray(json) ? "array" : "object";\n        case "string":\n            return json.length > 100 ? "string" : \'"\'.concat(json.split(\'"\').join(\'\\\\"\'), \'"\');\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === "NaN") return Number.NaN;\n            if (json === "Infinity") return Number.POSITIVE_INFINITY;\n            if (json === "-Infinity") return Number.NEGATIVE_INFINITY;\n            if (json === "") {\n                break;\n            }\n            if (typeof json == "string" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != "string" && typeof json != "number") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == "number") int32 = json;\n            else if (typeof json == "string" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != "number" && typeof json != "string") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != "number" && typeof json != "string") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== "boolean") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return "";\n            if (typeof json !== "string") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error("invalid UTF8");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === "") return new Uint8Array(0);\n            if (typeof json !== "string") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case "number":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case "string":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == "google.protobuf.NullValue") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don\'t know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == "number");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == "number");\n            if (Number.isNaN(value)) return "NaN";\n            if (value === Number.POSITIVE_INFINITY) return "Infinity";\n            if (value === Number.NEGATIVE_INFINITY) return "-Infinity";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == "string");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == "boolean");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");\n            // We use implicit conversion with `value != 0` to catch both 0n and "0"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == "map") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case "scalar":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case "message":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case "enum":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == "number");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case "scalar":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case "enum":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case "message":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case "scalar":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case "enum":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case "message":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case "oneof":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == "message" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case "scalar":\n                    case "enum":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case "map":\n                        switch(member.V.kind){\n                            case "scalar":\n                            case "enum":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case "message":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case "message":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can\'t use BytesValue.typeName as that will create a circular import\n                                mt.typeName === "google.protobuf.BytesValue") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never "map"\n                    switch(m.kind){\n                        case "message":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case "scalar":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case "enum":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error("repeated cannot contain ".concat(m.kind));\n                }\n                switch(m.kind){\n                    case "message":\n                        return m.T.equals(va, vb);\n                    case "enum":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case "scalar":\n                        return scalarEquals(m.T, va, vb);\n                    case "oneof":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never "map"\n                        switch(s.kind){\n                            case "message":\n                                return s.T.equals(va.value, vb.value);\n                            case "enum":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case "scalar":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error("oneof cannot contain ".concat(s.kind));\n                    case "map":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case "message":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case "enum":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case "scalar":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == "map") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == "oneof") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case "_":\n                capNext = true;\n                break;\n            case "0":\n            case "1":\n            case "2":\n            case "3":\n            case "4":\n            case "5":\n            case "6":\n            case "7":\n            case "8":\n            case "9":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join("");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    "constructor",\n    "toString",\n    "toJSON",\n    "valueOf"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    "getType",\n    "clone",\n    "equals",\n    "fromBinary",\n    "fromJson",\n    "fromJsonString",\n    "toBinary",\n    "toJson",\n    "toJsonString",\n    // names reserved by the runtime for the future\n    "toObject"\n]);\nconst fallback = (name)=>"".concat(name, "$");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = "oneof";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case "oneof":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case "enum":\n                    t[name] = 0;\n                    break;\n                case "map":\n                    t[name] = {};\n                    break;\n                case "scalar":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == "scalar") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * "Z") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec \'%Y-%m-%dT%H:%M:%S.%fZ\'. Likewise, in Java, one can use\n * the Joda Time\'s [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== "string") {\n            throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");\n        }\n        const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));\n        if (Number.isNaN(ms)) {\n            throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");\n        }\n        if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {\n            throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {\n            throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");\n        }\n        if (this.nanos < 0) {\n            throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");\n        }\n        let z = "Z";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === "000000") {\n                z = "." + nanosStr.substring(0, 3) + "Z";\n            } else if (nanosStr.substring(6) === "000") {\n                z = "." + nanosStr.substring(0, 6) + "Z";\n            } else {\n                z = "." + nanosStr + "Z";\n            }\n        }\n        return new Date(ms).toISOString().replace(".000Z", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = "google.protobuf.Timestamp";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "seconds",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: "nanos",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.AudioCodec\n */ var AudioCodec;\n(function(AudioCodec) {\n    /**\n   * @generated from enum value: DEFAULT_AC = 0;\n   */ AudioCodec[AudioCodec["DEFAULT_AC"] = 0] = "DEFAULT_AC";\n    /**\n   * @generated from enum value: OPUS = 1;\n   */ AudioCodec[AudioCodec["OPUS"] = 1] = "OPUS";\n    /**\n   * @generated from enum value: AAC = 2;\n   */ AudioCodec[AudioCodec["AAC"] = 2] = "AAC";\n})(AudioCodec || (AudioCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AudioCodec)\nproto3.util.setEnumType(AudioCodec, "livekit.AudioCodec", [\n    {\n        no: 0,\n        name: "DEFAULT_AC"\n    },\n    {\n        no: 1,\n        name: "OPUS"\n    },\n    {\n        no: 2,\n        name: "AAC"\n    }\n]);\n/**\n * @generated from enum livekit.VideoCodec\n */ var VideoCodec;\n(function(VideoCodec) {\n    /**\n   * @generated from enum value: DEFAULT_VC = 0;\n   */ VideoCodec[VideoCodec["DEFAULT_VC"] = 0] = "DEFAULT_VC";\n    /**\n   * @generated from enum value: H264_BASELINE = 1;\n   */ VideoCodec[VideoCodec["H264_BASELINE"] = 1] = "H264_BASELINE";\n    /**\n   * @generated from enum value: H264_MAIN = 2;\n   */ VideoCodec[VideoCodec["H264_MAIN"] = 2] = "H264_MAIN";\n    /**\n   * @generated from enum value: H264_HIGH = 3;\n   */ VideoCodec[VideoCodec["H264_HIGH"] = 3] = "H264_HIGH";\n    /**\n   * @generated from enum value: VP8 = 4;\n   */ VideoCodec[VideoCodec["VP8"] = 4] = "VP8";\n})(VideoCodec || (VideoCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoCodec)\nproto3.util.setEnumType(VideoCodec, "livekit.VideoCodec", [\n    {\n        no: 0,\n        name: "DEFAULT_VC"\n    },\n    {\n        no: 1,\n        name: "H264_BASELINE"\n    },\n    {\n        no: 2,\n        name: "H264_MAIN"\n    },\n    {\n        no: 3,\n        name: "H264_HIGH"\n    },\n    {\n        no: 4,\n        name: "VP8"\n    }\n]);\n/**\n * @generated from enum livekit.ImageCodec\n */ var ImageCodec;\n(function(ImageCodec) {\n    /**\n   * @generated from enum value: IC_DEFAULT = 0;\n   */ ImageCodec[ImageCodec["IC_DEFAULT"] = 0] = "IC_DEFAULT";\n    /**\n   * @generated from enum value: IC_JPEG = 1;\n   */ ImageCodec[ImageCodec["IC_JPEG"] = 1] = "IC_JPEG";\n})(ImageCodec || (ImageCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ImageCodec)\nproto3.util.setEnumType(ImageCodec, "livekit.ImageCodec", [\n    {\n        no: 0,\n        name: "IC_DEFAULT"\n    },\n    {\n        no: 1,\n        name: "IC_JPEG"\n    }\n]);\n/**\n * @generated from enum livekit.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n   * @generated from enum value: AUDIO = 0;\n   */ TrackType[TrackType["AUDIO"] = 0] = "AUDIO";\n    /**\n   * @generated from enum value: VIDEO = 1;\n   */ TrackType[TrackType["VIDEO"] = 1] = "VIDEO";\n    /**\n   * @generated from enum value: DATA = 2;\n   */ TrackType[TrackType["DATA"] = 2] = "DATA";\n})(TrackType || (TrackType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackType)\nproto3.util.setEnumType(TrackType, "livekit.TrackType", [\n    {\n        no: 0,\n        name: "AUDIO"\n    },\n    {\n        no: 1,\n        name: "VIDEO"\n    },\n    {\n        no: 2,\n        name: "DATA"\n    }\n]);\n/**\n * @generated from enum livekit.TrackSource\n */ var TrackSource;\n(function(TrackSource) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ TrackSource[TrackSource["UNKNOWN"] = 0] = "UNKNOWN";\n    /**\n   * @generated from enum value: CAMERA = 1;\n   */ TrackSource[TrackSource["CAMERA"] = 1] = "CAMERA";\n    /**\n   * @generated from enum value: MICROPHONE = 2;\n   */ TrackSource[TrackSource["MICROPHONE"] = 2] = "MICROPHONE";\n    /**\n   * @generated from enum value: SCREEN_SHARE = 3;\n   */ TrackSource[TrackSource["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";\n    /**\n   * @generated from enum value: SCREEN_SHARE_AUDIO = 4;\n   */ TrackSource[TrackSource["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";\n})(TrackSource || (TrackSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackSource)\nproto3.util.setEnumType(TrackSource, "livekit.TrackSource", [\n    {\n        no: 0,\n        name: "UNKNOWN"\n    },\n    {\n        no: 1,\n        name: "CAMERA"\n    },\n    {\n        no: 2,\n        name: "MICROPHONE"\n    },\n    {\n        no: 3,\n        name: "SCREEN_SHARE"\n    },\n    {\n        no: 4,\n        name: "SCREEN_SHARE_AUDIO"\n    }\n]);\n/**\n * @generated from enum livekit.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n   * @generated from enum value: LOW = 0;\n   */ VideoQuality[VideoQuality["LOW"] = 0] = "LOW";\n    /**\n   * @generated from enum value: MEDIUM = 1;\n   */ VideoQuality[VideoQuality["MEDIUM"] = 1] = "MEDIUM";\n    /**\n   * @generated from enum value: HIGH = 2;\n   */ VideoQuality[VideoQuality["HIGH"] = 2] = "HIGH";\n    /**\n   * @generated from enum value: OFF = 3;\n   */ VideoQuality[VideoQuality["OFF"] = 3] = "OFF";\n})(VideoQuality || (VideoQuality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoQuality)\nproto3.util.setEnumType(VideoQuality, "livekit.VideoQuality", [\n    {\n        no: 0,\n        name: "LOW"\n    },\n    {\n        no: 1,\n        name: "MEDIUM"\n    },\n    {\n        no: 2,\n        name: "HIGH"\n    },\n    {\n        no: 3,\n        name: "OFF"\n    }\n]);\n/**\n * @generated from enum livekit.ConnectionQuality\n */ var ConnectionQuality$1;\n(function(ConnectionQuality) {\n    /**\n   * @generated from enum value: POOR = 0;\n   */ ConnectionQuality[ConnectionQuality["POOR"] = 0] = "POOR";\n    /**\n   * @generated from enum value: GOOD = 1;\n   */ ConnectionQuality[ConnectionQuality["GOOD"] = 1] = "GOOD";\n    /**\n   * @generated from enum value: EXCELLENT = 2;\n   */ ConnectionQuality[ConnectionQuality["EXCELLENT"] = 2] = "EXCELLENT";\n    /**\n   * @generated from enum value: LOST = 3;\n   */ ConnectionQuality[ConnectionQuality["LOST"] = 3] = "LOST";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ConnectionQuality)\nproto3.util.setEnumType(ConnectionQuality$1, "livekit.ConnectionQuality", [\n    {\n        no: 0,\n        name: "POOR"\n    },\n    {\n        no: 1,\n        name: "GOOD"\n    },\n    {\n        no: 2,\n        name: "EXCELLENT"\n    },\n    {\n        no: 3,\n        name: "LOST"\n    }\n]);\n/**\n * @generated from enum livekit.ClientConfigSetting\n */ var ClientConfigSetting;\n(function(ClientConfigSetting) {\n    /**\n   * @generated from enum value: UNSET = 0;\n   */ ClientConfigSetting[ClientConfigSetting["UNSET"] = 0] = "UNSET";\n    /**\n   * @generated from enum value: DISABLED = 1;\n   */ ClientConfigSetting[ClientConfigSetting["DISABLED"] = 1] = "DISABLED";\n    /**\n   * @generated from enum value: ENABLED = 2;\n   */ ClientConfigSetting[ClientConfigSetting["ENABLED"] = 2] = "ENABLED";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientConfigSetting)\nproto3.util.setEnumType(ClientConfigSetting, "livekit.ClientConfigSetting", [\n    {\n        no: 0,\n        name: "UNSET"\n    },\n    {\n        no: 1,\n        name: "DISABLED"\n    },\n    {\n        no: 2,\n        name: "ENABLED"\n    }\n]);\n/**\n * @generated from enum livekit.DisconnectReason\n */ var DisconnectReason;\n(function(DisconnectReason) {\n    /**\n   * @generated from enum value: UNKNOWN_REASON = 0;\n   */ DisconnectReason[DisconnectReason["UNKNOWN_REASON"] = 0] = "UNKNOWN_REASON";\n    /**\n   * @generated from enum value: CLIENT_INITIATED = 1;\n   */ DisconnectReason[DisconnectReason["CLIENT_INITIATED"] = 1] = "CLIENT_INITIATED";\n    /**\n   * @generated from enum value: DUPLICATE_IDENTITY = 2;\n   */ DisconnectReason[DisconnectReason["DUPLICATE_IDENTITY"] = 2] = "DUPLICATE_IDENTITY";\n    /**\n   * @generated from enum value: SERVER_SHUTDOWN = 3;\n   */ DisconnectReason[DisconnectReason["SERVER_SHUTDOWN"] = 3] = "SERVER_SHUTDOWN";\n    /**\n   * @generated from enum value: PARTICIPANT_REMOVED = 4;\n   */ DisconnectReason[DisconnectReason["PARTICIPANT_REMOVED"] = 4] = "PARTICIPANT_REMOVED";\n    /**\n   * @generated from enum value: ROOM_DELETED = 5;\n   */ DisconnectReason[DisconnectReason["ROOM_DELETED"] = 5] = "ROOM_DELETED";\n    /**\n   * @generated from enum value: STATE_MISMATCH = 6;\n   */ DisconnectReason[DisconnectReason["STATE_MISMATCH"] = 6] = "STATE_MISMATCH";\n    /**\n   * @generated from enum value: JOIN_FAILURE = 7;\n   */ DisconnectReason[DisconnectReason["JOIN_FAILURE"] = 7] = "JOIN_FAILURE";\n})(DisconnectReason || (DisconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DisconnectReason)\nproto3.util.setEnumType(DisconnectReason, "livekit.DisconnectReason", [\n    {\n        no: 0,\n        name: "UNKNOWN_REASON"\n    },\n    {\n        no: 1,\n        name: "CLIENT_INITIATED"\n    },\n    {\n        no: 2,\n        name: "DUPLICATE_IDENTITY"\n    },\n    {\n        no: 3,\n        name: "SERVER_SHUTDOWN"\n    },\n    {\n        no: 4,\n        name: "PARTICIPANT_REMOVED"\n    },\n    {\n        no: 5,\n        name: "ROOM_DELETED"\n    },\n    {\n        no: 6,\n        name: "STATE_MISMATCH"\n    },\n    {\n        no: 7,\n        name: "JOIN_FAILURE"\n    }\n]);\n/**\n * @generated from enum livekit.ReconnectReason\n */ var ReconnectReason;\n(function(ReconnectReason) {\n    /**\n   * @generated from enum value: RR_UNKNOWN = 0;\n   */ ReconnectReason[ReconnectReason["RR_UNKNOWN"] = 0] = "RR_UNKNOWN";\n    /**\n   * @generated from enum value: RR_SIGNAL_DISCONNECTED = 1;\n   */ ReconnectReason[ReconnectReason["RR_SIGNAL_DISCONNECTED"] = 1] = "RR_SIGNAL_DISCONNECTED";\n    /**\n   * @generated from enum value: RR_PUBLISHER_FAILED = 2;\n   */ ReconnectReason[ReconnectReason["RR_PUBLISHER_FAILED"] = 2] = "RR_PUBLISHER_FAILED";\n    /**\n   * @generated from enum value: RR_SUBSCRIBER_FAILED = 3;\n   */ ReconnectReason[ReconnectReason["RR_SUBSCRIBER_FAILED"] = 3] = "RR_SUBSCRIBER_FAILED";\n    /**\n   * @generated from enum value: RR_SWITCH_CANDIDATE = 4;\n   */ ReconnectReason[ReconnectReason["RR_SWITCH_CANDIDATE"] = 4] = "RR_SWITCH_CANDIDATE";\n})(ReconnectReason || (ReconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ReconnectReason)\nproto3.util.setEnumType(ReconnectReason, "livekit.ReconnectReason", [\n    {\n        no: 0,\n        name: "RR_UNKNOWN"\n    },\n    {\n        no: 1,\n        name: "RR_SIGNAL_DISCONNECTED"\n    },\n    {\n        no: 2,\n        name: "RR_PUBLISHER_FAILED"\n    },\n    {\n        no: 3,\n        name: "RR_SUBSCRIBER_FAILED"\n    },\n    {\n        no: 4,\n        name: "RR_SWITCH_CANDIDATE"\n    }\n]);\n/**\n * @generated from enum livekit.SubscriptionError\n */ var SubscriptionError;\n(function(SubscriptionError) {\n    /**\n   * @generated from enum value: SE_UNKNOWN = 0;\n   */ SubscriptionError[SubscriptionError["SE_UNKNOWN"] = 0] = "SE_UNKNOWN";\n    /**\n   * @generated from enum value: SE_CODEC_UNSUPPORTED = 1;\n   */ SubscriptionError[SubscriptionError["SE_CODEC_UNSUPPORTED"] = 1] = "SE_CODEC_UNSUPPORTED";\n    /**\n   * @generated from enum value: SE_TRACK_NOTFOUND = 2;\n   */ SubscriptionError[SubscriptionError["SE_TRACK_NOTFOUND"] = 2] = "SE_TRACK_NOTFOUND";\n})(SubscriptionError || (SubscriptionError = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SubscriptionError)\nproto3.util.setEnumType(SubscriptionError, "livekit.SubscriptionError", [\n    {\n        no: 0,\n        name: "SE_UNKNOWN"\n    },\n    {\n        no: 1,\n        name: "SE_CODEC_UNSUPPORTED"\n    },\n    {\n        no: 2,\n        name: "SE_TRACK_NOTFOUND"\n    }\n]);\n/**\n * @generated from message livekit.Room\n */ let Room$1 = class Room extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = "";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = "";\n        /**\n     * @generated from field: uint32 empty_timeout = 3;\n     */ this.emptyTimeout = 0;\n        /**\n     * @generated from field: uint32 max_participants = 4;\n     */ this.maxParticipants = 0;\n        /**\n     * @generated from field: int64 creation_time = 5;\n     */ this.creationTime = protoInt64.zero;\n        /**\n     * @generated from field: string turn_password = 6;\n     */ this.turnPassword = "";\n        /**\n     * @generated from field: repeated livekit.Codec enabled_codecs = 7;\n     */ this.enabledCodecs = [];\n        /**\n     * @generated from field: string metadata = 8;\n     */ this.metadata = "";\n        /**\n     * @generated from field: uint32 num_participants = 9;\n     */ this.numParticipants = 0;\n        /**\n     * @generated from field: uint32 num_publishers = 11;\n     */ this.numPublishers = 0;\n        /**\n     * @generated from field: bool active_recording = 10;\n     */ this.activeRecording = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Room().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Room().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Room().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Room, a, b);\n    }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = "livekit.Room";\nRoom$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "name",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "empty_timeout",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: "max_participants",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: "creation_time",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 6,\n            name: "turn_password",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: "enabled_codecs",\n            kind: "message",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: "metadata",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: "num_participants",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: "num_publishers",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 10,\n            name: "active_recording",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.Codec\n */ class Codec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime = 1;\n     */ this.mime = "";\n        /**\n     * @generated from field: string fmtp_line = 2;\n     */ this.fmtpLine = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Codec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Codec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Codec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Codec, a, b);\n    }\n}\nCodec.runtime = proto3;\nCodec.typeName = "livekit.Codec";\nCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "mime",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "fmtp_line",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.PlayoutDelay\n */ class PlayoutDelay extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool enabled = 1;\n     */ this.enabled = false;\n        /**\n     * @generated from field: uint32 min = 2;\n     */ this.min = 0;\n        /**\n     * @generated from field: uint32 max = 3;\n     */ this.max = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new PlayoutDelay().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new PlayoutDelay().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new PlayoutDelay().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(PlayoutDelay, a, b);\n    }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = "livekit.PlayoutDelay";\nPlayoutDelay.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "enabled",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: "min",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: "max",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantPermission\n */ class ParticipantPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * allow participant to subscribe to other tracks in the room\n     *\n     * @generated from field: bool can_subscribe = 1;\n     */ this.canSubscribe = false;\n        /**\n     * allow participant to publish new tracks to room\n     *\n     * @generated from field: bool can_publish = 2;\n     */ this.canPublish = false;\n        /**\n     * allow participant to publish data\n     *\n     * @generated from field: bool can_publish_data = 3;\n     */ this.canPublishData = false;\n        /**\n     * sources that are allowed to be published\n     *\n     * @generated from field: repeated livekit.TrackSource can_publish_sources = 9;\n     */ this.canPublishSources = [];\n        /**\n     * indicates that it\'s hidden to others\n     *\n     * @generated from field: bool hidden = 7;\n     */ this.hidden = false;\n        /**\n     * indicates it\'s a recorder instance\n     *\n     * @generated from field: bool recorder = 8;\n     */ this.recorder = false;\n        /**\n     * indicates that participant can update own metadata\n     *\n     * @generated from field: bool can_update_metadata = 10;\n     */ this.canUpdateMetadata = false;\n        /**\n     * indicates that participant is an agent\n     *\n     * @generated from field: bool agent = 11;\n     */ this.agent = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantPermission, a, b);\n    }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = "livekit.ParticipantPermission";\nParticipantPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "can_subscribe",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: "can_publish",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: "can_publish_data",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: "can_publish_sources",\n            kind: "enum",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: "hidden",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: "recorder",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 10,\n            name: "can_update_metadata",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 11,\n            name: "agent",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantInfo\n */ class ParticipantInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = "";\n        /**\n     * @generated from field: string identity = 2;\n     */ this.identity = "";\n        /**\n     * @generated from field: livekit.ParticipantInfo.State state = 3;\n     */ this.state = ParticipantInfo_State.JOINING;\n        /**\n     * @generated from field: repeated livekit.TrackInfo tracks = 4;\n     */ this.tracks = [];\n        /**\n     * @generated from field: string metadata = 5;\n     */ this.metadata = "";\n        /**\n     * timestamp when participant joined room, in seconds\n     *\n     * @generated from field: int64 joined_at = 6;\n     */ this.joinedAt = protoInt64.zero;\n        /**\n     * @generated from field: string name = 9;\n     */ this.name = "";\n        /**\n     * @generated from field: uint32 version = 10;\n     */ this.version = 0;\n        /**\n     * @generated from field: string region = 12;\n     */ this.region = "";\n        /**\n     * indicates the participant has an active publisher connection\n     * and can publish to the server\n     *\n     * @generated from field: bool is_publisher = 13;\n     */ this.isPublisher = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantInfo, a, b);\n    }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = "livekit.ParticipantInfo";\nParticipantInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "identity",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "state",\n            kind: "enum",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: "tracks",\n            kind: "message",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: "metadata",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: "joined_at",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 9,\n            name: "name",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: "version",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: "permission",\n            kind: "message",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: "region",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: "is_publisher",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ParticipantInfo.State\n */ var ParticipantInfo_State;\n(function(ParticipantInfo_State) {\n    /**\n   * websocket\' connected, but not offered yet\n   *\n   * @generated from enum value: JOINING = 0;\n   */ ParticipantInfo_State[ParticipantInfo_State["JOINING"] = 0] = "JOINING";\n    /**\n   * server received client offer\n   *\n   * @generated from enum value: JOINED = 1;\n   */ ParticipantInfo_State[ParticipantInfo_State["JOINED"] = 1] = "JOINED";\n    /**\n   * ICE connectivity established\n   *\n   * @generated from enum value: ACTIVE = 2;\n   */ ParticipantInfo_State[ParticipantInfo_State["ACTIVE"] = 2] = "ACTIVE";\n    /**\n   * WS disconnected\n   *\n   * @generated from enum value: DISCONNECTED = 3;\n   */ ParticipantInfo_State[ParticipantInfo_State["DISCONNECTED"] = 3] = "DISCONNECTED";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ParticipantInfo_State)\nproto3.util.setEnumType(ParticipantInfo_State, "livekit.ParticipantInfo.State", [\n    {\n        no: 0,\n        name: "JOINING"\n    },\n    {\n        no: 1,\n        name: "JOINED"\n    },\n    {\n        no: 2,\n        name: "ACTIVE"\n    },\n    {\n        no: 3,\n        name: "DISCONNECTED"\n    }\n]);\n/**\n * @generated from message livekit.Encryption\n */ class Encryption extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Encryption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Encryption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Encryption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Encryption, a, b);\n    }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = "livekit.Encryption";\nEncryption.fields = proto3.util.newFieldList(()=>[]);\n/**\n * @generated from enum livekit.Encryption.Type\n */ var Encryption_Type;\n(function(Encryption_Type) {\n    /**\n   * @generated from enum value: NONE = 0;\n   */ Encryption_Type[Encryption_Type["NONE"] = 0] = "NONE";\n    /**\n   * @generated from enum value: GCM = 1;\n   */ Encryption_Type[Encryption_Type["GCM"] = 1] = "GCM";\n    /**\n   * @generated from enum value: CUSTOM = 2;\n   */ Encryption_Type[Encryption_Type["CUSTOM"] = 2] = "CUSTOM";\n})(Encryption_Type || (Encryption_Type = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Encryption_Type)\nproto3.util.setEnumType(Encryption_Type, "livekit.Encryption.Type", [\n    {\n        no: 0,\n        name: "NONE"\n    },\n    {\n        no: 1,\n        name: "GCM"\n    },\n    {\n        no: 2,\n        name: "CUSTOM"\n    }\n]);\n/**\n * @generated from message livekit.SimulcastCodecInfo\n */ class SimulcastCodecInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime_type = 1;\n     */ this.mimeType = "";\n        /**\n     * @generated from field: string mid = 2;\n     */ this.mid = "";\n        /**\n     * @generated from field: string cid = 3;\n     */ this.cid = "";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 4;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodecInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodecInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodecInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodecInfo, a, b);\n    }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = "livekit.SimulcastCodecInfo";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "mime_type",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "mid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "cid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: "layers",\n            kind: "message",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackInfo\n */ class TrackInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = "";\n        /**\n     * @generated from field: livekit.TrackType type = 2;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * @generated from field: string name = 3;\n     */ this.name = "";\n        /**\n     * @generated from field: bool muted = 4;\n     */ this.muted = false;\n        /**\n     * original width of video (unset for audio)\n     * clients may receive a lower resolution version with simulcast\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * original height of video (unset for audio)\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * true if track is simulcasted\n     *\n     * @generated from field: bool simulcast = 7;\n     */ this.simulcast = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 8;\n     */ this.disableDtx = false;\n        /**\n     * source of media\n     *\n     * @generated from field: livekit.TrackSource source = 9;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 10;\n     */ this.layers = [];\n        /**\n     * mime type of codec\n     *\n     * @generated from field: string mime_type = 11;\n     */ this.mimeType = "";\n        /**\n     * @generated from field: string mid = 12;\n     */ this.mid = "";\n        /**\n     * @generated from field: repeated livekit.SimulcastCodecInfo codecs = 13;\n     */ this.codecs = [];\n        /**\n     * @generated from field: bool stereo = 14;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 15;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 16;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * @generated from field: string stream = 17;\n     */ this.stream = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackInfo, a, b);\n    }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = "livekit.TrackInfo";\nTrackInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "type",\n            kind: "enum",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: "name",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: "muted",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 5,\n            name: "width",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: "height",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: "simulcast",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: "disable_dtx",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: "source",\n            kind: "enum",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: "layers",\n            kind: "message",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: "mime_type",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: "mid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: "codecs",\n            kind: "message",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: "stereo",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 15,\n            name: "disable_red",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 16,\n            name: "encryption",\n            kind: "enum",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: "stream",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * provide information about available spatial layers\n *\n * @generated from message livekit.VideoLayer\n */ class VideoLayer extends Message {\n    constructor(data){\n        super();\n        /**\n     * for tracks with a single layer, this should be HIGH\n     *\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: uint32 width = 2;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 3;\n     */ this.height = 0;\n        /**\n     * target bitrate in bit per second (bps), server will measure actual\n     *\n     * @generated from field: uint32 bitrate = 4;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 ssrc = 5;\n     */ this.ssrc = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoLayer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoLayer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoLayer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoLayer, a, b);\n    }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = "livekit.VideoLayer";\nVideoLayer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "quality",\n            kind: "enum",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: "width",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: "height",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: "bitrate",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: "ssrc",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * new DataPacket API\n *\n * @generated from message livekit.DataPacket\n */ class DataPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.DataPacket.Kind kind = 1;\n     */ this.kind = DataPacket_Kind.RELIABLE;\n        /**\n     * @generated from oneof livekit.DataPacket.value\n     */ this.value = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataPacket, a, b);\n    }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = "livekit.DataPacket";\nDataPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "kind",\n            kind: "enum",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 2,\n            name: "user",\n            kind: "message",\n            T: UserPacket,\n            oneof: "value"\n        },\n        {\n            no: 3,\n            name: "speaker",\n            kind: "message",\n            T: ActiveSpeakerUpdate,\n            oneof: "value"\n        }\n    ]);\n/**\n * @generated from enum livekit.DataPacket.Kind\n */ var DataPacket_Kind;\n(function(DataPacket_Kind) {\n    /**\n   * @generated from enum value: RELIABLE = 0;\n   */ DataPacket_Kind[DataPacket_Kind["RELIABLE"] = 0] = "RELIABLE";\n    /**\n   * @generated from enum value: LOSSY = 1;\n   */ DataPacket_Kind[DataPacket_Kind["LOSSY"] = 1] = "LOSSY";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DataPacket_Kind)\nproto3.util.setEnumType(DataPacket_Kind, "livekit.DataPacket.Kind", [\n    {\n        no: 0,\n        name: "RELIABLE"\n    },\n    {\n        no: 1,\n        name: "LOSSY"\n    }\n]);\n/**\n * @generated from message livekit.ActiveSpeakerUpdate\n */ class ActiveSpeakerUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ActiveSpeakerUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ActiveSpeakerUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ActiveSpeakerUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ActiveSpeakerUpdate, a, b);\n    }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = "livekit.ActiveSpeakerUpdate";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "speakers",\n            kind: "message",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SpeakerInfo\n */ class SpeakerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = "";\n        /**\n     * audio level, 0-1.0, 1 is loudest\n     *\n     * @generated from field: float level = 2;\n     */ this.level = 0;\n        /**\n     * true if speaker is currently active\n     *\n     * @generated from field: bool active = 3;\n     */ this.active = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakerInfo, a, b);\n    }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = "livekit.SpeakerInfo";\nSpeakerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "level",\n            kind: "scalar",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 3,\n            name: "active",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.UserPacket\n */ class UserPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of user that sent the message\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: string participant_identity = 5;\n     */ this.participantIdentity = "";\n        /**\n     * user defined payload\n     *\n     * @generated from field: bytes payload = 2;\n     */ this.payload = new Uint8Array(0);\n        /**\n     * the ID of the participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_sids = 3;\n     */ this.destinationSids = [];\n        /**\n     * identities of participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_identities = 6;\n     */ this.destinationIdentities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UserPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UserPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UserPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UserPacket, a, b);\n    }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = "livekit.UserPacket";\nUserPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: "participant_identity",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "payload",\n            kind: "scalar",\n            T: 12 /* ScalarType.BYTES */ \n        },\n        {\n            no: 3,\n            name: "destination_sids",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: "destination_identities",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: "topic",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            opt: true\n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantTracks\n */ class ParticipantTracks extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of participant to whom the tracks belong\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: repeated string track_sids = 2;\n     */ this.trackSids = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantTracks().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantTracks().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantTracks().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantTracks, a, b);\n    }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = "livekit.ParticipantTracks";\nParticipantTracks.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "track_sids",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        }\n    ]);\n/**\n * details about the server\n *\n * @generated from message livekit.ServerInfo\n */ class ServerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ServerInfo.Edition edition = 1;\n     */ this.edition = ServerInfo_Edition.Standard;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = "";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string region = 4;\n     */ this.region = "";\n        /**\n     * @generated from field: string node_id = 5;\n     */ this.nodeId = "";\n        /**\n     * additional debugging information. sent only if server is in development mode\n     *\n     * @generated from field: string debug_info = 6;\n     */ this.debugInfo = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ServerInfo, a, b);\n    }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = "livekit.ServerInfo";\nServerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "edition",\n            kind: "enum",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: "version",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "protocol",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: "region",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: "node_id",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: "debug_info",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ServerInfo.Edition\n */ var ServerInfo_Edition;\n(function(ServerInfo_Edition) {\n    /**\n   * @generated from enum value: Standard = 0;\n   */ ServerInfo_Edition[ServerInfo_Edition["Standard"] = 0] = "Standard";\n    /**\n   * @generated from enum value: Cloud = 1;\n   */ ServerInfo_Edition[ServerInfo_Edition["Cloud"] = 1] = "Cloud";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ServerInfo_Edition)\nproto3.util.setEnumType(ServerInfo_Edition, "livekit.ServerInfo.Edition", [\n    {\n        no: 0,\n        name: "Standard"\n    },\n    {\n        no: 1,\n        name: "Cloud"\n    }\n]);\n/**\n * details about the client\n *\n * @generated from message livekit.ClientInfo\n */ class ClientInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientInfo.SDK sdk = 1;\n     */ this.sdk = ClientInfo_SDK.UNKNOWN;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = "";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string os = 4;\n     */ this.os = "";\n        /**\n     * @generated from field: string os_version = 5;\n     */ this.osVersion = "";\n        /**\n     * @generated from field: string device_model = 6;\n     */ this.deviceModel = "";\n        /**\n     * @generated from field: string browser = 7;\n     */ this.browser = "";\n        /**\n     * @generated from field: string browser_version = 8;\n     */ this.browserVersion = "";\n        /**\n     * @generated from field: string address = 9;\n     */ this.address = "";\n        /**\n     * wifi, wired, cellular, vpn, empty if not known\n     *\n     * @generated from field: string network = 10;\n     */ this.network = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientInfo, a, b);\n    }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = "livekit.ClientInfo";\nClientInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sdk",\n            kind: "enum",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: "version",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "protocol",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: "os",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: "os_version",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: "device_model",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: "browser",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: "browser_version",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: "address",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: "network",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ClientInfo.SDK\n */ var ClientInfo_SDK;\n(function(ClientInfo_SDK) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ ClientInfo_SDK[ClientInfo_SDK["UNKNOWN"] = 0] = "UNKNOWN";\n    /**\n   * @generated from enum value: JS = 1;\n   */ ClientInfo_SDK[ClientInfo_SDK["JS"] = 1] = "JS";\n    /**\n   * @generated from enum value: SWIFT = 2;\n   */ ClientInfo_SDK[ClientInfo_SDK["SWIFT"] = 2] = "SWIFT";\n    /**\n   * @generated from enum value: ANDROID = 3;\n   */ ClientInfo_SDK[ClientInfo_SDK["ANDROID"] = 3] = "ANDROID";\n    /**\n   * @generated from enum value: FLUTTER = 4;\n   */ ClientInfo_SDK[ClientInfo_SDK["FLUTTER"] = 4] = "FLUTTER";\n    /**\n   * @generated from enum value: GO = 5;\n   */ ClientInfo_SDK[ClientInfo_SDK["GO"] = 5] = "GO";\n    /**\n   * @generated from enum value: UNITY = 6;\n   */ ClientInfo_SDK[ClientInfo_SDK["UNITY"] = 6] = "UNITY";\n    /**\n   * @generated from enum value: REACT_NATIVE = 7;\n   */ ClientInfo_SDK[ClientInfo_SDK["REACT_NATIVE"] = 7] = "REACT_NATIVE";\n    /**\n   * @generated from enum value: RUST = 8;\n   */ ClientInfo_SDK[ClientInfo_SDK["RUST"] = 8] = "RUST";\n    /**\n   * @generated from enum value: PYTHON = 9;\n   */ ClientInfo_SDK[ClientInfo_SDK["PYTHON"] = 9] = "PYTHON";\n    /**\n   * @generated from enum value: CPP = 10;\n   */ ClientInfo_SDK[ClientInfo_SDK["CPP"] = 10] = "CPP";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientInfo_SDK)\nproto3.util.setEnumType(ClientInfo_SDK, "livekit.ClientInfo.SDK", [\n    {\n        no: 0,\n        name: "UNKNOWN"\n    },\n    {\n        no: 1,\n        name: "JS"\n    },\n    {\n        no: 2,\n        name: "SWIFT"\n    },\n    {\n        no: 3,\n        name: "ANDROID"\n    },\n    {\n        no: 4,\n        name: "FLUTTER"\n    },\n    {\n        no: 5,\n        name: "GO"\n    },\n    {\n        no: 6,\n        name: "UNITY"\n    },\n    {\n        no: 7,\n        name: "REACT_NATIVE"\n    },\n    {\n        no: 8,\n        name: "RUST"\n    },\n    {\n        no: 9,\n        name: "PYTHON"\n    },\n    {\n        no: 10,\n        name: "CPP"\n    }\n]);\n/**\n * server provided client configuration\n *\n * @generated from message livekit.ClientConfiguration\n */ class ClientConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting resume_connection = 3;\n     */ this.resumeConnection = ClientConfigSetting.UNSET;\n        /**\n     * @generated from field: livekit.ClientConfigSetting force_relay = 5;\n     */ this.forceRelay = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientConfiguration, a, b);\n    }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = "livekit.ClientConfiguration";\nClientConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "video",\n            kind: "message",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: "screen",\n            kind: "message",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: "resume_connection",\n            kind: "enum",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: "disabled_codecs",\n            kind: "message",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: "force_relay",\n            kind: "enum",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.VideoConfiguration\n */ class VideoConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting hardware_encoder = 1;\n     */ this.hardwareEncoder = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoConfiguration, a, b);\n    }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = "livekit.VideoConfiguration";\nVideoConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "hardware_encoder",\n            kind: "enum",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.DisabledCodecs\n */ class DisabledCodecs extends Message {\n    constructor(data){\n        super();\n        /**\n     * disabled for both publish and subscribe\n     *\n     * @generated from field: repeated livekit.Codec codecs = 1;\n     */ this.codecs = [];\n        /**\n     * only disable for publish\n     *\n     * @generated from field: repeated livekit.Codec publish = 2;\n     */ this.publish = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DisabledCodecs().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DisabledCodecs().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DisabledCodecs().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DisabledCodecs, a, b);\n    }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = "livekit.DisabledCodecs";\nDisabledCodecs.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "codecs",\n            kind: "message",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: "publish",\n            kind: "message",\n            T: Codec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RTPDrift\n */ class RTPDrift extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint64 start_timestamp = 4;\n     */ this.startTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 end_timestamp = 5;\n     */ this.endTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 rtp_clock_ticks = 6;\n     */ this.rtpClockTicks = protoInt64.zero;\n        /**\n     * @generated from field: int64 drift_samples = 7;\n     */ this.driftSamples = protoInt64.zero;\n        /**\n     * @generated from field: double drift_ms = 8;\n     */ this.driftMs = 0;\n        /**\n     * @generated from field: double clock_rate = 9;\n     */ this.clockRate = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPDrift().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPDrift().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPDrift().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPDrift, a, b);\n    }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = "livekit.RTPDrift";\nRTPDrift.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "start_time",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: "end_time",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: "duration",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: "start_timestamp",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 5,\n            name: "end_timestamp",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 6,\n            name: "rtp_clock_ticks",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: "drift_samples",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 8,\n            name: "drift_ms",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 9,\n            name: "clock_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        }\n    ]);\n/**\n * @generated from message livekit.RTPStats\n */ class RTPStats extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint32 packets = 4;\n     */ this.packets = 0;\n        /**\n     * @generated from field: double packet_rate = 5;\n     */ this.packetRate = 0;\n        /**\n     * @generated from field: uint64 bytes = 6;\n     */ this.bytes = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes = 39;\n     */ this.headerBytes = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate = 7;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 packets_lost = 8;\n     */ this.packetsLost = 0;\n        /**\n     * @generated from field: double packet_loss_rate = 9;\n     */ this.packetLossRate = 0;\n        /**\n     * @generated from field: float packet_loss_percentage = 10;\n     */ this.packetLossPercentage = 0;\n        /**\n     * @generated from field: uint32 packets_duplicate = 11;\n     */ this.packetsDuplicate = 0;\n        /**\n     * @generated from field: double packet_duplicate_rate = 12;\n     */ this.packetDuplicateRate = 0;\n        /**\n     * @generated from field: uint64 bytes_duplicate = 13;\n     */ this.bytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_duplicate = 40;\n     */ this.headerBytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_duplicate = 14;\n     */ this.bitrateDuplicate = 0;\n        /**\n     * @generated from field: uint32 packets_padding = 15;\n     */ this.packetsPadding = 0;\n        /**\n     * @generated from field: double packet_padding_rate = 16;\n     */ this.packetPaddingRate = 0;\n        /**\n     * @generated from field: uint64 bytes_padding = 17;\n     */ this.bytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_padding = 41;\n     */ this.headerBytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_padding = 18;\n     */ this.bitratePadding = 0;\n        /**\n     * @generated from field: uint32 packets_out_of_order = 19;\n     */ this.packetsOutOfOrder = 0;\n        /**\n     * @generated from field: uint32 frames = 20;\n     */ this.frames = 0;\n        /**\n     * @generated from field: double frame_rate = 21;\n     */ this.frameRate = 0;\n        /**\n     * @generated from field: double jitter_current = 22;\n     */ this.jitterCurrent = 0;\n        /**\n     * @generated from field: double jitter_max = 23;\n     */ this.jitterMax = 0;\n        /**\n     * @generated from field: map<int32, uint32> gap_histogram = 24;\n     */ this.gapHistogram = {};\n        /**\n     * @generated from field: uint32 nacks = 25;\n     */ this.nacks = 0;\n        /**\n     * @generated from field: uint32 nack_acks = 37;\n     */ this.nackAcks = 0;\n        /**\n     * @generated from field: uint32 nack_misses = 26;\n     */ this.nackMisses = 0;\n        /**\n     * @generated from field: uint32 nack_repeated = 38;\n     */ this.nackRepeated = 0;\n        /**\n     * @generated from field: uint32 plis = 27;\n     */ this.plis = 0;\n        /**\n     * @generated from field: uint32 firs = 29;\n     */ this.firs = 0;\n        /**\n     * @generated from field: uint32 rtt_current = 31;\n     */ this.rttCurrent = 0;\n        /**\n     * @generated from field: uint32 rtt_max = 32;\n     */ this.rttMax = 0;\n        /**\n     * @generated from field: uint32 key_frames = 33;\n     */ this.keyFrames = 0;\n        /**\n     * @generated from field: uint32 layer_lock_plis = 35;\n     */ this.layerLockPlis = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPStats().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPStats().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPStats().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPStats, a, b);\n    }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = "livekit.RTPStats";\nRTPStats.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "start_time",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: "end_time",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: "duration",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: "packets",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: "packet_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: "bytes",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 39,\n            name: "header_bytes",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: "bitrate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 8,\n            name: "packets_lost",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 9,\n            name: "packet_loss_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 10,\n            name: "packet_loss_percentage",\n            kind: "scalar",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 11,\n            name: "packets_duplicate",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 12,\n            name: "packet_duplicate_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 13,\n            name: "bytes_duplicate",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 40,\n            name: "header_bytes_duplicate",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 14,\n            name: "bitrate_duplicate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 15,\n            name: "packets_padding",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 16,\n            name: "packet_padding_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 17,\n            name: "bytes_padding",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 41,\n            name: "header_bytes_padding",\n            kind: "scalar",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 18,\n            name: "bitrate_padding",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 19,\n            name: "packets_out_of_order",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 20,\n            name: "frames",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 21,\n            name: "frame_rate",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 22,\n            name: "jitter_current",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 23,\n            name: "jitter_max",\n            kind: "scalar",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 24,\n            name: "gap_histogram",\n            kind: "map",\n            K: 5 /* ScalarType.INT32 */ ,\n            V: {\n                kind: "scalar",\n                T: 13 /* ScalarType.UINT32 */ \n            }\n        },\n        {\n            no: 25,\n            name: "nacks",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 37,\n            name: "nack_acks",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 26,\n            name: "nack_misses",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 38,\n            name: "nack_repeated",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 27,\n            name: "plis",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 28,\n            name: "last_pli",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 29,\n            name: "firs",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 30,\n            name: "last_fir",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 31,\n            name: "rtt_current",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 32,\n            name: "rtt_max",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 33,\n            name: "key_frames",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 34,\n            name: "last_key_frame",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 35,\n            name: "layer_lock_plis",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 36,\n            name: "last_layer_lock_pli",\n            kind: "message",\n            T: Timestamp\n        },\n        {\n            no: 44,\n            name: "packet_drift",\n            kind: "message",\n            T: RTPDrift\n        },\n        {\n            no: 45,\n            name: "report_drift",\n            kind: "message",\n            T: RTPDrift\n        }\n    ]);\n/**\n * @generated from message livekit.TimedVersion\n */ class TimedVersion extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 unix_micro = 1;\n     */ this.unixMicro = protoInt64.zero;\n        /**\n     * @generated from field: int32 ticks = 2;\n     */ this.ticks = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TimedVersion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TimedVersion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TimedVersion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TimedVersion, a, b);\n    }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = "livekit.TimedVersion";\nTimedVersion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "unix_micro",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: "ticks",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator["throw"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === "number") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar R = typeof Reflect === "object" ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === "function") {\n    ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n} else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target);\n    };\n}\nfunction ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n    if (typeof listener !== "function") {\n        throw new TypeError(\'The "listener" argument must be of type Function. Received type \' + typeof listener);\n    }\n}\nObject.defineProperty(EventEmitter, "defaultMaxListeners", {\n    enumerable: true,\n    get: function() {\n        return defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError(\'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received \' + arg + ".");\n        }\n        defaultMaxListeners = arg;\n    }\n});\nEventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError(\'The value of "n" is out of range. It must be a non-negative number. Received \' + n + ".");\n    }\n    this._maxListeners = n;\n    return this;\n};\nfunction _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === "error";\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no \'error\' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node\'s output if this results in an unhandled exception.\n            throw er; // Unhandled \'error\' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));\n        err.context = er;\n        throw err; // Unhandled \'error\' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === "function") {\n        ReflectApply(handler, this, args);\n    } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === "newListener"! Before\n        // adding it to the listeners, first emit "newListener".\n        if (events.newListener !== undefined) {\n            target.emit("newListener", type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don\'t need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === "function") {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [\n                listener,\n                existing\n            ] : [\n                existing,\n                listener\n            ];\n        // If we\'ve already got an array, just append.\n        } else if (prepend) {\n            existing.unshift(listener);\n        } else {\n            existing.push(listener);\n        }\n        // Check for listener leak\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");\n            w.name = "MaxListenersExceededWarning";\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction _onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n};\n// Emits a \'removeListener\' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);\n        }\n    } else if (typeof list !== "function") {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--){\n            if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n            }\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else {\n            spliceOne(list, position);\n        }\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);\n    }\n    return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === "removeListener") continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners("removeListener");\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === "function") {\n        this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n        // LIFO order\n        for(i = listeners.length - 1; i >= 0; i--){\n            this.removeListener(type, listeners[i]);\n        }\n    }\n    return this;\n};\nfunction _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === "function") return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === "function") {\n        return emitter.listenerCount(type);\n    } else {\n        return listenerCount.call(emitter, type);\n    }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === "function") {\n            return 1;\n        } else if (evlistener !== undefined) {\n            return evlistener.length;\n        }\n    }\n    return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i){\n        ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n}\nfunction once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === "function") {\n                emitter.removeListener("error", errorListener);\n            }\n            resolve([].slice.call(arguments));\n        }\n        eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== "error") {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                once: true\n            });\n        }\n    });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === "function") {\n        eventTargetAgnosticAddListener(emitter, "error", handler, flags);\n    }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === "function") {\n        if (flags.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === "function") {\n        // EventTarget does not have `error` event semantics like Node\n        // EventEmitters, we do not listen for `error` events here.\n        emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n                emitter.removeEventListener(name, wrapListener);\n            }\n            listener(arg);\n        });\n    } else {\n        throw new TypeError(\'The "emitter" argument must be of type EventEmitter. Received type \' + typeof emitter);\n    }\n}\nvar eventsExports = events.exports;\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, "on" + eventNameToWrap, {\n        get () {\n            return this["_on" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this["_on" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);\n                delete this["_on" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== "boolean") {\n        return new Error("Argument type: " + typeof bool + ". Please use a boolean.");\n    }\n    logDisabled_ = bool;\n    return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== "boolean") {\n        return new Error("Argument type: " + typeof bool + ". Please use a boolean.");\n    }\n    deprecationWarnings_ = !bool;\n    return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it\'s not a browser\n    if (typeof window1 === "undefined" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = "Not a browser.";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = "firefox";\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = "chrome";\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = "safari";\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && "currentDirection" in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = "Not a supported browser.";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === "[object Object]";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash\'s `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith("Id")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith("Ids")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === "track" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== "object" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === "require" || key === "advanced" || key === "mediaSource") {\n                return;\n            }\n            const r = typeof c[key] === "object" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === "number") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === "deviceId" ? "sourceId" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === "number") {\n                    oc[oldname_("min", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_("max", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_("", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== "number") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_("", key)] = r.exact;\n            } else {\n                [\n                    "min",\n                    "max"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === "object") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, "autoGainControl", "googAutoGainControl");\n            remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === "object") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === "object" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === "environment" || face.ideal === "environment") {\n                    matches = [\n                        "back",\n                        "rear"\n                    ];\n                } else if (face.exact === "user" || face.ideal === "user") {\n                    matches = [\n                        "front"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === "videoinput");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes("back")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging("chrome: " + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging("chrome: " + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: "NotAllowedError",\n                PermissionDismissedError: "NotAllowedError",\n                InvalidStateError: "NotAllowedError",\n                DevicesNotFoundError: "NotFoundError",\n                ConstraintNotSatisfiedError: "OverconstrainedError",\n                TrackStartError: "NotReadableError",\n                MediaDeviceFailedDueToShutdown: "NotAllowedError",\n                MediaDeviceKillSwitchOn: "NotAllowedError",\n                TabCaptureError: "AbortError",\n                ScreenCaptureError: "AbortError",\n                DeviceCaptureError: "AbortError"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && ": ") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException("", "NotFoundError");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia$1(window1, getSourceId) {\n    if (window1.navigator.mediaDevices && "getDisplayMedia" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== "function") {\n        console.error("shimGetDisplayMedia: getSourceId argument is not " + "a function");\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        return getSourceId(constraints).then((sourceId)=>{\n            const widthSpecified = constraints.video && constraints.video.width;\n            const heightSpecified = constraints.video && constraints.video.height;\n            const frameRateSpecified = constraints.video && constraints.video.frameRate;\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: "desktop",\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: frameRateSpecified || 3\n                }\n            };\n            if (widthSpecified) {\n                constraints.video.mandatory.maxWidth = widthSpecified;\n            }\n            if (heightSpecified) {\n                constraints.video.mandatory.maxHeight = heightSpecified;\n            }\n            return window1.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === "object" && window1.RTCPeerConnection && !("ontrack" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, "ontrack", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener("track", this._ontrack);\n                }\n                this.addEventListener("track", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener("addtrack", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event("track");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event("track");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener("addstream", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, "track", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, "transceiver", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === "object" && window1.RTCPeerConnection && !("getSenders" in window1.RTCPeerConnection.prototype) && "createDTMFSender" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === "audio") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === "object" && window1.RTCPeerConnection && "getSenders" in window1.RTCPeerConnection.prototype && "createDTMFSender" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !("dtmf" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, "dtmf", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === "audio") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimGetStats(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n        if (arguments.length > 0 && typeof selector === "function") {\n            return origGetStats.apply(this, arguments);\n        }\n        // When spec-style getStats is supported, return those when called with\n        // either no arguments or the selector argument is null.\n        if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {\n            return origGetStats.apply(this, []);\n        }\n        const fixChromeStats_ = function(response) {\n            const standardReport = {};\n            const reports = response.result();\n            reports.forEach((report)=>{\n                const standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                        localcandidate: "local-candidate",\n                        remotecandidate: "remote-candidate"\n                    }[report.type] || report.type\n                };\n                report.names().forEach((name)=>{\n                    standardStats[name] = report.stat(name);\n                });\n                standardReport[standardStats.id] = standardStats;\n            });\n            return standardReport;\n        };\n        // shim getStats with maplike support\n        const makeMapStats = function(stats) {\n            return new Map(Object.keys(stats).map((key)=>[\n                    key,\n                    stats[key]\n                ]));\n        };\n        if (arguments.length >= 2) {\n            const successCallbackWrapper_ = function(response) {\n                onSucc(makeMapStats(fixChromeStats_(response)));\n            };\n            return origGetStats.apply(this, [\n                successCallbackWrapper_,\n                selector\n            ]);\n        }\n        // promise-support\n        return new Promise((resolve, reject)=>{\n            origGetStats.apply(this, [\n                function(response) {\n                    resolve(makeMapStats(fixChromeStats_(response)));\n                },\n                reject\n            ]);\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!("getStats" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!("getStats" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, "track", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!("getStats" in window1.RTCRtpSender.prototype && "getStats" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException("Track already exists.", "InvalidAccessError");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException("Track already exists.", "InvalidAccessError");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === "closed") {\n            throw new DOMException("The RTCPeerConnection\'s signalingState is \'closed\'.", "InvalidStateError");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException("The adapter.js addTrack polyfill only supports a single " + " stream which is associated with the specified track.", "NotSupportedError");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException("Track already exists.", "InvalidAccessError");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event("negotiationneeded"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, "g"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, "g"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        "createOffer",\n        "createAnswer"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === "function";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, "localDescription");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, "localDescription", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === "") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === "closed") {\n            throw new DOMException("The RTCPeerConnection\'s signalingState is \'closed\'.", "InvalidStateError");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack " + "does not implement interface RTCRtpSender.", "TypeError");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event("negotiationneeded"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            "setLocalDescription",\n            "setRemoteDescription",\n            "addIceCandidate"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === "addIceCandidate" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, "negotiationneeded", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {\n            if (pc.signalingState !== "stable") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetDisplayMedia: shimGetDisplayMedia$1,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetStats: shimGetStats,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+\'s deprecation warning with unprefixed version.\n        deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && "autoGainControl" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === "object" && typeof c.audio === "object") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, "autoGainControl", "mozAutoGainControl");\n                remap(c.audio, "noiseSuppression", "mozNoiseSuppression");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, "mozAutoGainControl", "autoGainControl");\n                remap(obj, "mozNoiseSuppression", "noiseSuppression");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === "audio" && typeof c === "object") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, "autoGainControl", "mozAutoGainControl");\n                    remap(c, "noiseSuppression", "mozNoiseSuppression");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && "getDisplayMedia" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException("getDisplayMedia without video " + "constraints is undefined");\n            err.name = "NotFoundError";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === "object" && window1.RTCTrackEvent && "receiver" in window1.RTCTrackEvent.prototype && !("transceiver" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, "transceiver", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== "object" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            "setLocalDescription",\n            "setRemoteDescription",\n            "addIceCandidate"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === "addIceCandidate" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: "inbound-rtp",\n        outboundrtp: "outbound-rtp",\n        candidatepair: "candidate-pair",\n        localcandidate: "local-candidate",\n        remotecandidate: "remote-candidate"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== "TypeError") {\n                        throw e;\n                    }\n                    // Avoid TypeError: "type" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && "getStats" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && "getStats" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, "track", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || "removeStream" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated("removeStream", "removeTrack");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if ("rid" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError("Invalid RID value provided.");\n                        }\n                    }\n                    if ("scaleResolutionDownBy" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError("scale_resolution_down_by must be >= 1.0");\n                        }\n                    }\n                    if ("maxFramerate" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError("max_framerate must be >= 0.0");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === "object" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!("encodings" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === "object" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== "object" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!("getLocalStreams" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!("addStream" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome\'s behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!("removeStream" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== "object" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!("getRemoteStreams" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!("onaddstream" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, "onaddstream", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener("addstream", this._onaddstream);\n                    this.removeEventListener("track", this._onaddstreampoly);\n                }\n                this.addEventListener("addstream", this._onaddstream = f);\n                this.addEventListener("track", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event("addstream");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener("track", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event("addstream");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== "object" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated("RTCIceServer.url", "RTCIceServer.urls");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ("generateCertificate" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, "generateCertificate", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === "object" && window1.RTCTrackEvent && "receiver" in window1.RTCTrackEvent.prototype && !("transceiver" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, "transceiver", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== "undefined") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === "audio");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === "sendrecv") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection("sendonly");\n                    } else {\n                        audioTransceiver.direction = "sendonly";\n                    }\n                } else if (audioTransceiver.direction === "recvonly") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection("inactive");\n                    } else {\n                        audioTransceiver.direction = "inactive";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver("audio", {\n                    direction: "recvonly"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== "undefined") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === "video");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === "sendrecv") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection("sendonly");\n                    } else {\n                        videoTransceiver.direction = "sendonly";\n                    }\n                } else if (videoTransceiver.direction === "recvonly") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection("inactive");\n                    } else {\n                        videoTransceiver.direction = "inactive";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver("video", {\n                    direction: "recvonly"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== "object" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ (function(module) {\n    // SDP helpers.\n    const SDPUtils = {};\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function() {\n        return Math.random().toString(36).substring(2, 12);\n    };\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function(blob) {\n        return blob.trim().split("\\n").map((line)=>line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function(blob) {\n        const parts = blob.split("\\nm=");\n        return parts.map((part, index)=>(index > 0 ? "m=" + part : part).trim() + "\\r\\n");\n    };\n    // Returns the session description.\n    SDPUtils.getDescription = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        return sections && sections[0];\n    };\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        sections.shift();\n        return sections;\n    };\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function(blob, prefix) {\n        return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n    };\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function(line) {\n        let parts;\n        // Parse both variants.\n        if (line.indexOf("a=candidate:") === 0) {\n            parts = line.substring(12).split(" ");\n        } else {\n            parts = line.substring(10).split(" ");\n        }\n        const candidate = {\n            foundation: parts[0],\n            component: {\n                1: "rtp",\n                2: "rtcp"\n            }[parts[1]] || parts[1],\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            address: parts[4],\n            // address is an alias for ip.\n            port: parseInt(parts[5], 10),\n            // skip parts[6] == \'typ\'\n            type: parts[7]\n        };\n        for(let i = 8; i < parts.length; i += 2){\n            switch(parts[i]){\n                case "raddr":\n                    candidate.relatedAddress = parts[i + 1];\n                    break;\n                case "rport":\n                    candidate.relatedPort = parseInt(parts[i + 1], 10);\n                    break;\n                case "tcptype":\n                    candidate.tcpType = parts[i + 1];\n                    break;\n                case "ufrag":\n                    candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                    candidate.usernameFragment = parts[i + 1];\n                    break;\n                default:\n                    // extension handling, in particular ufrag. Don\'t overwrite.\n                    if (candidate[parts[i]] === undefined) {\n                        candidate[parts[i]] = parts[i + 1];\n                    }\n                    break;\n            }\n        }\n        return candidate;\n    };\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function(candidate) {\n        const sdp = [];\n        sdp.push(candidate.foundation);\n        const component = candidate.component;\n        if (component === "rtp") {\n            sdp.push(1);\n        } else if (component === "rtcp") {\n            sdp.push(2);\n        } else {\n            sdp.push(component);\n        }\n        sdp.push(candidate.protocol.toUpperCase());\n        sdp.push(candidate.priority);\n        sdp.push(candidate.address || candidate.ip);\n        sdp.push(candidate.port);\n        const type = candidate.type;\n        sdp.push("typ");\n        sdp.push(type);\n        if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {\n            sdp.push("raddr");\n            sdp.push(candidate.relatedAddress);\n            sdp.push("rport");\n            sdp.push(candidate.relatedPort);\n        }\n        if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {\n            sdp.push("tcptype");\n            sdp.push(candidate.tcpType);\n        }\n        if (candidate.usernameFragment || candidate.ufrag) {\n            sdp.push("ufrag");\n            sdp.push(candidate.usernameFragment || candidate.ufrag);\n        }\n        return "candidate:" + sdp.join(" ");\n    };\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function(line) {\n        return line.substring(14).split(" ");\n    };\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function(line) {\n        let parts = line.substring(9).split(" ");\n        const parsed = {\n            payloadType: parseInt(parts.shift(), 10) // was: id\n        };\n        parts = parts[0].split("/");\n        parsed.name = parts[0];\n        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n        // legacy alias, got renamed back to channels in ORTC.\n        parsed.numChannels = parsed.channels;\n        return parsed;\n    };\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function(codec) {\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        const channels = codec.channels || codec.numChannels || 1;\n        return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\\r\\n";\n    };\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function(line) {\n        const parts = line.substring(9).split(" ");\n        return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",\n            uri: parts[1],\n            attributes: parts.slice(2).join(" ")\n        };\n    };\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function(headerExtension) {\n        return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\\r\\n";\n    };\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function(line) {\n        const parsed = {};\n        let kv;\n        const parts = line.substring(line.indexOf(" ") + 1).split(";");\n        for(let j = 0; j < parts.length; j++){\n            kv = parts[j].trim().split("=");\n            parsed[kv[0].trim()] = kv[1];\n        }\n        return parsed;\n    };\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function(codec) {\n        let line = "";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.parameters && Object.keys(codec.parameters).length) {\n            const params = [];\n            Object.keys(codec.parameters).forEach((param)=>{\n                if (codec.parameters[param] !== undefined) {\n                    params.push(param + "=" + codec.parameters[param]);\n                } else {\n                    params.push(param);\n                }\n            });\n            line += "a=fmtp:" + pt + " " + params.join(";") + "\\r\\n";\n        }\n        return line;\n    };\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function(line) {\n        const parts = line.substring(line.indexOf(" ") + 1).split(" ");\n        return {\n            type: parts.shift(),\n            parameter: parts.join(" ")\n        };\n    };\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function(codec) {\n        let lines = "";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n            // FIXME: special handling for trr-int?\n            codec.rtcpFeedback.forEach((fb)=>{\n                lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\\r\\n";\n            });\n        }\n        return lines;\n    };\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function(line) {\n        const sp = line.indexOf(" ");\n        const parts = {\n            ssrc: parseInt(line.substring(7, sp), 10)\n        };\n        const colon = line.indexOf(":", sp);\n        if (colon > -1) {\n            parts.attribute = line.substring(sp + 1, colon);\n            parts.value = line.substring(colon + 1);\n        } else {\n            parts.attribute = line.substring(sp + 1);\n        }\n        return parts;\n    };\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function(line) {\n        const parts = line.substring(13).split(" ");\n        return {\n            semantics: parts.shift(),\n            ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n        };\n    };\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function(mediaSection) {\n        const mid = SDPUtils.matchPrefix(mediaSection, "a=mid:")[0];\n        if (mid) {\n            return mid.substring(6);\n        }\n    };\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function(line) {\n        const parts = line.substring(14).split(" ");\n        return {\n            algorithm: parts[0].toLowerCase(),\n            // algorithm is case-sensitive in Edge.\n            value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n        };\n    };\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");\n        // Note: a=setup line is ignored since we use the \'auto\' role in Edge.\n        return {\n            role: "auto",\n            fingerprints: lines.map(SDPUtils.parseFingerprint)\n        };\n    };\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function(params, setupType) {\n        let sdp = "a=setup:" + setupType + "\\r\\n";\n        params.fingerprints.forEach((fp)=>{\n            sdp += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\\r\\n";\n        });\n        return sdp;\n    };\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function(line) {\n        const parts = line.substring(9).split(" ");\n        return {\n            tag: parseInt(parts[0], 10),\n            cryptoSuite: parts[1],\n            keyParams: parts[2],\n            sessionParams: parts.slice(3)\n        };\n    };\n    SDPUtils.writeCryptoLine = function(parameters) {\n        return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\\r\\n";\n    };\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function(keyParams) {\n        if (keyParams.indexOf("inline:") !== 0) {\n            return null;\n        }\n        const parts = keyParams.substring(7).split("|");\n        return {\n            keyMethod: "inline",\n            keySalt: parts[0],\n            lifeTime: parts[1],\n            mkiValue: parts[2] ? parts[2].split(":")[0] : undefined,\n            mkiLength: parts[2] ? parts[2].split(":")[1] : undefined\n        };\n    };\n    SDPUtils.writeCryptoKeyParams = function(keyParams) {\n        return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");\n    };\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, "a=crypto:");\n        return lines.map(SDPUtils.parseCryptoLine);\n    };\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];\n        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];\n        if (!(ufrag && pwd)) {\n            return null;\n        }\n        return {\n            usernameFragment: ufrag.substring(12),\n            password: pwd.substring(10)\n        };\n    };\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function(params) {\n        let sdp = "a=ice-ufrag:" + params.usernameFragment + "\\r\\n" + "a=ice-pwd:" + params.password + "\\r\\n";\n        if (params.iceLite) {\n            sdp += "a=ice-lite\\r\\n";\n        }\n        return sdp;\n    };\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function(mediaSection) {\n        const description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n        };\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(" ");\n        description.profile = mline[2];\n        for(let i = 3; i < mline.length; i++){\n            // find all codecs from mline[3..]\n            const pt = mline[i];\n            const rtpmapline = SDPUtils.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];\n            if (rtpmapline) {\n                const codec = SDPUtils.parseRtpMap(rtpmapline);\n                const fmtps = SDPUtils.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");\n                // Only the first a=fmtp:<pt> is considered.\n                codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils.parseRtcpFb);\n                description.codecs.push(codec);\n                // parse FEC mechanisms from rtpmap lines.\n                switch(codec.name.toUpperCase()){\n                    case "RED":\n                    case "ULPFEC":\n                        description.fecMechanisms.push(codec.name.toUpperCase());\n                        break;\n                }\n            }\n        }\n        SDPUtils.matchPrefix(mediaSection, "a=extmap:").forEach((line)=>{\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n        });\n        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils.parseRtcpFb);\n        description.codecs.forEach((codec)=>{\n            wildcardRtcpFb.forEach((fb)=>{\n                const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                    return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                });\n                if (!duplicate) {\n                    codec.rtcpFeedback.push(fb);\n                }\n            });\n        });\n        // FIXME: parse rtcp.\n        return description;\n    };\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function(kind, caps) {\n        let sdp = "";\n        // Build the mline.\n        sdp += "m=" + kind + " ";\n        sdp += caps.codecs.length > 0 ? "9" : "0"; // reject if no codecs.\n        sdp += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";\n        sdp += caps.codecs.map((codec)=>{\n            if (codec.preferredPayloadType !== undefined) {\n                return codec.preferredPayloadType;\n            }\n            return codec.payloadType;\n        }).join(" ") + "\\r\\n";\n        sdp += "c=IN IP4 0.0.0.0\\r\\n";\n        sdp += "a=rtcp:9 IN IP4 0.0.0.0\\r\\n";\n        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n        caps.codecs.forEach((codec)=>{\n            sdp += SDPUtils.writeRtpMap(codec);\n            sdp += SDPUtils.writeFmtp(codec);\n            sdp += SDPUtils.writeRtcpFb(codec);\n        });\n        let maxptime = 0;\n        caps.codecs.forEach((codec)=>{\n            if (codec.maxptime > maxptime) {\n                maxptime = codec.maxptime;\n            }\n        });\n        if (maxptime > 0) {\n            sdp += "a=maxptime:" + maxptime + "\\r\\n";\n        }\n        if (caps.headerExtensions) {\n            caps.headerExtensions.forEach((extension)=>{\n                sdp += SDPUtils.writeExtmap(extension);\n            });\n        }\n        // FIXME: write fecMechanisms.\n        return sdp;\n    };\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n        const encodingParameters = [];\n        const description = SDPUtils.parseRtpParameters(mediaSection);\n        const hasRed = description.fecMechanisms.indexOf("RED") !== -1;\n        const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;\n        // filter a=ssrc:... cname:, ignore PlanB-msid\n        const ssrcs = SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === "cname");\n        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n        let secondarySsrc;\n        const flows = SDPUtils.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line)=>{\n            const parts = line.substring(17).split(" ");\n            return parts.map((part)=>parseInt(part, 10));\n        });\n        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n            secondarySsrc = flows[0][1];\n        }\n        description.codecs.forEach((codec)=>{\n            if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {\n                let encParam = {\n                    ssrc: primarySsrc,\n                    codecPayloadType: parseInt(codec.parameters.apt, 10)\n                };\n                if (primarySsrc && secondarySsrc) {\n                    encParam.rtx = {\n                        ssrc: secondarySsrc\n                    };\n                }\n                encodingParameters.push(encParam);\n                if (hasRed) {\n                    encParam = JSON.parse(JSON.stringify(encParam));\n                    encParam.fec = {\n                        ssrc: primarySsrc,\n                        mechanism: hasUlpfec ? "red+ulpfec" : "red"\n                    };\n                    encodingParameters.push(encParam);\n                }\n            }\n        });\n        if (encodingParameters.length === 0 && primarySsrc) {\n            encodingParameters.push({\n                ssrc: primarySsrc\n            });\n        }\n        // we support both b=AS and b=TIAS but interpret AS as TIAS.\n        let bandwidth = SDPUtils.matchPrefix(mediaSection, "b=");\n        if (bandwidth.length) {\n            if (bandwidth[0].indexOf("b=TIAS:") === 0) {\n                bandwidth = parseInt(bandwidth[0].substring(7), 10);\n            } else if (bandwidth[0].indexOf("b=AS:") === 0) {\n                // use formula from JSEP to convert b=AS to TIAS value.\n                bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n            } else {\n                bandwidth = undefined;\n            }\n            encodingParameters.forEach((params)=>{\n                params.maxBitrate = bandwidth;\n            });\n        }\n        return encodingParameters;\n    };\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function(mediaSection) {\n        const rtcpParameters = {};\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === "cname")[0];\n        if (remoteSsrc) {\n            rtcpParameters.cname = remoteSsrc.value;\n            rtcpParameters.ssrc = remoteSsrc.ssrc;\n        }\n        // Edge uses the compound attribute instead of reducedSize\n        // compound is !reducedSize\n        const rsize = SDPUtils.matchPrefix(mediaSection, "a=rtcp-rsize");\n        rtcpParameters.reducedSize = rsize.length > 0;\n        rtcpParameters.compound = rsize.length === 0;\n        // parses the rtcp-mux attrіbute.\n        // Note that Edge does not support unmuxed RTCP.\n        const mux = SDPUtils.matchPrefix(mediaSection, "a=rtcp-mux");\n        rtcpParameters.mux = mux.length > 0;\n        return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n        let sdp = "";\n        if (rtcpParameters.reducedSize) {\n            sdp += "a=rtcp-rsize\\r\\n";\n        }\n        if (rtcpParameters.mux) {\n            sdp += "a=rtcp-mux\\r\\n";\n        }\n        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n            sdp += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\\r\\n";\n        }\n        return sdp;\n    };\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function(mediaSection) {\n        let parts;\n        const spec = SDPUtils.matchPrefix(mediaSection, "a=msid:");\n        if (spec.length === 1) {\n            parts = spec[0].substring(7).split(" ");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n        const planB = SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === "msid");\n        if (planB.length > 0) {\n            parts = planB[0].value.split(" ");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n    };\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function(mediaSection) {\n        const mline = SDPUtils.parseMLine(mediaSection);\n        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, "a=max-message-size:");\n        let maxMessageSize;\n        if (maxSizeLine.length > 0) {\n            maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n        }\n        if (isNaN(maxMessageSize)) {\n            maxMessageSize = 65536;\n        }\n        const sctpPort = SDPUtils.matchPrefix(mediaSection, "a=sctp-port:");\n        if (sctpPort.length > 0) {\n            return {\n                port: parseInt(sctpPort[0].substring(12), 10),\n                protocol: mline.fmt,\n                maxMessageSize\n            };\n        }\n        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, "a=sctpmap:");\n        if (sctpMapLines.length > 0) {\n            const parts = sctpMapLines[0].substring(10).split(" ");\n            return {\n                port: parseInt(parts[0], 10),\n                protocol: parts[1],\n                maxMessageSize\n            };\n        }\n    };\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function(media, sctp) {\n        let output = [];\n        if (media.protocol !== "DTLS/SCTP") {\n            output = [\n                "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\\r\\n",\n                "c=IN IP4 0.0.0.0\\r\\n",\n                "a=sctp-port:" + sctp.port + "\\r\\n"\n            ];\n        } else {\n            output = [\n                "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\\r\\n",\n                "c=IN IP4 0.0.0.0\\r\\n",\n                "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\\r\\n"\n            ];\n        }\n        if (sctp.maxMessageSize !== undefined) {\n            output.push("a=max-message-size:" + sctp.maxMessageSize + "\\r\\n");\n        }\n        return output.join("");\n    };\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function() {\n        return Math.random().toString().substr(2, 22);\n    };\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to \'thisisadapterortc\'\n    SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n        let sessionId;\n        const version = sessVer !== undefined ? sessVer : 2;\n        if (sessId) {\n            sessionId = sessId;\n        } else {\n            sessionId = SDPUtils.generateSessionId();\n        }\n        const user = sessUser || "thisisadapterortc";\n        // FIXME: sess-id should be an NTP timestamp.\n        return "v=0\\r\\n" + "o=" + user + " " + sessionId + " " + version + " IN IP4 127.0.0.1\\r\\n" + "s=-\\r\\n" + "t=0 0\\r\\n";\n    };\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function(mediaSection, sessionpart) {\n        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n        const lines = SDPUtils.splitLines(mediaSection);\n        for(let i = 0; i < lines.length; i++){\n            switch(lines[i]){\n                case "a=sendrecv":\n                case "a=sendonly":\n                case "a=recvonly":\n                case "a=inactive":\n                    return lines[i].substring(2);\n            }\n        }\n        if (sessionpart) {\n            return SDPUtils.getDirection(sessionpart);\n        }\n        return "sendrecv";\n    };\n    SDPUtils.getKind = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(" ");\n        return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function(mediaSection) {\n        return mediaSection.split(" ", 2)[1] === "0";\n    };\n    SDPUtils.parseMLine = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const parts = lines[0].substring(2).split(" ");\n        return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(" ")\n        };\n    };\n    SDPUtils.parseOLine = function(mediaSection) {\n        const line = SDPUtils.matchPrefix(mediaSection, "o=")[0];\n        const parts = line.substring(2).split(" ");\n        return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n        };\n    };\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function(blob) {\n        if (typeof blob !== "string" || blob.length === 0) {\n            return false;\n        }\n        const lines = SDPUtils.splitLines(blob);\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {\n                return false;\n            }\n        // TODO: check the modifier a bit more.\n        }\n        return true;\n    };\n    // Expose public methods.\n    {\n        module.exports = SDPUtils;\n    }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && "foundation" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn\'t be part of the candidate string.\n        if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener(\'icecandidate\', ...)\n    wrapPeerConnectionEvent(window1, "icecandidate", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, "candidate", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: "false"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && "relayProtocol" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener(\'icecandidate\', ...)\n    wrapPeerConnectionEvent(window1, "icecandidate", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === "relay") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: "tls",\n                    1: "tcp",\n                    2: "udp"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!("sctp" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, "sctp", {\n            get () {\n                return typeof this._sctp === "undefined" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === "firefox") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === "firefox" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an \'ugly worakaround\'\n        // to cover up the mess.\n        if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === "plan-b") {\n                Object.defineProperty(this, "sctp", {\n                    get () {\n                        return typeof this._sctp === "undefined" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the \'maxMessageSize\'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, "maxMessageSize", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && "createDataChannel" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, "datachannel", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || "connectionState" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, "connectionState", {\n        get () {\n            return ({\n                completed: "connected",\n                checking: "connecting"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, "onconnectionstatechange", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener("connectionstatechange", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        "setLocalDescription",\n        "setRemoteDescription"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event("connectionstatechange", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === "safari" && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf("\\na=extmap-allow-mixed") !== -1) {\n            const sdp = desc.sdp.split("\\n").filter((line)=>{\n                return line.trim() !== "a=extmap-allow-mixed";\n            }).join("\\n");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: "", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: "", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== "object" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection\'s operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can\'t reduce the glare\n        // window to zero on imperfect implementations, there\'s value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case "stable":\n                case "have-local-offer":\n                case "have-remote-pranswer":\n                    desc.type = "offer";\n                    break;\n                default:\n                    desc.type = "answer";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === "offer" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case "chrome":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging("Chrome shim is not included in this adapter release.");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging("Chrome shim can not determine version, not shimming.");\n                return adapter;\n            }\n            logging("adapter.js shimming chrome.");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimGetStats(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case "firefox":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging("Firefox shim is not included in this adapter release.");\n                return adapter;\n            }\n            logging("adapter.js shimming firefox.");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case "safari":\n            if (!safariShim || !options.shimSafari) {\n                logging("Safari shim is not included in this adapter release.");\n                return adapter;\n            }\n            logging("adapter.js shimming safari.");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging("Unsupported browser!");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = "AES-GCM";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = "lk_e2ee";\nconst SALT = "LKFrameEncryptionKey";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent["SetKey"] = "setKey";\n    KeyProviderEvent["RatchetRequest"] = "ratchetRequest";\n    KeyProviderEvent["KeyRatcheted"] = "keyRatcheted";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent["KeyRatcheted"] = "keyRatcheted";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";\n    EncryptionEvent["EncryptionError"] = "encryptionError";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent["Error"] = "cryptorError";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== "undefined";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";\n}\nfunction isVideoFrame(frame) {\n    return "type" in frame;\n}\nfunction importKey(keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "encrypt";\n    return __awaiter(this, void 0, void 0, function*() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n        return crypto.subtle.importKey("raw", keyBytes, algorithm, false, usage === "derive" ? [\n            "deriveBits",\n            "deriveKey"\n        ] : [\n            "encrypt",\n            "decrypt"\n        ]);\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey("raw", enc.encode(password), {\n            name: "PBKDF2"\n        }, false, [\n            "deriveBits",\n            "deriveKey"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey("raw", cryptoBuffer, "HKDF", false, [\n            "deriveBits",\n            "deriveKey"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case "HKDF":\n            return {\n                name: "HKDF",\n                salt: encodedSalt,\n                hash: "SHA-256",\n                info: new ArrayBuffer(128)\n            };\n        case "PBKDF2":\n            {\n                return {\n                    name: "PBKDF2",\n                    salt: encodedSalt,\n                    hash: "SHA-256",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error("algorithm ".concat(algorithmName, " is currently unsupported"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            "encrypt",\n            "decrypt"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can\'t, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug("key ratcheted event received", {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won\'t try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that\'s used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === "string" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || "an error has occured");\n        this.code = code;\n    }\n}\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status){\n        super(1, message);\n        this.status = status;\n        this.reason = reason;\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : "device is unsupported");\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : "track is invalid");\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : "unsupported server");\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : "unexpected connection state");\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : "unable to negotiate");\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : "unable to publish data");\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure["PermissionDenied"] = "PermissionDenied";\n    // device is not available\n    MediaDeviceFailure["NotFound"] = "NotFound";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure["DeviceInUse"] = "DeviceInUse";\n    MediaDeviceFailure["Other"] = "Other";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && "name" in error) {\n            if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === "NotReadableError" || error.name === "TrackStartError") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent["Connected"] = "connected";\n    /**\n   * When the connection to the server has been interrupted and it\'s attempting\n   * to reconnect.\n   */ RoomEvent["Reconnecting"] = "reconnecting";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent["Reconnected"] = "reconnected";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured\n   */ RoomEvent["Disconnected"] = "disconnected";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent["ConnectionStateChanged"] = "connectionStateChanged";\n    /**\n   * @deprecated StateChanged has been renamed to ConnectionStateChanged\n   */ RoomEvent["StateChanged"] = "connectionStateChanged";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent["MediaDevicesChanged"] = "mediaDevicesChanged";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent["ParticipantConnected"] = "participantConnected";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent["ParticipantDisconnected"] = "participantDisconnected";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn\'t mean the participant has subscribed to it. It\'s\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent["TrackPublished"] = "trackPublished";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent["TrackSubscribed"] = "trackSubscribed";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent["TrackUnpublished"] = "trackUnpublished";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent["TrackUnsubscribed"] = "trackUnsubscribed";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent["TrackMuted"] = "trackMuted";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent["TrackUnmuted"] = "trackUnmuted";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent["LocalTrackPublished"] = "localTrackPublished";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing "End" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent["LocalTrackUnpublished"] = "localTrackUnpublished";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent["ActiveSpeakersChanged"] = "activeSpeakersChanged";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant\'s\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent["ParticipantMetadataChanged"] = "participantMetadataChanged";\n    /**\n   * Participant\'s display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent["ParticipantNameChanged"] = "participantNameChanged";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room\'s state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent["RoomMetadataChanged"] = "roomMetadataChanged";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent["DataReceived"] = "dataReceived";\n    /**\n   * Connection quality was changed for a Participant. It\'ll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent["ConnectionQualityChanged"] = "connectionQualityChanged";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber\'s bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we\'ll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we\'ll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent["MediaDevicesError"] = "mediaDevicesError";\n    /**\n   * A participant\'s permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent["ParticipantPermissionsChanged"] = "participantPermissionsChanged";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent["SignalConnected"] = "signalConnected";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent["RecordingStatusChanged"] = "recordingStatusChanged";\n    RoomEvent["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";\n    RoomEvent["EncryptionError"] = "encryptionError";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent["DCBufferStatusChanged"] = "dcBufferStatusChanged";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent["ActiveDeviceChanged"] = "activeDeviceChanged";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn\'t mean the participant has subscribed to it. It\'s\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent["TrackPublished"] = "trackPublished";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]\'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent["TrackSubscribed"] = "trackSubscribed";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent["TrackUnpublished"] = "trackUnpublished";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent["TrackUnsubscribed"] = "trackUnsubscribed";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent["TrackMuted"] = "trackMuted";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent["TrackUnmuted"] = "trackUnmuted";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent["LocalTrackPublished"] = "localTrackPublished";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing "End" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent["LocalTrackUnpublished"] = "localTrackUnpublished";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant\'s\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent["ParticipantMetadataChanged"] = "participantMetadataChanged";\n    /**\n   * Participant\'s display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent["ParticipantNameChanged"] = "participantNameChanged";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent["DataReceived"] = "dataReceived";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent["IsSpeakingChanged"] = "isSpeakingChanged";\n    /**\n   * Connection quality was changed for a Participant. It\'ll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent["ConnectionQualityChanged"] = "connectionQualityChanged";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber\'s bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent["MediaDevicesError"] = "mediaDevicesError";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent["AudioStreamAcquired"] = "audioStreamAcquired";\n    /**\n   * A participant\'s permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent["ParticipantPermissionsChanged"] = "participantPermissionsChanged";\n    /** @internal */ ParticipantEvent["PCTrackAdded"] = "pcTrackAdded";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent["TransportsCreated"] = "transportsCreated";\n    EngineEvent["Connected"] = "connected";\n    EngineEvent["Disconnected"] = "disconnected";\n    EngineEvent["Resuming"] = "resuming";\n    EngineEvent["Resumed"] = "resumed";\n    EngineEvent["Restarting"] = "restarting";\n    EngineEvent["Restarted"] = "restarted";\n    EngineEvent["SignalResumed"] = "signalResumed";\n    EngineEvent["SignalRestarted"] = "signalRestarted";\n    EngineEvent["Closing"] = "closing";\n    EngineEvent["MediaTrackAdded"] = "mediaTrackAdded";\n    EngineEvent["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";\n    EngineEvent["DataPacketReceived"] = "dataPacketReceived";\n    EngineEvent["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";\n    EngineEvent["DCBufferStatusChanged"] = "dcBufferStatusChanged";\n    EngineEvent["ParticipantUpdate"] = "participantUpdate";\n    EngineEvent["RoomUpdate"] = "roomUpdate";\n    EngineEvent["SpeakersChanged"] = "speakersChanged";\n    EngineEvent["StreamStateChanged"] = "streamStateChanged";\n    EngineEvent["ConnectionQualityUpdate"] = "connectionQualityUpdate";\n    EngineEvent["SubscriptionError"] = "subscriptionError";\n    EngineEvent["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";\n    EngineEvent["RemoteMute"] = "remoteMute";\n    EngineEvent["SubscribedQualityUpdate"] = "subscribedQualityUpdate";\n    EngineEvent["LocalTrackUnpublished"] = "localTrackUnpublished";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent["Message"] = "message";\n    TrackEvent["Muted"] = "muted";\n    TrackEvent["Unmuted"] = "unmuted";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent["Restarted"] = "restarted";\n    TrackEvent["Ended"] = "ended";\n    TrackEvent["Subscribed"] = "subscribed";\n    TrackEvent["Unsubscribed"] = "unsubscribed";\n    /** @internal */ TrackEvent["UpdateSettings"] = "updateSettings";\n    /** @internal */ TrackEvent["UpdateSubscription"] = "updateSubscription";\n    /** @internal */ TrackEvent["AudioPlaybackStarted"] = "audioPlaybackStarted";\n    /** @internal */ TrackEvent["AudioPlaybackFailed"] = "audioPlaybackFailed";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent["AudioSilenceDetected"] = "audioSilenceDetected";\n    /** @internal */ TrackEvent["VisibilityChanged"] = "visibilityChanged";\n    /** @internal */ TrackEvent["VideoDimensionsChanged"] = "videoDimensionsChanged";\n    /** @internal */ TrackEvent["VideoPlaybackStarted"] = "videoPlaybackStarted";\n    /** @internal */ TrackEvent["VideoPlaybackFailed"] = "videoPlaybackFailed";\n    /** @internal */ TrackEvent["ElementAttached"] = "elementAttached";\n    /** @internal */ TrackEvent["ElementDetached"] = "elementDetached";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent["UpstreamPaused"] = "upstreamPaused";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent["UpstreamResumed"] = "upstreamResumed";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent["SubscriptionStatusChanged"] = "subscriptionStatusChanged";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent["SubscriptionFailed"] = "subscriptionFailed";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === "undefined" && typeof navigator === "undefined") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: "Firefox",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes("fxios") ? "iOS" : undefined\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: "Chrome",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes("crios") ? "iOS" : undefined\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: "Safari",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes("mobile/") ? "iOS" : "macOS"\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || "";\n}\nvar version$1 = "1.15.10";\nconst version = version$1;\nconst protocolVersion = 11;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setInterval = function() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nclass VideoPreset {\n    constructor(width, height, maxBitrate, maxFramerate, priority){\n        this.width = width;\n        this.height = height;\n        this.encoding = {\n            maxBitrate,\n            maxFramerate,\n            priority\n        };\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.width / this.height\n        };\n    }\n}\nconst backupCodecs = [\n    "vp8",\n    "h264"\n];\nconst videoCodecs = [\n    "vp8",\n    "h264",\n    "vp9",\n    "av1"\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 20000\n    };\n    AudioPresets.music = {\n        maxBitrate: 32000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 96000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, "medium"),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, "medium"),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, "medium"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, "medium"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, "medium"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, "medium"),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, "medium"),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, "medium")\n};\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.SignalTarget\n */ var SignalTarget;\n(function(SignalTarget) {\n    /**\n   * @generated from enum value: PUBLISHER = 0;\n   */ SignalTarget[SignalTarget["PUBLISHER"] = 0] = "PUBLISHER";\n    /**\n   * @generated from enum value: SUBSCRIBER = 1;\n   */ SignalTarget[SignalTarget["SUBSCRIBER"] = 1] = "SUBSCRIBER";\n})(SignalTarget || (SignalTarget = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SignalTarget)\nproto3.util.setEnumType(SignalTarget, "livekit.SignalTarget", [\n    {\n        no: 0,\n        name: "PUBLISHER"\n    },\n    {\n        no: 1,\n        name: "SUBSCRIBER"\n    }\n]);\n/**\n * @generated from enum livekit.StreamState\n */ var StreamState;\n(function(StreamState) {\n    /**\n   * @generated from enum value: ACTIVE = 0;\n   */ StreamState[StreamState["ACTIVE"] = 0] = "ACTIVE";\n    /**\n   * @generated from enum value: PAUSED = 1;\n   */ StreamState[StreamState["PAUSED"] = 1] = "PAUSED";\n})(StreamState || (StreamState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(StreamState)\nproto3.util.setEnumType(StreamState, "livekit.StreamState", [\n    {\n        no: 0,\n        name: "ACTIVE"\n    },\n    {\n        no: 1,\n        name: "PAUSED"\n    }\n]);\n/**\n * @generated from enum livekit.CandidateProtocol\n */ var CandidateProtocol;\n(function(CandidateProtocol) {\n    /**\n   * @generated from enum value: UDP = 0;\n   */ CandidateProtocol[CandidateProtocol["UDP"] = 0] = "UDP";\n    /**\n   * @generated from enum value: TCP = 1;\n   */ CandidateProtocol[CandidateProtocol["TCP"] = 1] = "TCP";\n    /**\n   * @generated from enum value: TLS = 2;\n   */ CandidateProtocol[CandidateProtocol["TLS"] = 2] = "TLS";\n})(CandidateProtocol || (CandidateProtocol = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CandidateProtocol)\nproto3.util.setEnumType(CandidateProtocol, "livekit.CandidateProtocol", [\n    {\n        no: 0,\n        name: "UDP"\n    },\n    {\n        no: 1,\n        name: "TCP"\n    },\n    {\n        no: 2,\n        name: "TLS"\n    }\n]);\n/**\n * @generated from message livekit.SignalRequest\n */ class SignalRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalRequest.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalRequest, a, b);\n    }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = "livekit.SignalRequest";\nSignalRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "offer",\n            kind: "message",\n            T: SessionDescription,\n            oneof: "message"\n        },\n        {\n            no: 2,\n            name: "answer",\n            kind: "message",\n            T: SessionDescription,\n            oneof: "message"\n        },\n        {\n            no: 3,\n            name: "trickle",\n            kind: "message",\n            T: TrickleRequest,\n            oneof: "message"\n        },\n        {\n            no: 4,\n            name: "add_track",\n            kind: "message",\n            T: AddTrackRequest,\n            oneof: "message"\n        },\n        {\n            no: 5,\n            name: "mute",\n            kind: "message",\n            T: MuteTrackRequest,\n            oneof: "message"\n        },\n        {\n            no: 6,\n            name: "subscription",\n            kind: "message",\n            T: UpdateSubscription,\n            oneof: "message"\n        },\n        {\n            no: 7,\n            name: "track_setting",\n            kind: "message",\n            T: UpdateTrackSettings,\n            oneof: "message"\n        },\n        {\n            no: 8,\n            name: "leave",\n            kind: "message",\n            T: LeaveRequest,\n            oneof: "message"\n        },\n        {\n            no: 10,\n            name: "update_layers",\n            kind: "message",\n            T: UpdateVideoLayers,\n            oneof: "message"\n        },\n        {\n            no: 11,\n            name: "subscription_permission",\n            kind: "message",\n            T: SubscriptionPermission,\n            oneof: "message"\n        },\n        {\n            no: 12,\n            name: "sync_state",\n            kind: "message",\n            T: SyncState,\n            oneof: "message"\n        },\n        {\n            no: 13,\n            name: "simulate",\n            kind: "message",\n            T: SimulateScenario,\n            oneof: "message"\n        },\n        {\n            no: 14,\n            name: "ping",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: "message"\n        },\n        {\n            no: 15,\n            name: "update_metadata",\n            kind: "message",\n            T: UpdateParticipantMetadata,\n            oneof: "message"\n        },\n        {\n            no: 16,\n            name: "ping_req",\n            kind: "message",\n            T: Ping,\n            oneof: "message"\n        }\n    ]);\n/**\n * @generated from message livekit.SignalResponse\n */ class SignalResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalResponse.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalResponse, a, b);\n    }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = "livekit.SignalResponse";\nSignalResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "join",\n            kind: "message",\n            T: JoinResponse,\n            oneof: "message"\n        },\n        {\n            no: 2,\n            name: "answer",\n            kind: "message",\n            T: SessionDescription,\n            oneof: "message"\n        },\n        {\n            no: 3,\n            name: "offer",\n            kind: "message",\n            T: SessionDescription,\n            oneof: "message"\n        },\n        {\n            no: 4,\n            name: "trickle",\n            kind: "message",\n            T: TrickleRequest,\n            oneof: "message"\n        },\n        {\n            no: 5,\n            name: "update",\n            kind: "message",\n            T: ParticipantUpdate,\n            oneof: "message"\n        },\n        {\n            no: 6,\n            name: "track_published",\n            kind: "message",\n            T: TrackPublishedResponse,\n            oneof: "message"\n        },\n        {\n            no: 8,\n            name: "leave",\n            kind: "message",\n            T: LeaveRequest,\n            oneof: "message"\n        },\n        {\n            no: 9,\n            name: "mute",\n            kind: "message",\n            T: MuteTrackRequest,\n            oneof: "message"\n        },\n        {\n            no: 10,\n            name: "speakers_changed",\n            kind: "message",\n            T: SpeakersChanged,\n            oneof: "message"\n        },\n        {\n            no: 11,\n            name: "room_update",\n            kind: "message",\n            T: RoomUpdate,\n            oneof: "message"\n        },\n        {\n            no: 12,\n            name: "connection_quality",\n            kind: "message",\n            T: ConnectionQualityUpdate,\n            oneof: "message"\n        },\n        {\n            no: 13,\n            name: "stream_state_update",\n            kind: "message",\n            T: StreamStateUpdate,\n            oneof: "message"\n        },\n        {\n            no: 14,\n            name: "subscribed_quality_update",\n            kind: "message",\n            T: SubscribedQualityUpdate,\n            oneof: "message"\n        },\n        {\n            no: 15,\n            name: "subscription_permission_update",\n            kind: "message",\n            T: SubscriptionPermissionUpdate,\n            oneof: "message"\n        },\n        {\n            no: 16,\n            name: "refresh_token",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            oneof: "message"\n        },\n        {\n            no: 17,\n            name: "track_unpublished",\n            kind: "message",\n            T: TrackUnpublishedResponse,\n            oneof: "message"\n        },\n        {\n            no: 18,\n            name: "pong",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: "message"\n        },\n        {\n            no: 19,\n            name: "reconnect",\n            kind: "message",\n            T: ReconnectResponse,\n            oneof: "message"\n        },\n        {\n            no: 20,\n            name: "pong_resp",\n            kind: "message",\n            T: Pong,\n            oneof: "message"\n        },\n        {\n            no: 21,\n            name: "subscription_response",\n            kind: "message",\n            T: SubscriptionResponse,\n            oneof: "message"\n        }\n    ]);\n/**\n * @generated from message livekit.SimulcastCodec\n */ class SimulcastCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = "";\n        /**\n     * @generated from field: string cid = 2;\n     */ this.cid = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodec, a, b);\n    }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = "livekit.SimulcastCodec";\nSimulcastCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "codec",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "cid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.AddTrackRequest\n */ class AddTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * client ID of track, to match it when RTC track is received\n     *\n     * @generated from field: string cid = 1;\n     */ this.cid = "";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = "";\n        /**\n     * @generated from field: livekit.TrackType type = 3;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * to be deprecated in favor of layers\n     *\n     * @generated from field: uint32 width = 4;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 5;\n     */ this.height = 0;\n        /**\n     * true to add track and initialize to muted\n     *\n     * @generated from field: bool muted = 6;\n     */ this.muted = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 7;\n     */ this.disableDtx = false;\n        /**\n     * @generated from field: livekit.TrackSource source = 8;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 9;\n     */ this.layers = [];\n        /**\n     * @generated from field: repeated livekit.SimulcastCodec simulcast_codecs = 10;\n     */ this.simulcastCodecs = [];\n        /**\n     * server ID of track, publish new codec to exist track\n     *\n     * @generated from field: string sid = 11;\n     */ this.sid = "";\n        /**\n     * @generated from field: bool stereo = 12;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 13;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 14;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * which stream the track belongs to, used to group tracks together.\n     * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together\n     *\n     * @generated from field: string stream = 15;\n     */ this.stream = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AddTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AddTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AddTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AddTrackRequest, a, b);\n    }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = "livekit.AddTrackRequest";\nAddTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "cid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "name",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "type",\n            kind: "enum",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: "width",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: "height",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: "muted",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: "disable_dtx",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: "source",\n            kind: "enum",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: "layers",\n            kind: "message",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: "simulcast_codecs",\n            kind: "message",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: "stereo",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 13,\n            name: "disable_red",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 14,\n            name: "encryption",\n            kind: "enum",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: "stream",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.TrickleRequest\n */ class TrickleRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string candidateInit = 1;\n     */ this.candidateInit = "";\n        /**\n     * @generated from field: livekit.SignalTarget target = 2;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrickleRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrickleRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrickleRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrickleRequest, a, b);\n    }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = "livekit.TrickleRequest";\nTrickleRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "candidateInit",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "target",\n            kind: "enum",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.MuteTrackRequest\n */ class MuteTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = "";\n        /**\n     * @generated from field: bool muted = 2;\n     */ this.muted = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MuteTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MuteTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MuteTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MuteTrackRequest, a, b);\n    }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = "livekit.MuteTrackRequest";\nMuteTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "muted",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.JoinResponse\n */ class JoinResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo other_participants = 3;\n     */ this.otherParticipants = [];\n        /**\n     * deprecated. use server_info.version instead.\n     *\n     * @generated from field: string server_version = 4;\n     */ this.serverVersion = "";\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 5;\n     */ this.iceServers = [];\n        /**\n     * use subscriber as the primary PeerConnection\n     *\n     * @generated from field: bool subscriber_primary = 6;\n     */ this.subscriberPrimary = false;\n        /**\n     * when the current server isn\'t available, return alternate url to retry connection\n     * when this is set, the other fields will be largely empty\n     *\n     * @generated from field: string alternative_url = 7;\n     */ this.alternativeUrl = "";\n        /**\n     * deprecated. use server_info.region instead.\n     *\n     * @generated from field: string server_region = 9;\n     */ this.serverRegion = "";\n        /**\n     * @generated from field: int32 ping_timeout = 10;\n     */ this.pingTimeout = 0;\n        /**\n     * @generated from field: int32 ping_interval = 11;\n     */ this.pingInterval = 0;\n        /**\n     * Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled\n     *\n     * @generated from field: bytes sif_trailer = 13;\n     */ this.sifTrailer = new Uint8Array(0);\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new JoinResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new JoinResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new JoinResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(JoinResponse, a, b);\n    }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = "livekit.JoinResponse";\nJoinResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "room",\n            kind: "message",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: "participant",\n            kind: "message",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: "other_participants",\n            kind: "message",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: "server_version",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: "ice_servers",\n            kind: "message",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: "subscriber_primary",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: "alternative_url",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: "client_configuration",\n            kind: "message",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: "server_region",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: "ping_timeout",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 11,\n            name: "ping_interval",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 12,\n            name: "server_info",\n            kind: "message",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: "sif_trailer",\n            kind: "scalar",\n            T: 12 /* ScalarType.BYTES */ \n        }\n    ]);\n/**\n * @generated from message livekit.ReconnectResponse\n */ class ReconnectResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 1;\n     */ this.iceServers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ReconnectResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ReconnectResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ReconnectResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ReconnectResponse, a, b);\n    }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = "livekit.ReconnectResponse";\nReconnectResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "ice_servers",\n            kind: "message",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: "client_configuration",\n            kind: "message",\n            T: ClientConfiguration\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPublishedResponse\n */ class TrackPublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string cid = 1;\n     */ this.cid = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPublishedResponse, a, b);\n    }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = "livekit.TrackPublishedResponse";\nTrackPublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "cid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "track",\n            kind: "message",\n            T: TrackInfo\n        }\n    ]);\n/**\n * @generated from message livekit.TrackUnpublishedResponse\n */ class TrackUnpublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackUnpublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackUnpublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackUnpublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackUnpublishedResponse, a, b);\n    }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = "livekit.TrackUnpublishedResponse";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SessionDescription\n */ class SessionDescription extends Message {\n    constructor(data){\n        super();\n        /**\n     * "answer" | "offer" | "pranswer" | "rollback"\n     *\n     * @generated from field: string type = 1;\n     */ this.type = "";\n        /**\n     * @generated from field: string sdp = 2;\n     */ this.sdp = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SessionDescription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SessionDescription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SessionDescription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SessionDescription, a, b);\n    }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = "livekit.SessionDescription";\nSessionDescription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "type",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "sdp",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantUpdate\n */ class ParticipantUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo participants = 1;\n     */ this.participants = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantUpdate, a, b);\n    }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = "livekit.ParticipantUpdate";\nParticipantUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participants",\n            kind: "message",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateSubscription\n */ class UpdateSubscription extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: bool subscribe = 2;\n     */ this.subscribe = false;\n        /**\n     * @generated from field: repeated livekit.ParticipantTracks participant_tracks = 3;\n     */ this.participantTracks = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateSubscription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateSubscription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateSubscription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateSubscription, a, b);\n    }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = "livekit.UpdateSubscription";\nUpdateSubscription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sids",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: "subscribe",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: "participant_tracks",\n            kind: "message",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateTrackSettings\n */ class UpdateTrackSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * when true, the track is placed in a paused state, with no new data returned\n     *\n     * @generated from field: bool disabled = 3;\n     */ this.disabled = false;\n        /**\n     * deprecated in favor of width & height\n     *\n     * @generated from field: livekit.VideoQuality quality = 4;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * for video, width to receive\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * for video, height to receive\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * @generated from field: uint32 fps = 7;\n     */ this.fps = 0;\n        /**\n     * subscription priority. 1 being the highest (0 is unset)\n     * when unset, server sill assign priority based on the order of subscription\n     * server will use priority in the following ways:\n     * 1. when subscribed tracks exceed per-participant subscription limit, server will\n     *    pause the lowest priority tracks\n     * 2. when the network is congested, server will assign available bandwidth to\n     *    higher priority tracks first. lowest priority tracks can be paused\n     *\n     * @generated from field: uint32 priority = 8;\n     */ this.priority = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateTrackSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateTrackSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateTrackSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateTrackSettings, a, b);\n    }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = "livekit.UpdateTrackSettings";\nUpdateTrackSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sids",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: "disabled",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 4,\n            name: "quality",\n            kind: "enum",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 5,\n            name: "width",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: "height",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: "fps",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 8,\n            name: "priority",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.LeaveRequest\n */ class LeaveRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * sent when server initiates the disconnect due to server-restart\n     * indicates clients should attempt full-reconnect sequence\n     *\n     * @generated from field: bool can_reconnect = 1;\n     */ this.canReconnect = false;\n        /**\n     * @generated from field: livekit.DisconnectReason reason = 2;\n     */ this.reason = DisconnectReason.UNKNOWN_REASON;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new LeaveRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new LeaveRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new LeaveRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(LeaveRequest, a, b);\n    }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = "livekit.LeaveRequest";\nLeaveRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "can_reconnect",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: "reason",\n            kind: "enum",\n            T: proto3.getEnumType(DisconnectReason)\n        }\n    ]);\n/**\n * message to indicate published video track dimensions are changing\n *\n * @generated from message livekit.UpdateVideoLayers\n */ class UpdateVideoLayers extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = "";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 2;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateVideoLayers().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateVideoLayers().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateVideoLayers().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateVideoLayers, a, b);\n    }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = "livekit.UpdateVideoLayers";\nUpdateVideoLayers.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "layers",\n            kind: "message",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateParticipantMetadata\n */ class UpdateParticipantMetadata extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string metadata = 1;\n     */ this.metadata = "";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateParticipantMetadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateParticipantMetadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateParticipantMetadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateParticipantMetadata, a, b);\n    }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = "livekit.UpdateParticipantMetadata";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "metadata",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "name",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ICEServer\n */ class ICEServer extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string urls = 1;\n     */ this.urls = [];\n        /**\n     * @generated from field: string username = 2;\n     */ this.username = "";\n        /**\n     * @generated from field: string credential = 3;\n     */ this.credential = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ICEServer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ICEServer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ICEServer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ICEServer, a, b);\n    }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = "livekit.ICEServer";\nICEServer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "urls",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: "username",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "credential",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SpeakersChanged\n */ class SpeakersChanged extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakersChanged().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakersChanged().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakersChanged().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakersChanged, a, b);\n    }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = "livekit.SpeakersChanged";\nSpeakersChanged.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "speakers",\n            kind: "message",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RoomUpdate\n */ class RoomUpdate extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RoomUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RoomUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RoomUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RoomUpdate, a, b);\n    }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = "livekit.RoomUpdate";\nRoomUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "room",\n            kind: "message",\n            T: Room$1\n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityInfo\n */ class ConnectionQualityInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: livekit.ConnectionQuality quality = 2;\n     */ this.quality = ConnectionQuality$1.POOR;\n        /**\n     * @generated from field: float score = 3;\n     */ this.score = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityInfo, a, b);\n    }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = "livekit.ConnectionQualityInfo";\nConnectionQualityInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "quality",\n            kind: "enum",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: "score",\n            kind: "scalar",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityUpdate\n */ class ConnectionQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ConnectionQualityInfo updates = 1;\n     */ this.updates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityUpdate, a, b);\n    }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = "livekit.ConnectionQualityUpdate";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "updates",\n            kind: "message",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateInfo\n */ class StreamStateInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = "";\n        /**\n     * @generated from field: livekit.StreamState state = 3;\n     */ this.state = StreamState.ACTIVE;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateInfo, a, b);\n    }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = "livekit.StreamStateInfo";\nStreamStateInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "state",\n            kind: "enum",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateUpdate\n */ class StreamStateUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.StreamStateInfo stream_states = 1;\n     */ this.streamStates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateUpdate, a, b);\n    }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = "livekit.StreamStateUpdate";\nStreamStateUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "stream_states",\n            kind: "message",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQuality\n */ class SubscribedQuality extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: bool enabled = 2;\n     */ this.enabled = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQuality().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQuality().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQuality().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQuality, a, b);\n    }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = "livekit.SubscribedQuality";\nSubscribedQuality.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "quality",\n            kind: "enum",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: "enabled",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedCodec\n */ class SubscribedCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = "";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality qualities = 2;\n     */ this.qualities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedCodec, a, b);\n    }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = "livekit.SubscribedCodec";\nSubscribedCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "codec",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "qualities",\n            kind: "message",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQualityUpdate\n */ class SubscribedQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = "";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality subscribed_qualities = 2;\n     */ this.subscribedQualities = [];\n        /**\n     * @generated from field: repeated livekit.SubscribedCodec subscribed_codecs = 3;\n     */ this.subscribedCodecs = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQualityUpdate, a, b);\n    }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = "livekit.SubscribedQualityUpdate";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "subscribed_qualities",\n            kind: "message",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: "subscribed_codecs",\n            kind: "message",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPermission\n */ class TrackPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * permission could be granted either by participant sid or identity\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: bool all_tracks = 2;\n     */ this.allTracks = false;\n        /**\n     * @generated from field: repeated string track_sids = 3;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: string participant_identity = 4;\n     */ this.participantIdentity = "";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPermission, a, b);\n    }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = "livekit.TrackPermission";\nTrackPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "all_tracks",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: "track_sids",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: "participant_identity",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermission\n */ class SubscriptionPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool all_participants = 1;\n     */ this.allParticipants = false;\n        /**\n     * @generated from field: repeated livekit.TrackPermission track_permissions = 2;\n     */ this.trackPermissions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermission, a, b);\n    }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = "livekit.SubscriptionPermission";\nSubscriptionPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "all_participants",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: "track_permissions",\n            kind: "message",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermissionUpdate\n */ class SubscriptionPermissionUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = "";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = "";\n        /**\n     * @generated from field: bool allowed = 3;\n     */ this.allowed = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermissionUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermissionUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermissionUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermissionUpdate, a, b);\n    }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = "livekit.SubscriptionPermissionUpdate";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "participant_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "allowed",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SyncState\n */ class SyncState extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.TrackPublishedResponse publish_tracks = 3;\n     */ this.publishTracks = [];\n        /**\n     * @generated from field: repeated livekit.DataChannelInfo data_channels = 4;\n     */ this.dataChannels = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SyncState().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SyncState().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SyncState().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SyncState, a, b);\n    }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = "livekit.SyncState";\nSyncState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "answer",\n            kind: "message",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: "subscription",\n            kind: "message",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: "publish_tracks",\n            kind: "message",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: "data_channels",\n            kind: "message",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: "offer",\n            kind: "message",\n            T: SessionDescription\n        }\n    ]);\n/**\n * @generated from message livekit.DataChannelInfo\n */ class DataChannelInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string label = 1;\n     */ this.label = "";\n        /**\n     * @generated from field: uint32 id = 2;\n     */ this.id = 0;\n        /**\n     * @generated from field: livekit.SignalTarget target = 3;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataChannelInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataChannelInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataChannelInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataChannelInfo, a, b);\n    }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = "livekit.DataChannelInfo";\nDataChannelInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "label",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "id",\n            kind: "scalar",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: "target",\n            kind: "enum",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.SimulateScenario\n */ class SimulateScenario extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SimulateScenario.scenario\n     */ this.scenario = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulateScenario().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulateScenario().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulateScenario().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulateScenario, a, b);\n    }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = "livekit.SimulateScenario";\nSimulateScenario.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "speaker_update",\n            kind: "scalar",\n            T: 5 /* ScalarType.INT32 */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 2,\n            name: "node_failure",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 3,\n            name: "migration",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 4,\n            name: "server_leave",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 5,\n            name: "switch_candidate_protocol",\n            kind: "enum",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: "scenario"\n        },\n        {\n            no: 6,\n            name: "subscriber_bandwidth",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 7,\n            name: "disconnect_signal_on_resume",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: "scenario"\n        },\n        {\n            no: 8,\n            name: "disconnect_signal_on_resume_no_messages",\n            kind: "scalar",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: "scenario"\n        }\n    ]);\n/**\n * @generated from message livekit.Ping\n */ class Ping extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 timestamp = 1;\n     */ this.timestamp = protoInt64.zero;\n        /**\n     * rtt in milliseconds calculated by client\n     *\n     * @generated from field: int64 rtt = 2;\n     */ this.rtt = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Ping().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Ping().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Ping().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Ping, a, b);\n    }\n}\nPing.runtime = proto3;\nPing.typeName = "livekit.Ping";\nPing.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "timestamp",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: "rtt",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.Pong\n */ class Pong extends Message {\n    constructor(data){\n        super();\n        /**\n     * timestamp field of last received ping request\n     *\n     * @generated from field: int64 last_ping_timestamp = 1;\n     */ this.lastPingTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: int64 timestamp = 2;\n     */ this.timestamp = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Pong().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Pong().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Pong().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Pong, a, b);\n    }\n}\nPong.runtime = proto3;\nPong.typeName = "livekit.Pong";\nPong.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "last_ping_timestamp",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: "timestamp",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.RegionSettings\n */ class RegionSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.RegionInfo regions = 1;\n     */ this.regions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionSettings, a, b);\n    }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = "livekit.RegionSettings";\nRegionSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "regions",\n            kind: "message",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RegionInfo\n */ class RegionInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string region = 1;\n     */ this.region = "";\n        /**\n     * @generated from field: string url = 2;\n     */ this.url = "";\n        /**\n     * @generated from field: int64 distance = 3;\n     */ this.distance = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionInfo, a, b);\n    }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = "livekit.RegionInfo";\nRegionInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "region",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "url",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: "distance",\n            kind: "scalar",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionResponse\n */ class SubscriptionResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = "";\n        /**\n     * @generated from field: livekit.SubscriptionError err = 2;\n     */ this.err = SubscriptionError.SE_UNKNOWN;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionResponse, a, b);\n    }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = "livekit.SubscriptionResponse";\nSubscriptionResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: "track_sid",\n            kind: "scalar",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: "err",\n            kind: "enum",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nfunction cloneDeep(value) {\n    if (typeof value === "undefined") {\n        return;\n    }\n    if (typeof structuredClone === "function") {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been "blessed" by the user.\nconst recycledElements = [];\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it\'ll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === "hidden") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream\'s first id, since it\'s id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = "audio";\n        if (this.kind === Track.Kind.Video) {\n            elementType = "video";\n        }\n        if (this.attachedElements.length === 0 && Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === "audio") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it\'s already attached to the element, it\'s possible\n        // the element\'s srcObject was set to something else out of band.\n        // we\'ll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === "audio");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === "NotAllowedError") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === "AbortError") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));\n            } else {\n                livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e);\n            }\n            // If audio playback isn\'t allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === "video") && e.name === "NotAllowedError") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === "hidden";\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === "hidden";\n            document.addEventListener("visibilitychange", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === "audio") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn\'t actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind["Audio"] = "audio";\n        Kind["Video"] = "video";\n        Kind["Unknown"] = "unknown";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source["Camera"] = "camera";\n        Source["Microphone"] = "microphone";\n        Source["ScreenShare"] = "screen_share";\n        Source["ScreenShareAudio"] = "screen_share_audio";\n        Source["Unknown"] = "unknown";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState["Active"] = "active";\n        StreamState["Paused"] = "paused";\n        StreamState["Unknown"] = "unknown";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a;\n    const opts = (_a = cloneDeep(options)) !== null && _a !== void 0 ? _a : {};\n    if (opts.audio === true) opts.audio = {};\n    if (opts.video === true) opts.video = {};\n    // use defaults\n    if (opts.audio) {\n        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);\n    }\n    if (opts.video) {\n        mergeObjectWithoutOverwriting(opts.video, videoDefaults);\n    }\n    return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === "object") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case "resolution":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n        } else {\n            constraints.video = options.video;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === "object") {\n            constraints.audio = options.audio;\n        } else {\n            constraints.audio = true;\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return __awaiter(this, void 0, void 0, function*() {\n        const ctx = getNewAudioContext();\n        if (ctx) {\n            const analyser = ctx.createAnalyser();\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            const source = ctx.createMediaStreamSource(new MediaStream([\n                track.mediaStreamTrack\n            ]));\n            source.connect(analyser);\n            yield sleep(timeOffset);\n            analyser.getByteTimeDomainData(dataArray);\n            const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n            ctx.close();\n            return !someNoise;\n        }\n        return false;\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        return new AudioContext1({\n            latencyHint: "interactive"\n        });\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return "audioinput";\n    } else if (source === Track.Source.Camera) {\n        return "videoinput";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    const codec = mimeType.split("/")[1].toLowerCase();\n    if (!videoCodecs.includes(codec)) {\n        throw Error("Video codec not supported: ".concat(codec));\n    }\n    return codec;\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (track instanceof Track) {\n        return {\n            trackSid: track.sid,\n            trackSource: track.source,\n            trackMuted: track.isMuted,\n            trackEnabled: track.mediaStreamTrack.enabled,\n            trackKind: track.kind\n        };\n    } else {\n        return {\n            trackSid: track.trackSid,\n            trackName: track.trackName,\n            track: track.track ? getLogContextFromTrack(track.track) : undefined,\n            trackEnabled: track.isEnabled,\n            trackEncrypted: track.isEncrypted,\n            trackMimeType: track.mimeType\n        };\n    }\n}\nconst separator = "|";\nconst ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        ""\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return "addTransceiver" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return "addTrack" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!("getCapabilities" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities("video");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === "video/AV1") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!("getCapabilities" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities("video");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === "video/VP9") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === "av1" || codec === "vp9";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement("audio");\n    }\n    return "setSinkId" in elm;\n}\nconst setCodecPreferencesVersions = {\n    Chrome: "100",\n    Safari: "15",\n    Firefox: "100"\n};\nfunction supportsSetCodecPreferences(transceiver) {\n    if (!isWeb()) {\n        return false;\n    }\n    if (!("setCodecPreferences" in transceiver)) {\n        return false;\n    }\n    const browser = getBrowser();\n    if (!(browser === null || browser === void 0 ? void 0 : browser.name) || !browser.version) {\n        // version is required\n        return false;\n    }\n    const v = setCodecPreferencesVersions[browser.name];\n    if (v) {\n        return compareVersions(browser.version, v) >= 0;\n    }\n    return false;\n}\nfunction isBrowserSupported() {\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Firefox";\n}\nfunction isChromiumBased() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Chrome";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Safari";\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === "Safari" && b.version.startsWith("17.");\n}\nfunction isMobile() {\n    if (!isWeb()) return false;\n    return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n    return typeof document !== "undefined";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == "ReactNative";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split(".");\n    const parts2 = v2.split(".");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === "" && v2 !== "") {\n        return -1;\n    } else if (v2 === "") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: "0px"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : "";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement("canvas");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext("2d");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = "grey";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error("Could not get empty media stream video track");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error("Could not get empty media stream audio track");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error("Audio Context not supported on this browser");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nclass Mutex {\n    constructor(){\n        this._locking = Promise.resolve();\n        this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let unlockNext;\n        const willLock = new Promise((resolve)=>unlockNext = ()=>{\n                this._locks -= 1;\n                resolve();\n            });\n        const willUnlock = this._locking.then(()=>unlockNext);\n        this._locking = this._locking.then(()=>willLock);\n        return willUnlock;\n    }\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === "string") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error("could not unwrap constraint");\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith("http")) {\n        return url.replace(/^(http)/, "ws");\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith("ws")) {\n        return url.replace(/^(ws)/, "http");\n    }\n    return url;\n}\nconst defaultId = "default";\nclass DeviceManager {\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    getDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                livekitLogger.debug("awaiting getUserMedia promise");\n                try {\n                    if (kind) {\n                        yield DeviceManager.userMediaPromiseMap.get(kind);\n                    } else {\n                        yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                    }\n                } catch (e) {\n                    livekitLogger.warn("error waiting for media permissons");\n                }\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n            !(isSafari() && this.hasDeviceInUse(kind))) {\n                const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device)=>{\n                    const noLabel = device.label === "";\n                    const isRelevant = kind ? device.kind === kind : true;\n                    return noLabel && isRelevant;\n                });\n                if (isDummyDeviceOrEmpty) {\n                    const permissionsToAcquire = {\n                        video: kind !== "audioinput" && kind !== "audiooutput",\n                        audio: kind !== "videoinput"\n                    };\n                    const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    stream.getTracks().forEach((track)=>{\n                        track.stop();\n                    });\n                }\n            }\n            if (kind) {\n                devices = devices.filter((device)=>device.kind === kind);\n            }\n            return devices;\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it\'s \'default\': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const device = devices.find((d)=>d.groupId === groupId && d.deviceId !== defaultId);\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    "audioinput",\n    "audiooutput",\n    "videoinput"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel("unmute");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new Mutex();\n        this.pauseUpstreamLock = new Mutex();\n        this.processorLock = new Mutex();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel("new-track");\n                this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener("ended", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we\'ll need to signal with remote that\n                // the track is "muted"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener("mute", this.handleTrackMuteEvent);\n                newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack && this.processorElement) {\n                this.log.debug("restarting processor", this.logContext);\n                if (this.kind === "unknown") {\n                    throw TypeError("cannot set processor on track of unknown kind");\n                }\n                attachToElement(newTrack, this.processorElement);\n                // ensure the processorElement itself stays muted\n                this.processorElement.muted = true;\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender) {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we\'d want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.kind === Track.Kind.Audio) {\n                throw new Error("cannot get dimensions for audio tracks");\n            }\n            if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === "iOS") {\n                // browsers report wrong initial resolution on iOS.\n                // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                yield sleep(10);\n            }\n            const started = Date.now();\n            while(Date.now() - started < timeout){\n                const dims = this.dimensions;\n                if (dims) {\n                    return dims;\n                }\n                yield sleep(50);\n            }\n            throw new TrackInvalidError("unable to get track dimensions after timeout");\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // screen share doesn\'t have a usable device id\n            if (this.source === Track.Source.ScreenShare) {\n                return;\n            }\n            const { deviceId, groupId } = this._mediaStreamTrack.getSettings();\n            const kind = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";\n            return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track) {\n        let userProvidedTrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError("unable to replace an unpublished track");\n            }\n            this.log.debug("replace MediaStreamTrack", this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            this.providedByUser = userProvidedTrack;\n            if (this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!constraints) {\n                constraints = this._constraints;\n            }\n            this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {\n                constraints\n            }));\n            const streamConstraints = {\n                audio: false,\n                video: false\n            };\n            if (this.kind === Track.Kind.Video) {\n                streamConstraints.video = constraints;\n            } else {\n                streamConstraints.audio = constraints;\n            }\n            // these steps are duplicated from setMediaStreamTrack because we must stop\n            // the previous tracks before new tracks can be acquired\n            this.attachedElements.forEach((el)=>{\n                detachTrack(this.mediaStreamTrack, el);\n            });\n            this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);\n            // on Safari, the old audio track must be stopped before attempting to acquire\n            // the new track, otherwise the new track will stop with\n            // \'A MediaStreamTrack ended due to a capture failure`\n            this._mediaStreamTrack.stop();\n            // create new track and attach\n            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n            const newTrack = mediaStream.getTracks()[0];\n            newTrack.addEventListener("ended", this.handleEnded);\n            this.log.debug("re-acquired MediaStreamTrack", this.logContext);\n            yield this.setMediaStreamTrack(newTrack);\n            this._constraints = constraints;\n            this.emit(TrackEvent.Restarted, this);\n            return this;\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user\'s own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn("unable to pause upstream for an unpublished track", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");\n                }\n                yield this.sender.replaceTrack(null);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn("unable to resume upstream for an unpublished track", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                // this operation is noop if mediastreamtrack is already being sent\n                yield this.sender.replaceTrack(this._mediaStreamTrack);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack\'s underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                this.log.debug("setting up processor", this.logContext);\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === "unknown") {\n                    throw TypeError("cannot set processor on track of unknown kind");\n                }\n                this.processorElement = (_a = this.processorElement) !== null && _a !== void 0 ? _a : document.createElement(this.kind);\n                attachToElement(this._mediaStreamTrack, this.processorElement);\n                this.processorElement.muted = true;\n                this.processorElement.play().catch((error)=>this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    })));\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    element: this.processorElement\n                };\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    for (const el of this.attachedElements){\n                        if (el !== this.processorElement && showProcessedStreamLocally) {\n                            detachTrack(this._mediaStreamTrack, el);\n                            attachToElement(this.processor.processedTrack, el);\n                        }\n                    }\n                    yield (_b = this.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.processor) return;\n            this.log.debug("stopping processor", this.logContext);\n            (_a = this.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n            yield this.processor.destroy();\n            this.processor = undefined;\n            (_b = this.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n            this.processorElement = undefined;\n            yield this.restart();\n        });\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case "error":\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case "initAck":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case "enable":\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError("couldn\'t set encryption status, participant not found".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    if (this.encryptionEnabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case "ratchetKey":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error("e2ee worker encountered an error:", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");\n        }\n        livekitLogger.info("setting up e2ee");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker(\'\');\n            const msg = {\n                kind: "init",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info("initializing worker", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn("ignoring server sent trailer as it\'s empty");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.participants.forEach((participant)=>{\n                    participant.tracks.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: "removeTransform",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError("expected room to be present on signal connect");\n            }\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error("could not ratchet key, worker is missing");\n        }\n        const msg = {\n            kind: "ratchetRequest",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error("could not set key, worker is missing");\n        }\n        const msg = {\n            kind: "setKey",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: "enable",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError("failed to enable e2ee, worker is not ready");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError("could not post rtp map, worker is missing");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError("could not post rtp map, local participant identity is missing");\n        }\n        const msg = {\n            kind: "setRTPMap",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error("could not post SIF trailer, worker is missing");\n        }\n        const msg = {\n            kind: "setSifTrailer",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {\n            throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!(track instanceof LocalTrack) || !sender) {\n            if (!sender) livekitLogger.warn("early return because sender is not ready");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: "decode",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: "updateCodec",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: "decode",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === "") {\n            throw TypeError("local identity needs to be known in order to set up encrypted sender");\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info("initialize script transform");\n            const options = {\n                kind: "encode",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info("initialize encoded streams");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: "encode",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus["WAITING"] = 0] = "WAITING";\n    QueueTaskStatus[QueueTaskStatus["RUNNING"] = 1] = "RUNNING";\n    QueueTaskStatus[QueueTaskStatus["COMPLETED"] = 2] = "COMPLETED";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new Mutex();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nconst passThroughQueueSignals = [\n    "syncState",\n    "trickle",\n    "offer",\n    "answer",\n    "simulate",\n    "leave"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace("request allowed to bypass queue:", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState["CONNECTING"] = 0] = "CONNECTING";\n    SignalConnectionState[SignalConnectionState["CONNECTED"] = 1] = "CONNECTED";\n    SignalConnectionState[SignalConnectionState["RECONNECTING"] = 2] = "RECONNECTING";\n    SignalConnectionState[SignalConnectionState["DISCONNECTING"] = 3] = "DISCONNECTING";\n    SignalConnectionState[SignalConnectionState["DISCONNECTED"] = 4] = "DISCONNECTED";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new Mutex();\n        this.connectionLock = new Mutex();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we\'d want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        url = toWebsocketUrl(url);\n        // strip trailing slash\n        url = url.replace(/\\/$/, "");\n        url += "/rtc";\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError("room connection has been cancelled (signal)"));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError("room connection has timed out (signal)"));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);\n                    this.log.debug("connecting to ".concat(url + params), this.logContext);\n                    if (this.ws) {\n                        yield this.close();\n                    }\n                    this.ws = new WebSocket(url + params);\n                    this.ws.binaryType = "arraybuffer";\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch("http".concat(url.substring(2), "/validate").concat(params));\n                                    if (resp.status.toFixed(0).startsWith("4")) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, 0 /* ConnectionErrorReason.NotAllowed */ , resp.status));\n                                    } else {\n                                        reject(new ConnectionError("Internal error", 2 /* ConnectionErrorReason.InternalError */ , resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError("server was not reachable", 1 /* ConnectionErrorReason.ServerUnreachable */ ));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c, _d;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === "string") {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json);\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error("could not decode websocket message: ".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === "join") {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== "leave") {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === "reconnect") {\n                                        resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.value);\n                                    } else {\n                                        resolve();\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === "leave") {\n                                    reject(new ConnectionError("Received leave request while trying to (re)connect", 4 /* ConnectionErrorReason.LeaveRequest */ ));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError("did not receive join response, got ".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.case, " instead")));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError("Websocket got closed during a (re)connection attempt"));\n                        }\n                        this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            try {\n                this.state = SignalConnectionState.DISCONNECTING;\n                if (this.ws) {\n                    this.ws.onmessage = null;\n                    this.ws.onopen = null;\n                    this.ws.onclose = null;\n                    // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                    const closePromise = new Promise((resolve)=>{\n                        if (this.ws) {\n                            this.ws.onclose = ()=>{\n                                resolve();\n                            };\n                        } else {\n                            resolve();\n                        }\n                    });\n                    if (this.ws.readyState < this.ws.CLOSING) {\n                        this.ws.close();\n                        // 250ms grace period for ws to close gracefully\n                        yield Promise.race([\n                            closePromise,\n                            sleep(250)\n                        ]);\n                    }\n                    this.ws = undefined;\n                }\n            } finally{\n                this.state = SignalConnectionState.DISCONNECTED;\n                this.clearPingInterval();\n                unlock();\n            }\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: "offer",\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: "answer",\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: "trickle",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: "mute",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: "addTrack",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata, name) {\n        return this.sendRequest({\n            case: "updateMetadata",\n            value: new UpdateParticipantMetadata({\n                metadata,\n                name\n            })\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: "trackSetting",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: "subscription",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: "syncState",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: "updateLayers",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: "subscriptionPermission",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: "simulate",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: "ping",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: "pingReq",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: "leave",\n            value: new LeaveRequest({\n                canReconnect: false,\n                reason: DisconnectReason.CLIENT_INITIATED\n            })\n        });\n    }\n    sendRequest(message) {\n        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return __awaiter(this, void 0, void 0, function*() {\n            // capture all requests while reconnecting and put them in a queue\n            // unless the request originates from the queue, then don\'t enqueue again\n            const canQueue = !fromQueue && !canPassThroughQueue(message);\n            if (canQueue && this.state === SignalConnectionState.RECONNECTING) {\n                this.queuedRequests.push(()=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.sendRequest(message, true);\n                    }));\n                return;\n            }\n            // make sure previously queued requests are being sent first\n            if (!fromQueue) {\n                yield this.requestQueue.flush();\n            }\n            if (this.signalLatency) {\n                yield sleep(this.signalLatency);\n            }\n            if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n                this.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.case), this.logContext);\n                return;\n            }\n            const req = new SignalRequest({\n                message\n            });\n            try {\n                if (this.useJSON) {\n                    this.ws.send(req.toJsonString());\n                } else {\n                    this.ws.send(req.toBinary());\n                }\n            } catch (e) {\n                this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug("received unsupported message", this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === "answer") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === "offer") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === "trickle") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === "update") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === "trackPublished") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === "speakersChanged") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === "leave") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === "mute") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === "roomUpdate") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === "connectionQuality") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === "streamStateUpdate") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === "subscribedQualityUpdate") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === "subscriptionPermissionUpdate") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === "refreshToken") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === "trackUnpublished") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === "subscriptionResponse") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === "pong") ;\n        else if (msg.case === "pongResp") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else {\n            this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn("ping timeout duration not set", this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose("ping timeout");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn("ping interval duration not set", this.logContext);\n            return;\n        }\n        this.log.debug("start ping interval", this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug("clearing ping interval", this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: "offer",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case "answer":\n        case "offer":\n        case "pranswer":\n        case "rollback":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set("access_token", token);\n    // opts\n    if (opts.reconnect) {\n        params.set("reconnect", "1");\n        if (opts.sid) {\n            params.set("sid", opts.sid);\n        }\n    }\n    params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");\n    // ClientInfo\n    params.set("sdk", isReactNative() ? "reactnative" : "js");\n    params.set("version", info.version);\n    params.set("protocol", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set("device_model", info.deviceModel);\n    }\n    if (info.os) {\n        params.set("os", info.os);\n    }\n    if (info.osVersion) {\n        params.set("os_version", info.osVersion);\n    }\n    if (info.browser) {\n        params.set("browser", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set("browser_version", info.browserVersion);\n    }\n    if (opts.publishOnly !== undefined) {\n        params.set("publish", opts.publishOnly);\n    }\n    if (opts.adaptiveStream) {\n        params.set("adaptive_stream", "1");\n    }\n    if (opts.reconnectReason) {\n        params.set("reconnect_reason", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set("network", navigator.connection.type);\n    }\n    return "?".concat(params.toString());\n}\nvar parser$1 = {};\nvar grammar$2 = {\n    exports: {}\n};\nvar grammar$1 = grammar$2.exports = {\n    v: [\n        {\n            name: "version",\n            reg: /^(\\d*)$/\n        }\n    ],\n    o: [\n        {\n            // o=- 20518 0 IN IP4 203.0.113.1\n            // NB: sessionId will be a String in most cases because it is huge\n            name: "origin",\n            reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n            names: [\n                "username",\n                "sessionId",\n                "sessionVersion",\n                "netType",\n                "ipVer",\n                "address"\n            ],\n            format: "%s %s %d %s IP%d %s"\n        }\n    ],\n    // default parsing of these only (though some of these feel outdated)\n    s: [\n        {\n            name: "name"\n        }\n    ],\n    i: [\n        {\n            name: "description"\n        }\n    ],\n    u: [\n        {\n            name: "uri"\n        }\n    ],\n    e: [\n        {\n            name: "email"\n        }\n    ],\n    p: [\n        {\n            name: "phone"\n        }\n    ],\n    z: [\n        {\n            name: "timezones"\n        }\n    ],\n    // TODO: this one can actually be parsed properly...\n    r: [\n        {\n            name: "repeats"\n        }\n    ],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [\n        {\n            // t=0 0\n            name: "timing",\n            reg: /^(\\d*) (\\d*)/,\n            names: [\n                "start",\n                "stop"\n            ],\n            format: "%d %d"\n        }\n    ],\n    c: [\n        {\n            // c=IN IP4 10.47.197.26\n            name: "connection",\n            reg: /^IN IP(\\d) (\\S*)/,\n            names: [\n                "version",\n                "ip"\n            ],\n            format: "IN IP%d %s"\n        }\n    ],\n    b: [\n        {\n            // b=AS:4000\n            push: "bandwidth",\n            reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n            names: [\n                "type",\n                "limit"\n            ],\n            format: "%s:%s"\n        }\n    ],\n    m: [\n        {\n            // m=video 51744 RTP/AVP 126 97 98 34 31\n            // NB: special - pushes to session\n            // TODO: rtp/fmtp should be filtered by the payloads found here?\n            reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n            names: [\n                "type",\n                "port",\n                "protocol",\n                "payloads"\n            ],\n            format: "%s %d %s %s"\n        }\n    ],\n    a: [\n        {\n            // a=rtpmap:110 opus/48000/2\n            push: "rtp",\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n            names: [\n                "payload",\n                "codec",\n                "rate",\n                "encoding"\n            ],\n            format: function(o) {\n                return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";\n            }\n        },\n        {\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n            // a=fmtp:111 minptime=10; useinbandfec=1\n            push: "fmtp",\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n            names: [\n                "payload",\n                "config"\n            ],\n            format: "fmtp:%d %s"\n        },\n        {\n            // a=control:streamid=0\n            name: "control",\n            reg: /^control:(.*)/,\n            format: "control:%s"\n        },\n        {\n            // a=rtcp:65179 IN IP4 193.84.77.194\n            name: "rtcp",\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n            names: [\n                "port",\n                "netType",\n                "ipVer",\n                "address"\n            ],\n            format: function(o) {\n                return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";\n            }\n        },\n        {\n            // a=rtcp-fb:98 trr-int 100\n            push: "rtcpFbTrrInt",\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n            names: [\n                "payload",\n                "value"\n            ],\n            format: "rtcp-fb:%s trr-int %d"\n        },\n        {\n            // a=rtcp-fb:98 nack rpsi\n            push: "rtcpFb",\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n            names: [\n                "payload",\n                "type",\n                "subtype"\n            ],\n            format: function(o) {\n                return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";\n            }\n        },\n        {\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n            // a=extmap:1/recvonly URI-gps-string\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n            push: "ext",\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n            names: [\n                "value",\n                "direction",\n                "encrypt-uri",\n                "uri",\n                "config"\n            ],\n            format: function(o) {\n                return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");\n            }\n        },\n        {\n            // a=extmap-allow-mixed\n            name: "extmapAllowMixed",\n            reg: /^(extmap-allow-mixed)/\n        },\n        {\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n            push: "crypto",\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                "id",\n                "suite",\n                "config",\n                "sessionConfig"\n            ],\n            format: function(o) {\n                return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";\n            }\n        },\n        {\n            // a=setup:actpass\n            name: "setup",\n            reg: /^setup:(\\w*)/,\n            format: "setup:%s"\n        },\n        {\n            // a=connection:new\n            name: "connectionType",\n            reg: /^connection:(new|existing)/,\n            format: "connection:%s"\n        },\n        {\n            // a=mid:1\n            name: "mid",\n            reg: /^mid:([^\\s]*)/,\n            format: "mid:%s"\n        },\n        {\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n            name: "msid",\n            reg: /^msid:(.*)/,\n            format: "msid:%s"\n        },\n        {\n            // a=ptime:20\n            name: "ptime",\n            reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n            format: "ptime:%d"\n        },\n        {\n            // a=maxptime:60\n            name: "maxptime",\n            reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n            format: "maxptime:%d"\n        },\n        {\n            // a=sendrecv\n            name: "direction",\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\n        },\n        {\n            // a=ice-lite\n            name: "icelite",\n            reg: /^(ice-lite)/\n        },\n        {\n            // a=ice-ufrag:F7gI\n            name: "iceUfrag",\n            reg: /^ice-ufrag:(\\S*)/,\n            format: "ice-ufrag:%s"\n        },\n        {\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n            name: "icePwd",\n            reg: /^ice-pwd:(\\S*)/,\n            format: "ice-pwd:%s"\n        },\n        {\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n            name: "fingerprint",\n            reg: /^fingerprint:(\\S*) (\\S*)/,\n            names: [\n                "type",\n                "hash"\n            ],\n            format: "fingerprint:%s %s"\n        },\n        {\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n            push: "candidates",\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n            names: [\n                "foundation",\n                "component",\n                "transport",\n                "priority",\n                "ip",\n                "port",\n                "type",\n                "raddr",\n                "rport",\n                "tcptype",\n                "generation",\n                "network-id",\n                "network-cost"\n            ],\n            format: function(o) {\n                var str = "candidate:%s %d %s %d %s %d typ %s";\n                str += o.raddr != null ? " raddr %s rport %d" : "%v%v";\n                // NB: candidate has three optional chunks, so %void middles one if it\'s missing\n                str += o.tcptype != null ? " tcptype %s" : "%v";\n                if (o.generation != null) {\n                    str += " generation %d";\n                }\n                str += o["network-id"] != null ? " network-id %d" : "%v";\n                str += o["network-cost"] != null ? " network-cost %d" : "%v";\n                return str;\n            }\n        },\n        {\n            // a=end-of-candidates (keep after the candidates line for readability)\n            name: "endOfCandidates",\n            reg: /^(end-of-candidates)/\n        },\n        {\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n            name: "remoteCandidates",\n            reg: /^remote-candidates:(.*)/,\n            format: "remote-candidates:%s"\n        },\n        {\n            // a=ice-options:google-ice\n            name: "iceOptions",\n            reg: /^ice-options:(\\S*)/,\n            format: "ice-options:%s"\n        },\n        {\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n            push: "ssrcs",\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n            names: [\n                "id",\n                "attribute",\n                "value"\n            ],\n            format: function(o) {\n                var str = "ssrc:%d";\n                if (o.attribute != null) {\n                    str += " %s";\n                    if (o.value != null) {\n                        str += ":%s";\n                    }\n                }\n                return str;\n            }\n        },\n        {\n            // a=ssrc-group:FEC 1 2\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\n            push: "ssrcGroups",\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n            names: [\n                "semantics",\n                "ssrcs"\n            ],\n            format: "ssrc-group:%s %s"\n        },\n        {\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n            name: "msidSemantic",\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n            names: [\n                "semantic",\n                "token"\n            ],\n            format: "msid-semantic: %s %s" // space after \':\' is not accidental\n        },\n        {\n            // a=group:BUNDLE audio video\n            push: "groups",\n            reg: /^group:(\\w*) (.*)/,\n            names: [\n                "type",\n                "mids"\n            ],\n            format: "group:%s %s"\n        },\n        {\n            // a=rtcp-mux\n            name: "rtcpMux",\n            reg: /^(rtcp-mux)/\n        },\n        {\n            // a=rtcp-rsize\n            name: "rtcpRsize",\n            reg: /^(rtcp-rsize)/\n        },\n        {\n            // a=sctpmap:5000 webrtc-datachannel 1024\n            name: "sctpmap",\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                "sctpmapNumber",\n                "app",\n                "maxMessageSize"\n            ],\n            format: function(o) {\n                return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";\n            }\n        },\n        {\n            // a=x-google-flag:conference\n            name: "xGoogleFlag",\n            reg: /^x-google-flag:([^\\s]*)/,\n            format: "x-google-flag:%s"\n        },\n        {\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n            push: "rids",\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n            names: [\n                "id",\n                "direction",\n                "params"\n            ],\n            format: function(o) {\n                return o.params ? "rid:%s %s %s" : "rid:%s %s";\n            }\n        },\n        {\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n            // a=imageattr:* send [x=800,y=640] recv *\n            // a=imageattr:100 recv [x=320,y=240]\n            push: "imageattrs",\n            reg: new RegExp(// a=imageattr:97\n            "^imageattr:(\\\\d+|\\\\*)" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n            "[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)" + // recv [x=330,y=250]\n            "(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?"),\n            names: [\n                "pt",\n                "dir1",\n                "attrs1",\n                "dir2",\n                "attrs2"\n            ],\n            format: function(o) {\n                return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");\n            }\n        },\n        {\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n            // a=simulcast:recv 1;4,5 send 6;7\n            name: "simulcast",\n            reg: new RegExp(// a=simulcast:\n            "^simulcast:" + // send 1,2,3;~4,~5\n            "(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)" + // space + recv 6;~7,~8\n            "(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?" + // end\n            "$"),\n            names: [\n                "dir1",\n                "list1",\n                "dir2",\n                "list2"\n            ],\n            format: function(o) {\n                return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");\n            }\n        },\n        {\n            // old simulcast draft 03 (implemented by Firefox)\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n            // a=simulcast: recv pt=97;98 send pt=97\n            // a=simulcast: send rid=5;6;7 paused=6,7\n            name: "simulcast_03",\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n            names: [\n                "value"\n            ],\n            format: "simulcast: %s"\n        },\n        {\n            // a=framerate:25\n            // a=framerate:29.97\n            name: "framerate",\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n            format: "framerate:%s"\n        },\n        {\n            // RFC4570\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n            name: "sourceFilter",\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n            names: [\n                "filterMode",\n                "netType",\n                "addressTypes",\n                "destAddress",\n                "srcList"\n            ],\n            format: "source-filter: %s %s %s %s %s"\n        },\n        {\n            // a=bundle-only\n            name: "bundleOnly",\n            reg: /^(bundle-only)/\n        },\n        {\n            // a=label:1\n            name: "label",\n            reg: /^label:(.+)/,\n            format: "label:%s"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n            name: "sctpPort",\n            reg: /^sctp-port:(\\d+)$/,\n            format: "sctp-port:%s"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n            name: "maxMessageSize",\n            reg: /^max-message-size:(\\d+)$/,\n            format: "max-message-size:%s"\n        },\n        {\n            // RFC7273\n            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n            push: "tsRefClocks",\n            reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n            names: [\n                "clksrc",\n                "clksrcExt"\n            ],\n            format: function(o) {\n                return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");\n            }\n        },\n        {\n            // RFC7273\n            // a=mediaclk:direct=963214424\n            name: "mediaClk",\n            reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n            names: [\n                "id",\n                "mediaClockName",\n                "mediaClockValue",\n                "rateNumerator",\n                "rateDenominator"\n            ],\n            format: function(o) {\n                var str = "mediaclk:";\n                str += o.id != null ? "id=%s %s" : "%v%s";\n                str += o.mediaClockValue != null ? "=%s" : "";\n                str += o.rateNumerator != null ? " rate=%s" : "";\n                str += o.rateDenominator != null ? "/%s" : "";\n                return str;\n            }\n        },\n        {\n            // a=keywds:keywords\n            name: "keywords",\n            reg: /^keywds:(.+)$/,\n            format: "keywds:%s"\n        },\n        {\n            // a=content:main\n            name: "content",\n            reg: /^content:(.+)/,\n            format: "content:%s"\n        },\n        // BFCP https://tools.ietf.org/html/rfc4583\n        {\n            // a=floorctrl:c-s\n            name: "bfcpFloorCtrl",\n            reg: /^floorctrl:(c-only|s-only|c-s)/,\n            format: "floorctrl:%s"\n        },\n        {\n            // a=confid:1\n            name: "bfcpConfId",\n            reg: /^confid:(\\d+)/,\n            format: "confid:%s"\n        },\n        {\n            // a=userid:1\n            name: "bfcpUserId",\n            reg: /^userid:(\\d+)/,\n            format: "userid:%s"\n        },\n        {\n            // a=floorid:1\n            name: "bfcpFloorId",\n            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n            names: [\n                "id",\n                "mStream"\n            ],\n            format: "floorid:%s mstrm:%s"\n        },\n        {\n            // any a= that we don\'t understand is kept verbatim on media.invalid\n            push: "invalid",\n            names: [\n                "value"\n            ]\n        }\n    ]\n};\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar$1).forEach(function(key) {\n    var objs = grammar$1[key];\n    objs.forEach(function(obj) {\n        if (!obj.reg) {\n            obj.reg = /(.*)/;\n        }\n        if (!obj.format) {\n            obj.format = "%s";\n        }\n    });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n    var toIntIfInt = function(v) {\n        return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function(match, location, names, rawName) {\n        if (rawName && !names) {\n            location[rawName] = toIntIfInt(match[1]);\n        } else {\n            for(var i = 0; i < names.length; i += 1){\n                if (match[i + 1] != null) {\n                    location[names[i]] = toIntIfInt(match[i + 1]);\n                }\n            }\n        }\n    };\n    var parseReg = function(obj, location, content) {\n        var needsBlank = obj.name && obj.names;\n        if (obj.push && !location[obj.push]) {\n            location[obj.push] = [];\n        } else if (needsBlank && !location[obj.name]) {\n            location[obj.name] = {};\n        }\n        var keyLocation = obj.push ? {} : // blank object that will be pushed\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\n        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n        if (obj.push) {\n            location[obj.push].push(keyLocation);\n        }\n    };\n    var grammar = grammarExports;\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function(sdp) {\n        var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n        // parse lines we understand\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n            var type = l[0];\n            var content = l.slice(2);\n            if (type === "m") {\n                media.push({\n                    rtp: [],\n                    fmtp: []\n                });\n                location = media[media.length - 1]; // point at latest media line\n            }\n            for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                var obj = grammar[type][j];\n                if (obj.reg.test(content)) {\n                    return parseReg(obj, location, content);\n                }\n            }\n        });\n        session.media = media; // link it up\n        return session;\n    };\n    var paramReducer = function(acc, expr) {\n        var s = expr.split(/=(.+)/, 2);\n        if (s.length === 2) {\n            acc[s[0]] = toIntIfInt(s[1]);\n        } else if (s.length === 1 && expr.length > 1) {\n            acc[s[0]] = undefined;\n        }\n        return acc;\n    };\n    exports.parseParams = function(str) {\n        return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function(str) {\n        return str.toString().split(" ").map(Number);\n    };\n    exports.parseRemoteCandidates = function(str) {\n        var candidates = [];\n        var parts = str.split(" ").map(toIntIfInt);\n        for(var i = 0; i < parts.length; i += 3){\n            candidates.push({\n                component: parts[i],\n                ip: parts[i + 1],\n                port: parts[i + 2]\n            });\n        }\n        return candidates;\n    };\n    exports.parseImageAttributes = function(str) {\n        return str.split(" ").map(function(item) {\n            return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});\n        });\n    };\n    exports.parseSimulcastStreamList = function(str) {\n        return str.split(";").map(function(stream) {\n            return stream.split(",").map(function(format) {\n                var scid, paused = false;\n                if (format[0] !== "~") {\n                    scid = toIntIfInt(format);\n                } else {\n                    scid = toIntIfInt(format.substring(1, format.length));\n                    paused = true;\n                }\n                return {\n                    scid: scid,\n                    paused: paused\n                };\n            });\n        });\n    };\n})(parser$1);\nvar grammar = grammarExports;\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function(x) {\n        if (i >= len) {\n            return x; // missing argument\n        }\n        var arg = args[i];\n        i += 1;\n        switch(x){\n            case "%%":\n                return "%";\n            case "%s":\n                return String(arg);\n            case "%d":\n                return Number(arg);\n            case "%v":\n                return "";\n        }\n    });\n// NB: we discard excess arguments - they are typically undefined from makeLine\n};\nvar makeLine = function(type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [\n        type + "=" + str\n    ];\n    if (obj.names) {\n        for(var i = 0; i < obj.names.length; i += 1){\n            var n = obj.names[i];\n            if (obj.name) {\n                args.push(location[obj.name][n]);\n            } else {\n                // for mLine and push attributes\n                args.push(location[obj.names[i]]);\n            }\n        }\n    } else {\n        args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n};\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n    "v",\n    "o",\n    "s",\n    "i",\n    "u",\n    "e",\n    "p",\n    "c",\n    "b",\n    "t",\n    "r",\n    "z",\n    "a"\n];\nvar defaultInnerOrder = [\n    "i",\n    "c",\n    "b",\n    "a"\n];\nvar writer$1 = function(session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n        session.version = 0; // \'v=0\' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n        session.name = " "; // \'s= \' must be there if no meaningful name set\n    }\n    session.media.forEach(function(mLine) {\n        if (mLine.payloads == null) {\n            mLine.payloads = "";\n        }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function(type) {\n        grammar[type].forEach(function(obj) {\n            if (obj.name in session && session[obj.name] != null) {\n                sdp.push(makeLine(type, obj, session));\n            } else if (obj.push in session && session[obj.push] != null) {\n                session[obj.push].forEach(function(el) {\n                    sdp.push(makeLine(type, obj, el));\n                });\n            }\n        });\n    });\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function(mLine) {\n        sdp.push(makeLine("m", grammar.m[0], mLine));\n        innerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in mLine && mLine[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, mLine));\n                } else if (obj.push in mLine && mLine[obj.push] != null) {\n                    mLine[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n    });\n    return sdp.join("\\r\\n") + "\\r\\n";\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig; // Alias of parseParams().\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst PCEvents = {\n    NegotiationStarted: "negotiationStarted",\n    NegotiationComplete: "negotiationComplete",\n    RTPVideoPayloadTypes: "rtpVideoPayloadTypes"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let mediaConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), 100);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this.mediaConstraints = mediaConstraints;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = isChromiumBased() ? // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n        new RTCPeerConnection(this.config, this.mediaConstraints) : new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            let mungedSDP = undefined;\n            if (sd.type === "offer") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === "answer") {\n                const sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : "");\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === "audio") {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(";").filter((attr)=>!attr.includes("maxaveragebitrate")).join(";");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: "maxaveragebitrate=".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === "answer") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === "video") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug("restarting ICE", this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === "have-local-offer") {\n                // we\'re waiting for the peer to accept our offer, so we\'ll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don\'t have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === "closed") {\n                this.log.warn("could not createOffer with closed peer connection", this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug("starting to negotiate", this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === "audio") {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === "video") {\n                    ensureVideoDDExtensionForSVC(media);\n                    // mung sdp for codec bitrate setting that can\'t apply by sendEncoding\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        let fmtpFound = false;\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                if (!fmtp.config.includes("x-google-start-bitrate")) {\n                                    fmtp.config += ";x-google-start-bitrate=".concat(Math.round(trackbr.maxbr * startBitrateForSVC));\n                                }\n                                if (!fmtp.config.includes("x-google-max-bitrate")) {\n                                    fmtp.config += ";x-google-max-bitrate=".concat(trackbr.maxbr);\n                                }\n                                fmtpFound = true;\n                                break;\n                            }\n                        }\n                        if (!fmtpFound) {\n                            media.fmtp.push({\n                                payload: codecPayload,\n                                config: "x-google-start-bitrate=".concat(Math.round(trackbr.maxbr * startBitrateForSVC), ";x-google-max-bitrate=").concat(trackbr.maxbr)\n                            });\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : "");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === "audio") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState("PC closed, cannot add track");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState("PC closed, cannot configure");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : "closed";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : "closed";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = "";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case "transport":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case "candidate-pair":\n                        if (selectedCandidatePairId === "" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case "remote-candidate":\n                        candidates.set(v.id, "".concat(v.address, ":").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === "") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                // this error cannot always be caught.\n                // If the local description has a setCodecPreferences error, this error will be uncaught\n                let msg = "unknown error";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === "string") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === "opus") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === "nack")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: "nack"\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes("stereo=1")) {\n                        fmtp.config += ";stereo=1";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n    var _a, _b, _c, _d;\n    const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n    if (!isSVCCodec(codec)) {\n        return;\n    }\n    let maxID = 0;\n    const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext)=>{\n        if (ext.uri === ddExtensionURI) {\n            return true;\n        }\n        if (ext.value > maxID) {\n            maxID = ext.value;\n        }\n        return false;\n    });\n    if (!ddFound) {\n        (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n            value: maxID + 1,\n            uri: ddExtensionURI\n        });\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === "audio") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === "opus") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === "nack")) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes("sprop-stereo=1")) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nconst defaultVideoCodec = "vp8";\nconst publishDefaults = {\n    /**\n   * @deprecated\n   */ audioBitrate: AudioPresets.music.maxBitrate,\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n};\nconst videoDefaults = {\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    expWebAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState["NEW"] = 0] = "NEW";\n    PCTransportState[PCTransportState["CONNECTING"] = 1] = "CONNECTING";\n    PCTransportState[PCTransportState["CONNECTED"] = 2] = "CONNECTED";\n    PCTransportState[PCTransportState["FAILED"] = 3] = "FAILED";\n    PCTransportState[PCTransportState["CLOSING"] = 4] = "CLOSING";\n    PCTransportState[PCTransportState["CLOSED"] = 5] = "CLOSED";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === "connected")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === "failed")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === "connecting")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === "closed")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === "closed")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === "new")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        const googConstraints = {\n            optional: [\n                {\n                    googDscp: true\n                }\n            ]\n        };\n        this.publisher = new PCTransport(rtcConfig, googConstraints, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new Mutex();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== "closed") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn\'t have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it\'s needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            yield this.subscriber.setRemoteDescription(sd);\n            // answer the offer\n            const answer = yield this.subscriber.createAndSetAnswer();\n            return answer;\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {\n                    this.log.debug("negotiation required, start negotiating", this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject("negotiation timed out");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject("negotiation aborted");\n                    };\n                    abortController.signal.addEventListener("abort", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport\'s address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport, abortController) {\n        let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n        return __awaiter(this, void 0, void 0, function*() {\n            const connectionState = pcTransport.getConnectionState();\n            if (connectionState === "connected") {\n                return;\n            }\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const abortHandler = ()=>{\n                        this.log.warn("abort transport connection", this.logContext);\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        reject(new ConnectionError("room connection has been cancelled", 3 /* ConnectionErrorReason.Cancelled */ ));\n                    };\n                    if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                        abortHandler();\n                    }\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);\n                    const connectTimeout = CriticalTimers.setTimeout(()=>{\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);\n                        reject(new ConnectionError("could not establish pc connection"));\n                    }, timeout);\n                    while(this.state !== PCTransportState.CONNECTED){\n                        yield sleep(50); // FIXME we shouldn\'t rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            reject(new ConnectionError("room connection has been cancelled", 3 /* ConnectionErrorReason.Cancelled */ ));\n                            return;\n                        }\n                    }\n                    CriticalTimers.clearTimeout(connectTimeout);\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);\n                    resolve();\n                }));\n        });\n    }\n}\nconst lossyDataChannel = "_lossy";\nconst reliableDataChannel = "_reliable";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = "leave-reconnect";\nvar PCState;\n(function(PCState) {\n    PCState[PCState["New"] = 0] = "New";\n    PCState[PCState["Connected"] = 1] = "Connected";\n    PCState[PCState["Disconnected"] = 2] = "Disconnected";\n    PCState[PCState["Reconnecting"] = 3] = "Reconnecting";\n    PCState[PCState["Closed"] = 4] = "Closed";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_ref)=>{\n            let { channel } = _ref;\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!channel) {\n                    return;\n                }\n                if (channel.label === reliableDataChannel) {\n                    this.reliableDCSub = channel;\n                } else if (channel.label === lossyDataChannel) {\n                    this.lossyDCSub = channel;\n                } else {\n                    return;\n                }\n                this.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), this.logContext);\n                channel.onmessage = this.handleDataMessage;\n            });\n        };\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _b, _c;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === "speaker") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_c = dp.value) === null || _c === void 0 ? void 0 : _c.case) === "user") {\n                        this.emit(EngineEvent.DataPacketReceived, dp.value.value, dp.kind);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we\'ll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn("".concat(connection, " disconnected"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration, "ms. giving up"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug("reconnecting in ".concat(delay, "ms"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== "undefined" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to \'onLine\'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new Mutex();\n        this.dataProcessLock = new Mutex();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomSid: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            identity: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === 1 /* ConnectionErrorReason.ServerUnreachable */ ) {\n                        this.log.warn("Couldn\'t connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError("a track with the same ID has already been published");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError("publication of local track timed out, no response from server"));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error("Cancelled publication by calling unpublish"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to \'disconnected\' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            this.createDataChannels();\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n                this.fullReconnectOnNext = true;\n                // reconnect immediately instead of waiting for next attempt\n                this.handleDisconnect(leaveReconnect);\n            } else {\n                this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                this.close();\n            }\n            this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = "relay";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = "unified-plan";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = "gather_continually";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    setPreferredCodec(transceiver, kind, videoCodec) {\n        if (!("getCapabilities" in RTCRtpSender)) {\n            return;\n        }\n        const cap = RTCRtpSender.getCapabilities(kind);\n        if (!cap) return;\n        this.log.debug("get sender capabilities", Object.assign(Object.assign({}, this.logContext), {\n            cap\n        }));\n        const matched = [];\n        const partialMatched = [];\n        const unmatched = [];\n        cap.codecs.forEach((c)=>{\n            const codec = c.mimeType.toLowerCase();\n            if (codec === "audio/opus") {\n                matched.push(c);\n                return;\n            }\n            const matchesVideoCodec = codec === "video/".concat(videoCodec);\n            if (!matchesVideoCodec) {\n                unmatched.push(c);\n                return;\n            }\n            // for h264 codecs that have sdpFmtpLine available, use only if the\n            // profile-level-id is 42e01f for cross-browser compatibility\n            if (videoCodec === "h264") {\n                if (c.sdpFmtpLine && c.sdpFmtpLine.includes("profile-level-id=42e01f")) {\n                    matched.push(c);\n                } else {\n                    partialMatched.push(c);\n                }\n                return;\n            }\n            matched.push(c);\n        });\n        if (supportsSetCodecPreferences(transceiver)) {\n            transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n        }\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn("using add-track fallback", this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug("using add-track fallback", this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState("Cannot stream on this device");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("publisher is closed");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            const transceiverInit = {\n                direction: "sendonly",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won\'t effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            if (track.kind === Track.Kind.Video && opts.videoCodec) {\n                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n                track.codec = opts.videoCodec;\n            }\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("publisher is closed");\n            }\n            const transceiverInit = {\n                direction: "sendonly"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won\'t effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("publisher is closed");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn("already attempting reconnect, returning early", this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don\'t attempt reconnection\n                    throw new UnexpectedConnectionState("could not reconnect, url or token not saved");\n                }\n                this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn("attempted connection restart, without signal options present", this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                        throw new UnexpectedConnectionState("could not reconnect, token might be expired");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error("simulated failure");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError("Signal connection got severed during reconnect");\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we\'re not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.url || !this.token) {\n                // permanent failure, don\'t attempt reconnection\n                throw new UnexpectedConnectionState("could not reconnect, url or token not saved");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("publisher and subscriber connections unset");\n            }\n            this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            try {\n                this.setupSignalClientCallbacks();\n                const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n                if (res) {\n                    const rtcConfig = this.makeRTCConfiguration(res);\n                    this.pcManager.updateConfiguration(rtcConfig);\n                }\n            } catch (error) {\n                let message = "";\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                    throw new UnexpectedConnectionState("could not reconnect, token might be expired");\n                }\n                if (error instanceof ConnectionError && error.reason === 4 /* ConnectionErrorReason.LeaveRequest */ ) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error("simulated failure");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError("Signal connection got severed during reconnect");\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it\'s id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === "open" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("PC manager is closed");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug("waiting for peer connection to reconnect", this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState("PC manager is closed");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError("could not establish PC connection, ".concat(e.message));\n            }\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind) {\n        let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState("PC manager is closed");\n            }\n            const transport = subscriber ? this.pcManager.subscriber : this.pcManager.publisher;\n            const transportName = subscriber ? "Subscriber" : "Publisher";\n            if (!transport) {\n                throw new ConnectionError("".concat(transportName, " connection not set"));\n            }\n            if (!subscriber && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking") {\n                // start negotiation\n                this.negotiate();\n            }\n            const targetChannel = this.dataChannelForKind(kind, subscriber);\n            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {\n                return;\n            }\n            // wait until ICE connected\n            const endTime = new Date().getTime() + this.peerConnectionTimeout;\n            while(new Date().getTime() < endTime){\n                if (transport.isICEConnected && ((_a = this.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === "open") {\n                    return;\n                }\n                yield sleep(50);\n            }\n            throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()));\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensureDataTransportConnected(kind, false);\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError("PC manager is closed"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug("engine disconnected while negotiation was ongoing", this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject("cannot negotiate on closed engine");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo()\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener("online", this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener("online", this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error("region availability is only supported for LiveKit Cloud domains");\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug("next region: ".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {\n                headers: {\n                    authorization: "Bearer ".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 /* ConnectionErrorReason.NotAllowed */  : undefined, regionSettingsResponse.status);\n            }\n        });\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if ("bytesReceived" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if ("bytesSent" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this.mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug("stopping mic track", this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug("reacquiring mic track", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== "boolean") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!this.audioContext) {\n                    throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === "unknown") {\n                    throw TypeError("cannot set processor on track of unknown kind");\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    audioContext: this.audioContext\n                };\n                this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === "outbound-rtp") {\n                    audioStats = {\n                        type: "audio",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn("silence detected on local audio track", this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case "audio":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case "video":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    "q",\n    "h",\n    "f"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren\'t simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug("using video encoding", videoEncoding);\n    }\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        livekitLogger.debug("using svc with scalabilityMode ".concat(scalabilityMode));\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));\n        }\n        for(let i = 0; i < sm.spatial; i += 1){\n            encodings.push({\n                rid: videoRids[2 - i],\n                maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n                /* @ts-ignore */ maxFramerate: original.encoding.maxFramerate\n            });\n        }\n        /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        livekitLogger.debug("encodings", encodings);\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. ion-sfu translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ]);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ]);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn("requested a different codec than specified as backup", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case "av1":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case "vp9":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        if (preset.encoding.maxFramerate) {\n            encoding.maxFramerate = preset.encoding.maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === "ios") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");\n                }\n                livekitLogger.info(\'Setting framerate of encoding "\'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : "", \'" to \').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error("invalid scalability mode");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case "h":\n                case "_KEY":\n                case "_KEY_SHIFT":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : "");\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new Mutex();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        var _a, e_1, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        var _a, e_2, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug("stopping camera track", this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug("reacquiring camera track", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === "outbound-rtp") {\n                    const vs = {\n                        type: "video",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        framesSent: v.framesSent,\n                        timestamp: v.timestamp,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n                    };\n                    // locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when video is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    restartTrack(options) {\n        var _a, e_3, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== "boolean") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const sc = _c;\n                    if (sc.sender) {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.setProcessor.call(this, processor, showProcessedStreamLocally);\n            if ((_d = this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                try {\n                    for(var _f = true, _g = __asyncValues(this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                        _c = _h.value;\n                        _f = false;\n                        const sc = _c;\n                        yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(this.processor.processedTrack);\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            throw new Error("".concat(codec, " already added"));\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        var _a, codecs_1, codecs_1_1;\n        var _b, e_5, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn("cannot set publishing layers, encodings mismatch");\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : "";\n                    if (rid === "") {\n                        rid = "q";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug("setting encodings", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case "f":\n            return VideoQuality.HIGH;\n        case "h":\n            return VideoQuality.MEDIUM;\n        case "q":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: VideoQuality.HIGH - i,\n                width: Math.ceil(width / Math.pow(2, i)),\n                height: Math.ceil(height / Math.pow(2, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(3, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener("removetrack", onRemoveTrack);\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener("removetrack", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack\'s underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn\'t been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug("using audio context mapping", this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that\'s left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn\'t running already\n        if (context.state !== "running") {\n            context.resume().then(()=>{\n                if (context.state !== "running") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn\'t be started automatically"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === "inbound-rtp") {\n                    receiverStats = {\n                        type: "audio",\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It\'s possible attach is called multiple times on an element. When that\'s\n        // the case, we\'d want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn("visibility resize observer not triggered", this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn("stopObservingElementInfo ignored", this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = "";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === "inbound-rtp") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: "video",\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === "codec") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== "" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === "screen") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we\'ll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we\'ll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a;\n            this.isPiP = true;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = false;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && document.pictureInPictureElement === element;\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = document.pictureInPictureElement === this.element;\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);\n        this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);\n        this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);\n    }\n}\n// does not account for occlusion by other elements\nfunction isElementInViewport(el) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== "" ? parseFloat(opacity) > 0 : true) && display !== "none";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus["Desired"] = "desired";\n        SubscriptionStatus["Subscribed"] = "subscribed";\n        SubscriptionStatus["Unsubscribed"] = "unsubscribed";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus["Allowed"] = "allowed";\n        PermissionStatus["NotAllowed"] = "not_allowed";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals "muted" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals "unmuted" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality["Excellent"] = "excellent";\n    ConnectionQuality["Good"] = "good";\n    ConnectionQuality["Poor"] = "poor";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality["Lost"] = "lost";\n    ConnectionQuality["Unknown"] = "unknown";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign(Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a)), {\n            participantSid: this.sid,\n            participantId: this.identity\n        });\n    }\n    get isEncrypted() {\n        return this.tracks.size > 0 && Array.from(this.tracks.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a, _b;\n        return (_b = (_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) !== null && _b !== void 0 ? _b : false;\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, loggerOptions){\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n    }\n    getTracks() {\n        return Array.from(this.tracks.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user\'s camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */ getTrack(source) {\n        for (const [, pub] of this.tracks){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track\'s name.\n   * @param name\n   * @returns\n   */ getTrackByName(name) {\n        for (const [, pub] of this.tracks){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrack(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it\'s possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it\'s possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        });\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTracks.forEach((track)=>(track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.tracks.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : "",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it\'s not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn\'t keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: "",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client\'s desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (this.track instanceof RemoteVideoTrack) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!(this.track instanceof RemoteVideoTrack)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn("cannot update track settings when not subscribed", this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, loggerOptions){\n        super(sid, identity || "", name, metadata, loggerOptions);\n        this.signalClient = signalClient;\n        this.tracks = new Map();\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant\'s audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant\'s microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it\'s possible for the media track to arrive before participant info\n        let publication = this.getTrackPublication(sid);\n        // it\'s also possible that the browser didn\'t honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith("TR")) {\n                // find the first track that matches type\n                this.tracks.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn\'t locate the track, it\'s possible that the metadata hasn\'t\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === "ended") {\n            this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === "video";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication\'s muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    getTrackPublication(sid) {\n        return this.tracks.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublication(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.tracks.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it\'s ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.tracks.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.tracks.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTracks.forEach((pub)=>{\n                var _a;\n                if (pub.track instanceof RemoteAudioTrack) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : "default"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options){\n        super(sid, identity, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, "Got disconnected during reconnection attempt");\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we\'ll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTracks.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.tracks.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? "camera" : "microphone"\n                                });\n                                if (currentPermissions && currentPermissions.state === "denied") {\n                                    this.log.warn("user has revoked access to ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== "denied") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error("GetUserMedia Permission denied");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            yield track.restartTrack();\n                        }\n                    } catch (e) {\n                        this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map();\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.tracks.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setMetadata(metadata) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : "");\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setName(name) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : "", name);\n    }\n    /**\n   * Enable or disable a participant\'s camera track.\n   *\n   * If a track has already published, it\'ll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant\'s microphone track.\n   *\n   * If a track has already published, it\'ll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant\'s screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            let track = this.getTrack(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                        // no-op it\'s already been requested\n                        return;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else if (track && track.track) {\n                // screenshare cannot be muted, unpublish instead\n                if (source === Track.Source.ScreenShare) {\n                    track = yield this.unpublishTrack(track.track);\n                    const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n                    if (screenAudioTrack && screenAudioTrack.track) {\n                        this.unpublishTrack(screenAudioTrack.track);\n                    }\n                } else {\n                    yield track.mute();\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it\'s already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            const constraints = constraintsForOptions(opts);\n            let stream;\n            try {\n                stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (constraints.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (constraints.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n            if (constraints.audio) {\n                this.microphoneError = undefined;\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n            }\n            if (constraints.video) {\n                this.cameraError = undefined;\n            }\n            return stream.getTracks().map((mediaStreamTrack)=>{\n                const isAudio = mediaStreamTrack.kind === "audio";\n                isAudio ? options.audio : options.video;\n                let trackConstraints;\n                const conOrBool = isAudio ? constraints.audio : constraints.video;\n                if (typeof conOrBool !== "boolean") {\n                    trackConstraints = conOrBool;\n                }\n                const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                if (track.kind === Track.Kind.Video) {\n                    track.source = Track.Source.Camera;\n                } else if (track.kind === Track.Kind.Audio) {\n                    track.source = Track.Source.Microphone;\n                }\n                track.mediaStream = stream;\n                return track;\n            });\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError("getDisplayMedia not supported");\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError("no video track found");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n            if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n                yield this.pendingPublishPromises.get(track);\n            }\n            let defaultConstraints;\n            if (track instanceof MediaStreamTrack) {\n                defaultConstraints = track.getConstraints();\n            } else {\n                // we want to access constraints directly as `track.mediaStreamTrack`\n                // might be pointing to a non-device track (e.g. processed track) already\n                defaultConstraints = track.constraints;\n                let deviceKind = undefined;\n                switch(track.source){\n                    case Track.Source.Microphone:\n                        deviceKind = "audioinput";\n                        break;\n                    case Track.Source.Camera:\n                        deviceKind = "videoinput";\n                }\n                if (deviceKind && this.activeDeviceMap.has(deviceKind)) {\n                    defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                        deviceId: this.activeDeviceMap.get(deviceKind)\n                    });\n                }\n            }\n            // convert raw media track into audio or video track\n            if (track instanceof MediaStreamTrack) {\n                switch(track.kind){\n                    case "audio":\n                        track = new LocalAudioTrack(track, defaultConstraints, true, this.audioContext, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    case "video":\n                        track = new LocalVideoTrack(track, defaultConstraints, true, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    default:\n                        throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));\n                }\n            } else {\n                track.updateLoggerOptions({\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n            }\n            if (track instanceof LocalAudioTrack) {\n                track.setAudioContext(this.audioContext);\n            }\n            // is it already published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (existingPublication) {\n                this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(existingPublication)));\n                return existingPublication;\n            }\n            const isStereoInput = "channelCount" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n            track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n            const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n            // disable dtx for stereo track if not enabled explicitly\n            if (isStereo) {\n                if (!options) {\n                    options = {};\n                }\n                if (options.dtx === undefined) {\n                    this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                }\n                if (options.red === undefined) {\n                    this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");\n                }\n                (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n            }\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            // disable simulcast if e2ee is set on safari\n            if (isSafari() && this.roomOptions.e2ee) {\n                this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext));\n                opts.simulcast = false;\n            }\n            if (opts.source) {\n                track.source = opts.source;\n            }\n            const publishPromise = this.publish(track, opts, isStereo);\n            this.pendingPublishPromises.set(track, publishPromise);\n            try {\n                const publication = yield publishPromise;\n                return publication;\n            } catch (e) {\n                throw e;\n            } finally{\n                this.pendingPublishPromises.delete(track);\n            }\n        });\n    }\n    publish(track, opts, isStereo) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>track instanceof LocalTrack && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info("publishing a second track with the same source: ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === "av1" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === "vp9" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it\'s quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (track instanceof LocalVideoTrack) {\n                    if (isSVCCodec(videoCodec)) {\n                        // vp9 svc with screenshare has problem to encode, always use L1T3 here\n                        if (track.source === Track.Source.ScreenShare && videoCodec === "vp9") {\n                            opts.scalabilityMode = "L1T3";\n                        }\n                        // set scalabilityMode to \'L3T3_KEY\' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : "L3T3_KEY";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: ""\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate) !== null && _g !== void 0 ? _g : opts.audioBitrate,\n                        priority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : "high",\n                        networkPriority: (_l = (_k = opts.audioPreset) === null || _k === void 0 ? void 0 : _k.priority) !== null && _l !== void 0 ? _l : "high"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState("cannot publish track when not connected");\n            }\n            const ti = yield this.engine.addTrack(req);\n            // server might not support the codec the client has requested, in that case, fallback\n            // to a supported codec\n            let primaryCodecMime;\n            ti.codecs.forEach((codec)=>{\n                if (primaryCodecMime === undefined) {\n                    primaryCodecMime = codec.mimeType;\n                }\n            });\n            if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                if (updatedCodec !== videoCodec) {\n                    this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        codec: updatedCodec\n                    }));\n                    /* @ts-ignore */ opts.videoCodec = updatedCodec;\n                    // recompute encodings since bitrates/etc could have changed\n                    encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                }\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            if (!this.engine.pcManager) {\n                throw new UnexpectedConnectionState("pcManager is not ready");\n            }\n            this.log.debug("publishing ".concat(track.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            track.sender = yield this.engine.createSender(track, opts, encodings);\n            if (encodings) {\n                if (isFireFox() && track.kind === Track.Kind.Audio) {\n                    /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n             livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n             publish high quality audio track. But firefox always uses this value as the actual\n             bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n             So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n             fix the issue.\n           */ let trackTransceiver = undefined;\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        if (transceiver.sender === track.sender) {\n                            trackTransceiver = transceiver;\n                            break;\n                        }\n                    }\n                    if (trackTransceiver) {\n                        this.engine.pcManager.publisher.setTrackCodecBitrate({\n                            transceiver: trackTransceiver,\n                            codec: "opus",\n                            maxbr: ((_m = encodings[0]) === null || _m === void 0 ? void 0 : _m.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                        });\n                    }\n                } else if (track.codec && isSVCCodec(track.codec) && ((_o = encodings[0]) === null || _o === void 0 ? void 0 : _o.maxBitrate)) {\n                    this.engine.pcManager.publisher.setTrackCodecBitrate({\n                        cid: req.cid,\n                        codec: track.codec,\n                        maxbr: encodings[0].maxBitrate / 1000\n                    });\n                }\n            }\n            yield this.engine.negotiate();\n            if (track instanceof LocalVideoTrack) {\n                track.startMonitor(this.engine.client);\n            } else if (track instanceof LocalAudioTrack) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError("track is not published");\n            }\n            if (!(track instanceof LocalVideoTrack)) {\n                throw new TrackInvalidError("track is not a video track");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState("cannot publish track when not connected");\n            }\n            const ti = yield this.engine.addTrack(req);\n            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n            yield this.engine.negotiate();\n            this.log.debug("published ".concat(videoCodec, " for track ").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = "inactive";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (track instanceof LocalVideoTrack) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.tracks.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTracks.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTracks.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>track instanceof LocalTrackPublication);\n        });\n    }\n    republishAllTracks(options) {\n        let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const localPubs = [];\n            this.tracks.forEach((pub)=>{\n                if (pub.track) {\n                    if (options) {\n                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                    }\n                    localPubs.push(pub);\n                }\n            });\n            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                    const track = pub.track;\n                    yield this.unpublishTrack(track, false);\n                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n                        // generally we need to restart the track before publishing, often a full reconnect\n                        // is necessary because computer had gone to sleep.\n                        this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {\n                            track: pub.trackSid\n                        }));\n                        yield track.restartTrack();\n                    }\n                    yield this.publishTrack(track, pub.options);\n                })));\n        });\n    }\n    publishData(data, kind) {\n        let publishOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return __awaiter(this, void 0, void 0, function*() {\n            const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n            const destinationSids = [];\n            const topic = !Array.isArray(publishOptions) ? publishOptions.topic : undefined;\n            if (destination !== undefined) {\n                destination.forEach((val)=>{\n                    if (val instanceof RemoteParticipant) {\n                        destinationSids.push(val.sid);\n                    } else {\n                        destinationSids.push(val);\n                    }\n                });\n            }\n            const packet = new DataPacket({\n                kind,\n                value: {\n                    case: "user",\n                    value: new UserPacket({\n                        participantSid: this.sid,\n                        payload: data,\n                        destinationSids: destinationSids,\n                        topic\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, kind);\n        });\n    }\n    /**\n   * Control who can subscribe to LocalParticipant\'s published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server\'s track mute status doesn\'t match actual, we\'ll have to update\n        // the server\'s copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.tracks.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.tracks.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState["Disconnected"] = "disconnected";\n    ConnectionState["Connecting"] = "connecting";\n    ConnectionState["Connected"] = "connected";\n    ConnectionState["Reconnecting"] = "reconnecting";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1000;\n/** @deprecated RoomState has been renamed to [[ConnectionState]] */ const RoomState = ConnectionState;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others\' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _c;\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info("already connected to room ".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().catch((e)=>{\n                        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _d;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== 3 /* ConnectionErrorReason.Cancelled */  && e.reason !== 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_d = this.abortController) === null || _d === void 0 ? void 0 : _d.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3 /* ConnectionErrorReason.Cancelled */ )) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl) {\n                                    this.log.info("Initial connection failed with ConnectionError: ".concat(e.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                    reject(e);\n                                }\n                            } else {\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _e, _f, _g;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    publishOnly: connectOptions.publishOnly,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === "object" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return "".concat(key, ": ").concat(value);\n                }).join(", ")), {\n                    room: (_e = joinResponse.room) === null || _e === void 0 ? void 0 : _e.name,\n                    roomSid: (_f = joinResponse.room) === null || _f === void 0 ? void 0 : _f.sid,\n                    identity: (_g = joinResponse.participant) === null || _g === void 0 ? void 0 : _g.identity\n                });\n                if (!joinResponse.serverVersion) {\n                    throw new UnsupportedServer("unknown server version");\n                }\n                if (joinResponse.serverVersion === "0.15.1" && this.options.dynacast) {\n                    this.log.debug("disabling dynacast due to server version", this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n            if (this.options.e2ee && this.e2eeManager) {\n                this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _h, _j;\n                if (this.state === ConnectionState.Reconnecting) {\n                    this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_h = this.regionUrlProvider) === null || _h === void 0 ? void 0 : _h.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError("could not establish signal connection");\n                    if (err instanceof Error) {\n                        resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError("Connection attempt aborted");\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both \'pagehide\' and \'beforeunload\' to capture broadest set of browser behaviors\n                    window.addEventListener("pagehide", this.onPageLeave);\n                    window.addEventListener("beforeunload", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener("freeze", this.onPageLeave);\n                    (_j = navigator.mediaDevices) === null || _j === void 0 ? void 0 : _j.addEventListener("devicechange", this.handleDeviceChange);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return __awaiter(_this, void 0, void 0, function*() {\n                var _k, _l, _m, _o;\n                const unlock = yield this.disconnectLock.lock();\n                try {\n                    if (this.state === ConnectionState.Disconnected) {\n                        this.log.debug("already disconnected", this.logContext);\n                        return;\n                    }\n                    this.log.info("disconnect from room", Object.assign({}, this.logContext));\n                    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n                        // try aborting pending connection attempt\n                        this.log.warn("abort connection attempt", this.logContext);\n                        (_k = this.abortController) === null || _k === void 0 ? void 0 : _k.abort();\n                        // in case the abort controller didn\'t manage to cancel the connection attempt, reject the connect promise explicitly\n                        (_m = (_l = this.connectFuture) === null || _l === void 0 ? void 0 : _l.reject) === null || _m === void 0 ? void 0 : _m.call(_l, new ConnectionError("Client initiated disconnect"));\n                        this.connectFuture = undefined;\n                    }\n                    // send leave\n                    if (!((_o = this.engine) === null || _o === void 0 ? void 0 : _o.client.isDisconnected)) {\n                        yield this.engine.client.sendLeave();\n                    }\n                    // close engine (also closes client)\n                    if (this.engine) {\n                        yield this.engine.close();\n                    }\n                    this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                    /* @ts-ignore */ this.engine = undefined;\n                } finally{\n                    unlock();\n                }\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === "iOS") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = "livekit-dummy-audio-el";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement("audio");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener("visibilitychange", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.participants.forEach((p)=>{\n                    p.audioTracks.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.participants.values()){\n                    p.videoTracks.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === "NotAllowedError") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.participants.values()){\n                this.handleParticipantDisconnected(p.sid, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.cachedParticipantSids = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_p) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                // emit participant connected events after connection has been re-established\n                this.participants.forEach((participant)=>{\n                    this.emit(RoomEvent.ParticipantConnected, participant);\n                });\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // ensure identity <=> sid mapping\n                const sid = this.identityToSid.get(info.identity);\n                if (sid && sid !== info.sid) {\n                    // sid had changed, need to remove previous participant\n                    this.handleParticipantDisconnected(sid, this.participants.get(sid));\n                }\n                let remoteParticipant = this.participants.get(info.sid);\n                const isNewParticipant = !remoteParticipant;\n                // when it\'s disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.sid, remoteParticipant);\n                } else {\n                    // create participant if doesn\'t exist\n                    remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n                    if (!isNewParticipant) {\n                        // just update, no events\n                        remoteParticipant.updateInfo(info);\n                    }\n                }\n            });\n        };\n        // updates are sent only when there\'s a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.participants.get(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.participants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.participants.get(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.participants.get(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublication(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                pub.track.streamState = Track.streamStateFromProto(streamState.state);\n                participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.participants.get(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.participants.values()).find((p)=>p.tracks.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (userPacket, kind)=>{\n            // find the participant\n            const participant = this.participants.get(userPacket.participantSid);\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.participants.get(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _q;\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (pub.track instanceof LocalAudioTrack) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_q = pub.track) === null || _q === void 0 ? void 0 : _q.getDeviceId();\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.participants = new Map();\n        this.cachedParticipantSids = [];\n        this.identityToSid = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new Mutex();\n        this.localParticipant = new LocalParticipant("", "", this.engine, this.options);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn("Could not set audio output: ".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== "") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error("e2ee not configured, please set e2ee settings within the room options");\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            this.e2eeManager = new E2EEManager(this.options.e2ee);\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (participant instanceof LocalParticipant) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        return {\n            room: this.name,\n            roomSid: this.sid,\n            identity: this.localParticipant.identity\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /** server assigned unique room id */ get sid() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : "";\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n            this.cachedParticipantSids = Array.from(this.participants.keys());\n        }).on(EngineEvent.Resumed, ()=>{\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            this.emit(RoomEvent.Reconnected);\n            this.registerConnectionReconcile();\n            this.updateSubscriptions();\n            // once reconnected, figure out if any participants connected during reconnect and emit events for it\n            const diffParticipants = Array.from(this.participants.values()).filter((p)=>!this.cachedParticipantSids.includes(p.sid));\n            diffParticipants.forEach((p)=>this.emit(RoomEvent.ParticipantConnected, p));\n            this.cachedParticipantSids = [];\n        }).on(EngineEvent.SignalResumed, ()=>{\n            if (this.state === ConnectionState.Reconnecting) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome\'s unique behavior of creating `default`\n   * devices. When encountered, it\'ll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug("prepareConnection to ".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: "HEAD"\n                        });\n                        this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: "HEAD"\n                    });\n                }\n            } catch (e) {\n                this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        const sid = this.identityToSid.get(identity);\n        if (sid) {\n            return this.participants.get(sid);\n        }\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case "signal-reconnect":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose("simulate disconnect");\n                    break;\n                case "speaker":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "speakerUpdate",\n                            value: 3\n                        }\n                    });\n                    break;\n                case "node-failure":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "nodeFailure",\n                            value: true\n                        }\n                    });\n                    break;\n                case "server-leave":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "serverLeave",\n                            value: true\n                        }\n                    });\n                    break;\n                case "migration":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "migration",\n                            value: true\n                        }\n                    });\n                    break;\n                case "resume-reconnect":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose("simulate resume-disconnect");\n                    break;\n                case "disconnect-signal-on-resume":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose("simulate resume-disconnect");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "disconnectSignalOnResume",\n                            value: true\n                        }\n                    });\n                    break;\n                case "disconnect-signal-on-resume-no-messages":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose("simulate resume-disconnect");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "disconnectSignalOnResumeNoMessages",\n                            value: true\n                        }\n                    });\n                    break;\n                case "full-reconnect":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose("simulate full-reconnect");\n                    break;\n                case "force-tcp":\n                case "force-tls":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "switchCandidateProtocol",\n                            value: scenario === "force-tls" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    canReconnect: true\n                                }));\n                            }\n                        });\n                    break;\n                case "subscriber-bandwidth":\n                    if (arg === undefined || typeof arg !== "number") {\n                        throw new Error("subscriber-bandwidth requires a number as argument");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: "subscriberBandwidth",\n                            value: BigInt(arg)\n                        }\n                    });\n                    break;\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    /**\n   * Returns the active audio output device used in this room.\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   * @deprecated use `getActiveDevice(\'audiooutput\')` instead\n   */ getActiveAudioOutputDevice() {\n        var _a, _b;\n        return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : "";\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind, deviceId) {\n        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var _a, _b;\n        var _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let deviceHasChanged = false;\n            let success = true;\n            const deviceConstraint = exact ? {\n                exact: deviceId\n            } : deviceId;\n            if (kind === "audioinput") {\n                const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n                this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track)=>track.source === Track.Source.Microphone);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === "videoinput") {\n                const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n                this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track)=>track.source === Track.Source.Camera);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === "audiooutput") {\n                if (!supportsSetSinkId() && !this.options.expWebAudioMix || this.options.expWebAudioMix && this.audioContext && !("setSinkId" in this.audioContext)) {\n                    throw new Error("cannot switch audio output, setSinkId not supported");\n                }\n                (_a = (_c = this.options).audioOutput) !== null && _a !== void 0 ? _a : _c.audioOutput = {};\n                const prevDeviceId = this.options.audioOutput.deviceId;\n                this.options.audioOutput.deviceId = deviceId;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                try {\n                    if (this.options.expWebAudioMix) {\n                        // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.setSinkId(deviceId);\n                    } else {\n                        yield Promise.all(Array.from(this.participants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    }\n                } catch (e) {\n                    this.options.audioOutput.deviceId = prevDeviceId;\n                    throw e;\n                }\n            }\n            if (deviceHasChanged && success) {\n                this.localParticipant.activeDeviceMap.set(kind, deviceId);\n                this.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n            }\n            return success;\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.participants.clear();\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don\'t fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We\'ll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn("skipping incoming track after Room disconnected", this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantId = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn\'t support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith("TR")) trackId = streamId;\n        if (participantId === this.localParticipant.sid) {\n            this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);\n            return;\n        }\n        const participant = this.participants.get(participantId);\n        if (!participant) {\n            this.log.error("Tried to add a track for a participant, that\'s not present. Sid: ".concat(participantId), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === "object") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.participants.forEach((p)=>{\n                p.tracks.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.tracks.forEach((pub)=>{\n                var _a, _b;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.tracks.clear();\n            this.localParticipant.videoTracks.clear();\n            this.localParticipant.audioTracks.clear();\n            this.participants.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.expWebAudioMix === "boolean") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener("beforeunload", this.onPageLeave);\n                window.removeEventListener("pagehide", this.onPageLeave);\n                window.removeEventListener("freeze", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener("devicechange", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(sid, participant) {\n        // remove and send event\n        this.participants.delete(sid);\n        if (!participant) {\n            return;\n        }\n        this.identityToSid.delete(participant.identity);\n        participant.tracks.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n    }\n    acquireAudioContext() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.options.expWebAudioMix !== "boolean" && this.options.expWebAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.expWebAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === "closed") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.audioContext && this.audioContext.state === "suspended") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn\'t work, we just continue with regular processing\n                try {\n                    yield this.audioContext.resume();\n                } catch (e) {\n                    this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            if (this.options.expWebAudioMix) {\n                this.participants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(id, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n        } else {\n            participant = new RemoteParticipant(this.engine.client, id, "", undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.expWebAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn("Could not set audio output: ".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(id, info) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        const participant = this.createParticipant(id, info);\n        this.participants.set(id, participant);\n        this.identityToSid.set(info.identity, info.sid);\n        // if we have valid info and the participant wasn\'t in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (sid)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.participants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTracks()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTracks(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we\'ll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.participants.values()){\n            for (const pub of p.videoTracks.values()){\n                if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn\'t tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    }\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitWhenConnected(event) {\n        if (this.state === ConnectionState.Connected) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: "RM_SIMULATED",\n                name: "simulated-room",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: "",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: "",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: "simulated-local",\n                name: "local-name"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: "video-dummy"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: "simulated-".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === "object") {\n            return "logContext" in arg && arg.logContext;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus["IDLE"] = 0] = "IDLE";\n    CheckStatus[CheckStatus["RUNNING"] = 1] = "RUNNING";\n    CheckStatus[CheckStatus["SKIPPED"] = 2] = "SKIPPED";\n    CheckStatus[CheckStatus["SUCCESS"] = 3] = "SUCCESS";\n    CheckStatus[CheckStatus["FAILED"] = 4] = "FAILED";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.errorsAsWarnings = false;\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        if (options.errorsAsWarnings) {\n            this.errorsAsWarnings = options.errorsAsWarnings;\n        }\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error("check is running already");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === "error");\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            yield this.room.connect(this.url, this.token);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: "info",\n            message\n        });\n        this.emit("update", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: "warning",\n            message\n        });\n        this.emit("update", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: "error",\n            message\n        });\n        this.emit("update", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit("update", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it\'ll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        options !== null && options !== void 0 ? options : options = {};\n        (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n        (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n        const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (options.audio) {\n            DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete("audioinput"));\n        }\n        if (options.video) {\n            DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete("videoinput"));\n        }\n        const stream = yield mediaPromise;\n        return stream.getTracks().map((mediaStreamTrack)=>{\n            const isAudio = mediaStreamTrack.kind === "audio";\n            isAudio ? options.audio : options.video;\n            let trackConstraints;\n            const conOrBool = isAudio ? constraints.audio : constraints.video;\n            if (typeof conOrBool !== "boolean") {\n                trackConstraints = conOrBool;\n            }\n            // update the constraints with the device id the user gave permissions to in the permission prompt\n            // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n            if (trackConstraints) {\n                trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;\n            } else {\n                trackConstraints = {\n                    deviceId: mediaStreamTrack.getSettings().deviceId\n                };\n            }\n            const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n            if (track.kind === Track.Kind.Video) {\n                track.source = Track.Source.Camera;\n            } else if (track.kind === Track.Kind.Audio) {\n                track.source = Track.Source.Microphone;\n            }\n            track.mediaStream = stream;\n            return track;\n        });\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError("getDisplayMedia not supported");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError("no video track found");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return "Can publish audio";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it\'s publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error("Could not get RTCStats");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === "outbound-rtp" && stat.mediaType === "audio") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error("Could not determine packets are sent");\n            }\n            this.appendMessage("published ".concat(numPackets, " audio packets"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return "Can publish video";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it\'s publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error("Could not get RTCStats");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === "outbound-rtp" && stat.mediaType === "video") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error("Could not determine packets are sent");\n            }\n            this.appendMessage("published ".concat(numPackets, " video packets"));\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return "Resuming connection after interruption";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            room.on(RoomEvent.Reconnecting, ()=>{\n                reconnectingTriggered = true;\n            }).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose("");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error("Did not attempt to reconnect");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning("reconnection is only possible in Redis-based configurations");\n                throw new Error("Not able to reconnect");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return "Can connect via TURN";\n    }\n    perform() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith("turn:")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith("turns:")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith("stun:")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning("No STUN servers configured on server side.");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: "relay"\n                    }\n                });\n            } else {\n                this.appendWarning("No TURN servers configured.");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return "Establishing WebRTC connection";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += " (private)";\n                            } else {\n                                if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {\n                                    hasTcp = true;\n                                    str += " (passive)";\n                                } else if (candidate.protocol === "udp") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info("now the room is connected");\n            } catch (err) {\n                this.appendWarning("ports need to be open on firewall in order to connect.");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning("Server is not configured for ICE/TCP");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(".");\n    if (parts.length === 4) {\n        if (parts[0] === "10") {\n            return true;\n        } else if (parts[0] === "192" && parts[1] === "168") {\n            return true;\n        } else if (parts[0] === "172") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return "Connecting to signal connection via WebSocket";\n    }\n    perform() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {\n                this.appendWarning("Server is insecure, clients may block connections to it");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage("LiveKit Cloud: ".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        super();\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: "",\n            description: ""\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit("checkUpdate", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on("update", handleUpdate);\n            const result = yield test.run();\n            test.off("update", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : "user",\n        confidence: "low"\n    };\n    // 1. Try to get facingMode from track settings.\n    if ("facingMode" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.debug("rawFacingMode", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === "string" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: "high"\n            };\n        }\n    }\n    // 2. If we don\'t have a high confidence we try to get the facing mode from the device label.\n    if ([\n        "low",\n        "medium"\n    ].includes(result.confidence)) {\n        livekitLogger.debug("Try to get facing mode from device label: (".concat(track.label, ")"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        "obs virtual camera",\n        {\n            facingMode: "environment",\n            confidence: "medium"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        "iphone",\n        {\n            facingMode: "environment",\n            confidence: "medium"\n        }\n    ],\n    [\n        "ipad",\n        {\n            facingMode: "environment",\n            confidence: "medium"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can\'t infer anything from it.\n    if (label === "") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        "user",\n        "environment",\n        "left",\n        "right"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3QvbGl2ZWtpdC1jbGllbnQuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxpQkFBaUJDLENBQUMsRUFBRUMsQ0FBQztJQUM3QkEsRUFBRUMsT0FBTyxDQUFDLFNBQVVDLENBQUM7UUFDcEJBLEtBQUssT0FBT0EsTUFBTSxZQUFZLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsTUFBTUcsT0FBT0MsSUFBSSxDQUFDSixHQUFHRCxPQUFPLENBQUMsU0FBVU0sQ0FBQztZQUNwRixJQUFJQSxNQUFNLGFBQWEsQ0FBRUEsQ0FBQUEsS0FBS1IsQ0FBQUEsR0FBSTtnQkFDakMsSUFBSVMsSUFBSUgsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdLO2dCQUMzQ0YsT0FBT0ssY0FBYyxDQUFDWCxHQUFHUSxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7b0JBQ3ZDSSxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9ULENBQUMsQ0FBQ0ssRUFBRTtvQkFBRTtnQkFDakM7WUFDRDtRQUNEO0lBQ0Q7SUFDQSxPQUFPRixPQUFPUSxNQUFNLENBQUNkO0FBQ3RCO0FBRUEsSUFBSWUsaUJBQWlCLE9BQU9DLGVBQWUsY0FBY0EsYUFBYSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxPQUFPQyxTQUFTLGNBQWNBLE9BQU8sQ0FBQztBQUU5TCxTQUFTQyx3QkFBeUJDLENBQUM7SUFDbEMsT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxJQUFJaEIsT0FBT2lCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEdBQUcsYUFBYUEsQ0FBQyxDQUFDLFVBQVUsR0FBR0E7QUFDakc7QUFFQSxJQUFJSyxXQUFXO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRTNCOzs7OztBQUtBLEdBQ0MsVUFBVUMsTUFBTTtJQUNkLFVBQVVDLElBQUksRUFBRUMsVUFBVTtRQUV6QixJQUFJRixPQUFPRCxPQUFPLEVBQUU7WUFDbEJDLE9BQU9ELE9BQU8sR0FBR0c7UUFDbkIsT0FBTztZQUNMRCxLQUFLRSxHQUFHLEdBQUdEO1FBQ2I7SUFDRixHQUFHZixnQkFBZ0I7UUFFakIsMERBQTBEO1FBQzFELElBQUlpQixPQUFPLFlBQWE7UUFDeEIsSUFBSUMsZ0JBQWdCO1FBQ3BCLElBQUlDLE9BQU8sZ0JBQWtCRCxpQkFBaUIsT0FBT2hCLE9BQU9rQixTQUFTLEtBQUtGLGlCQUFpQixrQkFBa0JHLElBQUksQ0FBQ25CLE9BQU9rQixTQUFTLENBQUNFLFNBQVM7UUFDNUksSUFBSUMsYUFBYTtZQUFDO1lBQVM7WUFBUztZQUFRO1lBQVE7U0FBUTtRQUU1RCxnRUFBZ0U7UUFDaEUsU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxVQUFVO1lBQ2pDLElBQUlDLFNBQVNGLEdBQUcsQ0FBQ0MsV0FBVztZQUM1QixJQUFJLE9BQU9DLE9BQU9DLElBQUksS0FBSyxZQUFZO2dCQUNyQyxPQUFPRCxPQUFPQyxJQUFJLENBQUNIO1lBQ3JCLE9BQU87Z0JBQ0wsSUFBSTtvQkFDRixPQUFPSSxTQUFTckIsU0FBUyxDQUFDb0IsSUFBSSxDQUFDbEIsSUFBSSxDQUFDaUIsUUFBUUY7Z0JBQzlDLEVBQUUsT0FBT3JDLEdBQUc7b0JBQ1YsNkRBQTZEO29CQUM3RCxPQUFPO3dCQUNMLE9BQU95QyxTQUFTckIsU0FBUyxDQUFDc0IsS0FBSyxDQUFDQSxLQUFLLENBQUNILFFBQVE7NEJBQUNGOzRCQUFLTTt5QkFBVTtvQkFDaEU7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsK0VBQStFO1FBQy9FLFNBQVNDO1lBQ1AsSUFBSUMsUUFBUWpCLEdBQUcsRUFBRTtnQkFDZixJQUFJaUIsUUFBUWpCLEdBQUcsQ0FBQ2MsS0FBSyxFQUFFO29CQUNyQkcsUUFBUWpCLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDRyxTQUFTRjtnQkFDN0IsT0FBTztvQkFDTCxtRUFBbUU7b0JBQ25FRixTQUFTckIsU0FBUyxDQUFDc0IsS0FBSyxDQUFDQSxLQUFLLENBQUNHLFFBQVFqQixHQUFHLEVBQUU7d0JBQUNpQjt3QkFBU0Y7cUJBQVU7Z0JBQ2xFO1lBQ0Y7WUFDQSxJQUFJRSxRQUFRQyxLQUFLLEVBQUVELFFBQVFDLEtBQUs7UUFDbEM7UUFFQSxzREFBc0Q7UUFDdEQsd0VBQXdFO1FBQ3hFLFNBQVNDLFdBQVdULFVBQVU7WUFDNUIsSUFBSUEsZUFBZSxTQUFTO2dCQUMxQkEsYUFBYTtZQUNmO1lBQ0EsSUFBSSxPQUFPTyxZQUFZZixlQUFlO2dCQUNwQyxPQUFPLE9BQU8sK0VBQStFO1lBQy9GLE9BQU8sSUFBSVEsZUFBZSxXQUFXUCxNQUFNO2dCQUN6QyxPQUFPYTtZQUNULE9BQU8sSUFBSUMsT0FBTyxDQUFDUCxXQUFXLEtBQUtVLFdBQVc7Z0JBQzVDLE9BQU9aLFdBQVdTLFNBQVNQO1lBQzdCLE9BQU8sSUFBSU8sUUFBUWpCLEdBQUcsS0FBS29CLFdBQVc7Z0JBQ3BDLE9BQU9aLFdBQVdTLFNBQVM7WUFDN0IsT0FBTztnQkFDTCxPQUFPaEI7WUFDVDtRQUNGO1FBRUEsZ0VBQWdFO1FBRWhFLFNBQVNvQixzQkFBc0JDLEtBQUssRUFBRUMsVUFBVTtZQUM5Qyx3QkFBd0IsR0FDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlqQixXQUFXa0IsTUFBTSxFQUFFRCxJQUFLO2dCQUMxQyxJQUFJZCxhQUFhSCxVQUFVLENBQUNpQixFQUFFO2dCQUM5QixJQUFJLENBQUNkLFdBQVcsR0FBR2MsSUFBSUYsUUFBUXJCLE9BQU8sSUFBSSxDQUFDeUIsYUFBYSxDQUFDaEIsWUFBWVksT0FBT0M7WUFDOUU7WUFFQSwyQ0FBMkM7WUFDM0MsSUFBSSxDQUFDdkIsR0FBRyxHQUFHLElBQUksQ0FBQzJCLEtBQUs7UUFDdkI7UUFFQSx5RUFBeUU7UUFDekUsMEVBQTBFO1FBQzFFLFNBQVNDLGdDQUFnQ2xCLFVBQVUsRUFBRVksS0FBSyxFQUFFQyxVQUFVO1lBQ3BFLE9BQU87Z0JBQ0wsSUFBSSxPQUFPTixZQUFZZixlQUFlO29CQUNwQ21CLHNCQUFzQjNCLElBQUksQ0FBQyxJQUFJLEVBQUU0QixPQUFPQztvQkFDeEMsSUFBSSxDQUFDYixXQUFXLENBQUNJLEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUMvQjtZQUNGO1FBQ0Y7UUFFQSx1RUFBdUU7UUFDdkUsaUVBQWlFO1FBQ2pFLFNBQVNjLHFCQUFxQm5CLFVBQVUsRUFBRVksS0FBSyxFQUFFQyxVQUFVO1lBQ3pELHdCQUF3QixHQUN4QixPQUFPSixXQUFXVCxlQUFla0IsZ0NBQWdDZCxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUMvRTtRQUNBLFNBQVNlLE9BQU9DLElBQUksRUFBRUMsWUFBWSxFQUFFQyxPQUFPO1lBQ3pDLElBQUk3QyxRQUFPLElBQUk7WUFDZixJQUFJOEM7WUFDSkYsZUFBZUEsZ0JBQWdCLE9BQU8sU0FBU0E7WUFDL0MsSUFBSUcsYUFBYTtZQUNqQixJQUFJLE9BQU9KLFNBQVMsVUFBVTtnQkFDNUJJLGNBQWMsTUFBTUo7WUFDdEIsT0FBTyxJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDbkNJLGFBQWFmO1lBQ2Y7WUFDQSxTQUFTZ0IsdUJBQXVCQyxRQUFRO2dCQUN0QyxJQUFJQyxZQUFZLENBQUMvQixVQUFVLENBQUM4QixTQUFTLElBQUksUUFBTyxFQUFHRSxXQUFXO2dCQUM5RCxJQUFJLGdCQUFrQnJDLGlCQUFpQixDQUFDaUMsWUFBWTtnQkFFcEQsZ0NBQWdDO2dCQUNoQyxJQUFJO29CQUNGakQsT0FBT3NELFlBQVksQ0FBQ0wsV0FBVyxHQUFHRztvQkFDbEM7Z0JBQ0YsRUFBRSxPQUFPRyxRQUFRLENBQUM7Z0JBRWxCLGlDQUFpQztnQkFDakMsSUFBSTtvQkFDRnZELE9BQU93RCxRQUFRLENBQUNDLE1BQU0sR0FBR0MsbUJBQW1CVCxjQUFjLE1BQU1HLFlBQVk7Z0JBQzlFLEVBQUUsT0FBT0csUUFBUSxDQUFDO1lBQ3BCO1lBQ0EsU0FBU0k7Z0JBQ1AsSUFBSUM7Z0JBQ0osSUFBSSxnQkFBa0I1QyxpQkFBaUIsQ0FBQ2lDLFlBQVk7Z0JBQ3BELElBQUk7b0JBQ0ZXLGNBQWM1RCxPQUFPc0QsWUFBWSxDQUFDTCxXQUFXO2dCQUMvQyxFQUFFLE9BQU9NLFFBQVEsQ0FBQztnQkFFbEIsd0RBQXdEO2dCQUN4RCxJQUFJLE9BQU9LLGdCQUFnQjVDLGVBQWU7b0JBQ3hDLElBQUk7d0JBQ0YsSUFBSXlDLFNBQVN6RCxPQUFPd0QsUUFBUSxDQUFDQyxNQUFNO3dCQUNuQyxJQUFJSSxXQUFXSixPQUFPSyxPQUFPLENBQUNKLG1CQUFtQlQsY0FBYzt3QkFDL0QsSUFBSVksYUFBYSxDQUFDLEdBQUc7NEJBQ25CRCxjQUFjLFdBQVdHLElBQUksQ0FBQ04sT0FBT08sS0FBSyxDQUFDSCxVQUFVLENBQUMsRUFBRTt3QkFDMUQ7b0JBQ0YsRUFBRSxPQUFPTixRQUFRLENBQUM7Z0JBQ3BCO2dCQUVBLHVFQUF1RTtnQkFDdkUsSUFBSXJELE1BQUsrRCxNQUFNLENBQUNMLFlBQVksS0FBSzFCLFdBQVc7b0JBQzFDMEIsY0FBYzFCO2dCQUNoQjtnQkFDQSxPQUFPMEI7WUFDVDtZQUNBLFNBQVNNO2dCQUNQLElBQUksZ0JBQWtCbEQsaUJBQWlCLENBQUNpQyxZQUFZO2dCQUVwRCxnQ0FBZ0M7Z0JBQ2hDLElBQUk7b0JBQ0ZqRCxPQUFPc0QsWUFBWSxDQUFDYSxVQUFVLENBQUNsQjtvQkFDL0I7Z0JBQ0YsRUFBRSxPQUFPTSxRQUFRLENBQUM7Z0JBRWxCLGlDQUFpQztnQkFDakMsSUFBSTtvQkFDRnZELE9BQU93RCxRQUFRLENBQUNDLE1BQU0sR0FBR0MsbUJBQW1CVCxjQUFjO2dCQUM1RCxFQUFFLE9BQU9NLFFBQVEsQ0FBQztZQUNwQjtZQUVBOzs7O09BSUMsR0FFRHJELE1BQUsyQyxJQUFJLEdBQUdBO1lBQ1ozQyxNQUFLK0QsTUFBTSxHQUFHO2dCQUNaLFNBQVM7Z0JBQ1QsU0FBUztnQkFDVCxRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsU0FBUztnQkFDVCxVQUFVO1lBQ1o7WUFDQS9ELE1BQUtzQyxhQUFhLEdBQUdPLFdBQVdKO1lBQ2hDekMsTUFBS2tFLFFBQVEsR0FBRztnQkFDZCxPQUFPcEI7WUFDVDtZQUNBOUMsTUFBS21FLFFBQVEsR0FBRyxTQUFVakMsS0FBSyxFQUFFa0MsT0FBTztnQkFDdEMsSUFBSSxPQUFPbEMsVUFBVSxZQUFZbEMsTUFBSytELE1BQU0sQ0FBQzdCLE1BQU1pQixXQUFXLEdBQUcsS0FBS25CLFdBQVc7b0JBQy9FRSxRQUFRbEMsTUFBSytELE1BQU0sQ0FBQzdCLE1BQU1pQixXQUFXLEdBQUc7Z0JBQzFDO2dCQUNBLElBQUksT0FBT2pCLFVBQVUsWUFBWUEsU0FBUyxLQUFLQSxTQUFTbEMsTUFBSytELE1BQU0sQ0FBQ00sTUFBTSxFQUFFO29CQUMxRXZCLGVBQWVaO29CQUNmLElBQUlrQyxZQUFZLE9BQU87d0JBQ3JCLG1CQUFtQjt3QkFDbkJwQix1QkFBdUJkO29CQUN6QjtvQkFDQUQsc0JBQXNCM0IsSUFBSSxDQUFDTixPQUFNa0MsT0FBT1M7b0JBQ3hDLElBQUksT0FBT2QsWUFBWWYsaUJBQWlCb0IsUUFBUWxDLE1BQUsrRCxNQUFNLENBQUNNLE1BQU0sRUFBRTt3QkFDbEUsT0FBTztvQkFDVDtnQkFDRixPQUFPO29CQUNMLE1BQU0sK0NBQStDbkM7Z0JBQ3ZEO1lBQ0Y7WUFDQWxDLE1BQUtzRSxlQUFlLEdBQUcsU0FBVXBDLEtBQUs7Z0JBQ3BDVSxlQUFlVjtnQkFDZixJQUFJLENBQUN1QixxQkFBcUI7b0JBQ3hCekQsTUFBS21FLFFBQVEsQ0FBQ2pDLE9BQU87Z0JBQ3ZCO1lBQ0Y7WUFDQWxDLE1BQUt1RSxVQUFVLEdBQUc7Z0JBQ2hCdkUsTUFBS21FLFFBQVEsQ0FBQ3ZCLGNBQWM7Z0JBQzVCb0I7WUFDRjtZQUNBaEUsTUFBS3dFLFNBQVMsR0FBRyxTQUFVSixPQUFPO2dCQUNoQ3BFLE1BQUttRSxRQUFRLENBQUNuRSxNQUFLK0QsTUFBTSxDQUFDVSxLQUFLLEVBQUVMO1lBQ25DO1lBQ0FwRSxNQUFLMEUsVUFBVSxHQUFHLFNBQVVOLE9BQU87Z0JBQ2pDcEUsTUFBS21FLFFBQVEsQ0FBQ25FLE1BQUsrRCxNQUFNLENBQUNNLE1BQU0sRUFBRUQ7WUFDcEM7WUFFQSxrQ0FBa0M7WUFDbEMsSUFBSU8sZUFBZWxCO1lBQ25CLElBQUlrQixnQkFBZ0IsTUFBTTtnQkFDeEJBLGVBQWUvQjtZQUNqQjtZQUNBNUMsTUFBS21FLFFBQVEsQ0FBQ1EsY0FBYztRQUM5QjtRQUVBOzs7O0tBSUMsR0FFRCxJQUFJQyxnQkFBZ0IsSUFBSWxDO1FBQ3hCLElBQUltQyxpQkFBaUIsQ0FBQztRQUN0QkQsY0FBY0UsU0FBUyxHQUFHLFNBQVNBLFVBQVVuQyxJQUFJO1lBQy9DLElBQUksT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWUEsU0FBUyxJQUFJO2dCQUN2RSxNQUFNLElBQUlvQyxVQUFVO1lBQ3RCO1lBQ0EsSUFBSUMsU0FBU0gsY0FBYyxDQUFDbEMsS0FBSztZQUNqQyxJQUFJLENBQUNxQyxRQUFRO2dCQUNYQSxTQUFTSCxjQUFjLENBQUNsQyxLQUFLLEdBQUcsSUFBSUQsT0FBT0MsTUFBTWlDLGNBQWNWLFFBQVEsSUFBSVUsY0FBY3RDLGFBQWE7WUFDeEc7WUFDQSxPQUFPMEM7UUFDVDtRQUVBLDREQUE0RDtRQUM1RCxJQUFJQyxPQUFPLGdCQUFrQm5FLGdCQUFnQmhCLE9BQU9jLEdBQUcsR0FBR29CO1FBQzFENEMsY0FBY00sVUFBVSxHQUFHO1lBQ3pCLElBQUksZ0JBQWtCcEUsaUJBQWlCaEIsT0FBT2MsR0FBRyxLQUFLZ0UsZUFBZTtnQkFDbkU5RSxPQUFPYyxHQUFHLEdBQUdxRTtZQUNmO1lBQ0EsT0FBT0w7UUFDVDtRQUNBQSxjQUFjTyxVQUFVLEdBQUcsU0FBU0E7WUFDbEMsT0FBT047UUFDVDtRQUVBLHdDQUF3QztRQUN4Q0QsYUFBYSxDQUFDLFVBQVUsR0FBR0E7UUFDM0IsT0FBT0E7SUFDVDtBQUNGLEdBQUdyRTtBQUNILElBQUk2RSxrQkFBa0I3RSxTQUFTQyxPQUFPO0FBRXRDLElBQUk2RTtBQUNILFVBQVVBLFFBQVE7SUFDakJBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDckMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNwQkEsV0FBVyxDQUFDLFVBQVUsR0FBRztJQUN6QkEsV0FBVyxDQUFDLE9BQU8sR0FBRztJQUN0QkEsV0FBVyxDQUFDLGNBQWMsR0FBRztJQUM3QkEsV0FBVyxDQUFDLFFBQVEsR0FBRztJQUN2QkEsV0FBVyxDQUFDLGNBQWMsR0FBRztJQUM3QkEsV0FBVyxDQUFDLFNBQVMsR0FBRztJQUN4QkEsV0FBVyxDQUFDLFNBQVMsR0FBRztJQUN4QkEsV0FBVyxDQUFDLFlBQVksR0FBRztJQUMzQkEsV0FBVyxDQUFDLGNBQWMsR0FBRztJQUM3QkEsV0FBVyxDQUFDLE9BQU8sR0FBRztBQUN4QixHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLElBQUlDLGdCQUFnQkgsZ0JBQWdCTixTQUFTLENBQUM7QUFDOUNTLGNBQWNqQixlQUFlLENBQUNlLFNBQVNHLElBQUk7QUFDM0M7O0NBRUMsR0FDRCxTQUFTVixVQUFVbkMsSUFBSTtJQUNyQixNQUFNcUMsU0FBU0ksZ0JBQWdCTixTQUFTLENBQUNuQztJQUN6Q3FDLE9BQU9WLGVBQWUsQ0FBQ2lCLGNBQWNyQixRQUFRO0lBQzdDLE9BQU9jO0FBQ1Q7QUFDQSxTQUFTUyxZQUFZdkQsS0FBSyxFQUFFQyxVQUFVO0lBQ3BDLElBQUlBLFlBQVk7UUFDZGlELGdCQUFnQk4sU0FBUyxDQUFDM0MsWUFBWWdDLFFBQVEsQ0FBQ2pDO0lBQ2pEO0lBQ0EsS0FBSyxNQUFNOEMsVUFBVTdGLE9BQU91RyxPQUFPLENBQUNOLGdCQUFnQkQsVUFBVSxJQUFJUSxNQUFNLENBQUNDLENBQUFBO1FBQ3ZFLElBQUksQ0FBQ0MsU0FBUyxHQUFHRDtRQUNqQixPQUFPQyxTQUFTQyxVQUFVLENBQUM7SUFDN0IsR0FBR0MsR0FBRyxDQUFDQyxDQUFBQTtRQUNMLElBQUksR0FBR0MsS0FBSyxHQUFHRDtRQUNmLE9BQU9DO0lBQ1QsR0FBSTtRQUNGakIsT0FBT2IsUUFBUSxDQUFDakM7SUFDbEI7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNnRSxnQkFBZ0JDLFNBQVM7SUFDaEMsSUFBSW5CLFNBQVNyRCxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRzREO0lBQ2pGLE1BQU1hLGtCQUFrQnBCLE9BQU8xQyxhQUFhO0lBQzVDMEMsT0FBTzFDLGFBQWEsR0FBRyxDQUFDaEIsWUFBWStFLGFBQWFsRTtRQUMvQyxNQUFNbUUsWUFBWUYsZ0JBQWdCOUUsWUFBWStFLGFBQWFsRTtRQUMzRCxNQUFNb0UsV0FBV2xCLFFBQVEsQ0FBQy9ELFdBQVc7UUFDckMsTUFBTWtGLFVBQVVELFlBQVlGLGVBQWVFLFdBQVdsQixTQUFTb0IsTUFBTTtRQUNyRSxPQUFPLENBQUNDLEtBQUtDO1lBQ1gsSUFBSUEsU0FBU0wsVUFBVUksS0FBS0M7aUJBQWNMLFVBQVVJO1lBQ3BELElBQUlGLFNBQVM7Z0JBQ1hMLFVBQVVJLFVBQVVHLEtBQUtDO1lBQzNCO1FBQ0Y7SUFDRjtJQUNBM0IsT0FBT2IsUUFBUSxDQUFDYSxPQUFPZCxRQUFRLEtBQUssMkRBQTJEO0FBQ2pHO0FBQ0FrQixnQkFBZ0JOLFNBQVMsQ0FBQztBQUUxQiw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakM7O0NBRUMsR0FDRCxTQUFTOEIsT0FBT0MsU0FBUyxFQUFFSCxHQUFHO0lBQzVCLHVIQUF1SDtJQUN2SCxJQUFJLENBQUNHLFdBQVc7UUFDZCxNQUFNLElBQUlDLE1BQU1KO0lBQ2xCO0FBQ0Y7QUFDQSxNQUFNSyxjQUFjLHVCQUNsQkMsY0FBYyxDQUFDLHVCQUNmQyxhQUFhLFlBQ2JDLFlBQVksWUFDWkMsWUFBWSxDQUFDO0FBQ2Y7O0NBRUMsR0FDRCxTQUFTQyxZQUFZQyxHQUFHO0lBQ3RCLElBQUksT0FBT0EsUUFBUSxVQUFVLE1BQU0sSUFBSVAsTUFBTSxxQkFBcUIsT0FBT087SUFDekUsSUFBSSxDQUFDQyxPQUFPQyxTQUFTLENBQUNGLFFBQVFBLE1BQU1ILGFBQWFHLE1BQU1GLFdBQVcsTUFBTSxJQUFJTCxNQUFNLHFCQUFxQk8sTUFBTSw2R0FBNkc7QUFDNU47QUFDQTs7Q0FFQyxHQUNELFNBQVNHLGFBQWFILEdBQUc7SUFDdkIsSUFBSSxPQUFPQSxRQUFRLFVBQVUsTUFBTSxJQUFJUCxNQUFNLHNCQUFzQixPQUFPTztJQUMxRSxJQUFJLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUUEsTUFBTUosY0FBY0ksTUFBTSxHQUFHLE1BQU0sSUFBSVAsTUFBTSxzQkFBc0JPLE1BQU0sNkdBQTZHO0FBQ3ROO0FBQ0E7O0NBRUMsR0FDRCxTQUFTSSxjQUFjSixHQUFHO0lBQ3hCLElBQUksT0FBT0EsUUFBUSxVQUFVLE1BQU0sSUFBSVAsTUFBTSx1QkFBdUIsT0FBT087SUFDM0UsSUFBSSxDQUFDQyxPQUFPSSxRQUFRLENBQUNMLE1BQU07SUFDM0IsSUFBSUEsTUFBTU4sZUFBZU0sTUFBTUwsYUFBYSxNQUFNLElBQUlGLE1BQU0sdUJBQXVCTyxNQUFNLDZHQUE2RztBQUN4TTtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxNQUFNTSxpQkFBaUJDLE9BQU87QUFDOUI7Ozs7Q0FJQyxHQUNELFNBQVNDLFlBQVlDLFVBQVU7SUFDN0IsaUpBQWlKO0lBQ2pKLE1BQU1DLElBQUlELFVBQVUsQ0FBQ0gsZUFBZTtJQUNwQ2YsT0FBT21CLEdBQUc7SUFDVixPQUFPQSxHQUFHLDBEQUEwRDtBQUN0RTtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsWUFBWUYsVUFBVSxFQUFFRyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsR0FBRztJQUNwRCwwR0FBMEc7SUFDMUdMLFVBQVUsQ0FBQ0gsZUFBZSxHQUFHUyxhQUFhSCxVQUFVQyxPQUFPbkMsR0FBRyxDQUFDc0MsQ0FBQUEsSUFBTTtZQUNuRUMsSUFBSUQsRUFBRUMsRUFBRTtZQUNSM0YsTUFBTTBGLEVBQUUxRixJQUFJO1lBQ1o0RixXQUFXVCxVQUFVLENBQUNPLEVBQUVDLEVBQUUsQ0FBQztRQUM3QjtBQUNGO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRixhQUFhSCxRQUFRLEVBQUVDLE1BQU0sRUFDdEMsNkRBQTZEO0FBQzdETSxJQUFJO0lBQ0YsTUFBTUMsUUFBUXRKLE9BQU91SixNQUFNLENBQUM7SUFDNUIsTUFBTUMsVUFBVXhKLE9BQU91SixNQUFNLENBQUM7SUFDOUIsTUFBTUUsZUFBZSxFQUFFO0lBQ3ZCLEtBQUssTUFBTUMsU0FBU1gsT0FBUTtRQUMxQix5Q0FBeUM7UUFDekMsa0ZBQWtGO1FBQ2xGLE1BQU1ySixJQUFJaUssbUJBQW1CRDtRQUM3QkQsYUFBYUcsSUFBSSxDQUFDbEs7UUFDbEI0SixLQUFLLENBQUNJLE1BQU1sRyxJQUFJLENBQUMsR0FBRzlEO1FBQ3BCOEosT0FBTyxDQUFDRSxNQUFNUCxFQUFFLENBQUMsR0FBR3pKO0lBQ3RCO0lBQ0EsT0FBTztRQUNMb0o7UUFDQUMsUUFBUVU7UUFDUix5Q0FBeUM7UUFDekMsZ0RBQWdEO1FBQ2hESSxVQUFTckcsSUFBSTtZQUNYLE9BQU84RixLQUFLLENBQUM5RixLQUFLO1FBQ3BCO1FBQ0FzRyxZQUFXWCxFQUFFO1lBQ1gsT0FBT0ssT0FBTyxDQUFDTCxHQUFHO1FBQ3BCO0lBQ0Y7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNZLFNBQVNqQixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsR0FBRztJQUNyQyxNQUFNTCxhQUFhLENBQUM7SUFDcEIsS0FBSyxNQUFNZSxTQUFTWCxPQUFRO1FBQzFCLE1BQU1ySixJQUFJaUssbUJBQW1CRDtRQUM3QmYsVUFBVSxDQUFDakosRUFBRTBKLFNBQVMsQ0FBQyxHQUFHMUosRUFBRXlKLEVBQUU7UUFDOUJSLFVBQVUsQ0FBQ2pKLEVBQUV5SixFQUFFLENBQUMsR0FBR3pKLEVBQUUwSixTQUFTO0lBQ2hDO0lBQ0FQLFlBQVlGLFlBQVlHLFVBQVVDO0lBQ2xDLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTZ0IsbUJBQW1CRCxLQUFLO0lBQy9CLElBQUksZUFBZUEsT0FBTztRQUN4QixPQUFPQTtJQUNUO0lBQ0EsT0FBTzFKLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBR04sUUFBUTtRQUM3Q04sV0FBV00sTUFBTWxHLElBQUk7SUFDdkI7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQzs7Ozs7O0NBTUMsR0FDRCxNQUFNeUc7SUFDSjs7R0FFQyxHQUNEQyxPQUFPQyxLQUFLLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQ0MsT0FBTyxHQUFHQyxPQUFPLENBQUNDLElBQUksQ0FBQ0osTUFBTSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxJQUFJLElBQUksRUFBRUQ7SUFDbEU7SUFDQTs7R0FFQyxHQUNESSxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUNILE9BQU8sR0FBR0MsT0FBTyxDQUFDQyxJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFJO0lBQy9DO0lBQ0E7Ozs7Ozs7O0dBUUMsR0FDREMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDekIsTUFBTUMsT0FBTyxJQUFJLENBQUNQLE9BQU8sSUFDdkJRLFNBQVNELEtBQUtOLE9BQU8sQ0FBQ1EsR0FBRyxFQUN6QjdCLE1BQU00QixPQUFPRSxlQUFlLENBQUNKO1FBQy9CRSxPQUFPRyxXQUFXLENBQUMsSUFBSSxFQUFFL0IsSUFBSWdDLGFBQWEsQ0FBQ1AsUUFBUUEsTUFBTVEsVUFBVSxFQUFFakM7UUFDckUsT0FBTyxJQUFJO0lBQ2I7SUFDQTs7R0FFQyxHQUNEa0MsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDM0IsTUFBTUMsT0FBTyxJQUFJLENBQUNQLE9BQU8sSUFDdkJRLFNBQVNELEtBQUtOLE9BQU8sQ0FBQ2UsSUFBSSxFQUMxQnBDLE1BQU00QixPQUFPRSxlQUFlLENBQUNKO1FBQy9CRSxPQUFPRyxXQUFXLENBQUNKLE1BQU1RLFdBQVduQyxLQUFLLElBQUk7UUFDN0MsT0FBTyxJQUFJO0lBQ2I7SUFDQTs7R0FFQyxHQUNEcUMsZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDbEMsSUFBSVU7UUFDSixJQUFJO1lBQ0ZBLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0Y7UUFDcEIsRUFBRSxPQUFPekwsR0FBRztZQUNWLE1BQU0sSUFBSThILE1BQU0saUJBQWlCOEQsTUFBTSxDQUFDLElBQUksQ0FBQ3JCLE9BQU8sR0FBR3RCLFFBQVEsRUFBRSxnQkFBZ0IyQyxNQUFNLENBQUM1TCxhQUFhOEgsUUFBUTlILEVBQUU2TCxPQUFPLEdBQUdDLE9BQU85TDtRQUNsSTtRQUNBLE9BQU8sSUFBSSxDQUFDcUwsUUFBUSxDQUFDRSxNQUFNVjtJQUM3QjtJQUNBOztHQUVDLEdBQ0RrQixTQUFTbEIsT0FBTyxFQUFFO1FBQ2hCLE1BQU1DLE9BQU8sSUFBSSxDQUFDUCxPQUFPLElBQ3ZCUyxNQUFNRixLQUFLTixPQUFPLENBQUNRLEdBQUcsRUFDdEI3QixNQUFNNkIsSUFBSWdCLGdCQUFnQixDQUFDbkIsVUFDM0JvQixTQUFTOUMsSUFBSStDLGFBQWE7UUFDNUJsQixJQUFJbUIsWUFBWSxDQUFDLElBQUksRUFBRUYsUUFBUTlDO1FBQy9CLE9BQU84QyxPQUFPRyxNQUFNO0lBQ3RCO0lBQ0E7OztHQUdDLEdBQ0RDLE9BQU94QixPQUFPLEVBQUU7UUFDZCxNQUFNQyxPQUFPLElBQUksQ0FBQ1AsT0FBTyxJQUN2QmdCLE9BQU9ULEtBQUtOLE9BQU8sQ0FBQ2UsSUFBSSxFQUN4QnBDLE1BQU1vQyxLQUFLUyxnQkFBZ0IsQ0FBQ25CO1FBQzlCLE9BQU9VLEtBQUtZLFlBQVksQ0FBQyxJQUFJLEVBQUVoRDtJQUNqQztJQUNBOztHQUVDLEdBQ0RtRCxhQUFhekIsT0FBTyxFQUFFO1FBQ3BCLElBQUkwQjtRQUNKLE1BQU0xQyxRQUFRLElBQUksQ0FBQ3dDLE1BQU0sQ0FBQ3hCO1FBQzFCLE9BQU9hLEtBQUtjLFNBQVMsQ0FBQzNDLE9BQU8sTUFBTSxDQUFDMEMsS0FBSzFCLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRNEIsWUFBWSxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ3BKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0dBY0MsR0FDREcsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUM7WUFDakJNLG1CQUFtQjtRQUNyQjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEcEMsVUFBVTtRQUNSLGtFQUFrRTtRQUNsRSxpQ0FBaUM7UUFDakMsMEdBQTBHO1FBQzFHLE9BQU9wSyxPQUFPeU0sY0FBYyxDQUFDLElBQUksRUFBRUMsV0FBVztJQUNoRDtBQUNGO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDOztDQUVDLEdBQ0QsU0FBU0MsZ0JBQWdCdEMsT0FBTyxFQUFFdkIsUUFBUSxFQUFFOEQsTUFBTSxFQUFFNUQsR0FBRztJQUNyRCxJQUFJb0Q7SUFDSixNQUFNaEQsWUFBWSxDQUFDZ0QsS0FBS3BELFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJSSxTQUFTLE1BQU0sUUFBUWdELE9BQU8sS0FBSyxJQUFJQSxLQUFLdEQsU0FBUytELFNBQVMsQ0FBQy9ELFNBQVNnRSxXQUFXLENBQUMsT0FBTztJQUNqSyxNQUFNbkMsT0FBTztRQUNYLENBQUN2QixVQUFVLEVBQUUsU0FBVTJELElBQUk7WUFDekIxQyxRQUFRQyxJQUFJLENBQUMwQyxVQUFVLENBQUMsSUFBSTtZQUM1QjNDLFFBQVFDLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO1FBQ3JDO0lBQ0YsQ0FBQyxDQUFDM0QsVUFBVTtJQUNacEosT0FBT2tOLGNBQWMsQ0FBQ3ZDLEtBQUsxSixTQUFTLEVBQUUsSUFBSWdKO0lBQzFDakssT0FBT2dLLE1BQU0sQ0FBQ1csTUFBTTtRQUNsQk47UUFDQXZCO1FBQ0E4RCxRQUFRdkMsUUFBUUMsSUFBSSxDQUFDNkMsWUFBWSxDQUFDUDtRQUNsQ3BDLFlBQVdDLEtBQUssRUFBRUMsT0FBTztZQUN2QixPQUFPLElBQUlDLE9BQU9ILFVBQVUsQ0FBQ0MsT0FBT0M7UUFDdEM7UUFDQVEsVUFBU0MsU0FBUyxFQUFFVCxPQUFPO1lBQ3pCLE9BQU8sSUFBSUMsT0FBT08sUUFBUSxDQUFDQyxXQUFXVDtRQUN4QztRQUNBVyxnQkFBZUMsVUFBVSxFQUFFWixPQUFPO1lBQ2hDLE9BQU8sSUFBSUMsT0FBT1UsY0FBYyxDQUFDQyxZQUFZWjtRQUMvQztRQUNBUixRQUFPa0QsQ0FBQyxFQUFFQyxDQUFDO1lBQ1QsT0FBT2hELFFBQVFDLElBQUksQ0FBQ0osTUFBTSxDQUFDUyxNQUFNeUMsR0FBR0M7UUFDdEM7SUFDRjtJQUNBLE9BQU8xQztBQUNUO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLFNBQVMyQyxpQkFBaUJDLE1BQU0sRUFBRW5DLElBQUksRUFBRVAsR0FBRyxFQUFFUCxJQUFJO0lBQy9DLE9BQU87UUFDTGlEO1FBQ0FuQztRQUNBUDtRQUNBUDtRQUNBcUMsaUJBQWdCN0QsUUFBUSxFQUFFOEQsTUFBTSxFQUFFNUQsR0FBRztZQUNuQyxPQUFPMkQsZ0JBQWdCLElBQUksRUFBRTdELFVBQVU4RCxRQUFRNUQ7UUFDakQ7UUFDQWU7UUFDQWQ7UUFDQVA7SUFDRjtBQUNGO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDOzs7O0NBSUMsR0FDRCxJQUFJOEU7QUFDSCxVQUFVQSxVQUFVO0lBQ25CLDRCQUE0QjtJQUM1Qix5Q0FBeUM7SUFDekNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDdEMsMkVBQTJFO0lBQzNFLDhCQUE4QjtJQUM5QkEsVUFBVSxDQUFDQSxVQUFVLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUN0Q0EsVUFBVSxDQUFDQSxVQUFVLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUN2QywyRUFBMkU7SUFDM0UsOEJBQThCO0lBQzlCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3RDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3hDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3hDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3JDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDLDJCQUEyQjtJQUMzQix3RUFBd0U7SUFDeEUsMEVBQTBFO0lBQzFFLHdDQUF3QztJQUN4QyxtQkFBbUI7SUFDbkIscURBQXFEO0lBQ3JELG9CQUFvQjtJQUNwQkEsVUFBVSxDQUFDQSxVQUFVLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUN2Q0EsVUFBVSxDQUFDQSxVQUFVLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRztJQUN4QyxrQkFBa0I7SUFDbEJBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDMUNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDMUNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDeENBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7QUFDMUMsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ2hDOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2pCOztHQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDbkM7Ozs7R0FJQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUU1QixtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLHFFQUFxRTtBQUNyRSx5RUFBeUU7QUFDekUsT0FBTztBQUNQLEVBQUU7QUFDRixtRUFBbUU7QUFDbkUsZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCx5RUFBeUU7QUFDekUsZ0VBQWdFO0FBQ2hFLGdCQUFnQjtBQUNoQix5REFBeUQ7QUFDekQsdUVBQXVFO0FBQ3ZFLDJEQUEyRDtBQUMzRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSxtRUFBbUU7QUFDbkUsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHVFQUF1RTtBQUN2RSxFQUFFO0FBQ0YsdUVBQXVFO0FBQ3ZFLCtEQUErRDtBQUMvRCx3RUFBd0U7QUFDeEUsMERBQTBEO0FBQzFELHlFQUF5RSxHQUN6RTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsV0FBVztJQUNmLElBQUssSUFBSUMsUUFBUSxHQUFHQSxRQUFRLElBQUlBLFNBQVMsRUFBRztRQUMxQyxJQUFJUixJQUFJLElBQUksQ0FBQ1MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQzVCSixXQUFXLENBQUNOLElBQUksSUFBRyxLQUFNUTtRQUN6QixJQUFJLENBQUNSLElBQUksSUFBRyxLQUFNLEdBQUc7WUFDbkIsSUFBSSxDQUFDVyxZQUFZO1lBQ2pCLE9BQU87Z0JBQUNMO2dCQUFTQzthQUFTO1FBQzVCO0lBQ0Y7SUFDQSxJQUFJSyxhQUFhLElBQUksQ0FBQ0gsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ3JDLDRDQUE0QztJQUM1Q0osV0FBVyxDQUFDTSxhQUFhLElBQUcsS0FBTTtJQUNsQyxrREFBa0Q7SUFDbERMLFdBQVcsQ0FBQ0ssYUFBYSxJQUFHLEtBQU07SUFDbEMsSUFBSSxDQUFDQSxhQUFhLElBQUcsS0FBTSxHQUFHO1FBQzVCLElBQUksQ0FBQ0QsWUFBWTtRQUNqQixPQUFPO1lBQUNMO1lBQVNDO1NBQVM7SUFDNUI7SUFDQSxJQUFLLElBQUlDLFFBQVEsR0FBR0EsU0FBUyxJQUFJQSxTQUFTLEVBQUc7UUFDM0MsSUFBSVIsSUFBSSxJQUFJLENBQUNTLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUM1QkgsWUFBWSxDQUFDUCxJQUFJLElBQUcsS0FBTVE7UUFDMUIsSUFBSSxDQUFDUixJQUFJLElBQUcsS0FBTSxHQUFHO1lBQ25CLElBQUksQ0FBQ1csWUFBWTtZQUNqQixPQUFPO2dCQUFDTDtnQkFBU0M7YUFBUztRQUM1QjtJQUNGO0lBQ0EsTUFBTSxJQUFJakcsTUFBTTtBQUNsQjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVN1RyxjQUFjQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTNELEtBQUs7SUFDbEMsSUFBSyxJQUFJeEgsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUlBLElBQUksRUFBRztRQUNqQyxNQUFNNEssUUFBUU0sT0FBT2xMO1FBQ3JCLE1BQU1vTCxVQUFVLENBQUVSLENBQUFBLFVBQVUsS0FBSyxLQUFLTyxNQUFNO1FBQzVDLE1BQU1FLE9BQU8sQ0FBQ0QsVUFBVVIsUUFBUSxPQUFPQSxLQUFJLElBQUs7UUFDaERwRCxNQUFNYixJQUFJLENBQUMwRTtRQUNYLElBQUksQ0FBQ0QsU0FBUztZQUNaO1FBQ0Y7SUFDRjtJQUNBLE1BQU1FLFlBQVlKLE9BQU8sS0FBSyxPQUFPLENBQUNDLEtBQUssSUFBRyxLQUFNO0lBQ3BELE1BQU1JLGNBQWMsQ0FBRUosQ0FBQUEsTUFBTSxLQUFLO0lBQ2pDM0QsTUFBTWIsSUFBSSxDQUFDLENBQUM0RSxjQUFjRCxZQUFZLE9BQU9BLFNBQVEsSUFBSztJQUMxRCxJQUFJLENBQUNDLGFBQWE7UUFDaEI7SUFDRjtJQUNBLElBQUssSUFBSXZMLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFJQSxJQUFJLEVBQUc7UUFDakMsTUFBTTRLLFFBQVFPLE9BQU9uTDtRQUNyQixNQUFNb0wsVUFBVSxDQUFFUixDQUFBQSxVQUFVLEtBQUs7UUFDakMsTUFBTVMsT0FBTyxDQUFDRCxVQUFVUixRQUFRLE9BQU9BLEtBQUksSUFBSztRQUNoRHBELE1BQU1iLElBQUksQ0FBQzBFO1FBQ1gsSUFBSSxDQUFDRCxTQUFTO1lBQ1o7UUFDRjtJQUNGO0lBQ0E1RCxNQUFNYixJQUFJLENBQUN3RSxPQUFPLEtBQUs7QUFDekI7QUFDQSw0QkFBNEI7QUFDNUIsTUFBTUssaUJBQWlCO0FBQ3ZCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGdCQUFnQkMsR0FBRztJQUMxQix3QkFBd0I7SUFDeEIsTUFBTUMsUUFBUUQsR0FBRyxDQUFDLEVBQUUsS0FBSztJQUN6QixJQUFJQyxPQUFPO1FBQ1RELE1BQU1BLElBQUloSyxLQUFLLENBQUM7SUFDbEI7SUFDQSx5RUFBeUU7SUFDekUsd0VBQXdFO0lBQ3hFLG1EQUFtRDtJQUNuRCxNQUFNa0ssT0FBTztJQUNiLElBQUlsQixVQUFVO0lBQ2QsSUFBSUMsV0FBVztJQUNmLFNBQVNrQixZQUFZQyxLQUFLLEVBQUVDLEdBQUc7UUFDN0IseUJBQXlCO1FBQ3pCLE1BQU1DLFdBQVc5RyxPQUFPd0csSUFBSWhLLEtBQUssQ0FBQ29LLE9BQU9DO1FBQ3pDcEIsWUFBWWlCO1FBQ1psQixVQUFVQSxVQUFVa0IsT0FBT0k7UUFDM0IsNkJBQTZCO1FBQzdCLElBQUl0QixXQUFXYyxnQkFBZ0I7WUFDN0JiLFdBQVdBLFdBQVlELENBQUFBLFVBQVVjLGlCQUFpQjtZQUNsRGQsVUFBVUEsVUFBVWM7UUFDdEI7SUFDRjtJQUNBSyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2xCQSxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2xCQSxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2xCQSxZQUFZLENBQUM7SUFDYixPQUFPRixRQUFRTSxPQUFPdkIsU0FBU0MsWUFBWXVCLFFBQVF4QixTQUFTQztBQUM5RDtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTd0IsY0FBY2pCLEVBQUUsRUFBRUMsRUFBRTtJQUMzQixJQUFJaUIsT0FBT0YsUUFBUWhCLElBQUlDO0lBQ3ZCLDRFQUE0RTtJQUM1RSxzRUFBc0U7SUFDdEUsTUFBTWtCLFdBQVdELEtBQUtqQixFQUFFLEdBQUc7SUFDM0IsSUFBSWtCLFVBQVU7UUFDWkQsT0FBT0gsT0FBT0csS0FBS2xCLEVBQUUsRUFBRWtCLEtBQUtqQixFQUFFO0lBQ2hDO0lBQ0EsTUFBTW1CLFNBQVNDLGVBQWVILEtBQUtsQixFQUFFLEVBQUVrQixLQUFLakIsRUFBRTtJQUM5QyxPQUFPa0IsV0FBVyxNQUFNQyxTQUFTQTtBQUNuQztBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxlQUFlckIsRUFBRSxFQUFFQyxFQUFFO0lBQzNCLEdBQ0NELEVBQUUsRUFDRkMsRUFBRSxFQUNILEdBQUdxQixXQUFXdEIsSUFBSUMsR0FBRTtJQUNyQix5RUFBeUU7SUFDekUsd0JBQXdCO0lBQ3hCLHNFQUFzRTtJQUN0RSx3RUFBd0U7SUFDeEUscUJBQXFCO0lBQ3JCLDBFQUEwRTtJQUMxRSxJQUFJQSxNQUFNLFVBQVU7UUFDbEIsT0FBT3pDLE9BQU84QyxpQkFBaUJMLEtBQUtEO0lBQ3RDO0lBQ0EsMEVBQTBFO0lBQzFFLHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsb0JBQW9CO0lBQ3BCLG9DQUFvQztJQUNwQyw2Q0FBNkM7SUFDN0MsNERBQTREO0lBQzVELGlFQUFpRTtJQUNqRSxzQ0FBc0M7SUFDdEMsTUFBTXVCLE1BQU12QixLQUFLO0lBQ2pCLE1BQU13QixNQUFNLENBQUN4QixPQUFPLEtBQUtDLE1BQU0sS0FBSztJQUNwQyxNQUFNd0IsT0FBT3hCLE1BQU0sS0FBSztJQUN4QixvRUFBb0U7SUFDcEUsNEVBQTRFO0lBQzVFLG1EQUFtRDtJQUNuRCxJQUFJeUIsU0FBU0gsTUFBTUMsTUFBTSxVQUFVQyxPQUFPO0lBQzFDLElBQUlFLFNBQVNILE1BQU1DLE9BQU87SUFDMUIsSUFBSUcsU0FBU0gsT0FBTztJQUNwQiw2Q0FBNkM7SUFDN0MsTUFBTWYsT0FBTztJQUNiLElBQUlnQixVQUFVaEIsTUFBTTtRQUNsQmlCLFVBQVVFLEtBQUtDLEtBQUssQ0FBQ0osU0FBU2hCO1FBQzlCZ0IsVUFBVWhCO0lBQ1o7SUFDQSxJQUFJaUIsVUFBVWpCLE1BQU07UUFDbEJrQixVQUFVQyxLQUFLQyxLQUFLLENBQUNILFNBQVNqQjtRQUM5QmlCLFVBQVVqQjtJQUNaO0lBQ0Esd0VBQXdFO0lBQ3hFLDBFQUEwRTtJQUMxRSxpQ0FBaUM7SUFDakMsT0FBT2tCLE9BQU9HLFFBQVEsS0FBS0MsK0JBQStCTCxVQUFVSywrQkFBK0JOO0FBQ3JHO0FBQ0EsU0FBU0osV0FBV3RCLEVBQUUsRUFBRUMsRUFBRTtJQUN4QixPQUFPO1FBQ0xELElBQUlBLE9BQU87UUFDWEMsSUFBSUEsT0FBTztJQUNiO0FBQ0Y7QUFDQSxTQUFTZSxRQUFRaEIsRUFBRSxFQUFFQyxFQUFFO0lBQ3JCLE9BQU87UUFDTEQsSUFBSUEsS0FBSztRQUNUQyxJQUFJQSxLQUFLO0lBQ1g7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNjLE9BQU92QixPQUFPLEVBQUVDLFFBQVE7SUFDL0JBLFdBQVcsQ0FBQ0E7SUFDWixJQUFJRCxTQUFTO1FBQ1hBLFVBQVUsQ0FBQ0EsVUFBVTtJQUN2QixPQUFPO1FBQ0wsbURBQW1EO1FBQ25ELHlEQUF5RDtRQUN6RCx5REFBeUQ7UUFDekRDLFlBQVk7SUFDZDtJQUNBLE9BQU91QixRQUFReEIsU0FBU0M7QUFDMUI7QUFDQTs7Q0FFQyxHQUNELE1BQU11QyxpQ0FBaUNDLENBQUFBO0lBQ3JDLE1BQU1DLFVBQVUxRSxPQUFPeUU7SUFDdkIsT0FBTyxVQUFVekwsS0FBSyxDQUFDMEwsUUFBUW5OLE1BQU0sSUFBSW1OO0FBQzNDO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsY0FBYzVHLEtBQUssRUFBRWUsS0FBSztJQUNqQyxJQUFJZixTQUFTLEdBQUc7UUFDZCwyQkFBMkI7UUFDM0IsTUFBT0EsUUFBUSxLQUFNO1lBQ25CZSxNQUFNYixJQUFJLENBQUNGLFFBQVEsT0FBTztZQUMxQkEsUUFBUUEsVUFBVTtRQUNwQjtRQUNBZSxNQUFNYixJQUFJLENBQUNGO0lBQ2IsT0FBTztRQUNMLElBQUssSUFBSXpHLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCd0gsTUFBTWIsSUFBSSxDQUFDRixRQUFRLE1BQU07WUFDekJBLFFBQVFBLFNBQVM7UUFDbkI7UUFDQWUsTUFBTWIsSUFBSSxDQUFDO0lBQ2I7QUFDRjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTMkc7SUFDUCxJQUFJbEQsSUFBSSxJQUFJLENBQUNTLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUM1QixJQUFJd0IsU0FBU2xDLElBQUk7SUFDakIsSUFBSSxDQUFDQSxJQUFJLElBQUcsS0FBTSxHQUFHO1FBQ25CLElBQUksQ0FBQ1csWUFBWTtRQUNqQixPQUFPdUI7SUFDVDtJQUNBbEMsSUFBSSxJQUFJLENBQUNTLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUN4QndCLFVBQVUsQ0FBQ2xDLElBQUksSUFBRyxLQUFNO0lBQ3hCLElBQUksQ0FBQ0EsSUFBSSxJQUFHLEtBQU0sR0FBRztRQUNuQixJQUFJLENBQUNXLFlBQVk7UUFDakIsT0FBT3VCO0lBQ1Q7SUFDQWxDLElBQUksSUFBSSxDQUFDUyxHQUFHLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDeEJ3QixVQUFVLENBQUNsQyxJQUFJLElBQUcsS0FBTTtJQUN4QixJQUFJLENBQUNBLElBQUksSUFBRyxLQUFNLEdBQUc7UUFDbkIsSUFBSSxDQUFDVyxZQUFZO1FBQ2pCLE9BQU91QjtJQUNUO0lBQ0FsQyxJQUFJLElBQUksQ0FBQ1MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ3hCd0IsVUFBVSxDQUFDbEMsSUFBSSxJQUFHLEtBQU07SUFDeEIsSUFBSSxDQUFDQSxJQUFJLElBQUcsS0FBTSxHQUFHO1FBQ25CLElBQUksQ0FBQ1csWUFBWTtRQUNqQixPQUFPdUI7SUFDVDtJQUNBLDJCQUEyQjtJQUMzQmxDLElBQUksSUFBSSxDQUFDUyxHQUFHLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDeEJ3QixVQUFVLENBQUNsQyxJQUFJLElBQUcsS0FBTTtJQUN4QixJQUFLLElBQUltRCxZQUFZLEdBQUcsQ0FBQ25ELElBQUksSUFBRyxNQUFPLEtBQUttRCxZQUFZLElBQUlBLFlBQWFuRCxJQUFJLElBQUksQ0FBQ1MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ2pHLElBQUksQ0FBQ1YsSUFBSSxJQUFHLEtBQU0sR0FBRyxNQUFNLElBQUkxRixNQUFNO0lBQ3JDLElBQUksQ0FBQ3FHLFlBQVk7SUFDakIsa0RBQWtEO0lBQ2xELE9BQU91QixXQUFXO0FBQ3BCO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLFNBQVNrQjtJQUNQLE1BQU1DLEtBQUssSUFBSUMsU0FBUyxJQUFJQyxZQUFZO0lBQ3hDLHNFQUFzRTtJQUN0RSxNQUFNQyxLQUFLLE9BQU9DLFdBQVcsY0FBYyxPQUFPSixHQUFHSyxXQUFXLEtBQUssY0FBYyxPQUFPTCxHQUFHTSxZQUFZLEtBQUssY0FBYyxPQUFPTixHQUFHTyxXQUFXLEtBQUssY0FBYyxPQUFPUCxHQUFHUSxZQUFZLEtBQUssY0FBZSxRQUFPQyxXQUFXLFlBQVksT0FBT0EsUUFBUUMsR0FBRyxJQUFJLFlBQVlELFFBQVFDLEdBQUcsQ0FBQ0Msa0JBQWtCLEtBQUssR0FBRTtJQUNuVCxJQUFJUixJQUFJO1FBQ04sTUFBTVMsTUFBTVIsT0FBTyx5QkFDakJTLE1BQU1ULE9BQU8sd0JBQ2JVLE9BQU9WLE9BQU8sTUFDZFcsT0FBT1gsT0FBTztRQUNoQixPQUFPO1lBQ0xZLE1BQU1aLE9BQU87WUFDYmEsV0FBVztZQUNYbkcsT0FBTTlCLEtBQUs7Z0JBQ1QsTUFBTWtJLEtBQUssT0FBT2xJLFNBQVMsV0FBV0EsUUFBUW9ILE9BQU9wSDtnQkFDckQsSUFBSWtJLEtBQUtMLE9BQU9LLEtBQUtOLEtBQUs7b0JBQ3hCLE1BQU0sSUFBSTNKLE1BQU0sa0JBQWtCOEQsTUFBTSxDQUFDL0I7Z0JBQzNDO2dCQUNBLE9BQU9rSTtZQUNUO1lBQ0FDLFFBQU9uSSxLQUFLO2dCQUNWLE1BQU1rSSxLQUFLLE9BQU9sSSxTQUFTLFdBQVdBLFFBQVFvSCxPQUFPcEg7Z0JBQ3JELElBQUlrSSxLQUFLSCxRQUFRRyxLQUFLSixNQUFNO29CQUMxQixNQUFNLElBQUk3SixNQUFNLG1CQUFtQjhELE1BQU0sQ0FBQy9CO2dCQUM1QztnQkFDQSxPQUFPa0k7WUFDVDtZQUNBRSxLQUFJcEksS0FBSztnQkFDUGdILEdBQUdPLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQ3pGLEtBQUssQ0FBQzlCLFFBQVE7Z0JBQ3JDLE9BQU87b0JBQ0x5RSxJQUFJdUMsR0FBR3FCLFFBQVEsQ0FBQyxHQUFHO29CQUNuQjNELElBQUlzQyxHQUFHcUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ3JCO1lBQ0Y7WUFDQUMsTUFBS3RJLEtBQUs7Z0JBQ1JnSCxHQUFHTyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUNZLE1BQU0sQ0FBQ25JLFFBQVE7Z0JBQ3RDLE9BQU87b0JBQ0x5RSxJQUFJdUMsR0FBR3FCLFFBQVEsQ0FBQyxHQUFHO29CQUNuQjNELElBQUlzQyxHQUFHcUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ3JCO1lBQ0Y7WUFDQXBELEtBQUlSLEVBQUUsRUFBRUMsRUFBRTtnQkFDUnNDLEdBQUd1QixRQUFRLENBQUMsR0FBRzlELElBQUk7Z0JBQ25CdUMsR0FBR3VCLFFBQVEsQ0FBQyxHQUFHN0QsSUFBSTtnQkFDbkIsT0FBT3NDLEdBQUdLLFdBQVcsQ0FBQyxHQUFHO1lBQzNCO1lBQ0FtQixNQUFLL0QsRUFBRSxFQUFFQyxFQUFFO2dCQUNUc0MsR0FBR3VCLFFBQVEsQ0FBQyxHQUFHOUQsSUFBSTtnQkFDbkJ1QyxHQUFHdUIsUUFBUSxDQUFDLEdBQUc3RCxJQUFJO2dCQUNuQixPQUFPc0MsR0FBR00sWUFBWSxDQUFDLEdBQUc7WUFDNUI7UUFDRjtJQUNGO0lBQ0EsTUFBTW1CLG9CQUFvQnpJLENBQUFBLFFBQVNqQyxPQUFPLGFBQWEzRixJQUFJLENBQUM0SCxRQUFRLGtCQUFrQitCLE1BQU0sQ0FBQy9CO0lBQzdGLE1BQU0wSSxxQkFBcUIxSSxDQUFBQSxRQUFTakMsT0FBTyxXQUFXM0YsSUFBSSxDQUFDNEgsUUFBUSxtQkFBbUIrQixNQUFNLENBQUMvQjtJQUM3RixPQUFPO1FBQ0xnSSxNQUFNO1FBQ05DLFdBQVc7UUFDWG5HLE9BQU05QixLQUFLO1lBQ1QsSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzVCQSxRQUFRQSxNQUFNd0csUUFBUTtZQUN4QjtZQUNBaUMsa0JBQWtCekk7WUFDbEIsT0FBT0E7UUFDVDtRQUNBbUksUUFBT25JLEtBQUs7WUFDVixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDNUJBLFFBQVFBLE1BQU13RyxRQUFRO1lBQ3hCO1lBQ0FrQyxtQkFBbUIxSTtZQUNuQixPQUFPQTtRQUNUO1FBQ0FvSSxLQUFJcEksS0FBSztZQUNQLElBQUksT0FBT0EsU0FBUyxVQUFVO2dCQUM1QkEsUUFBUUEsTUFBTXdHLFFBQVE7WUFDeEI7WUFDQWlDLGtCQUFrQnpJO1lBQ2xCLE9BQU9nRixnQkFBZ0JoRjtRQUN6QjtRQUNBc0ksTUFBS3RJLEtBQUs7WUFDUixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDNUJBLFFBQVFBLE1BQU13RyxRQUFRO1lBQ3hCO1lBQ0FrQyxtQkFBbUIxSTtZQUNuQixPQUFPZ0YsZ0JBQWdCaEY7UUFDekI7UUFDQWlGLEtBQUlSLEVBQUUsRUFBRUMsRUFBRTtZQUNSLE9BQU9nQixjQUFjakIsSUFBSUM7UUFDM0I7UUFDQThELE1BQUsvRCxFQUFFLEVBQUVDLEVBQUU7WUFDVCxPQUFPb0IsZUFBZXJCLElBQUlDO1FBQzVCO0lBQ0Y7QUFDRjtBQUNBLE1BQU1pRSxhQUFhNUI7QUFFbkIsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLDhGQUE4RixHQUM5Rjs7Ozs7OztDQU9DLEdBQ0QsSUFBSTZCO0FBQ0gsVUFBVUEsUUFBUTtJQUNqQjs7R0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ25DOzs7R0FHQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDOzs7Ozs7R0FNQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7SUFDNUM7OztHQUdDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDdkM7OztHQUdDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDckM7OztHQUdDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7QUFDcEMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLE1BQU1DO0lBQ0o3RixZQUFZOEYsV0FBVyxDQUFFO1FBQ3ZCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ0QsV0FBVyxHQUFHQSxnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSUEsY0FBYyxJQUFJRTtRQUN0RixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQzdFLEdBQUcsR0FBRyxFQUFFO0lBQ2Y7SUFDQTs7R0FFQyxHQUNEN0IsU0FBUztRQUNQLElBQUksQ0FBQzBHLE1BQU0sQ0FBQy9JLElBQUksQ0FBQyxJQUFJZ0osV0FBVyxJQUFJLENBQUM5RSxHQUFHLElBQUksbUJBQW1CO1FBQy9ELElBQUkrRSxNQUFNO1FBQ1YsSUFBSyxJQUFJNVAsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzBQLE1BQU0sQ0FBQ3pQLE1BQU0sRUFBRUQsSUFBSzRQLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUMxUCxFQUFFLENBQUNDLE1BQU07UUFDekUsSUFBSXVILFFBQVEsSUFBSW1JLFdBQVdDO1FBQzNCLElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUk3UCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMFAsTUFBTSxDQUFDelAsTUFBTSxFQUFFRCxJQUFLO1lBQzNDd0gsTUFBTXNJLEdBQUcsQ0FBQyxJQUFJLENBQUNKLE1BQU0sQ0FBQzFQLEVBQUUsRUFBRTZQO1lBQzFCQSxVQUFVLElBQUksQ0FBQ0gsTUFBTSxDQUFDMVAsRUFBRSxDQUFDQyxNQUFNO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDeVAsTUFBTSxHQUFHLEVBQUU7UUFDaEIsT0FBT2xJO0lBQ1Q7SUFDQTs7Ozs7R0FLQyxHQUNEdUksT0FBTztRQUNMLElBQUksQ0FBQ1AsS0FBSyxDQUFDN0ksSUFBSSxDQUFDO1lBQ2QrSSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQjdFLEtBQUssSUFBSSxDQUFDQSxHQUFHO1FBQ2Y7UUFDQSxJQUFJLENBQUM2RSxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUM3RSxHQUFHLEdBQUcsRUFBRTtRQUNiLE9BQU8sSUFBSTtJQUNiO0lBQ0E7OztHQUdDLEdBQ0RtRixPQUFPO1FBQ0wsb0JBQW9CO1FBQ3BCLElBQUlDLFFBQVEsSUFBSSxDQUFDakgsTUFBTTtRQUN2Qix5QkFBeUI7UUFDekIsSUFBSWtILE9BQU8sSUFBSSxDQUFDVixLQUFLLENBQUNXLEdBQUc7UUFDekIsSUFBSSxDQUFDRCxNQUFNLE1BQU0sSUFBSXhMLE1BQU07UUFDM0IsSUFBSSxDQUFDZ0wsTUFBTSxHQUFHUSxLQUFLUixNQUFNO1FBQ3pCLElBQUksQ0FBQzdFLEdBQUcsR0FBR3FGLEtBQUtyRixHQUFHO1FBQ25CLGtDQUFrQztRQUNsQyxJQUFJLENBQUN1RixNQUFNLENBQUNILE1BQU1qSSxVQUFVO1FBQzVCLE9BQU8sSUFBSSxDQUFDcUksR0FBRyxDQUFDSjtJQUNsQjtJQUNBOzs7Ozs7R0FNQyxHQUNESyxJQUFJQyxPQUFPLEVBQUU3SSxJQUFJLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUMwSSxNQUFNLENBQUMsQ0FBQ0csV0FBVyxJQUFJN0ksSUFBRyxNQUFPO0lBQy9DO0lBQ0E7O0dBRUMsR0FDRDJJLElBQUlKLEtBQUssRUFBRTtRQUNULElBQUksSUFBSSxDQUFDcEYsR0FBRyxDQUFDNUssTUFBTSxFQUFFO1lBQ25CLElBQUksQ0FBQ3lQLE1BQU0sQ0FBQy9JLElBQUksQ0FBQyxJQUFJZ0osV0FBVyxJQUFJLENBQUM5RSxHQUFHO1lBQ3hDLElBQUksQ0FBQ0EsR0FBRyxHQUFHLEVBQUU7UUFDZjtRQUNBLElBQUksQ0FBQzZFLE1BQU0sQ0FBQy9JLElBQUksQ0FBQ3NKO1FBQ2pCLE9BQU8sSUFBSTtJQUNiO0lBQ0E7O0dBRUMsR0FDREcsT0FBTzNKLEtBQUssRUFBRTtRQUNackIsYUFBYXFCO1FBQ2IsOENBQThDO1FBQzlDLE1BQU9BLFFBQVEsS0FBTTtZQUNuQixJQUFJLENBQUNvRSxHQUFHLENBQUNsRSxJQUFJLENBQUNGLFFBQVEsT0FBTztZQUM3QkEsUUFBUUEsVUFBVTtRQUNwQjtRQUNBLElBQUksQ0FBQ29FLEdBQUcsQ0FBQ2xFLElBQUksQ0FBQ0Y7UUFDZCxPQUFPLElBQUk7SUFDYjtJQUNBOztHQUVDLEdBQ0QrSixNQUFNL0osS0FBSyxFQUFFO1FBQ1h6QixZQUFZeUI7UUFDWjRHLGNBQWM1RyxPQUFPLElBQUksQ0FBQ29FLEdBQUc7UUFDN0IsT0FBTyxJQUFJO0lBQ2I7SUFDQTs7R0FFQyxHQUNENEYsS0FBS2hLLEtBQUssRUFBRTtRQUNWLElBQUksQ0FBQ29FLEdBQUcsQ0FBQ2xFLElBQUksQ0FBQ0YsUUFBUSxJQUFJO1FBQzFCLE9BQU8sSUFBSTtJQUNiO0lBQ0E7O0dBRUMsR0FDRGUsTUFBTWYsS0FBSyxFQUFFO1FBQ1gsSUFBSSxDQUFDMkosTUFBTSxDQUFDM0osTUFBTXVCLFVBQVUsR0FBRyxrQ0FBa0M7UUFDakUsT0FBTyxJQUFJLENBQUNxSSxHQUFHLENBQUM1SjtJQUNsQjtJQUNBOztHQUVDLEdBQ0RpSyxPQUFPakssS0FBSyxFQUFFO1FBQ1osSUFBSXdKLFFBQVEsSUFBSSxDQUFDVixXQUFXLENBQUNvQixNQUFNLENBQUNsSztRQUNwQyxJQUFJLENBQUMySixNQUFNLENBQUNILE1BQU1qSSxVQUFVLEdBQUcsa0NBQWtDO1FBQ2pFLE9BQU8sSUFBSSxDQUFDcUksR0FBRyxDQUFDSjtJQUNsQjtJQUNBOztHQUVDLEdBQ0RXLE1BQU1uSyxLQUFLLEVBQUU7UUFDWHBCLGNBQWNvQjtRQUNkLElBQUl3SixRQUFRLElBQUlOLFdBQVc7UUFDM0IsSUFBSWpDLFNBQVN1QyxNQUFNWSxNQUFNLEVBQUVDLFVBQVUsQ0FBQyxHQUFHckssT0FBTztRQUNoRCxPQUFPLElBQUksQ0FBQzRKLEdBQUcsQ0FBQ0o7SUFDbEI7SUFDQTs7R0FFQyxHQUNEYyxPQUFPdEssS0FBSyxFQUFFO1FBQ1osSUFBSXdKLFFBQVEsSUFBSU4sV0FBVztRQUMzQixJQUFJakMsU0FBU3VDLE1BQU1ZLE1BQU0sRUFBRUcsVUFBVSxDQUFDLEdBQUd2SyxPQUFPO1FBQ2hELE9BQU8sSUFBSSxDQUFDNEosR0FBRyxDQUFDSjtJQUNsQjtJQUNBOztHQUVDLEdBQ0RnQixRQUFReEssS0FBSyxFQUFFO1FBQ2JyQixhQUFhcUI7UUFDYixJQUFJd0osUUFBUSxJQUFJTixXQUFXO1FBQzNCLElBQUlqQyxTQUFTdUMsTUFBTVksTUFBTSxFQUFFSyxTQUFTLENBQUMsR0FBR3pLLE9BQU87UUFDL0MsT0FBTyxJQUFJLENBQUM0SixHQUFHLENBQUNKO0lBQ2xCO0lBQ0E7O0dBRUMsR0FDRGtCLFNBQVMxSyxLQUFLLEVBQUU7UUFDZHpCLFlBQVl5QjtRQUNaLElBQUl3SixRQUFRLElBQUlOLFdBQVc7UUFDM0IsSUFBSWpDLFNBQVN1QyxNQUFNWSxNQUFNLEVBQUU3QixRQUFRLENBQUMsR0FBR3ZJLE9BQU87UUFDOUMsT0FBTyxJQUFJLENBQUM0SixHQUFHLENBQUNKO0lBQ2xCO0lBQ0E7O0dBRUMsR0FDRG1CLE9BQU8zSyxLQUFLLEVBQUU7UUFDWnpCLFlBQVl5QjtRQUNaLGdCQUFnQjtRQUNoQkEsUUFBUSxDQUFDQSxTQUFTLElBQUlBLFNBQVMsRUFBQyxNQUFPO1FBQ3ZDNEcsY0FBYzVHLE9BQU8sSUFBSSxDQUFDb0UsR0FBRztRQUM3QixPQUFPLElBQUk7SUFDYjtJQUNBOztHQUVDLEdBQ0R3RyxTQUFTNUssS0FBSyxFQUFFO1FBQ2QsSUFBSXdKLFFBQVEsSUFBSU4sV0FBVyxJQUN6QjJCLE9BQU8sSUFBSTVELFNBQVN1QyxNQUFNWSxNQUFNLEdBQ2hDVSxLQUFLbkMsV0FBV1AsR0FBRyxDQUFDcEk7UUFDdEI2SyxLQUFLdEMsUUFBUSxDQUFDLEdBQUd1QyxHQUFHckcsRUFBRSxFQUFFO1FBQ3hCb0csS0FBS3RDLFFBQVEsQ0FBQyxHQUFHdUMsR0FBR3BHLEVBQUUsRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQ2tGLEdBQUcsQ0FBQ0o7SUFDbEI7SUFDQTs7R0FFQyxHQUNEdUIsUUFBUS9LLEtBQUssRUFBRTtRQUNiLElBQUl3SixRQUFRLElBQUlOLFdBQVcsSUFDekIyQixPQUFPLElBQUk1RCxTQUFTdUMsTUFBTVksTUFBTSxHQUNoQ1UsS0FBS25DLFdBQVdMLElBQUksQ0FBQ3RJO1FBQ3ZCNkssS0FBS3RDLFFBQVEsQ0FBQyxHQUFHdUMsR0FBR3JHLEVBQUUsRUFBRTtRQUN4Qm9HLEtBQUt0QyxRQUFRLENBQUMsR0FBR3VDLEdBQUdwRyxFQUFFLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUNrRixHQUFHLENBQUNKO0lBQ2xCO0lBQ0E7O0dBRUMsR0FDRHdCLE1BQU1oTCxLQUFLLEVBQUU7UUFDWCxJQUFJOEssS0FBS25DLFdBQVdQLEdBQUcsQ0FBQ3BJO1FBQ3hCd0UsY0FBY3NHLEdBQUdyRyxFQUFFLEVBQUVxRyxHQUFHcEcsRUFBRSxFQUFFLElBQUksQ0FBQ04sR0FBRztRQUNwQyxPQUFPLElBQUk7SUFDYjtJQUNBOztHQUVDLEdBQ0Q2RyxPQUFPakwsS0FBSyxFQUFFO1FBQ1osSUFBSThLLEtBQUtuQyxXQUFXUCxHQUFHLENBQUNwSSxRQUN0QixnQkFBZ0I7UUFDaEJrTCxPQUFPSixHQUFHcEcsRUFBRSxJQUFJLElBQ2hCRCxLQUFLcUcsR0FBR3JHLEVBQUUsSUFBSSxJQUFJeUcsTUFDbEJ4RyxLQUFLLENBQUNvRyxHQUFHcEcsRUFBRSxJQUFJLElBQUlvRyxHQUFHckcsRUFBRSxLQUFLLEVBQUMsSUFBS3lHO1FBQ3JDMUcsY0FBY0MsSUFBSUMsSUFBSSxJQUFJLENBQUNOLEdBQUc7UUFDOUIsT0FBTyxJQUFJO0lBQ2I7SUFDQTs7R0FFQyxHQUNEK0csT0FBT25MLEtBQUssRUFBRTtRQUNaLElBQUk4SyxLQUFLbkMsV0FBV0wsSUFBSSxDQUFDdEk7UUFDekJ3RSxjQUFjc0csR0FBR3JHLEVBQUUsRUFBRXFHLEdBQUdwRyxFQUFFLEVBQUUsSUFBSSxDQUFDTixHQUFHO1FBQ3BDLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFDQSxNQUFNZ0g7SUFDSnBJLFlBQVlvQixHQUFHLEVBQUVpSCxXQUFXLENBQUU7UUFDNUIsSUFBSSxDQUFDQyxRQUFRLEdBQUd0SCxjQUFjLHdCQUF3QjtRQUN0RDs7S0FFQyxHQUNELElBQUksQ0FBQzJGLE1BQU0sR0FBRzlDLGNBQWMsc0RBQXNEO1FBQ2xGLElBQUksQ0FBQ3pDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUMrRSxHQUFHLEdBQUcvRSxJQUFJNUssTUFBTTtRQUNyQixJQUFJLENBQUM2SyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUN3RyxJQUFJLEdBQUcsSUFBSTVELFNBQVM3QyxJQUFJZ0csTUFBTSxFQUFFaEcsSUFBSW1ILFVBQVUsRUFBRW5ILElBQUk3QyxVQUFVO1FBQ25FLElBQUksQ0FBQzhKLFdBQVcsR0FBR0EsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUlBLGNBQWMsSUFBSUc7SUFDeEY7SUFDQTs7R0FFQyxHQUNEM0IsTUFBTTtRQUNKLElBQUlBLE1BQU0sSUFBSSxDQUFDRixNQUFNLElBQ25CRyxVQUFVRCxRQUFRLEdBQ2xCNEIsV0FBVzVCLE1BQU07UUFDbkIsSUFBSUMsV0FBVyxLQUFLMkIsV0FBVyxLQUFLQSxXQUFXLEdBQUcsTUFBTSxJQUFJeE4sTUFBTSwyQkFBMkI2TCxVQUFVLGdCQUFnQjJCO1FBQ3ZILE9BQU87WUFBQzNCO1lBQVMyQjtTQUFTO0lBQzVCO0lBQ0E7OztHQUdDLEdBQ0RDLEtBQUtELFFBQVEsRUFBRTtRQUNiLElBQUlFLFFBQVEsSUFBSSxDQUFDdEgsR0FBRztRQUNwQixPQUFRb0g7WUFDTixLQUFLN0MsU0FBU2dELE1BQU07Z0JBQ2xCLE1BQU8sSUFBSSxDQUFDeEgsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHLEdBQUcsS0FBTTtnQkFDbEMsU0FBUztnQkFDWDtnQkFDQTtZQUNGLDJCQUEyQjtZQUMzQixnREFBZ0Q7WUFDaEQsS0FBS3VFLFNBQVNpRCxLQUFLO2dCQUNqQixJQUFJLENBQUN4SCxHQUFHLElBQUk7WUFDZCwyQkFBMkI7WUFDM0IsZ0RBQWdEO1lBQ2hELEtBQUt1RSxTQUFTa0QsS0FBSztnQkFDakIsSUFBSSxDQUFDekgsR0FBRyxJQUFJO2dCQUNaO1lBQ0YsS0FBS3VFLFNBQVNtRCxlQUFlO2dCQUMzQixJQUFJNUMsTUFBTSxJQUFJLENBQUNRLE1BQU07Z0JBQ3JCLElBQUksQ0FBQ3RGLEdBQUcsSUFBSThFO2dCQUNaO1lBQ0YsS0FBS1AsU0FBU29ELFVBQVU7Z0JBQ3RCLDRFQUE0RTtnQkFDNUUsMkRBQTJEO2dCQUMzRCxJQUFJOU07Z0JBQ0osTUFBTyxDQUFDQSxJQUFJLElBQUksQ0FBQzJLLEdBQUcsRUFBRSxDQUFDLEVBQUUsTUFBTWpCLFNBQVNxRCxRQUFRLENBQUU7b0JBQ2hELElBQUksQ0FBQ1AsSUFBSSxDQUFDeE07Z0JBQ1o7Z0JBQ0E7WUFDRjtnQkFDRSxNQUFNLElBQUlqQixNQUFNLHlCQUF5QndOO1FBQzdDO1FBQ0EsSUFBSSxDQUFDbkgsWUFBWTtRQUNqQixPQUFPLElBQUksQ0FBQ0YsR0FBRyxDQUFDOEgsUUFBUSxDQUFDUCxPQUFPLElBQUksQ0FBQ3RILEdBQUc7SUFDMUM7SUFDQTs7R0FFQyxHQUNEQyxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUNELEdBQUcsR0FBRyxJQUFJLENBQUM4RSxHQUFHLEVBQUUsTUFBTSxJQUFJZ0QsV0FBVztJQUNoRDtJQUNBOztHQUVDLEdBQ0RwQyxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUNKLE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RnQixTQUFTO1FBQ1AsSUFBSXlCLE1BQU0sSUFBSSxDQUFDekMsTUFBTTtRQUNyQixnQkFBZ0I7UUFDaEIsT0FBT3lDLFFBQVEsSUFBSSxDQUFFQSxDQUFBQSxNQUFNO0lBQzdCO0lBQ0E7O0dBRUMsR0FDRHBCLFFBQVE7UUFDTixPQUFPckMsV0FBVzFELEdBQUcsSUFBSSxJQUFJLENBQUNxRyxRQUFRO0lBQ3hDO0lBQ0E7O0dBRUMsR0FDREgsU0FBUztRQUNQLE9BQU94QyxXQUFXSCxJQUFJLElBQUksSUFBSSxDQUFDOEMsUUFBUTtJQUN6QztJQUNBOztHQUVDLEdBQ0RMLFNBQVM7UUFDUCxJQUFJLENBQUN4RyxJQUFJQyxHQUFHLEdBQUcsSUFBSSxDQUFDNEcsUUFBUTtRQUM1QixpQkFBaUI7UUFDakIsSUFBSWUsSUFBSSxDQUFFNUgsQ0FBQUEsS0FBSztRQUNmQSxLQUFLLENBQUNBLE9BQU8sSUFBSSxDQUFDQyxLQUFLLE1BQU0sRUFBQyxJQUFLMkg7UUFDbkMzSCxLQUFLQSxPQUFPLElBQUkySDtRQUNoQixPQUFPMUQsV0FBVzFELEdBQUcsQ0FBQ1IsSUFBSUM7SUFDNUI7SUFDQTs7R0FFQyxHQUNEc0YsT0FBTztRQUNMLElBQUksQ0FBQ3ZGLElBQUlDLEdBQUcsR0FBRyxJQUFJLENBQUM0RyxRQUFRO1FBQzVCLE9BQU83RyxPQUFPLEtBQUtDLE9BQU87SUFDNUI7SUFDQTs7R0FFQyxHQUNEOEYsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDSyxJQUFJLENBQUN5QixTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUNqSSxHQUFHLElBQUksS0FBSyxHQUFHO0lBQ2xEO0lBQ0E7O0dBRUMsR0FDRHFHLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ0csSUFBSSxDQUFDeEMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDaEUsR0FBRyxJQUFJLEtBQUssR0FBRztJQUNqRDtJQUNBOztHQUVDLEdBQ0QwRyxVQUFVO1FBQ1IsT0FBT3BDLFdBQVdILElBQUksQ0FBQyxJQUFJLENBQUNrQyxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRO0lBQ3ZEO0lBQ0E7O0dBRUMsR0FDREUsV0FBVztRQUNULE9BQU9qQyxXQUFXMUQsR0FBRyxDQUFDLElBQUksQ0FBQ3lGLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVE7SUFDdEQ7SUFDQTs7R0FFQyxHQUNEUCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUNVLElBQUksQ0FBQzBCLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQ2xJLEdBQUcsSUFBSSxLQUFLLEdBQUc7SUFDbkQ7SUFDQTs7R0FFQyxHQUNEaUcsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDTyxJQUFJLENBQUMyQixVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUNuSSxHQUFHLElBQUksS0FBSyxHQUFHO0lBQ25EO0lBQ0E7O0dBRUMsR0FDRHRELFFBQVE7UUFDTixJQUFJb0ksTUFBTSxJQUFJLENBQUNRLE1BQU0sSUFDbkJnQyxRQUFRLElBQUksQ0FBQ3RILEdBQUc7UUFDbEIsSUFBSSxDQUFDQSxHQUFHLElBQUk4RTtRQUNaLElBQUksQ0FBQzdFLFlBQVk7UUFDakIsT0FBTyxJQUFJLENBQUNGLEdBQUcsQ0FBQzhILFFBQVEsQ0FBQ1AsT0FBT0EsUUFBUXhDO0lBQzFDO0lBQ0E7O0dBRUMsR0FDRGMsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDb0IsV0FBVyxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQzFMLEtBQUs7SUFDM0M7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQzs7O0NBR0MsR0FDRCxTQUFTMkwsVUFBVXpMLElBQUksRUFBRWpCLEtBQUs7SUFDNUIsSUFBSUEsaUJBQWlCTyxXQUFXLENBQUNVLEtBQUswTCxZQUFZLEVBQUU7UUFDbEQsT0FBTzNNO0lBQ1Q7SUFDQSxPQUFPaUIsS0FBSzBMLFlBQVksQ0FBQ0QsU0FBUyxDQUFDMU07QUFDckM7QUFDQztJQUNDLCtCQUErQjhELFdBQVc4SSxNQUFNO0lBQ2hELDhCQUE4QjlJLFdBQVcrSSxLQUFLO0lBQzlDLDhCQUE4Qi9JLFdBQVdnSixLQUFLO0lBQzlDLCtCQUErQmhKLFdBQVdpSixNQUFNO0lBQ2hELDhCQUE4QmpKLFdBQVdrSixLQUFLO0lBQzlDLCtCQUErQmxKLFdBQVdtSixNQUFNO0lBQ2hELDZCQUE2Qm5KLFdBQVdvSixJQUFJO0lBQzVDLCtCQUErQnBKLFdBQVdxSixNQUFNO0lBQ2hELDhCQUE4QnJKLFdBQVdzSixLQUFLO0FBQ2hEO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLHFEQUFxRCxHQUNyRDs7Q0FFQyxHQUNELFNBQVNDLGFBQWFwTSxJQUFJLEVBQUV5QyxDQUFDLEVBQUVDLENBQUM7SUFDOUIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLG1GQUFtRjtRQUNuRixPQUFPO0lBQ1Q7SUFDQSxpRUFBaUU7SUFDakUsSUFBSTFDLFFBQVE2QyxXQUFXc0osS0FBSyxFQUFFO1FBQzVCLElBQUksQ0FBRTFKLENBQUFBLGFBQWF3RixVQUFTLEtBQU0sQ0FBRXZGLENBQUFBLGFBQWF1RixVQUFTLEdBQUk7WUFDNUQsT0FBTztRQUNUO1FBQ0EsSUFBSXhGLEVBQUVsSyxNQUFNLEtBQUttSyxFQUFFbkssTUFBTSxFQUFFO1lBQ3pCLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJbUssRUFBRWxLLE1BQU0sRUFBRUQsSUFBSztZQUNqQyxJQUFJbUssQ0FBQyxDQUFDbkssRUFBRSxLQUFLb0ssQ0FBQyxDQUFDcEssRUFBRSxFQUFFO2dCQUNqQixPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBLHNGQUFzRjtJQUN0RiwwRUFBMEU7SUFDMUUsT0FBUTBIO1FBQ04sS0FBSzZDLFdBQVdpSixNQUFNO1FBQ3RCLEtBQUtqSixXQUFXd0osT0FBTztRQUN2QixLQUFLeEosV0FBV2dKLEtBQUs7UUFDckIsS0FBS2hKLFdBQVd5SixRQUFRO1FBQ3hCLEtBQUt6SixXQUFXMEosTUFBTTtZQUNwQixxREFBcUQ7WUFDckQsT0FBTzlKLEtBQUtDO0lBQ2hCO0lBQ0EseUVBQXlFO0lBQ3pFLDBDQUEwQztJQUMxQyxPQUFPO0FBQ1Q7QUFDQTs7O0NBR0MsR0FDRCxTQUFTOEosbUJBQW1CeE0sSUFBSSxFQUFFeU0sUUFBUTtJQUN4QyxPQUFRek07UUFDTixLQUFLNkMsV0FBV29KLElBQUk7WUFDbEIsT0FBTztRQUNULEtBQUtwSixXQUFXaUosTUFBTTtRQUN0QixLQUFLakosV0FBV3dKLE9BQU87UUFDdkIsS0FBS3hKLFdBQVdnSixLQUFLO1FBQ3JCLEtBQUtoSixXQUFXeUosUUFBUTtRQUN4QixLQUFLekosV0FBVzBKLE1BQU07WUFDcEIsa0hBQWtIO1lBQ2xILE9BQU9FLFlBQVksSUFBSS9FLFdBQVdYLElBQUksR0FBRztRQUMzQyxLQUFLbEUsV0FBVzhJLE1BQU07UUFDdEIsS0FBSzlJLFdBQVcrSSxLQUFLO1lBQ25CLE9BQU87UUFDVCxLQUFLL0ksV0FBV3NKLEtBQUs7WUFDbkIsT0FBTyxJQUFJbEUsV0FBVztRQUN4QixLQUFLcEYsV0FBV3FKLE1BQU07WUFDcEIsT0FBTztRQUNUO1lBQ0Usb0RBQW9EO1lBQ3BELGdFQUFnRTtZQUNoRSxPQUFPO0lBQ1g7QUFDRjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNRLGVBQWUxTSxJQUFJLEVBQUVqQixLQUFLO0lBQ2pDLE1BQU00TixjQUFjNU4sVUFBVTdHO0lBQzlCLElBQUlzUyxXQUFXN0MsU0FBU2dELE1BQU07SUFDOUIsSUFBSWlDLHFCQUFxQjdOLFVBQVU7SUFDbkMsK0hBQStIO0lBQy9ILE9BQVFpQjtRQUNOLEtBQUs2QyxXQUFXcUosTUFBTTtZQUNwQlUscUJBQXFCRCxlQUFlLENBQUM1TixNQUFNeEcsTUFBTTtZQUNqRGlTLFdBQVc3QyxTQUFTbUQsZUFBZTtZQUNuQztRQUNGLEtBQUtqSSxXQUFXb0osSUFBSTtZQUNsQlcscUJBQXFCN04sVUFBVTtZQUMvQjtRQUNGLEtBQUs4RCxXQUFXOEksTUFBTTtZQUNwQm5CLFdBQVc3QyxTQUFTaUQsS0FBSztZQUN6QjtRQUNGLEtBQUsvSCxXQUFXK0ksS0FBSztZQUNuQnBCLFdBQVc3QyxTQUFTa0QsS0FBSztZQUN6QjtRQUNGLEtBQUtoSSxXQUFXZ0osS0FBSztZQUNuQmUscUJBQXFCRCxlQUFlNU4sU0FBUyxHQUFHLHlDQUF5QztZQUN6RjtRQUNGLEtBQUs4RCxXQUFXaUosTUFBTTtZQUNwQmMscUJBQXFCRCxlQUFlNU4sU0FBUyxHQUFHLHlDQUF5QztZQUN6RjtRQUNGLEtBQUs4RCxXQUFXd0osT0FBTztZQUNyQk8scUJBQXFCRCxlQUFlNU4sU0FBUyxHQUFHLHlDQUF5QztZQUN6RnlMLFdBQVc3QyxTQUFTaUQsS0FBSztZQUN6QjtRQUNGLEtBQUsvSCxXQUFXc0osS0FBSztZQUNuQlMscUJBQXFCRCxlQUFlLENBQUM1TixNQUFNdUIsVUFBVTtZQUNyRGtLLFdBQVc3QyxTQUFTbUQsZUFBZTtZQUNuQztRQUNGLEtBQUtqSSxXQUFXZ0ssT0FBTztZQUNyQnJDLFdBQVc3QyxTQUFTa0QsS0FBSztZQUN6QjtRQUNGLEtBQUtoSSxXQUFXaUssUUFBUTtZQUN0QnRDLFdBQVc3QyxTQUFTa0QsS0FBSztZQUN6QjtRQUNGLEtBQUtoSSxXQUFXeUosUUFBUTtZQUN0Qk0scUJBQXFCRCxlQUFlNU4sU0FBUztZQUM3Q3lMLFdBQVc3QyxTQUFTaUQsS0FBSztZQUN6QjtRQUNGLEtBQUsvSCxXQUFXMEosTUFBTTtZQUNwQksscUJBQXFCRCxlQUFlNU4sU0FBUztZQUM3QztJQUNKO0lBQ0EsTUFBTXRILFNBQVNvTCxVQUFVLENBQUM3QyxLQUFLLENBQUMrTSxXQUFXO0lBQzNDLE9BQU87UUFBQ3ZDO1FBQVUvUztRQUFRa1YsZUFBZUM7S0FBbUI7QUFDOUQ7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsMFVBQTBVLEdBQzFVLE1BQU1JLHNCQUFzQmxQLE9BQU87QUFDbkMsMkNBQTJDO0FBQzNDLE1BQU1tUCxlQUFlO0lBQ25CQyxtQkFBbUI7SUFDbkI3TSxlQUFlUCxDQUFBQSxRQUFTLElBQUlxSyxhQUFhcks7QUFDM0M7QUFDQSwrQ0FBK0M7QUFDL0MsTUFBTXFOLGdCQUFnQjtJQUNwQkMsb0JBQW9CO0lBQ3BCaE0sZUFBZSxJQUFNLElBQUl3RztBQUMzQjtBQUNBLFNBQVN5RixrQkFBa0J0TixPQUFPO0lBQ2hDLE9BQU9BLFVBQVUxSyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUc0TixlQUFlbE4sV0FBV2tOO0FBQzdFO0FBQ0EsU0FBU0ssbUJBQW1Cdk4sT0FBTztJQUNqQyxPQUFPQSxVQUFVMUssT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHOE4sZ0JBQWdCcE4sV0FBV29OO0FBQzlFO0FBQ0EsU0FBU0k7SUFDUCxPQUFPO1FBQ0xwTixpQkFBaUJrTjtRQUNqQm5NLGtCQUFrQm9NO1FBQ2xCRSxtQkFBa0J6TSxPQUFPO1lBQ3ZCLElBQUlVO1lBQ0osT0FBTyxDQUFDQSxLQUFLVixPQUFPLENBQUNpTSxvQkFBb0IsTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUNoRjtRQUNBZ00sc0JBQXFCMU0sT0FBTztZQUMxQixPQUFPQSxPQUFPLENBQUNpTSxvQkFBb0I7UUFDckM7UUFDQUksb0JBQW1Cck0sT0FBTyxFQUFFSSxNQUFNO1lBQ2hDLE1BQU1uTSxJQUFJK0w7WUFDVixNQUFNMk0sSUFBSTFZLENBQUMsQ0FBQ2dZLG9CQUFvQjtZQUNoQyxJQUFJVSxHQUFHO2dCQUNMLEtBQUssTUFBTUMsS0FBS0QsRUFBRztvQkFDakJ2TSxPQUFPeUgsR0FBRyxDQUFDK0UsRUFBRW5QLEVBQUUsRUFBRW1QLEVBQUVuRCxRQUFRLEVBQUU3QixHQUFHLENBQUNnRixFQUFFdkwsSUFBSTtnQkFDekM7WUFDRjtRQUNGO1FBQ0F3TCxnQkFBZTdNLE9BQU8sRUFBRXZDLEVBQUUsRUFBRWdNLFFBQVEsRUFBRXBJLElBQUk7WUFDeEMsTUFBTXBOLElBQUkrTDtZQUNWLElBQUksQ0FBQzVMLE1BQU1DLE9BQU8sQ0FBQ0osQ0FBQyxDQUFDZ1ksb0JBQW9CLEdBQUc7Z0JBQzFDaFksQ0FBQyxDQUFDZ1ksb0JBQW9CLEdBQUcsRUFBRTtZQUM3QjtZQUNBaFksQ0FBQyxDQUFDZ1ksb0JBQW9CLENBQUMvTixJQUFJLENBQUM7Z0JBQzFCVDtnQkFDQWdNO2dCQUNBcEk7WUFDRjtRQUNGO1FBQ0FoQyxhQUFZVyxPQUFPLEVBQUU4TSxNQUFNLEVBQUV0VixNQUFNLEVBQUV3SCxPQUFPO1lBQzFDLE1BQU1DLE9BQU9lLFFBQVF0QixPQUFPO1lBQzVCLE1BQU00RSxNQUFNOUwsV0FBV0wsWUFBWTJWLE9BQU8zRixHQUFHLEdBQUcyRixPQUFPekssR0FBRyxHQUFHN0s7WUFDN0QsTUFBT3NWLE9BQU96SyxHQUFHLEdBQUdpQixJQUFLO2dCQUN2QixNQUFNLENBQUN3RSxTQUFTMkIsU0FBUyxHQUFHcUQsT0FBT2pGLEdBQUcsSUFDcENrRixRQUFROU4sS0FBS2lDLE1BQU0sQ0FBQzhMLElBQUksQ0FBQ2xGO2dCQUMzQixJQUFJLENBQUNpRixPQUFPO29CQUNWLE1BQU0xTCxPQUFPeUwsT0FBT3BELElBQUksQ0FBQ0Q7b0JBQ3pCLElBQUl6SyxRQUFRbU4saUJBQWlCLEVBQUU7d0JBQzdCLElBQUksQ0FBQ1UsY0FBYyxDQUFDN00sU0FBUzhILFNBQVMyQixVQUFVcEk7b0JBQ2xEO29CQUNBO2dCQUNGO2dCQUNBLElBQUk0TCxTQUFTak4sU0FDWGtOLFdBQVdILE1BQU1HLFFBQVEsRUFDekJ4UCxZQUFZcVAsTUFBTXJQLFNBQVM7Z0JBQzdCLElBQUlxUCxNQUFNSSxLQUFLLEVBQUU7b0JBQ2ZGLFNBQVNBLE1BQU0sQ0FBQ0YsTUFBTUksS0FBSyxDQUFDelAsU0FBUyxDQUFDO29CQUN0QyxJQUFJdVAsT0FBT0csSUFBSSxJQUFJMVAsV0FBVzt3QkFDNUIsT0FBT3VQLE9BQU9qUCxLQUFLO29CQUNyQjtvQkFDQWlQLE9BQU9HLElBQUksR0FBRzFQO29CQUNkQSxZQUFZO2dCQUNkO2dCQUNBLE9BQVFxUCxNQUFNTSxJQUFJO29CQUNoQixLQUFLO29CQUNMLEtBQUs7d0JBQ0gsTUFBTUMsYUFBYVAsTUFBTU0sSUFBSSxJQUFJLFNBQVN2TCxXQUFXa0osS0FBSyxHQUFHK0IsTUFBTVEsQ0FBQzt3QkFDcEUsSUFBSUMsT0FBT0M7d0JBQ1gsa0hBQWtIO3dCQUNsSCxJQUFJVixNQUFNTSxJQUFJLElBQUksWUFBWU4sTUFBTVcsQ0FBQyxHQUFHLEdBQUc7NEJBQ3pDRixPQUFPRzt3QkFDVDt3QkFDQSxJQUFJVCxVQUFVOzRCQUNaLElBQUlVLE1BQU1YLE1BQU0sQ0FBQ3ZQLFVBQVUsRUFBRSx5RUFBeUU7NEJBQ3RHLElBQUkrTCxZQUFZN0MsU0FBU21ELGVBQWUsSUFBSXVELGNBQWN4TCxXQUFXcUosTUFBTSxJQUFJbUMsY0FBY3hMLFdBQVdzSixLQUFLLEVBQUU7Z0NBQzdHLElBQUlqWCxJQUFJMlksT0FBT25GLE1BQU0sS0FBS21GLE9BQU96SyxHQUFHO2dDQUNwQyxNQUFPeUssT0FBT3pLLEdBQUcsR0FBR2xPLEVBQUc7b0NBQ3JCeVosSUFBSTFQLElBQUksQ0FBQ3NQLEtBQUtWLFFBQVFRO2dDQUN4Qjs0QkFDRixPQUFPO2dDQUNMTSxJQUFJMVAsSUFBSSxDQUFDc1AsS0FBS1YsUUFBUVE7NEJBQ3hCO3dCQUNGLE9BQU87NEJBQ0xMLE1BQU0sQ0FBQ3ZQLFVBQVUsR0FBRzhQLEtBQUtWLFFBQVFRO3dCQUNuQzt3QkFDQTtvQkFDRixLQUFLO3dCQUNILE1BQU1PLGNBQWNkLE1BQU1RLENBQUM7d0JBQzNCLElBQUlMLFVBQVU7NEJBQ1oseUVBQXlFOzRCQUN6RUQsTUFBTSxDQUFDdlAsVUFBVSxDQUFDUSxJQUFJLENBQUM0UCxpQkFBaUJoQixRQUFRLElBQUllLGVBQWU3Tzt3QkFDckUsT0FBTzs0QkFDTCxJQUFJaU8sTUFBTSxDQUFDdlAsVUFBVSxZQUFZYSxTQUFTO2dDQUN4Q3VQLGlCQUFpQmhCLFFBQVFHLE1BQU0sQ0FBQ3ZQLFVBQVUsRUFBRXNCOzRCQUM5QyxPQUFPO2dDQUNMaU8sTUFBTSxDQUFDdlAsVUFBVSxHQUFHb1EsaUJBQWlCaEIsUUFBUSxJQUFJZSxlQUFlN087Z0NBQ2hFLElBQUk2TyxZQUFZbEQsWUFBWSxJQUFJLENBQUNvQyxNQUFNSSxLQUFLLElBQUksQ0FBQ0osTUFBTUcsUUFBUSxFQUFFO29DQUMvREQsTUFBTSxDQUFDdlAsVUFBVSxHQUFHbVEsWUFBWWxELFlBQVksQ0FBQ29ELFdBQVcsQ0FBQ2QsTUFBTSxDQUFDdlAsVUFBVTtnQ0FDNUU7NEJBQ0Y7d0JBQ0Y7d0JBQ0E7b0JBQ0YsS0FBSzt3QkFDSCxJQUFJLENBQUNzUSxRQUFRQyxPQUFPLEdBQUdDLGFBQWFuQixPQUFPRCxRQUFROU47d0JBQ25ELDhFQUE4RTt3QkFDOUVpTyxNQUFNLENBQUN2UCxVQUFVLENBQUNzUSxPQUFPLEdBQUdDO3dCQUM1QjtnQkFDSjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0Esa0VBQWtFO0FBQ2xFLDJDQUEyQztBQUMzQyxTQUFTSCxpQkFBaUJoQixNQUFNLEVBQUU5TSxPQUFPLEVBQUVoQixPQUFPO0lBQ2hELE1BQU1FLFNBQVNjLFFBQVF0QixPQUFPLEdBQUdDLE9BQU8sQ0FBQ1EsR0FBRztJQUM1Q0QsT0FBT0csV0FBVyxDQUFDVyxTQUFTOE0sUUFBUUEsT0FBT25GLE1BQU0sSUFBSTNJO0lBQ3JELE9BQU9nQjtBQUNUO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVNrTyxhQUFhbkIsS0FBSyxFQUFFRCxNQUFNLEVBQUU5TixPQUFPO0lBQzFDLE1BQU14SCxTQUFTc1YsT0FBT25GLE1BQU0sSUFDMUJyRSxNQUFNd0osT0FBT3pLLEdBQUcsR0FBRzdLO0lBQ3JCLElBQUkyVyxLQUFLQztJQUNULE1BQU90QixPQUFPekssR0FBRyxHQUFHaUIsSUFBSztRQUN2QixJQUFJLENBQUN3RSxRQUFRLEdBQUdnRixPQUFPakYsR0FBRztRQUMxQixPQUFRQztZQUNOLEtBQUs7Z0JBQ0hxRyxNQUFNVixhQUFhWCxRQUFRQyxNQUFNc0IsQ0FBQztnQkFDbEM7WUFDRixLQUFLO2dCQUNILE9BQVF0QixNQUFNdUIsQ0FBQyxDQUFDakIsSUFBSTtvQkFDbEIsS0FBSzt3QkFDSGUsTUFBTVgsYUFBYVgsUUFBUUMsTUFBTXVCLENBQUMsQ0FBQ2YsQ0FBQzt3QkFDcEM7b0JBQ0YsS0FBSzt3QkFDSGEsTUFBTXRCLE9BQU8vRSxLQUFLO3dCQUNsQjtvQkFDRixLQUFLO3dCQUNIcUcsTUFBTU4saUJBQWlCaEIsUUFBUSxJQUFJQyxNQUFNdUIsQ0FBQyxDQUFDZixDQUFDLElBQUl2Tzt3QkFDaEQ7Z0JBQ0o7Z0JBQ0E7UUFDSjtJQUNGO0lBQ0EsSUFBSW1QLFFBQVFoWCxXQUFXO1FBQ3JCLElBQUlvWCxTQUFTOUMsbUJBQW1Cc0IsTUFBTXNCLENBQUMsRUFBRXRNLFNBQVN5TSxNQUFNO1FBQ3hETCxNQUFNcEIsTUFBTXNCLENBQUMsSUFBSXZNLFdBQVdvSixJQUFJLEdBQUdxRCxPQUFPL0osUUFBUSxLQUFLK0o7SUFDekQ7SUFDQSxJQUFJLE9BQU9KLE9BQU8sWUFBWSxPQUFPQSxPQUFPLFVBQVU7UUFDcERBLE1BQU1BLElBQUkzSixRQUFRO0lBQ3BCO0lBQ0EsSUFBSTRKLFFBQVFqWCxXQUFXO1FBQ3JCLE9BQVE0VixNQUFNdUIsQ0FBQyxDQUFDakIsSUFBSTtZQUNsQixLQUFLO2dCQUNIZSxNQUFNM0MsbUJBQW1Cc0IsTUFBTXVCLENBQUMsQ0FBQ2YsQ0FBQyxFQUFFeEwsU0FBU3lNLE1BQU07Z0JBQ25EO1lBQ0YsS0FBSztnQkFDSEosTUFBTTtnQkFDTjtZQUNGLEtBQUs7Z0JBQ0hBLE1BQU0sSUFBSXJCLE1BQU11QixDQUFDLENBQUNmLENBQUM7Z0JBQ25CO1FBQ0o7SUFDRjtJQUNBLE9BQU87UUFBQ1k7UUFBS0M7S0FBSTtBQUNuQjtBQUNBLHdFQUF3RTtBQUN4RSwwREFBMEQ7QUFDMUQsU0FBU1QsbUJBQW1CYixNQUFNLEVBQUU3TixJQUFJO0lBQ3RDLE1BQU16QixJQUFJaVEsYUFBYVgsUUFBUTdOO0lBQy9CLE9BQU8sT0FBT3pCLEtBQUssV0FBV0EsRUFBRWdILFFBQVEsS0FBS2hIO0FBQy9DO0FBQ0Esd0RBQXdEO0FBQ3hELFNBQVNpUSxhQUFhWCxNQUFNLEVBQUU3TixJQUFJO0lBQ2hDLE9BQVFBO1FBQ04sS0FBSzZDLFdBQVdxSixNQUFNO1lBQ3BCLE9BQU8yQixPQUFPN0UsTUFBTTtRQUN0QixLQUFLbkcsV0FBV29KLElBQUk7WUFDbEIsT0FBTzRCLE9BQU85RSxJQUFJO1FBQ3BCLEtBQUtsRyxXQUFXOEksTUFBTTtZQUNwQixPQUFPa0MsT0FBT3hFLE1BQU07UUFDdEIsS0FBS3hHLFdBQVcrSSxLQUFLO1lBQ25CLE9BQU9pQyxPQUFPM0UsS0FBSztRQUNyQixLQUFLckcsV0FBV2tKLEtBQUs7WUFDbkIsT0FBTzhCLE9BQU8vRSxLQUFLO1FBQ3JCLEtBQUtqRyxXQUFXZ0osS0FBSztZQUNuQixPQUFPZ0MsT0FBTzlELEtBQUs7UUFDckIsS0FBS2xILFdBQVdpSixNQUFNO1lBQ3BCLE9BQU8rQixPQUFPM0QsTUFBTTtRQUN0QixLQUFLckgsV0FBV3dKLE9BQU87WUFDckIsT0FBT3dCLE9BQU8vRCxPQUFPO1FBQ3ZCLEtBQUtqSCxXQUFXc0osS0FBSztZQUNuQixPQUFPMEIsT0FBTy9OLEtBQUs7UUFDckIsS0FBSytDLFdBQVdnSyxPQUFPO1lBQ3JCLE9BQU9nQixPQUFPdEUsT0FBTztRQUN2QixLQUFLMUcsV0FBV2lLLFFBQVE7WUFDdEIsT0FBT2UsT0FBT3BFLFFBQVE7UUFDeEIsS0FBSzVHLFdBQVd5SixRQUFRO1lBQ3RCLE9BQU91QixPQUFPbEUsUUFBUTtRQUN4QixLQUFLOUcsV0FBVzBKLE1BQU07WUFDcEIsT0FBT3NCLE9BQU83RCxNQUFNO1FBQ3RCLEtBQUtuSCxXQUFXbUosTUFBTTtZQUNwQixPQUFPNkIsT0FBT25GLE1BQU07UUFDdEIsS0FBSzdGLFdBQVcyTSxNQUFNO1lBQ3BCLE9BQU8zQixPQUFPbkUsTUFBTTtJQUN4QjtBQUNGO0FBQ0EsU0FBUytGLGNBQWN0TyxNQUFNLEVBQUVwQixPQUFPLEVBQUUrTixLQUFLLEVBQUVvQixHQUFHLEVBQUVuUSxLQUFLO0lBQ3ZEb0MsT0FBT3lILEdBQUcsQ0FBQ2tGLE1BQU10UCxFQUFFLEVBQUVtSixTQUFTbUQsZUFBZTtJQUM3QzNKLE9BQU9rSCxJQUFJO0lBQ1gsZ0VBQWdFO0lBQ2hFLDBEQUEwRDtJQUMxRCxJQUFJcUgsV0FBV1I7SUFDZix3SUFBd0k7SUFDeEksT0FBUXBCLE1BQU1zQixDQUFDO1FBQ2IsS0FBS3ZNLFdBQVdrSixLQUFLO1FBQ3JCLEtBQUtsSixXQUFXZ0ssT0FBTztRQUN2QixLQUFLaEssV0FBV21KLE1BQU07UUFDdEIsS0FBS25KLFdBQVdpSyxRQUFRO1FBQ3hCLEtBQUtqSyxXQUFXMk0sTUFBTTtZQUNwQkUsV0FBV2xTLE9BQU9tUyxRQUFRLENBQUNUO1lBQzNCO1FBQ0YsS0FBS3JNLFdBQVdvSixJQUFJO1lBQ2xCblAsT0FBT29TLE9BQU8sVUFBVUEsT0FBTztZQUMvQlEsV0FBV1IsT0FBTztZQUNsQjtJQUNKO0lBQ0EsNENBQTRDO0lBQzVDVSxjQUFjek8sUUFBUTJNLE1BQU1zQixDQUFDLEVBQUUsR0FBR00sVUFBVTtJQUM1QyxnREFBZ0Q7SUFDaEQsT0FBUTVCLE1BQU11QixDQUFDLENBQUNqQixJQUFJO1FBQ2xCLEtBQUs7WUFDSHdCLGNBQWN6TyxRQUFRMk0sTUFBTXVCLENBQUMsQ0FBQ2YsQ0FBQyxFQUFFLEdBQUd2UCxPQUFPO1lBQzNDO1FBQ0YsS0FBSztZQUNINlEsY0FBY3pPLFFBQVEwQixXQUFXa0osS0FBSyxFQUFFLEdBQUdoTixPQUFPO1lBQ2xEO1FBQ0YsS0FBSztZQUNIOFEsa0JBQWtCMU8sUUFBUXBCLFNBQVMrTixNQUFNdUIsQ0FBQyxDQUFDZixDQUFDLEVBQUUsR0FBR3ZQO1lBQ2pEO0lBQ0o7SUFDQW9DLE9BQU9tSCxJQUFJO0FBQ2I7QUFDQSxTQUFTdUgsa0JBQWtCMU8sTUFBTSxFQUFFcEIsT0FBTyxFQUFFQyxJQUFJLEVBQUU2SSxPQUFPLEVBQUU5SixLQUFLO0lBQzlELElBQUlBLFVBQVU3RyxXQUFXO1FBQ3ZCLE1BQU02SSxVQUFVMEssVUFBVXpMLE1BQU1qQjtRQUNoQ29DLE9BQU95SCxHQUFHLENBQUNDLFNBQVNsQixTQUFTbUQsZUFBZSxFQUFFaEwsS0FBSyxDQUFDaUIsUUFBUUUsUUFBUSxDQUFDbEI7SUFDdkU7QUFDRjtBQUNBLFNBQVM2UCxjQUFjek8sTUFBTSxFQUFFbkIsSUFBSSxFQUFFNkksT0FBTyxFQUFFOUosS0FBSyxFQUFFK1Esb0JBQW9CO0lBQ3ZFLElBQUksQ0FBQ3RGLFVBQVUvUyxRQUFRbVYsbUJBQW1CLEdBQUdGLGVBQWUxTSxNQUFNakI7SUFDbEUsSUFBSSxDQUFDNk4sc0JBQXNCa0Qsc0JBQXNCO1FBQy9DM08sT0FBT3lILEdBQUcsQ0FBQ0MsU0FBUzJCLFNBQVMsQ0FBQy9TLE9BQU8sQ0FBQ3NIO0lBQ3hDO0FBQ0Y7QUFDQSxTQUFTZ1IsWUFBWTVPLE1BQU0sRUFBRW5CLElBQUksRUFBRTZJLE9BQU8sRUFBRTlKLEtBQUs7SUFDL0MsSUFBSSxDQUFDQSxNQUFNeEcsTUFBTSxFQUFFO1FBQ2pCO0lBQ0Y7SUFDQTRJLE9BQU95SCxHQUFHLENBQUNDLFNBQVNsQixTQUFTbUQsZUFBZSxFQUFFekMsSUFBSTtJQUNsRCxJQUFJLEdBQUc1USxPQUFPLEdBQUdpVixlQUFlMU07SUFDaEMsSUFBSyxJQUFJMUgsSUFBSSxHQUFHQSxJQUFJeUcsTUFBTXhHLE1BQU0sRUFBRUQsSUFBSztRQUNyQzZJLE1BQU0sQ0FBQzFKLE9BQU8sQ0FBQ3NILEtBQUssQ0FBQ3pHLEVBQUU7SUFDekI7SUFDQTZJLE9BQU9tSCxJQUFJO0FBQ2I7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsNlFBQTZRLEdBQzdRLFNBQVMwSDtJQUNQLE9BQU8zYSxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUdrTywyQkFBMkI7UUFDaEVsTSxjQUFhTixPQUFPLEVBQUVJLE1BQU0sRUFBRXBCLE9BQU87WUFDbkMsTUFBTUMsT0FBT2UsUUFBUXRCLE9BQU87WUFDNUIsS0FBSyxNQUFNcU8sU0FBUzlOLEtBQUtpQyxNQUFNLENBQUNnTyxRQUFRLEdBQUk7Z0JBQzFDLElBQUlsUixPQUNGLGlGQUFpRjtnQkFDakZrUCxXQUFXSCxNQUFNRyxRQUFRLEVBQ3pCeFAsWUFBWXFQLE1BQU1yUCxTQUFTO2dCQUM3QixJQUFJcVAsTUFBTUksS0FBSyxFQUFFO29CQUNmLE1BQU1BLFFBQVFuTixPQUFPLENBQUMrTSxNQUFNSSxLQUFLLENBQUN6UCxTQUFTLENBQUM7b0JBQzVDLElBQUl5UCxNQUFNQyxJQUFJLEtBQUsxUCxXQUFXO3dCQUM1QixVQUFVLDhCQUE4QjtvQkFDMUM7b0JBQ0FNLFFBQVFtUCxNQUFNblAsS0FBSztnQkFDckIsT0FBTztvQkFDTEEsUUFBUWdDLE9BQU8sQ0FBQ3RDLFVBQVU7Z0JBQzVCO2dCQUNBLE9BQVFxUCxNQUFNTSxJQUFJO29CQUNoQixLQUFLO29CQUNMLEtBQUs7d0JBQ0gsSUFBSUMsYUFBYVAsTUFBTU0sSUFBSSxJQUFJLFNBQVN2TCxXQUFXa0osS0FBSyxHQUFHK0IsTUFBTVEsQ0FBQzt3QkFDbEUsSUFBSUwsVUFBVTs0QkFDWixJQUFJSCxNQUFNb0MsTUFBTSxFQUFFO2dDQUNoQkgsWUFBWTVPLFFBQVFrTixZQUFZUCxNQUFNdFAsRUFBRSxFQUFFTzs0QkFDNUMsT0FBTztnQ0FDTCxLQUFLLE1BQU1vUixRQUFRcFIsTUFBTztvQ0FDeEI2USxjQUFjek8sUUFBUWtOLFlBQVlQLE1BQU10UCxFQUFFLEVBQUUyUixNQUFNO2dDQUNwRDs0QkFDRjt3QkFDRixPQUFPOzRCQUNMLElBQUlwUixVQUFVN0csV0FBVztnQ0FDdkIwWCxjQUFjek8sUUFBUWtOLFlBQVlQLE1BQU10UCxFQUFFLEVBQUVPLE9BQU8sQ0FBQyxDQUFDK08sTUFBTUksS0FBSyxJQUFJSixNQUFNelAsR0FBRzs0QkFDL0U7d0JBQ0Y7d0JBQ0E7b0JBQ0YsS0FBSzt3QkFDSCxJQUFJNFAsVUFBVTs0QkFDWixLQUFLLE1BQU1rQyxRQUFRcFIsTUFBTztnQ0FDeEI4USxrQkFBa0IxTyxRQUFRcEIsU0FBUytOLE1BQU1RLENBQUMsRUFBRVIsTUFBTXRQLEVBQUUsRUFBRTJSOzRCQUN4RDt3QkFDRixPQUFPOzRCQUNMTixrQkFBa0IxTyxRQUFRcEIsU0FBUytOLE1BQU1RLENBQUMsRUFBRVIsTUFBTXRQLEVBQUUsRUFBRU87d0JBQ3hEO3dCQUNBO29CQUNGLEtBQUs7d0JBQ0gsS0FBSyxNQUFNLENBQUNtUSxLQUFLQyxJQUFJLElBQUk5WixPQUFPdUcsT0FBTyxDQUFDbUQsT0FBUTs0QkFDOUMwUSxjQUFjdE8sUUFBUXBCLFNBQVMrTixPQUFPb0IsS0FBS0M7d0JBQzdDO3dCQUNBO2dCQUNKO1lBQ0Y7WUFDQSxJQUFJcFAsUUFBUXFOLGtCQUFrQixFQUFFO2dCQUM5QixJQUFJLENBQUNBLGtCQUFrQixDQUFDck0sU0FBU0k7WUFDbkM7WUFDQSxPQUFPQTtRQUNUO0lBQ0Y7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQywrR0FBK0csR0FDL0csNkNBQTZDO0FBQzdDLElBQUlpUCxXQUFXLG1FQUFtRUMsS0FBSyxDQUFDO0FBQ3hGLHFGQUFxRjtBQUNyRixJQUFJQyxXQUFXLEVBQUU7QUFDakIsSUFBSyxJQUFJaFksSUFBSSxHQUFHQSxJQUFJOFgsU0FBUzdYLE1BQU0sRUFBRUQsSUFBS2dZLFFBQVEsQ0FBQ0YsUUFBUSxDQUFDOVgsRUFBRSxDQUFDaVksVUFBVSxDQUFDLEdBQUcsR0FBR2pZO0FBQ2hGLDZCQUE2QjtBQUM3QmdZLFFBQVEsQ0FBQyxJQUFJQyxVQUFVLENBQUMsR0FBRyxHQUFHSCxTQUFTdFcsT0FBTyxDQUFDO0FBQy9Dd1csUUFBUSxDQUFDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEdBQUdILFNBQVN0VyxPQUFPLENBQUM7QUFDL0MsTUFBTTBXLGNBQWM7SUFDbEI7Ozs7Ozs7Ozs7R0FVQyxHQUNEeE0sS0FBSXlNLFNBQVM7UUFDWCxzRUFBc0U7UUFDdEUsSUFBSUMsS0FBS0QsVUFBVWxZLE1BQU0sR0FBRyxJQUFJO1FBQ2hDLElBQUlrWSxTQUFTLENBQUNBLFVBQVVsWSxNQUFNLEdBQUcsRUFBRSxJQUFJLEtBQUttWSxNQUFNO2FBQU8sSUFBSUQsU0FBUyxDQUFDQSxVQUFVbFksTUFBTSxHQUFHLEVBQUUsSUFBSSxLQUFLbVksTUFBTTtRQUMzRyxJQUFJNVEsUUFBUSxJQUFJbUksV0FBV3lJLEtBQ3pCQyxVQUFVLEdBQ1YseUJBQXlCO1FBQ3pCQyxXQUFXLEdBQ1gsMkJBQTJCO1FBQzNCbE8sR0FDQSxlQUFlO1FBQ2ZtTyxJQUFJLEdBQUcsZ0JBQWdCO1FBQ3pCLElBQUssSUFBSXZZLElBQUksR0FBR0EsSUFBSW1ZLFVBQVVsWSxNQUFNLEVBQUVELElBQUs7WUFDekNvSyxJQUFJNE4sUUFBUSxDQUFDRyxVQUFVRixVQUFVLENBQUNqWSxHQUFHO1lBQ3JDLElBQUlvSyxNQUFNeEssV0FBVztnQkFDbkIsT0FBUXVZLFNBQVMsQ0FBQ25ZLEVBQUU7b0JBQ2xCLGdEQUFnRDtvQkFDaEQsS0FBSzt3QkFDSHNZLFdBQVc7b0JBQ2IsaUNBQWlDO29CQUNqQyxnREFBZ0Q7b0JBQ2hELEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0g7b0JBQ0YsZ0NBQWdDO29CQUNoQzt3QkFDRSxNQUFNNVQsTUFBTTtnQkFDaEI7WUFDRjtZQUNBLE9BQVE0VDtnQkFDTixLQUFLO29CQUNIQyxJQUFJbk87b0JBQ0prTyxXQUFXO29CQUNYO2dCQUNGLEtBQUs7b0JBQ0g5USxLQUFLLENBQUM2USxVQUFVLEdBQUdFLEtBQUssSUFBSSxDQUFDbk8sSUFBSSxFQUFDLEtBQU07b0JBQ3hDbU8sSUFBSW5PO29CQUNKa08sV0FBVztvQkFDWDtnQkFDRixLQUFLO29CQUNIOVEsS0FBSyxDQUFDNlEsVUFBVSxHQUFHLENBQUNFLElBQUksRUFBQyxLQUFNLElBQUksQ0FBQ25PLElBQUksRUFBQyxLQUFNO29CQUMvQ21PLElBQUluTztvQkFDSmtPLFdBQVc7b0JBQ1g7Z0JBQ0YsS0FBSztvQkFDSDlRLEtBQUssQ0FBQzZRLFVBQVUsR0FBRyxDQUFDRSxJQUFJLE1BQU0sSUFBSW5PO29CQUNsQ2tPLFdBQVc7b0JBQ1g7WUFDSjtRQUNGO1FBQ0EsSUFBSUEsWUFBWSxHQUFHLE1BQU01VCxNQUFNO1FBQy9CLE9BQU84QyxNQUFNbUwsUUFBUSxDQUFDLEdBQUcwRjtJQUMzQjtJQUNBOztHQUVDLEdBQ0R4SixLQUFJckgsS0FBSztRQUNQLElBQUlnUixTQUFTLElBQ1hGLFdBQVcsR0FDWCwyQkFBMkI7UUFDM0JsTyxHQUNBLGVBQWU7UUFDZm1PLElBQUksR0FBRyxnQ0FBZ0M7UUFDekMsSUFBSyxJQUFJdlksSUFBSSxHQUFHQSxJQUFJd0gsTUFBTXZILE1BQU0sRUFBRUQsSUFBSztZQUNyQ29LLElBQUk1QyxLQUFLLENBQUN4SCxFQUFFO1lBQ1osT0FBUXNZO2dCQUNOLEtBQUs7b0JBQ0hFLFVBQVVWLFFBQVEsQ0FBQzFOLEtBQUssRUFBRTtvQkFDMUJtTyxJQUFJLENBQUNuTyxJQUFJLE1BQU07b0JBQ2ZrTyxXQUFXO29CQUNYO2dCQUNGLEtBQUs7b0JBQ0hFLFVBQVVWLFFBQVEsQ0FBQ1MsSUFBSW5PLEtBQUssRUFBRTtvQkFDOUJtTyxJQUFJLENBQUNuTyxJQUFJLEVBQUMsS0FBTTtvQkFDaEJrTyxXQUFXO29CQUNYO2dCQUNGLEtBQUs7b0JBQ0hFLFVBQVVWLFFBQVEsQ0FBQ1MsSUFBSW5PLEtBQUssRUFBRTtvQkFDOUJvTyxVQUFVVixRQUFRLENBQUMxTixJQUFJLEdBQUc7b0JBQzFCa08sV0FBVztvQkFDWDtZQUNKO1FBQ0Y7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUEsVUFBVTtZQUNaRSxVQUFVVixRQUFRLENBQUNTLEVBQUU7WUFDckJDLFVBQVU7WUFDVixJQUFJRixZQUFZLEdBQUdFLFVBQVU7UUFDL0I7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsZ1JBQWdSLEdBQ2hSLG9DQUFvQztBQUNwQyxNQUFNQyxtQkFBbUI7SUFDdkJDLHFCQUFxQjtBQUN2QjtBQUNBLDJDQUEyQztBQUMzQyxNQUFNQyxvQkFBb0I7SUFDeEJwUCxtQkFBbUI7SUFDbkJxUCxlQUFlO0lBQ2ZDLG1CQUFtQjtJQUNuQnhQLGNBQWM7QUFDaEI7QUFDQSxTQUFTeEIsZ0JBQWdCSixPQUFPO0lBQzlCLE9BQU9BLFVBQVUxSyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcwUixtQkFBbUJoUixXQUFXZ1I7QUFDakY7QUFDQSxTQUFTN1AsaUJBQWlCbkIsT0FBTztJQUMvQixPQUFPQSxVQUFVMUssT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHNFIsb0JBQW9CbFIsV0FBV2tSO0FBQ2xGO0FBQ0EsU0FBU0cscUJBQXFCQyxjQUFjO0lBQzFDLE1BQU1DLGFBQWFELGVBQWVFLFdBQVdDO0lBQzdDLE9BQU87UUFDTHJSO1FBQ0FlO1FBQ0FkLGFBQVlKLElBQUksRUFBRVMsSUFBSSxFQUFFVixPQUFPLEVBQUVnQixPQUFPO1lBQ3RDLElBQUlOLFFBQVEsUUFBUXRMLE1BQU1DLE9BQU8sQ0FBQ3FMLFNBQVMsT0FBT0EsUUFBUSxVQUFVO2dCQUNsRSxNQUFNLElBQUl6RCxNQUFNLHlCQUF5QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSxnQkFBZ0IyQyxNQUFNLENBQUMsSUFBSSxDQUFDckksS0FBSyxDQUFDZ0k7WUFDbkc7WUFDQU0sVUFBVUEsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVSxJQUFJZjtZQUNqRSxNQUFNeVIsWUFBWSxDQUFDO1lBQ25CLEtBQUssTUFBTSxDQUFDQyxTQUFTbFIsVUFBVSxJQUFJbkwsT0FBT3VHLE9BQU8sQ0FBQzZFLE1BQU87Z0JBQ3ZELE1BQU1xTixRQUFROU4sS0FBS2lDLE1BQU0sQ0FBQzBQLFlBQVksQ0FBQ0Q7Z0JBQ3ZDLElBQUksQ0FBQzVELE9BQU87b0JBQ1YsSUFBSSxDQUFDL04sUUFBUWlSLG1CQUFtQixFQUFFO3dCQUNoQyxNQUFNLElBQUloVSxNQUFNLHlCQUF5QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSxxQkFBc0IyQyxNQUFNLENBQUM0USxTQUFTO29CQUN2RztvQkFDQTtnQkFDRjtnQkFDQSxJQUFJalQsWUFBWXFQLE1BQU1yUCxTQUFTO2dCQUMvQixJQUFJdVAsU0FBU2pOO2dCQUNiLElBQUkrTSxNQUFNSSxLQUFLLEVBQUU7b0JBQ2YsSUFBSTFOLGNBQWMsUUFBUXNOLE1BQU1NLElBQUksSUFBSSxVQUFVO3dCQUVoRDtvQkFDRjtvQkFDQSxNQUFNd0QsT0FBT0gsU0FBUyxDQUFDM0QsTUFBTUksS0FBSyxDQUFDelAsU0FBUyxDQUFDO29CQUM3QyxJQUFJbVQsTUFBTTt3QkFDUixNQUFNLElBQUk1VSxNQUFNLHlCQUF5QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSx5Q0FBMEMyQyxNQUFNLENBQUNnTixNQUFNSSxLQUFLLENBQUNyVixJQUFJLEVBQUUsZ0JBQWtCaUksTUFBTSxDQUFDOFEsTUFBTSxRQUFVOVEsTUFBTSxDQUFDNFEsU0FBUztvQkFDN0w7b0JBQ0FELFNBQVMsQ0FBQzNELE1BQU1JLEtBQUssQ0FBQ3pQLFNBQVMsQ0FBQyxHQUFHaVQ7b0JBQ25DMUQsU0FBU0EsTUFBTSxDQUFDRixNQUFNSSxLQUFLLENBQUN6UCxTQUFTLENBQUMsR0FBRzt3QkFDdkMwUCxNQUFNMVA7b0JBQ1I7b0JBQ0FBLFlBQVk7Z0JBQ2Q7Z0JBQ0EsSUFBSXFQLE1BQU1HLFFBQVEsRUFBRTtvQkFDbEIsSUFBSXpOLGNBQWMsTUFBTTt3QkFDdEI7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDckwsTUFBTUMsT0FBTyxDQUFDb0wsWUFBWTt3QkFDN0IsTUFBTSxJQUFJeEQsTUFBTSx1QkFBdUI4RCxNQUFNLENBQUNkLEtBQUs3QixRQUFRLEVBQUUsS0FBSzJDLE1BQU0sQ0FBQ2dOLE1BQU1qVixJQUFJLEVBQUUsZ0JBQWdCaUksTUFBTSxDQUFDLElBQUksQ0FBQ3JJLEtBQUssQ0FBQytIO29CQUN6SDtvQkFDQSxNQUFNcVIsY0FBYzdELE1BQU0sQ0FBQ3ZQLFVBQVU7b0JBQ3JDLEtBQUssTUFBTXFULFlBQVl0UixVQUFXO3dCQUNoQyxJQUFJc1IsYUFBYSxNQUFNOzRCQUNyQixNQUFNLElBQUk5VSxNQUFNLHVCQUF1QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSxLQUFLMkMsTUFBTSxDQUFDZ04sTUFBTWpWLElBQUksRUFBRSxnQkFBZ0JpSSxNQUFNLENBQUMsSUFBSSxDQUFDckksS0FBSyxDQUFDcVo7d0JBQ3pIO3dCQUNBLElBQUkzQzt3QkFDSixrSEFBa0g7d0JBQ2xILE9BQVFyQixNQUFNTSxJQUFJOzRCQUNoQixLQUFLO2dDQUNIZSxNQUFNckIsTUFBTVEsQ0FBQyxDQUFDL04sUUFBUSxDQUFDdVIsVUFBVS9SO2dDQUNqQzs0QkFDRixLQUFLO2dDQUNIb1AsTUFBTTRDLFNBQVNqRSxNQUFNUSxDQUFDLEVBQUV3RCxVQUFVL1IsUUFBUWlSLG1CQUFtQjtnQ0FDN0QsSUFBSTdCLFFBQVFqWCxXQUFXO2dDQUN2Qjs0QkFDRixLQUFLO2dDQUNILElBQUk7b0NBQ0ZpWCxNQUFNNkMsV0FBV2xFLE1BQU1RLENBQUMsRUFBRXdELFVBQVVoRSxNQUFNVyxDQUFDO2dDQUM3QyxFQUFFLE9BQU92WixHQUFHO29DQUNWLElBQUlGLElBQUksdUJBQXVCOEwsTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLEtBQUsyQyxNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGdCQUFnQmlJLE1BQU0sQ0FBQyxJQUFJLENBQUNySSxLQUFLLENBQUNxWjtvQ0FDL0csSUFBSTVjLGFBQWE4SCxTQUFTOUgsRUFBRTZMLE9BQU8sQ0FBQ3hJLE1BQU0sR0FBRyxHQUFHO3dDQUM5Q3ZELEtBQUssS0FBSzhMLE1BQU0sQ0FBQzVMLEVBQUU2TCxPQUFPO29DQUM1QjtvQ0FDQSxNQUFNLElBQUkvRCxNQUFNaEk7Z0NBQ2xCO2dDQUNBO3dCQUNKO3dCQUNBNmMsWUFBWTVTLElBQUksQ0FBQ2tRO29CQUNuQjtnQkFDRixPQUFPLElBQUlyQixNQUFNTSxJQUFJLElBQUksT0FBTztvQkFDOUIsSUFBSTVOLGNBQWMsTUFBTTt3QkFDdEI7b0JBQ0Y7b0JBQ0EsSUFBSXJMLE1BQU1DLE9BQU8sQ0FBQ29MLGNBQWMsT0FBT0EsYUFBYSxVQUFVO3dCQUM1RCxNQUFNLElBQUl4RCxNQUFNLHVCQUF1QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSxLQUFLMkMsTUFBTSxDQUFDZ04sTUFBTWpWLElBQUksRUFBRSxnQkFBZ0JpSSxNQUFNLENBQUMsSUFBSSxDQUFDckksS0FBSyxDQUFDK0g7b0JBQ3pIO29CQUNBLE1BQU15UixZQUFZakUsTUFBTSxDQUFDdlAsVUFBVTtvQkFDbkMsS0FBSyxNQUFNLENBQUN5VCxZQUFZQyxhQUFhLElBQUk5YyxPQUFPdUcsT0FBTyxDQUFDNEUsV0FBWTt3QkFDbEUsSUFBSTJSLGlCQUFpQixNQUFNOzRCQUN6QixNQUFNLElBQUluVixNQUFNLHVCQUF1QjhELE1BQU0sQ0FBQ2QsS0FBSzdCLFFBQVEsRUFBRSxLQUFLMkMsTUFBTSxDQUFDZ04sTUFBTWpWLElBQUksRUFBRTt3QkFDdkY7d0JBQ0EsSUFBSXNXO3dCQUNKLE9BQVFyQixNQUFNdUIsQ0FBQyxDQUFDakIsSUFBSTs0QkFDbEIsS0FBSztnQ0FDSGUsTUFBTXJCLE1BQU11QixDQUFDLENBQUNmLENBQUMsQ0FBQy9OLFFBQVEsQ0FBQzRSLGNBQWNwUztnQ0FDdkM7NEJBQ0YsS0FBSztnQ0FDSG9QLE1BQU00QyxTQUFTakUsTUFBTXVCLENBQUMsQ0FBQ2YsQ0FBQyxFQUFFNkQsY0FBY3BTLFFBQVFpUixtQkFBbUI7Z0NBQ25FLElBQUk3QixRQUFRalgsV0FBVztnQ0FDdkI7NEJBQ0YsS0FBSztnQ0FDSCxJQUFJO29DQUNGaVgsTUFBTTZDLFdBQVdsRSxNQUFNdUIsQ0FBQyxDQUFDZixDQUFDLEVBQUU2RCxjQUFjclAsU0FBU3lNLE1BQU07Z0NBQzNELEVBQUUsT0FBT3JhLEdBQUc7b0NBQ1YsSUFBSUYsSUFBSSxxQ0FBcUM4TCxNQUFNLENBQUNkLEtBQUs3QixRQUFRLEVBQUUsS0FBSzJDLE1BQU0sQ0FBQ2dOLE1BQU1qVixJQUFJLEVBQUUsZ0JBQWdCaUksTUFBTSxDQUFDLElBQUksQ0FBQ3JJLEtBQUssQ0FBQytIO29DQUM3SCxJQUFJdEwsYUFBYThILFNBQVM5SCxFQUFFNkwsT0FBTyxDQUFDeEksTUFBTSxHQUFHLEdBQUc7d0NBQzlDdkQsS0FBSyxLQUFLOEwsTUFBTSxDQUFDNUwsRUFBRTZMLE9BQU87b0NBQzVCO29DQUNBLE1BQU0sSUFBSS9ELE1BQU1oSTtnQ0FDbEI7Z0NBQ0E7d0JBQ0o7d0JBQ0EsSUFBSTs0QkFDRmlkLFNBQVMsQ0FBQ0QsV0FBV2xFLE1BQU1zQixDQUFDLEVBQUV0QixNQUFNc0IsQ0FBQyxJQUFJdk0sV0FBV29KLElBQUksR0FBR2lHLGNBQWMsU0FBUyxPQUFPQSxjQUFjLFVBQVUsUUFBUUEsYUFBYUEsWUFBWXBQLFNBQVN5TSxNQUFNLEVBQUVoSyxRQUFRLEdBQUcsR0FBRzRKO3dCQUNuTCxFQUFFLE9BQU9qYSxHQUFHOzRCQUNWLElBQUlGLElBQUksbUNBQW1DOEwsTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLEtBQUsyQyxNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGdCQUFnQmlJLE1BQU0sQ0FBQyxJQUFJLENBQUNySSxLQUFLLENBQUMrSDs0QkFDM0gsSUFBSXRMLGFBQWE4SCxTQUFTOUgsRUFBRTZMLE9BQU8sQ0FBQ3hJLE1BQU0sR0FBRyxHQUFHO2dDQUM5Q3ZELEtBQUssS0FBSzhMLE1BQU0sQ0FBQzVMLEVBQUU2TCxPQUFPOzRCQUM1Qjs0QkFDQSxNQUFNLElBQUkvRCxNQUFNaEk7d0JBQ2xCO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wsT0FBUThZLE1BQU1NLElBQUk7d0JBQ2hCLEtBQUs7NEJBQ0gsTUFBTVEsY0FBY2QsTUFBTVEsQ0FBQzs0QkFDM0IsSUFBSTlOLGNBQWMsUUFBUW9PLFlBQVl6USxRQUFRLElBQUkseUJBQXlCO2dDQUN6RSxJQUFJMlAsTUFBTUksS0FBSyxFQUFFO29DQUNmLE1BQU0sSUFBSWxSLE1BQU0sdUJBQXVCOEQsTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLEtBQUsyQyxNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGlEQUFrRGlJLE1BQU0sQ0FBQzRRLFNBQVM7Z0NBQ3pKO2dDQUNBOzRCQUNGOzRCQUNBLElBQUkxRCxNQUFNLENBQUN2UCxVQUFVLFlBQVlhLFNBQVM7Z0NBQ3hDME8sTUFBTSxDQUFDdlAsVUFBVSxDQUFDOEIsUUFBUSxDQUFDQyxXQUFXVDs0QkFDeEMsT0FBTztnQ0FDTGlPLE1BQU0sQ0FBQ3ZQLFVBQVUsR0FBR21RLFlBQVlyTyxRQUFRLENBQUNDLFdBQVdUO2dDQUNwRCxJQUFJNk8sWUFBWWxELFlBQVksSUFBSSxDQUFDb0MsTUFBTUksS0FBSyxFQUFFO29DQUM1Q0YsTUFBTSxDQUFDdlAsVUFBVSxHQUFHbVEsWUFBWWxELFlBQVksQ0FBQ29ELFdBQVcsQ0FBQ2QsTUFBTSxDQUFDdlAsVUFBVTtnQ0FDNUU7NEJBQ0Y7NEJBQ0E7d0JBQ0YsS0FBSzs0QkFDSCxNQUFNMlQsWUFBWUwsU0FBU2pFLE1BQU1RLENBQUMsRUFBRTlOLFdBQVdULFFBQVFpUixtQkFBbUI7NEJBQzFFLElBQUlvQixjQUFjbGEsV0FBVztnQ0FDM0I4VixNQUFNLENBQUN2UCxVQUFVLEdBQUcyVDs0QkFDdEI7NEJBQ0E7d0JBQ0YsS0FBSzs0QkFDSCxJQUFJO2dDQUNGcEUsTUFBTSxDQUFDdlAsVUFBVSxHQUFHdVQsV0FBV2xFLE1BQU1RLENBQUMsRUFBRTlOLFdBQVdzTixNQUFNVyxDQUFDOzRCQUM1RCxFQUFFLE9BQU92WixHQUFHO2dDQUNWLElBQUlGLElBQUksdUJBQXVCOEwsTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLEtBQUsyQyxNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGdCQUFnQmlJLE1BQU0sQ0FBQyxJQUFJLENBQUNySSxLQUFLLENBQUMrSDtnQ0FDL0csSUFBSXRMLGFBQWE4SCxTQUFTOUgsRUFBRTZMLE9BQU8sQ0FBQ3hJLE1BQU0sR0FBRyxHQUFHO29DQUM5Q3ZELEtBQUssS0FBSzhMLE1BQU0sQ0FBQzVMLEVBQUU2TCxPQUFPO2dDQUM1QjtnQ0FDQSxNQUFNLElBQUkvRCxNQUFNaEk7NEJBQ2xCOzRCQUNBO29CQUNKO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPK0w7UUFDVDtRQUNBTSxjQUFhTixPQUFPLEVBQUVoQixPQUFPO1lBQzNCLE1BQU1DLE9BQU9lLFFBQVF0QixPQUFPO1lBQzVCLE1BQU1nQixPQUFPLENBQUM7WUFDZCxJQUFJcU47WUFDSixJQUFJO2dCQUNGLEtBQUssTUFBTXVFLFVBQVVyUyxLQUFLaUMsTUFBTSxDQUFDcVEsUUFBUSxHQUFJO29CQUMzQyxJQUFJOVI7b0JBQ0osSUFBSTZSLE9BQU9qRSxJQUFJLElBQUksU0FBUzt3QkFDMUIsTUFBTUYsUUFBUW5OLE9BQU8sQ0FBQ3NSLE9BQU81VCxTQUFTLENBQUM7d0JBQ3ZDLElBQUl5UCxNQUFNblAsS0FBSyxLQUFLN0csV0FBVzs0QkFDN0I7d0JBQ0Y7d0JBQ0E0VixRQUFRdUUsT0FBT0UsU0FBUyxDQUFDckUsTUFBTUMsSUFBSTt3QkFDbkMsSUFBSSxDQUFDTCxPQUFPOzRCQUNWLE1BQU0sMkJBQTJCSSxNQUFNQyxJQUFJO3dCQUM3Qzt3QkFDQTNOLFlBQVk4USxXQUFXeEQsT0FBT0ksTUFBTW5QLEtBQUssRUFBRWdCO29CQUM3QyxPQUFPO3dCQUNMK04sUUFBUXVFO3dCQUNSN1IsWUFBWThRLFdBQVd4RCxPQUFPL00sT0FBTyxDQUFDK00sTUFBTXJQLFNBQVMsQ0FBQyxFQUFFc0I7b0JBQzFEO29CQUNBLElBQUlTLGNBQWN0SSxXQUFXO3dCQUMzQnVJLElBQUksQ0FBQ1YsUUFBUW9SLGlCQUFpQixHQUFHckQsTUFBTWpWLElBQUksR0FBR2lWLE1BQU0wRSxRQUFRLENBQUMsR0FBR2hTO29CQUNsRTtnQkFDRjtZQUNGLEVBQUUsT0FBT3RMLEdBQUc7Z0JBQ1YsTUFBTUYsSUFBSThZLFFBQVEsdUJBQXVCaE4sTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLEtBQUsyQyxNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGNBQWMseUJBQXlCaUksTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFO2dCQUNwSixNQUFNc1UsSUFBSXZkLGFBQWE4SCxRQUFROUgsRUFBRTZMLE9BQU8sR0FBR0MsT0FBTzlMO2dCQUNsRCxNQUFNLElBQUk4SCxNQUFNaEksSUFBS3lkLENBQUFBLEVBQUVsYSxNQUFNLEdBQUcsSUFBSSxLQUFLdUksTUFBTSxDQUFDMlIsS0FBSyxFQUFDO1lBQ3hEO1lBQ0EsT0FBT2hTO1FBQ1Q7UUFDQXVSO1FBQ0FSO1FBQ0EvWSxPQUFPaWE7SUFDVDtBQUNGO0FBQ0EsU0FBU0EsZUFBZWpTLElBQUk7SUFDMUIsSUFBSUEsU0FBUyxNQUFNO1FBQ2pCLE9BQU87SUFDVDtJQUNBLE9BQVEsT0FBT0E7UUFDYixLQUFLO1lBQ0gsT0FBT3RMLE1BQU1DLE9BQU8sQ0FBQ3FMLFFBQVEsVUFBVTtRQUN6QyxLQUFLO1lBQ0gsT0FBT0EsS0FBS2xJLE1BQU0sR0FBRyxNQUFNLFdBQVcsSUFBS3VJLE1BQU0sQ0FBQ0wsS0FBSzRQLEtBQUssQ0FBQyxLQUFLL0gsSUFBSSxDQUFDLFFBQVE7UUFDakY7WUFDRSxPQUFPdEgsT0FBT1A7SUFDbEI7QUFDRjtBQUNBLDZFQUE2RTtBQUM3RSw2Q0FBNkM7QUFDN0MsU0FBU3VSLFdBQVdoUyxJQUFJLEVBQUVTLElBQUksRUFBRWdNLFFBQVE7SUFDdEMsK0RBQStEO0lBQy9ELG9DQUFvQztJQUNwQyxPQUFRek07UUFDTixxSEFBcUg7UUFDckgsOEVBQThFO1FBQzlFLEtBQUs2QyxXQUFXOEksTUFBTTtRQUN0QixLQUFLOUksV0FBVytJLEtBQUs7WUFDbkIsSUFBSW5MLFNBQVMsTUFBTSxPQUFPO1lBQzFCLElBQUlBLFNBQVMsT0FBTyxPQUFPakQsT0FBT21WLEdBQUc7WUFDckMsSUFBSWxTLFNBQVMsWUFBWSxPQUFPakQsT0FBT29WLGlCQUFpQjtZQUN4RCxJQUFJblMsU0FBUyxhQUFhLE9BQU9qRCxPQUFPcVYsaUJBQWlCO1lBQ3pELElBQUlwUyxTQUFTLElBQUk7Z0JBRWY7WUFDRjtZQUNBLElBQUksT0FBT0EsUUFBUSxZQUFZQSxLQUFLcVMsSUFBSSxHQUFHdmEsTUFBTSxLQUFLa0ksS0FBS2xJLE1BQU0sRUFBRTtnQkFFakU7WUFDRjtZQUNBLElBQUksT0FBT2tJLFFBQVEsWUFBWSxPQUFPQSxRQUFRLFVBQVU7Z0JBQ3REO1lBQ0Y7WUFDQSxNQUFNeUksUUFBUTFMLE9BQU9pRDtZQUNyQixJQUFJakQsT0FBT3VWLEtBQUssQ0FBQzdKLFFBQVE7Z0JBRXZCO1lBQ0Y7WUFDQSxJQUFJLENBQUMxTCxPQUFPSSxRQUFRLENBQUNzTCxRQUFRO2dCQUUzQjtZQUNGO1lBQ0EsSUFBSWxKLFFBQVE2QyxXQUFXK0ksS0FBSyxFQUFFak8sY0FBY3VMO1lBQzVDLE9BQU9BO1FBQ1QsdUdBQXVHO1FBQ3ZHLEtBQUtyRyxXQUFXa0osS0FBSztRQUNyQixLQUFLbEosV0FBV2dLLE9BQU87UUFDdkIsS0FBS2hLLFdBQVdpSyxRQUFRO1FBQ3hCLEtBQUtqSyxXQUFXMk0sTUFBTTtRQUN0QixLQUFLM00sV0FBV21KLE1BQU07WUFDcEIsSUFBSXZMLFNBQVMsTUFBTSxPQUFPO1lBQzFCLElBQUlxSTtZQUNKLElBQUksT0FBT3JJLFFBQVEsVUFBVXFJLFFBQVFySTtpQkFBVSxJQUFJLE9BQU9BLFFBQVEsWUFBWUEsS0FBS2xJLE1BQU0sR0FBRyxHQUFHO2dCQUM3RixJQUFJa0ksS0FBS3FTLElBQUksR0FBR3ZhLE1BQU0sS0FBS2tJLEtBQUtsSSxNQUFNLEVBQUV1USxRQUFRdEwsT0FBT2lEO1lBQ3pEO1lBQ0EsSUFBSXFJLFVBQVU1USxXQUFXO1lBQ3pCLElBQUk4SCxRQUFRNkMsV0FBV21KLE1BQU0sRUFBRXRPLGFBQWFvTDtpQkFBWXhMLFlBQVl3TDtZQUNwRSxPQUFPQTtRQUNULHVHQUF1RztRQUN2RyxLQUFLakcsV0FBV2dKLEtBQUs7UUFDckIsS0FBS2hKLFdBQVd5SixRQUFRO1FBQ3hCLEtBQUt6SixXQUFXMEosTUFBTTtZQUNwQixJQUFJOUwsU0FBUyxNQUFNLE9BQU9pSCxXQUFXWCxJQUFJO1lBQ3pDLElBQUksT0FBT3RHLFFBQVEsWUFBWSxPQUFPQSxRQUFRLFVBQVU7WUFDeEQsTUFBTXVTLE9BQU90TCxXQUFXN0csS0FBSyxDQUFDSjtZQUM5Qix5RUFBeUU7WUFDekUsT0FBT2dNLFdBQVd1RyxLQUFLek4sUUFBUSxLQUFLeU47UUFDdEMsS0FBS25RLFdBQVd3SixPQUFPO1FBQ3ZCLEtBQUt4SixXQUFXaUosTUFBTTtZQUNwQixJQUFJckwsU0FBUyxNQUFNLE9BQU9pSCxXQUFXWCxJQUFJO1lBQ3pDLElBQUksT0FBT3RHLFFBQVEsWUFBWSxPQUFPQSxRQUFRLFVBQVU7WUFDeEQsTUFBTXdTLFFBQVF2TCxXQUFXUixNQUFNLENBQUN6RztZQUNoQyx5RUFBeUU7WUFDekUsT0FBT2dNLFdBQVd3RyxNQUFNMU4sUUFBUSxLQUFLME47UUFDdkMsUUFBUTtRQUNSLEtBQUtwUSxXQUFXb0osSUFBSTtZQUNsQixJQUFJeEwsU0FBUyxNQUFNLE9BQU87WUFDMUIsSUFBSSxPQUFPQSxTQUFTLFdBQVc7WUFDL0IsT0FBT0E7UUFDVCxVQUFVO1FBQ1YsS0FBS29DLFdBQVdxSixNQUFNO1lBQ3BCLElBQUl6TCxTQUFTLE1BQU0sT0FBTztZQUMxQixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDNUI7WUFDRjtZQUNBLDZEQUE2RDtZQUM3RCxnR0FBZ0c7WUFDaEcsSUFBSTtnQkFDRi9HLG1CQUFtQitHO1lBQ3JCLEVBQUUsT0FBT3ZMLEdBQUc7Z0JBQ1YsTUFBTSxJQUFJOEgsTUFBTTtZQUNsQjtZQUNBLE9BQU95RDtRQUNULHVHQUF1RztRQUN2RyxrRkFBa0Y7UUFDbEYsS0FBS29DLFdBQVdzSixLQUFLO1lBQ25CLElBQUkxTCxTQUFTLFFBQVFBLFNBQVMsSUFBSSxPQUFPLElBQUl3SCxXQUFXO1lBQ3hELElBQUksT0FBT3hILFNBQVMsVUFBVTtZQUM5QixPQUFPK1AsWUFBWXhNLEdBQUcsQ0FBQ3ZEO0lBQzNCO0lBQ0EsTUFBTSxJQUFJekQ7QUFDWjtBQUNBLFNBQVMrVSxTQUFTL1IsSUFBSSxFQUFFUyxJQUFJLEVBQUV1USxtQkFBbUI7SUFDL0MsSUFBSXZRLFNBQVMsTUFBTTtRQUNqQixzREFBc0Q7UUFDdEQsT0FBTztJQUNUO0lBQ0EsMEVBQTBFO0lBQzFFLE9BQVEsT0FBT0E7UUFDYixLQUFLO1lBQ0gsSUFBSWpELE9BQU9DLFNBQVMsQ0FBQ2dELE9BQU87Z0JBQzFCLE9BQU9BO1lBQ1Q7WUFDQTtRQUNGLEtBQUs7WUFDSCxNQUFNMUIsUUFBUWlCLEtBQUtkLFFBQVEsQ0FBQ3VCO1lBQzVCLHdFQUF3RTtZQUN4RSxJQUFJMUIsU0FBU2lTLHFCQUFxQjtnQkFDaEMsT0FBT2pTLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNUCxFQUFFO1lBQy9EO1lBQ0E7SUFDSjtJQUNBLE1BQU0sSUFBSXhCLE1BQU0sc0JBQXNCOEQsTUFBTSxDQUFDZCxLQUFLN0IsUUFBUSxFQUFFLGdCQUFnQjJDLE1BQU0sQ0FBQzRSLGVBQWVqUztBQUNwRztBQUNBLFNBQVM4USxVQUFVdlIsSUFBSSxFQUFFakIsS0FBSyxFQUFFK1Esb0JBQW9CLEVBQUVvQixhQUFhO0lBQ2pFLElBQUl6UDtJQUNKLElBQUkxQyxVQUFVN0csV0FBVztRQUN2QixPQUFPNkc7SUFDVDtJQUNBLElBQUlBLFVBQVUsS0FBSyxDQUFDK1Esc0JBQXNCO1FBQ3hDLHNEQUFzRDtRQUN0RCxPQUFPNVg7SUFDVDtJQUNBLElBQUlnWixlQUFlO1FBQ2pCLE9BQU9uUztJQUNUO0lBQ0EsSUFBSWlCLEtBQUs3QixRQUFRLElBQUksNkJBQTZCO1FBQ2hELE9BQU87SUFDVDtJQUNBLE1BQU1nUixNQUFNblAsS0FBS2IsVUFBVSxDQUFDSjtJQUM1QixPQUFPLENBQUMwQyxLQUFLME4sUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUl0VyxJQUFJLE1BQU0sUUFBUTRJLE9BQU8sS0FBSyxJQUFJQSxLQUFLMUMsT0FBTywwREFBMEQ7QUFDcks7QUFDQSxTQUFTeVMsWUFBWXhSLElBQUksRUFBRWpCLEtBQUssRUFBRStRLG9CQUFvQjtJQUNwRCxJQUFJL1EsVUFBVTdHLFdBQVc7UUFDdkIsT0FBT0E7SUFDVDtJQUNBLE9BQVE4SDtRQUNOLHVHQUF1RztRQUN2RyxLQUFLNkMsV0FBV2tKLEtBQUs7UUFDckIsS0FBS2xKLFdBQVdpSyxRQUFRO1FBQ3hCLEtBQUtqSyxXQUFXMk0sTUFBTTtRQUN0QixLQUFLM00sV0FBV2dLLE9BQU87UUFDdkIsS0FBS2hLLFdBQVdtSixNQUFNO1lBQ3BCbFAsT0FBTyxPQUFPaUMsU0FBUztZQUN2QixPQUFPQSxTQUFTLEtBQUsrUSx1QkFBdUIvUSxRQUFRN0c7UUFDdEQscUhBQXFIO1FBQ3JILDhFQUE4RTtRQUM5RSxLQUFLMkssV0FBVytJLEtBQUs7UUFDckIsd0JBQXdCO1FBQ3hCLEtBQUsvSSxXQUFXOEksTUFBTTtZQUNwQixxQ0FBcUM7WUFDckM3TyxPQUFPLE9BQU9pQyxTQUFTO1lBQ3ZCLElBQUl2QixPQUFPdVYsS0FBSyxDQUFDaFUsUUFBUSxPQUFPO1lBQ2hDLElBQUlBLFVBQVV2QixPQUFPb1YsaUJBQWlCLEVBQUUsT0FBTztZQUMvQyxJQUFJN1QsVUFBVXZCLE9BQU9xVixpQkFBaUIsRUFBRSxPQUFPO1lBQy9DLE9BQU85VCxVQUFVLEtBQUsrUSx1QkFBdUIvUSxRQUFRN0c7UUFDdkQsVUFBVTtRQUNWLEtBQUsySyxXQUFXcUosTUFBTTtZQUNwQnBQLE9BQU8sT0FBT2lDLFNBQVM7WUFDdkIsT0FBT0EsTUFBTXhHLE1BQU0sR0FBRyxLQUFLdVgsdUJBQXVCL1EsUUFBUTdHO1FBQzVELFFBQVE7UUFDUixLQUFLMkssV0FBV29KLElBQUk7WUFDbEJuUCxPQUFPLE9BQU9pQyxTQUFTO1lBQ3ZCLE9BQU9BLFNBQVMrUSx1QkFBdUIvUSxRQUFRN0c7UUFDakQsK0VBQStFO1FBQy9FLEtBQUsySyxXQUFXaUosTUFBTTtRQUN0QixLQUFLakosV0FBV3dKLE9BQU87UUFDdkIsS0FBS3hKLFdBQVdnSixLQUFLO1FBQ3JCLEtBQUtoSixXQUFXeUosUUFBUTtRQUN4QixLQUFLekosV0FBVzBKLE1BQU07WUFDcEJ6UCxPQUFPLE9BQU9pQyxTQUFTLFlBQVksT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVM7WUFDL0Usd0VBQXdFO1lBQ3hFLDZEQUE2RDtZQUM3RCxhQUFhO1lBQ2IsT0FBTytRLHdCQUF3Qi9RLFNBQVMsSUFBSUEsTUFBTXdHLFFBQVEsQ0FBQyxNQUFNck47UUFDbkUsdUdBQXVHO1FBQ3ZHLGtGQUFrRjtRQUNsRixLQUFLMkssV0FBV3NKLEtBQUs7WUFDbkJyUCxPQUFPaUMsaUJBQWlCa0o7WUFDeEIsT0FBTzZILHdCQUF3Qi9RLE1BQU11QixVQUFVLEdBQUcsSUFBSWtRLFlBQVlySixHQUFHLENBQUNwSSxTQUFTN0c7SUFDbkY7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxvVEFBb1QsR0FDcFQsU0FBU2diO0lBQ1AsT0FBTzlCLHFCQUFxQixDQUFDRyxXQUFXQztRQUN0QyxPQUFPLFNBQVNGLFdBQVd4RCxLQUFLLEVBQUUvTyxLQUFLLEVBQUVnQixPQUFPO1lBQzlDLElBQUkrTixNQUFNTSxJQUFJLElBQUksT0FBTztnQkFDdkIsTUFBTStFLFVBQVUsQ0FBQztnQkFDakIsT0FBUXJGLE1BQU11QixDQUFDLENBQUNqQixJQUFJO29CQUNsQixLQUFLO3dCQUNILEtBQUssTUFBTSxDQUFDZ0YsVUFBVUMsV0FBVyxJQUFJaGUsT0FBT3VHLE9BQU8sQ0FBQ21ELE9BQVE7NEJBQzFELE1BQU1vUSxNQUFNcUMsWUFBWTFELE1BQU11QixDQUFDLENBQUNmLENBQUMsRUFBRStFLFlBQVk7NEJBQy9DdlcsT0FBT3FTLFFBQVFqWDs0QkFDZmliLE9BQU8sQ0FBQ0MsU0FBUzdOLFFBQVEsR0FBRyxHQUFHNEosS0FBSyxtRUFBbUU7d0JBQ3pHO3dCQUNBO29CQUNGLEtBQUs7d0JBQ0gsS0FBSyxNQUFNLENBQUNpRSxVQUFVQyxXQUFXLElBQUloZSxPQUFPdUcsT0FBTyxDQUFDbUQsT0FBUTs0QkFDMUQsbUVBQW1FOzRCQUNuRW9VLE9BQU8sQ0FBQ0MsU0FBUzdOLFFBQVEsR0FBRyxHQUFHOE4sV0FBVzlSLE1BQU0sQ0FBQ3hCO3dCQUNuRDt3QkFDQTtvQkFDRixLQUFLO3dCQUNILE1BQU11VCxXQUFXeEYsTUFBTXVCLENBQUMsQ0FBQ2YsQ0FBQzt3QkFDMUIsS0FBSyxNQUFNLENBQUM4RSxVQUFVQyxXQUFXLElBQUloZSxPQUFPdUcsT0FBTyxDQUFDbUQsT0FBUTs0QkFDMURqQyxPQUFPdVcsZUFBZW5iLGFBQWEsT0FBT21iLGNBQWM7NEJBQ3hELE1BQU1sRSxNQUFNb0MsVUFBVStCLFVBQVVELFlBQVksTUFBTXRULFFBQVFtUixhQUFhOzRCQUN2RXBVLE9BQU9xUyxRQUFRalg7NEJBQ2ZpYixPQUFPLENBQUNDLFNBQVM3TixRQUFRLEdBQUcsR0FBRzRKLEtBQUssbUVBQW1FO3dCQUN6Rzt3QkFDQTtnQkFDSjtnQkFDQSxPQUFPcFAsUUFBUThCLGlCQUFpQixJQUFJeE0sT0FBT0MsSUFBSSxDQUFDNmQsU0FBUzVhLE1BQU0sR0FBRyxJQUFJNGEsVUFBVWpiO1lBQ2xGLE9BQU8sSUFBSTRWLE1BQU1HLFFBQVEsRUFBRTtnQkFDekIsTUFBTXNGLFVBQVUsRUFBRTtnQkFDbEIsT0FBUXpGLE1BQU1NLElBQUk7b0JBQ2hCLEtBQUs7d0JBQ0gsSUFBSyxJQUFJOVYsSUFBSSxHQUFHQSxJQUFJeUcsTUFBTXhHLE1BQU0sRUFBRUQsSUFBSzs0QkFDckNpYixRQUFRdFUsSUFBSSxDQUFDdVMsWUFBWTFELE1BQU1RLENBQUMsRUFBRXZQLEtBQUssQ0FBQ3pHLEVBQUUsRUFBRTt3QkFDOUM7d0JBQ0E7b0JBQ0YsS0FBSzt3QkFDSCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSXlHLE1BQU14RyxNQUFNLEVBQUVELElBQUs7NEJBQ3JDaWIsUUFBUXRVLElBQUksQ0FBQ3NTLFVBQVV6RCxNQUFNUSxDQUFDLEVBQUV2UCxLQUFLLENBQUN6RyxFQUFFLEVBQUUsTUFBTXlILFFBQVFtUixhQUFhO3dCQUN2RTt3QkFDQTtvQkFDRixLQUFLO3dCQUNILElBQUssSUFBSTVZLElBQUksR0FBR0EsSUFBSXlHLE1BQU14RyxNQUFNLEVBQUVELElBQUs7NEJBQ3JDaWIsUUFBUXRVLElBQUksQ0FBQ3dNLFVBQVVxQyxNQUFNUSxDQUFDLEVBQUV2UCxLQUFLLENBQUN6RyxFQUFFLEVBQUVpSixNQUFNLENBQUN4Qjt3QkFDbkQ7d0JBQ0E7Z0JBQ0o7Z0JBQ0EsT0FBT0EsUUFBUThCLGlCQUFpQixJQUFJMFIsUUFBUWhiLE1BQU0sR0FBRyxJQUFJZ2IsVUFBVXJiO1lBQ3JFLE9BQU87Z0JBQ0wsT0FBUTRWLE1BQU1NLElBQUk7b0JBQ2hCLEtBQUs7d0JBQ0gsT0FBT29ELFlBQVkxRCxNQUFNUSxDQUFDLEVBQUV2UCxPQUFPLENBQUMsQ0FBQytPLE1BQU1JLEtBQUssSUFBSUosTUFBTXpQLEdBQUcsSUFBSTBCLFFBQVE4QixpQkFBaUI7b0JBQzVGLEtBQUs7d0JBQ0gsT0FBTzBQLFVBQVV6RCxNQUFNUSxDQUFDLEVBQUV2UCxPQUFPLENBQUMsQ0FBQytPLE1BQU1JLEtBQUssSUFBSUosTUFBTXpQLEdBQUcsSUFBSTBCLFFBQVE4QixpQkFBaUIsRUFBRTlCLFFBQVFtUixhQUFhO29CQUNqSCxLQUFLO3dCQUNILE9BQU9uUyxVQUFVN0csWUFBWXVULFVBQVVxQyxNQUFNUSxDQUFDLEVBQUV2UCxPQUFPd0MsTUFBTSxDQUFDeEIsV0FBVzdIO2dCQUM3RTtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLHVPQUF1TyxHQUN2TyxTQUFTc2I7SUFDUCxPQUFPO1FBQ0x0VjtRQUNBb0UsYUFBWW1SLE1BQU0sRUFBRXpGLE1BQU07WUFDeEIsSUFBSXlGLFdBQVd2YixXQUFXO2dCQUN4QjtZQUNGO1lBQ0EsTUFBTThILE9BQU9nTyxPQUFPdk8sT0FBTztZQUMzQixLQUFLLE1BQU00UyxVQUFVclMsS0FBS2lDLE1BQU0sQ0FBQ3FRLFFBQVEsR0FBSTtnQkFDM0MsTUFBTTdULFlBQVk0VCxPQUFPNVQsU0FBUyxFQUNoQ1IsSUFBSStQLFFBQ0o1QyxJQUFJcUk7Z0JBQ04sSUFBSXJJLENBQUMsQ0FBQzNNLFVBQVUsS0FBS3ZHLFdBQVc7b0JBQzlCO2dCQUNGO2dCQUNBLE9BQVFtYSxPQUFPakUsSUFBSTtvQkFDakIsS0FBSzt3QkFDSCxNQUFNc0YsS0FBS3RJLENBQUMsQ0FBQzNNLFVBQVUsQ0FBQzBQLElBQUk7d0JBQzVCLElBQUl1RixPQUFPeGIsV0FBVzs0QkFDcEI7d0JBQ0Y7d0JBQ0EsTUFBTXliLGNBQWN0QixPQUFPRSxTQUFTLENBQUNtQjt3QkFDckMsSUFBSXZFLE1BQU0vRCxDQUFDLENBQUMzTSxVQUFVLENBQUNNLEtBQUs7d0JBQzVCLElBQUk0VSxlQUFlQSxZQUFZdkYsSUFBSSxJQUFJLGFBQWEsQ0FBRWUsQ0FBQUEsZUFBZXdFLFlBQVlyRixDQUFDLEdBQUc7NEJBQ25GYSxNQUFNLElBQUl3RSxZQUFZckYsQ0FBQyxDQUFDYTt3QkFDMUIsT0FBTyxJQUFJd0UsZUFBZUEsWUFBWXZGLElBQUksS0FBSyxZQUFZdUYsWUFBWXJGLENBQUMsS0FBS3pMLFdBQVdzSixLQUFLLEVBQUU7NEJBQzdGZ0QsTUFBTXlFLFFBQVF6RTt3QkFDaEI7d0JBQ0FsUixDQUFDLENBQUNRLFVBQVUsR0FBRzs0QkFDYjBQLE1BQU11Rjs0QkFDTjNVLE9BQU9vUTt3QkFDVDt3QkFDQTtvQkFDRixLQUFLO29CQUNMLEtBQUs7d0JBQ0gsSUFBSTBFLE9BQU96SSxDQUFDLENBQUMzTSxVQUFVO3dCQUN2QixJQUFJNFQsT0FBTy9ELENBQUMsS0FBS3pMLFdBQVdzSixLQUFLLEVBQUU7NEJBQ2pDMEgsT0FBT3hCLE9BQU9wRSxRQUFRLEdBQUc0RixLQUFLNVgsR0FBRyxDQUFDMlgsV0FBV0EsUUFBUUM7d0JBQ3ZEO3dCQUNBNVYsQ0FBQyxDQUFDUSxVQUFVLEdBQUdvVjt3QkFDZjtvQkFDRixLQUFLO3dCQUNILE9BQVF4QixPQUFPaEQsQ0FBQyxDQUFDakIsSUFBSTs0QkFDbkIsS0FBSzs0QkFDTCxLQUFLO2dDQUNILElBQUlpRSxPQUFPaEQsQ0FBQyxDQUFDZixDQUFDLEtBQUt6TCxXQUFXc0osS0FBSyxFQUFFO29DQUNuQyxLQUFLLE1BQU0sQ0FBQzVXLEdBQUdnSixFQUFFLElBQUlsSixPQUFPdUcsT0FBTyxDQUFDd1AsQ0FBQyxDQUFDM00sVUFBVSxFQUFHO3dDQUNqRFIsQ0FBQyxDQUFDUSxVQUFVLENBQUNsSixFQUFFLEdBQUdxZSxRQUFRclY7b0NBQzVCO2dDQUNGLE9BQU87b0NBQ0xsSixPQUFPZ0ssTUFBTSxDQUFDcEIsQ0FBQyxDQUFDUSxVQUFVLEVBQUUyTSxDQUFDLENBQUMzTSxVQUFVO2dDQUMxQztnQ0FDQTs0QkFDRixLQUFLO2dDQUNILE1BQU1tUSxjQUFjeUQsT0FBT2hELENBQUMsQ0FBQ2YsQ0FBQztnQ0FDOUIsS0FBSyxNQUFNL1ksS0FBS0YsT0FBT0MsSUFBSSxDQUFDOFYsQ0FBQyxDQUFDM00sVUFBVSxFQUFHO29DQUN6QyxJQUFJMFEsTUFBTS9ELENBQUMsQ0FBQzNNLFVBQVUsQ0FBQ2xKLEVBQUU7b0NBQ3pCLElBQUksQ0FBQ3FaLFlBQVlsRCxZQUFZLEVBQUU7d0NBQzdCLHVFQUF1RTt3Q0FDdkUsa0VBQWtFO3dDQUNsRXlELE1BQU0sSUFBSVAsWUFBWU87b0NBQ3hCO29DQUNBbFIsQ0FBQyxDQUFDUSxVQUFVLENBQUNsSixFQUFFLEdBQUc0WjtnQ0FDcEI7Z0NBQ0E7d0JBQ0o7d0JBQ0E7b0JBQ0YsS0FBSzt3QkFDSCxNQUFNMkUsS0FBS3pCLE9BQU8vRCxDQUFDO3dCQUNuQixJQUFJK0QsT0FBT3BFLFFBQVEsRUFBRTs0QkFDbkJoUSxDQUFDLENBQUNRLFVBQVUsR0FBRzJNLENBQUMsQ0FBQzNNLFVBQVUsQ0FBQ3hDLEdBQUcsQ0FBQ2tULENBQUFBLE1BQU9BLGVBQWUyRSxLQUFLM0UsTUFBTSxJQUFJMkUsR0FBRzNFO3dCQUMxRSxPQUFPLElBQUkvRCxDQUFDLENBQUMzTSxVQUFVLEtBQUt2RyxXQUFXOzRCQUNyQyxNQUFNaVgsTUFBTS9ELENBQUMsQ0FBQzNNLFVBQVU7NEJBQ3hCLElBQUlxVixHQUFHcEksWUFBWSxFQUFFO2dDQUNuQixJQUNBLHlFQUF5RTtnQ0FDekVvSSxHQUFHM1YsUUFBUSxLQUFLLDhCQUE4QjtvQ0FDNUNGLENBQUMsQ0FBQ1EsVUFBVSxHQUFHbVYsUUFBUXpFO2dDQUN6QixPQUFPO29DQUNMbFIsQ0FBQyxDQUFDUSxVQUFVLEdBQUcwUTtnQ0FDakI7NEJBQ0YsT0FBTztnQ0FDTGxSLENBQUMsQ0FBQ1EsVUFBVSxHQUFHMFEsZUFBZTJFLEtBQUszRSxNQUFNLElBQUkyRSxHQUFHM0U7NEJBQ2xEO3dCQUNGO3dCQUNBO2dCQUNKO1lBQ0Y7UUFDRjtRQUNBNVAsUUFBT1MsSUFBSSxFQUFFeUMsQ0FBQyxFQUFFQyxDQUFDO1lBQ2YsSUFBSUQsTUFBTUMsR0FBRztnQkFDWCxPQUFPO1lBQ1Q7WUFDQSxJQUFJLENBQUNELEtBQUssQ0FBQ0MsR0FBRztnQkFDWixPQUFPO1lBQ1Q7WUFDQSxPQUFPMUMsS0FBS2lDLE1BQU0sQ0FBQ3FRLFFBQVEsR0FBR3lCLEtBQUssQ0FBQy9lLENBQUFBO2dCQUNsQyxNQUFNZ2YsS0FBS3ZSLENBQUMsQ0FBQ3pOLEVBQUV5SixTQUFTLENBQUM7Z0JBQ3pCLE1BQU13VixLQUFLdlIsQ0FBQyxDQUFDMU4sRUFBRXlKLFNBQVMsQ0FBQztnQkFDekIsSUFBSXpKLEVBQUVpWixRQUFRLEVBQUU7b0JBQ2QsSUFBSStGLEdBQUd6YixNQUFNLEtBQUswYixHQUFHMWIsTUFBTSxFQUFFO3dCQUMzQixPQUFPO29CQUNUO29CQUNBLDZHQUE2RztvQkFDN0csT0FBUXZELEVBQUVvWixJQUFJO3dCQUNaLEtBQUs7NEJBQ0gsT0FBTzRGLEdBQUdELEtBQUssQ0FBQyxDQUFDdFIsR0FBR25LLElBQU10RCxFQUFFc1osQ0FBQyxDQUFDL08sTUFBTSxDQUFDa0QsR0FBR3dSLEVBQUUsQ0FBQzNiLEVBQUU7d0JBQy9DLEtBQUs7NEJBQ0gsT0FBTzBiLEdBQUdELEtBQUssQ0FBQyxDQUFDdFIsR0FBR25LLElBQU04VCxhQUFhcFgsRUFBRXNaLENBQUMsRUFBRTdMLEdBQUd3UixFQUFFLENBQUMzYixFQUFFO3dCQUN0RCxLQUFLOzRCQUNILE9BQU8wYixHQUFHRCxLQUFLLENBQUMsQ0FBQ3RSLEdBQUduSyxJQUFNOFQsYUFBYXZKLFdBQVdrSixLQUFLLEVBQUV0SixHQUFHd1IsRUFBRSxDQUFDM2IsRUFBRTtvQkFDckU7b0JBQ0EsTUFBTSxJQUFJMEUsTUFBTSwyQkFBMkI4RCxNQUFNLENBQUM5TCxFQUFFb1osSUFBSTtnQkFDMUQ7Z0JBQ0EsT0FBUXBaLEVBQUVvWixJQUFJO29CQUNaLEtBQUs7d0JBQ0gsT0FBT3BaLEVBQUVzWixDQUFDLENBQUMvTyxNQUFNLENBQUN5VSxJQUFJQztvQkFDeEIsS0FBSzt3QkFDSCxPQUFPN0gsYUFBYXZKLFdBQVdrSixLQUFLLEVBQUVpSSxJQUFJQztvQkFDNUMsS0FBSzt3QkFDSCxPQUFPN0gsYUFBYXBYLEVBQUVzWixDQUFDLEVBQUUwRixJQUFJQztvQkFDL0IsS0FBSzt3QkFDSCxJQUFJRCxHQUFHN0YsSUFBSSxLQUFLOEYsR0FBRzlGLElBQUksRUFBRTs0QkFDdkIsT0FBTzt3QkFDVDt3QkFDQSxNQUFNL0MsSUFBSXBXLEVBQUV1ZCxTQUFTLENBQUN5QixHQUFHN0YsSUFBSTt3QkFDN0IsSUFBSS9DLE1BQU1sVCxXQUFXOzRCQUNuQixPQUFPO3dCQUNUO3dCQUNBLDBHQUEwRzt3QkFDMUcsT0FBUWtULEVBQUVnRCxJQUFJOzRCQUNaLEtBQUs7Z0NBQ0gsT0FBT2hELEVBQUVrRCxDQUFDLENBQUMvTyxNQUFNLENBQUN5VSxHQUFHalYsS0FBSyxFQUFFa1YsR0FBR2xWLEtBQUs7NEJBQ3RDLEtBQUs7Z0NBQ0gsT0FBT3FOLGFBQWF2SixXQUFXa0osS0FBSyxFQUFFaUksR0FBR2pWLEtBQUssRUFBRWtWLEdBQUdsVixLQUFLOzRCQUMxRCxLQUFLO2dDQUNILE9BQU9xTixhQUFhaEIsRUFBRWtELENBQUMsRUFBRTBGLEdBQUdqVixLQUFLLEVBQUVrVixHQUFHbFYsS0FBSzt3QkFDL0M7d0JBQ0EsTUFBTSxJQUFJL0IsTUFBTSx3QkFBd0I4RCxNQUFNLENBQUNzSyxFQUFFZ0QsSUFBSTtvQkFDdkQsS0FBSzt3QkFDSCxNQUFNOVksT0FBT0QsT0FBT0MsSUFBSSxDQUFDMGUsSUFBSWxULE1BQU0sQ0FBQ3pMLE9BQU9DLElBQUksQ0FBQzJlO3dCQUNoRCxPQUFRamYsRUFBRXFhLENBQUMsQ0FBQ2pCLElBQUk7NEJBQ2QsS0FBSztnQ0FDSCxNQUFNUSxjQUFjNVosRUFBRXFhLENBQUMsQ0FBQ2YsQ0FBQztnQ0FDekIsT0FBT2haLEtBQUt5ZSxLQUFLLENBQUN4ZSxDQUFBQSxJQUFLcVosWUFBWXJQLE1BQU0sQ0FBQ3lVLEVBQUUsQ0FBQ3plLEVBQUUsRUFBRTBlLEVBQUUsQ0FBQzFlLEVBQUU7NEJBQ3hELEtBQUs7Z0NBQ0gsT0FBT0QsS0FBS3llLEtBQUssQ0FBQ3hlLENBQUFBLElBQUs2VyxhQUFhdkosV0FBV2tKLEtBQUssRUFBRWlJLEVBQUUsQ0FBQ3plLEVBQUUsRUFBRTBlLEVBQUUsQ0FBQzFlLEVBQUU7NEJBQ3BFLEtBQUs7Z0NBQ0gsTUFBTThZLGFBQWFyWixFQUFFcWEsQ0FBQyxDQUFDZixDQUFDO2dDQUN4QixPQUFPaFosS0FBS3llLEtBQUssQ0FBQ3hlLENBQUFBLElBQUs2VyxhQUFhaUMsWUFBWTJGLEVBQUUsQ0FBQ3plLEVBQUUsRUFBRTBlLEVBQUUsQ0FBQzFlLEVBQUU7d0JBQ2hFO3dCQUNBO2dCQUNKO1lBQ0Y7UUFDRjtRQUNBcUssT0FBTW1CLE9BQU87WUFDWCxNQUFNZixPQUFPZSxRQUFRdEIsT0FBTyxJQUMxQnVPLFNBQVMsSUFBSWhPLFFBQ2JrVSxNQUFNbEc7WUFDUixLQUFLLE1BQU1xRSxVQUFVclMsS0FBS2lDLE1BQU0sQ0FBQ3FRLFFBQVEsR0FBSTtnQkFDM0MsTUFBTW1CLFNBQVMxUyxPQUFPLENBQUNzUixPQUFPNVQsU0FBUyxDQUFDO2dCQUN4QyxJQUFJb1Y7Z0JBQ0osSUFBSXhCLE9BQU9wRSxRQUFRLEVBQUU7b0JBQ25CNEYsT0FBT0osT0FBT3hYLEdBQUcsQ0FBQ2tZO2dCQUNwQixPQUFPLElBQUk5QixPQUFPakUsSUFBSSxJQUFJLE9BQU87b0JBQy9CeUYsT0FBT0ssR0FBRyxDQUFDN0IsT0FBTzVULFNBQVMsQ0FBQztvQkFDNUIsS0FBSyxNQUFNLENBQUN5USxLQUFLM1EsRUFBRSxJQUFJbEosT0FBT3VHLE9BQU8sQ0FBQzZYLFFBQVM7d0JBQzdDSSxJQUFJLENBQUMzRSxJQUFJLEdBQUdpRixtQkFBbUI1VjtvQkFDakM7Z0JBQ0YsT0FBTyxJQUFJOFQsT0FBT2pFLElBQUksSUFBSSxTQUFTO29CQUNqQyxNQUFNVCxJQUFJMEUsT0FBT0UsU0FBUyxDQUFDa0IsT0FBT3RGLElBQUk7b0JBQ3RDMEYsT0FBT2xHLElBQUk7d0JBQ1RRLE1BQU1zRixPQUFPdEYsSUFBSTt3QkFDakJwUCxPQUFPb1YsbUJBQW1CVixPQUFPMVUsS0FBSztvQkFDeEMsSUFBSTt3QkFDRm9QLE1BQU1qVztvQkFDUjtnQkFDRixPQUFPO29CQUNMMmIsT0FBT00sbUJBQW1CVjtnQkFDNUI7Z0JBQ0FTLEdBQUcsQ0FBQzdCLE9BQU81VCxTQUFTLENBQUMsR0FBR29WO1lBQzFCO1lBQ0EsT0FBTzdGO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsZ0dBQWdHO0FBQ2hHLFNBQVNtRyxtQkFBbUJwVixLQUFLO0lBQy9CLElBQUlBLFVBQVU3RyxXQUFXO1FBQ3ZCLE9BQU82RztJQUNUO0lBQ0EsSUFBSUEsaUJBQWlCTyxTQUFTO1FBQzVCLE9BQU9QLE1BQU1hLEtBQUs7SUFDcEI7SUFDQSxJQUFJYixpQkFBaUJrSixZQUFZO1FBQy9CLE1BQU15RixJQUFJLElBQUl6RixXQUFXbEosTUFBTXVCLFVBQVU7UUFDekNvTixFQUFFdEYsR0FBRyxDQUFDcko7UUFDTixPQUFPMk87SUFDVDtJQUNBLE9BQU8zTztBQUNUO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVM2VSxRQUFRUSxLQUFLO0lBQ3BCLE9BQU9BLGlCQUFpQm5NLGFBQWFtTSxRQUFRLElBQUluTSxXQUFXbU07QUFDOUQ7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsTUFBTUM7SUFDSnRTLFlBQVlFLE1BQU0sRUFBRXFTLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNDLE9BQU8sR0FBR3RTO1FBQ2YsSUFBSSxDQUFDdVMsV0FBVyxHQUFHRjtJQUNyQjtJQUNBM0MsYUFBYWEsUUFBUSxFQUFFO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUNpQyxTQUFTLEVBQUU7WUFDbkIsTUFBTXhXLElBQUksQ0FBQztZQUNYLEtBQUssTUFBTTBQLEtBQUssSUFBSSxDQUFDK0csSUFBSSxHQUFJO2dCQUMzQnpXLENBQUMsQ0FBQzBQLEVBQUU2RSxRQUFRLENBQUMsR0FBR3ZVLENBQUMsQ0FBQzBQLEVBQUU5VSxJQUFJLENBQUMsR0FBRzhVO1lBQzlCO1lBQ0EsSUFBSSxDQUFDOEcsU0FBUyxHQUFHeFc7UUFDbkI7UUFDQSxPQUFPLElBQUksQ0FBQ3dXLFNBQVMsQ0FBQ2pDLFNBQVM7SUFDakM7SUFDQXpFLEtBQUtsRixPQUFPLEVBQUU7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDaEssT0FBTyxFQUFFO1lBQ2pCLE1BQU1aLElBQUksQ0FBQztZQUNYLEtBQUssTUFBTTBQLEtBQUssSUFBSSxDQUFDK0csSUFBSSxHQUFJO2dCQUMzQnpXLENBQUMsQ0FBQzBQLEVBQUVuUCxFQUFFLENBQUMsR0FBR21QO1lBQ1o7WUFDQSxJQUFJLENBQUM5TyxPQUFPLEdBQUdaO1FBQ2pCO1FBQ0EsT0FBTyxJQUFJLENBQUNZLE9BQU8sQ0FBQ2dLLFFBQVE7SUFDOUI7SUFDQTZMLE9BQU87UUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEVBQUU7WUFDYixJQUFJLENBQUNBLEdBQUcsR0FBRyxJQUFJLENBQUNILFdBQVcsQ0FBQyxJQUFJLENBQUNELE9BQU87UUFDMUM7UUFDQSxPQUFPLElBQUksQ0FBQ0ksR0FBRztJQUNqQjtJQUNBMUUsV0FBVztRQUNULElBQUksQ0FBQyxJQUFJLENBQUMyRSxVQUFVLEVBQUU7WUFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSSxDQUFDRixJQUFJLEdBQUc1VCxNQUFNLEdBQUcrVCxJQUFJLENBQUMsQ0FBQ3BTLEdBQUdDLElBQU1ELEVBQUVqRSxFQUFFLEdBQUdrRSxFQUFFbEUsRUFBRTtRQUNuRTtRQUNBLE9BQU8sSUFBSSxDQUFDb1csVUFBVTtJQUN4QjtJQUNBdEMsV0FBVztRQUNULElBQUksQ0FBQyxJQUFJLENBQUN3QyxPQUFPLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUcsRUFBRTtZQUNqQixNQUFNclMsSUFBSSxJQUFJLENBQUNxUyxPQUFPO1lBQ3RCLElBQUlDO1lBQ0osS0FBSyxNQUFNcEgsS0FBSyxJQUFJLENBQUMrRyxJQUFJLEdBQUk7Z0JBQzNCLElBQUkvRyxFQUFFTyxLQUFLLEVBQUU7b0JBQ1gsSUFBSVAsRUFBRU8sS0FBSyxLQUFLNkcsR0FBRzt3QkFDakJBLElBQUlwSCxFQUFFTyxLQUFLO3dCQUNYekwsRUFBRXhELElBQUksQ0FBQzhWO29CQUNUO2dCQUNGLE9BQU87b0JBQ0x0UyxFQUFFeEQsSUFBSSxDQUFDME87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNtSCxPQUFPO0lBQ3JCO0FBQ0Y7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakM7Ozs7Ozs7Q0FPQyxHQUNEOztDQUVDLEdBQ0QsU0FBU0UsZUFBZUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3hDLE1BQU1yYyxPQUFPc2MsZUFBZUY7SUFDNUIsSUFBSUMsU0FBUztRQUNYLDRFQUE0RTtRQUM1RSxPQUFPcmM7SUFDVDtJQUNBLE9BQU91YyxtQkFBbUJDLG9CQUFvQnhjO0FBQ2hEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTeWMsZUFBZUwsU0FBUztJQUMvQixPQUFPRCxlQUFlQyxXQUFXO0FBQ25DO0FBQ0E7O0NBRUMsR0FDRCxNQUFNTSxnQkFBZ0JKO0FBQ3RCOzs7Q0FHQyxHQUNELFNBQVNBLGVBQWVLLFNBQVM7SUFDL0IsSUFBSUMsVUFBVTtJQUNkLE1BQU0vUyxJQUFJLEVBQUU7SUFDWixJQUFLLElBQUlwSyxJQUFJLEdBQUdBLElBQUlrZCxVQUFVamQsTUFBTSxFQUFFRCxJQUFLO1FBQ3pDLElBQUlvVixJQUFJOEgsVUFBVUUsTUFBTSxDQUFDcGQ7UUFDekIsT0FBUW9WO1lBQ04sS0FBSztnQkFDSCtILFVBQVU7Z0JBQ1Y7WUFDRixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIL1MsRUFBRXpELElBQUksQ0FBQ3lPO2dCQUNQK0gsVUFBVTtnQkFDVjtZQUNGO2dCQUNFLElBQUlBLFNBQVM7b0JBQ1hBLFVBQVU7b0JBQ1YvSCxJQUFJQSxFQUFFclUsV0FBVztnQkFDbkI7Z0JBQ0FxSixFQUFFekQsSUFBSSxDQUFDeU87Z0JBQ1A7UUFDSjtJQUNGO0lBQ0EsT0FBT2hMLEVBQUU0RixJQUFJLENBQUM7QUFDaEI7QUFDQTs7O0NBR0MsR0FDRCxNQUFNcU4sMkJBQTJCLElBQUlDLElBQUk7SUFDekMsK0JBQStCO0lBQy9CO0lBQWU7SUFBWTtJQUFVO0NBQVU7QUFDL0M7OztDQUdDLEdBQ0QsTUFBTUMsNEJBQTRCLElBQUlELElBQUk7SUFDMUMsZ0NBQWdDO0lBQ2hDO0lBQVc7SUFBUztJQUFVO0lBQWM7SUFBWTtJQUFrQjtJQUFZO0lBQVU7SUFDaEcsK0NBQStDO0lBQy9DO0NBQVc7QUFDWCxNQUFNRSxXQUFXamQsQ0FBQUEsT0FBUSxHQUFHaUksTUFBTSxDQUFDakksTUFBTTtBQUN6Qzs7O0NBR0MsR0FDRCxNQUFNd2Msc0JBQXNCeGMsQ0FBQUE7SUFDMUIsSUFBSWdkLDBCQUEwQkUsR0FBRyxDQUFDbGQsT0FBTztRQUN2QyxPQUFPaWQsU0FBU2pkO0lBQ2xCO0lBQ0EsT0FBT0E7QUFDVDtBQUNBOzs7Q0FHQyxHQUNELE1BQU11YyxxQkFBcUJ2YyxDQUFBQTtJQUN6QixJQUFJOGMseUJBQXlCSSxHQUFHLENBQUNsZCxPQUFPO1FBQ3RDLE9BQU9pZCxTQUFTamQ7SUFDbEI7SUFDQSxPQUFPQTtBQUNUO0FBRUEsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLE1BQU1tZDtJQUNKalUsWUFBWWxKLElBQUksQ0FBRTtRQUNoQixJQUFJLENBQUN1VixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNpQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM3UixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUM0WCxPQUFPLEdBQUcvZDtRQUNmLElBQUksQ0FBQytKLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ3BKLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUM0RixTQUFTLEdBQUc2VyxlQUFlemM7SUFDbEM7SUFDQXFkLFNBQVNwSSxLQUFLLEVBQUU7UUFDZGhSLE9BQU9nUixNQUFNSSxLQUFLLEtBQUssSUFBSSxFQUFFLFNBQVNwTixNQUFNLENBQUNnTixNQUFNalYsSUFBSSxFQUFFLGdCQUFnQmlJLE1BQU0sQ0FBQyxJQUFJLENBQUNqSSxJQUFJO1FBQ3pGLElBQUksQ0FBQ29KLE1BQU0sQ0FBQ2hELElBQUksQ0FBQzZPO0lBQ25CO0lBQ0F5RSxVQUFVOVQsU0FBUyxFQUFFO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMwWCxPQUFPLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUc5Z0IsT0FBT3VKLE1BQU0sQ0FBQztZQUM3QixJQUFLLElBQUl0RyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMkosTUFBTSxDQUFDMUosTUFBTSxFQUFFRCxJQUFLO2dCQUMzQyxJQUFJLENBQUM2ZCxPQUFPLENBQUMsSUFBSSxDQUFDbFUsTUFBTSxDQUFDM0osRUFBRSxDQUFDbUcsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDd0QsTUFBTSxDQUFDM0osRUFBRTtZQUN6RDtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUM2ZCxPQUFPLENBQUMxWCxVQUFVO0lBQ2hDO0FBQ0Y7QUFFQSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakM7O0NBRUMsR0FDRCxNQUFNMlgsU0FBU3pULGlCQUFpQixVQUFVdVEsd0JBQXdCbEQsMEJBQTBCM2EsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHbVUsbUJBQW1CO0lBQzdJaFIsY0FBYVAsTUFBTTtRQUNqQixPQUFPLElBQUlvUyxrQkFBa0JwUyxRQUFRb1U7SUFDdkM7SUFDQWhVLFlBQVcyTCxNQUFNO1FBQ2YsS0FBSyxNQUFNcUUsVUFBVXJFLE9BQU92TyxPQUFPLEdBQUd3QyxNQUFNLENBQUNxUSxRQUFRLEdBQUk7WUFDdkQsSUFBSUQsT0FBT2hVLEdBQUcsRUFBRTtnQkFDZDtZQUNGO1lBQ0EsTUFBTXhGLE9BQU93WixPQUFPNVQsU0FBUyxFQUMzQlIsSUFBSStQO1lBQ04sSUFBSXFFLE9BQU9wRSxRQUFRLEVBQUU7Z0JBQ25CaFEsQ0FBQyxDQUFDcEYsS0FBSyxHQUFHLEVBQUU7Z0JBQ1o7WUFDRjtZQUNBLE9BQVF3WixPQUFPakUsSUFBSTtnQkFDakIsS0FBSztvQkFDSG5RLENBQUMsQ0FBQ3BGLEtBQUssR0FBRzt3QkFDUnNWLE1BQU1qVztvQkFDUjtvQkFDQTtnQkFDRixLQUFLO29CQUNIK0YsQ0FBQyxDQUFDcEYsS0FBSyxHQUFHO29CQUNWO2dCQUNGLEtBQUs7b0JBQ0hvRixDQUFDLENBQUNwRixLQUFLLEdBQUcsQ0FBQztvQkFDWDtnQkFDRixLQUFLO29CQUNIb0YsQ0FBQyxDQUFDcEYsS0FBSyxHQUFHMlQsbUJBQW1CNkYsT0FBTy9ELENBQUMsRUFBRStELE9BQU81RCxDQUFDLEdBQUcsOERBQThEO29CQUNoSDtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsOEtBQThLLEdBQzlLLFNBQVM0SCwwQkFBMEJDLFVBQVU7SUFDM0MsSUFBSTdVLElBQUk4VSxJQUFJQyxJQUFJQztJQUNoQixNQUFNaEUsSUFBSSxFQUFFO0lBQ1osSUFBSXNDO0lBQ0osS0FBSyxNQUFNakgsU0FBUyxPQUFPd0ksY0FBYyxhQUFhQSxlQUFlQSxXQUFZO1FBQy9FLE1BQU0zSSxJQUFJRztRQUNWSCxFQUFFbFAsU0FBUyxHQUFHdVcsZUFBZWxILE1BQU1qVixJQUFJLEVBQUVpVixNQUFNSSxLQUFLLEtBQUtoVztRQUN6RHlWLEVBQUU2RSxRQUFRLEdBQUcsQ0FBQy9RLEtBQUtxTSxNQUFNMEUsUUFBUSxNQUFNLFFBQVEvUSxPQUFPLEtBQUssSUFBSUEsS0FBSzhULGNBQWN6SCxNQUFNalYsSUFBSTtRQUM1RjhVLEVBQUVNLFFBQVEsR0FBRyxDQUFDc0ksS0FBS3pJLE1BQU1HLFFBQVEsTUFBTSxRQUFRc0ksT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDcEUsSUFBSXpJLE1BQU1NLElBQUksSUFBSSxVQUFVO1lBQzFCVCxFQUFFYyxDQUFDLEdBQUcsQ0FBQytILEtBQUsxSSxNQUFNVyxDQUFDLE1BQU0sUUFBUStILE9BQU8sS0FBSyxJQUFJQSxLQUFLMVQsU0FBU3lNLE1BQU07UUFDdkU7UUFDQSxrQ0FBa0M7UUFDbEMsOEVBQThFO1FBQzlFLDRFQUE0RTtRQUM1RSwyRUFBMkU7UUFDM0Usa0ZBQWtGO1FBQ2xGNUIsRUFBRXVDLE1BQU0sR0FBRyxDQUFDdUcsS0FBSzNJLE1BQU1vQyxNQUFNLE1BQU0sUUFBUXVHLE9BQU8sS0FBSyxJQUFJQSxLQUFLM0ksTUFBTU0sSUFBSSxJQUFJLFVBQVVOLE1BQU1NLElBQUksSUFBSSxZQUFZTixNQUFNUSxDQUFDLElBQUl6TCxXQUFXc0osS0FBSyxJQUFJMkIsTUFBTVEsQ0FBQyxJQUFJekwsV0FBV3FKLE1BQU07UUFDN0sseUNBQXlDO1FBQ3pDLG9EQUFvRDtRQUNwRCxJQUFJNEIsTUFBTUksS0FBSyxLQUFLaFcsV0FBVztZQUM3QixNQUFNd2UsU0FBUyxPQUFPNUksTUFBTUksS0FBSyxJQUFJLFdBQVdKLE1BQU1JLEtBQUssR0FBR0osTUFBTUksS0FBSyxDQUFDclYsSUFBSTtZQUM5RSxJQUFJLENBQUNrYyxLQUFLQSxFQUFFbGMsSUFBSSxJQUFJNmQsUUFBUTtnQkFDMUIzQixJQUFJLElBQUlpQixrQkFBa0JVO1lBQzVCO1lBQ0EvSSxFQUFFTyxLQUFLLEdBQUc2RztZQUNWQSxFQUFFbUIsUUFBUSxDQUFDdkk7UUFDYjtRQUNBOEUsRUFBRXhULElBQUksQ0FBQzBPO0lBQ1Q7SUFDQSxPQUFPOEU7QUFDVDtBQUVBLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkZDLEdBQ0QsTUFBTWtFLGtCQUFrQnJYO0lBQ3RCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7Ozs7O0tBTUMsR0FDRCxJQUFJLENBQUN3VSxPQUFPLEdBQUdsUCxXQUFXWCxJQUFJO1FBQzlCOzs7Ozs7O0tBT0MsR0FDRCxJQUFJLENBQUM4UCxLQUFLLEdBQUc7UUFDYlQsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0E3QixTQUFTRSxJQUFJLEVBQUVWLE9BQU8sRUFBRTtRQUN0QixJQUFJLE9BQU9VLFNBQVMsVUFBVTtZQUM1QixNQUFNLElBQUl6RCxNQUFNLHNEQUFzRDhELE1BQU0sQ0FBQ3NWLE9BQU8zVixJQUFJLENBQUNoSSxLQUFLLENBQUNnSTtRQUNqRztRQUNBLE1BQU1xVyxVQUFVclcsS0FBS3NXLEtBQUssQ0FBQztRQUMzQixJQUFJLENBQUNELFNBQVM7WUFDWixNQUFNLElBQUk5WixNQUFNO1FBQ2xCO1FBQ0EsTUFBTWdhLEtBQUtDLEtBQUtwVyxLQUFLLENBQUNpVyxPQUFPLENBQUMsRUFBRSxHQUFHLE1BQU1BLE9BQU8sQ0FBQyxFQUFFLEdBQUcsTUFBTUEsT0FBTyxDQUFDLEVBQUUsR0FBRyxNQUFNQSxPQUFPLENBQUMsRUFBRSxHQUFHLE1BQU1BLE9BQU8sQ0FBQyxFQUFFLEdBQUcsTUFBTUEsT0FBTyxDQUFDLEVBQUUsR0FBSUEsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUUsR0FBRyxHQUFFO1FBQy9KLElBQUl0WixPQUFPdVYsS0FBSyxDQUFDaUUsS0FBSztZQUNwQixNQUFNLElBQUloYSxNQUFNO1FBQ2xCO1FBQ0EsSUFBSWdhLEtBQUtDLEtBQUtwVyxLQUFLLENBQUMsMkJBQTJCbVcsS0FBS0MsS0FBS3BXLEtBQUssQ0FBQyx5QkFBeUI7WUFDdEYsTUFBTSxJQUFJN0QsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQzRaLE9BQU8sR0FBR2xQLFdBQVc3RyxLQUFLLENBQUNtVyxLQUFLO1FBQ3JDLElBQUksQ0FBQ0gsS0FBSyxHQUFHO1FBQ2IsSUFBSUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNkLElBQUksQ0FBQ0QsS0FBSyxHQUFHbEgsU0FBUyxNQUFNbUgsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJSSxNQUFNLENBQUMsSUFBSUosT0FBTyxDQUFDLEVBQUUsQ0FBQ3ZlLE1BQU0sS0FBSztRQUNoRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FnSixPQUFPeEIsT0FBTyxFQUFFO1FBQ2QsTUFBTWlYLEtBQUt4WixPQUFPLElBQUksQ0FBQ29aLE9BQU8sSUFBSTtRQUNsQyxJQUFJSSxLQUFLQyxLQUFLcFcsS0FBSyxDQUFDLDJCQUEyQm1XLEtBQUtDLEtBQUtwVyxLQUFLLENBQUMseUJBQXlCO1lBQ3RGLE1BQU0sSUFBSTdELE1BQU07UUFDbEI7UUFDQSxJQUFJLElBQUksQ0FBQzZaLEtBQUssR0FBRyxHQUFHO1lBQ2xCLE1BQU0sSUFBSTdaLE1BQU07UUFDbEI7UUFDQSxJQUFJbWEsSUFBSTtRQUNSLElBQUksSUFBSSxDQUFDTixLQUFLLEdBQUcsR0FBRztZQUNsQixNQUFNTyxXQUFXLENBQUMsSUFBSSxDQUFDUCxLQUFLLEdBQUcsVUFBUyxFQUFHdFIsUUFBUSxHQUFHckQsU0FBUyxDQUFDO1lBQ2hFLElBQUlrVixTQUFTbFYsU0FBUyxDQUFDLE9BQU8sVUFBVTtnQkFDdENpVixJQUFJLE1BQU1DLFNBQVNsVixTQUFTLENBQUMsR0FBRyxLQUFLO1lBQ3ZDLE9BQU8sSUFBSWtWLFNBQVNsVixTQUFTLENBQUMsT0FBTyxPQUFPO2dCQUMxQ2lWLElBQUksTUFBTUMsU0FBU2xWLFNBQVMsQ0FBQyxHQUFHLEtBQUs7WUFDdkMsT0FBTztnQkFDTGlWLElBQUksTUFBTUMsV0FBVztZQUN2QjtRQUNGO1FBQ0EsT0FBTyxJQUFJSCxLQUFLRCxJQUFJSyxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxTQUFTSDtJQUNyRDtJQUNBSSxTQUFTO1FBQ1AsT0FBTyxJQUFJTixLQUFLelosT0FBTyxJQUFJLENBQUNvWixPQUFPLElBQUksT0FBT3ZSLEtBQUttUyxJQUFJLENBQUMsSUFBSSxDQUFDWCxLQUFLLEdBQUc7SUFDdkU7SUFDQSxPQUFPWSxNQUFNO1FBQ1gsT0FBT2QsVUFBVWUsUUFBUSxDQUFDLElBQUlUO0lBQ2hDO0lBQ0EsT0FBT1MsU0FBU0MsSUFBSSxFQUFFO1FBQ3BCLE1BQU1YLEtBQUtXLEtBQUtDLE9BQU87UUFDdkIsT0FBTyxJQUFJakIsVUFBVTtZQUNuQkMsU0FBU2xQLFdBQVc3RyxLQUFLLENBQUN3RSxLQUFLQyxLQUFLLENBQUMwUixLQUFLO1lBQzFDSCxPQUFPRyxLQUFLLE9BQU87UUFDckI7SUFDRjtJQUNBLE9BQU9uWCxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUk0VyxZQUFZOVcsVUFBVSxDQUFDQyxPQUFPQztJQUMzQztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTRXLFlBQVlwVyxRQUFRLENBQUNDLFdBQVdUO0lBQzdDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJNFcsWUFBWWpXLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDcEQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ29YLFdBQVdsVSxHQUFHQztJQUMxQztBQUNGO0FBQ0FpVSxVQUFValgsT0FBTyxHQUFHMFc7QUFDcEJPLFVBQVV4WSxRQUFRLEdBQUc7QUFDckJ3WSxVQUFVMVUsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDakRoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO0tBQUU7QUFFRiwrQkFBK0I7QUFDL0IsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixpREFBaUQ7QUFDakQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakM7O0NBRUMsR0FDRCxJQUFJdUo7QUFDSCxVQUFVQSxVQUFVO0lBQ25COztHQUVDLEdBQ0RBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDM0M7O0dBRUMsR0FDREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNyQzs7R0FFQyxHQUNEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQ3RDLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUNoQyw4REFBOEQ7QUFDOUR6QixPQUFPelcsSUFBSSxDQUFDekIsV0FBVyxDQUFDMlosWUFBWSxzQkFBc0I7SUFBQztRQUN6RHJaLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0NBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUlpZjtBQUNILFVBQVVBLFVBQVU7SUFDbkI7O0dBRUMsR0FDREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUMzQzs7R0FFQyxHQUNEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUc7SUFDOUM7O0dBRUMsR0FDREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRztJQUMxQzs7R0FFQyxHQUNEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQzFDOztHQUVDLEdBQ0RBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7QUFDdEMsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ2hDLDhEQUE4RDtBQUM5RDFCLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUM0WixZQUFZLHNCQUFzQjtJQUFDO1FBQ3pEdFosSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxJQUFJa2Y7QUFDSCxVQUFVQSxVQUFVO0lBQ25COztHQUVDLEdBQ0RBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDM0M7O0dBRUMsR0FDREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztBQUMxQyxHQUFHQSxjQUFlQSxDQUFBQSxhQUFhLENBQUM7QUFDaEMsOERBQThEO0FBQzlEM0IsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQzZaLFlBQVksc0JBQXNCO0lBQUM7UUFDekR2WixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0NBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUltZjtBQUNILFVBQVVBLFNBQVM7SUFDbEI7O0dBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNwQzs7R0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BDOztHQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7QUFDckMsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLDZEQUE2RDtBQUM3RDVCLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUM4WixXQUFXLHFCQUFxQjtJQUFDO1FBQ3ZEeFosSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSW9mO0FBQ0gsVUFBVUEsV0FBVztJQUNwQjs7R0FFQyxHQUNEQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzFDOztHQUVDLEdBQ0RBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDekM7O0dBRUMsR0FDREEsV0FBVyxDQUFDQSxXQUFXLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUM3Qzs7R0FFQyxHQUNEQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQy9DOztHQUVDLEdBQ0RBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztBQUN2RCxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLCtEQUErRDtBQUMvRDdCLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUMrWixhQUFhLHVCQUF1QjtJQUFDO1FBQzNEelosSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxJQUFJcWY7QUFDSCxVQUFVQSxZQUFZO0lBQ3JCOztHQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDeEM7O0dBRUMsR0FDREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUMzQzs7R0FFQyxHQUNEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3pDOztHQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7QUFDMUMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsZ0VBQWdFO0FBQ2hFOUIsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ2dhLGNBQWMsd0JBQXdCO0lBQUM7UUFDN0QxWixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSXNmO0FBQ0gsVUFBVUMsaUJBQWlCO0lBQzFCOztHQUVDLEdBQ0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ25EOztHQUVDLEdBQ0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ25EOztHQUVDLEdBQ0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ3hEOztHQUVDLEdBQ0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQ3JELEdBQUdELHVCQUF3QkEsQ0FBQUEsc0JBQXNCLENBQUM7QUFDbEQscUVBQXFFO0FBQ3JFL0IsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ2lhLHFCQUFxQiw2QkFBNkI7SUFBQztRQUN6RTNaLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxJQUFJd2Y7QUFDSCxVQUFVQSxtQkFBbUI7SUFDNUI7O0dBRUMsR0FDREEsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDeEQ7O0dBRUMsR0FDREEsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDM0Q7O0dBRUMsR0FDREEsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7QUFDNUQsR0FBR0EsdUJBQXdCQSxDQUFBQSxzQkFBc0IsQ0FBQztBQUNsRCx1RUFBdUU7QUFDdkVqQyxPQUFPelcsSUFBSSxDQUFDekIsV0FBVyxDQUFDbWEscUJBQXFCLCtCQUErQjtJQUFDO1FBQzNFN1osSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSXlmO0FBQ0gsVUFBVUEsZ0JBQWdCO0lBQ3pCOztHQUVDLEdBQ0RBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDM0Q7O0dBRUMsR0FDREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUM3RDs7R0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQy9EOztHQUVDLEdBQ0RBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7SUFDNUQ7O0dBRUMsR0FDREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLHNCQUFzQixHQUFHLEVBQUUsR0FBRztJQUNoRTs7R0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUN6RDs7R0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQzNEOztHQUVDLEdBQ0RBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0FBQzNELEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsb0VBQW9FO0FBQ3BFbEMsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ29hLGtCQUFrQiw0QkFBNEI7SUFBQztRQUNyRTlaLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSTBmO0FBQ0gsVUFBVUEsZUFBZTtJQUN4Qjs7R0FFQyxHQUNEQSxlQUFlLENBQUNBLGVBQWUsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQ3JEOztHQUVDLEdBQ0RBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLHlCQUF5QixHQUFHLEVBQUUsR0FBRztJQUNqRTs7R0FFQyxHQUNEQSxlQUFlLENBQUNBLGVBQWUsQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDOUQ7O0dBRUMsR0FDREEsZUFBZSxDQUFDQSxlQUFlLENBQUMsdUJBQXVCLEdBQUcsRUFBRSxHQUFHO0lBQy9EOztHQUVDLEdBQ0RBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLHNCQUFzQixHQUFHLEVBQUUsR0FBRztBQUNoRSxHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLG1FQUFtRTtBQUNuRW5DLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUNxYSxpQkFBaUIsMkJBQTJCO0lBQUM7UUFDbkUvWixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0NBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUkyZjtBQUNILFVBQVVBLGlCQUFpQjtJQUMxQjs7R0FFQyxHQUNEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUN6RDs7R0FFQyxHQUNEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsdUJBQXVCLEdBQUcsRUFBRSxHQUFHO0lBQ25FOztHQUVDLEdBQ0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDbEUsR0FBR0EscUJBQXNCQSxDQUFBQSxvQkFBb0IsQ0FBQztBQUM5QyxxRUFBcUU7QUFDckVwQyxPQUFPelcsSUFBSSxDQUFDekIsV0FBVyxDQUFDc2EsbUJBQW1CLDZCQUE2QjtJQUFDO1FBQ3ZFaGEsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSTRmLFNBQVMsTUFBTUMsYUFBYXBaO0lBQzlCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3VXLEdBQUcsR0FBRztRQUNYOztLQUVDLEdBQ0QsSUFBSSxDQUFDOWYsSUFBSSxHQUFHO1FBQ1o7O0tBRUMsR0FDRCxJQUFJLENBQUMrZixZQUFZLEdBQUc7UUFDcEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2Qjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHcFIsV0FBV1gsSUFBSTtRQUNuQzs7S0FFQyxHQUNELElBQUksQ0FBQ2dTLFlBQVksR0FBRztRQUNwQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7UUFDdkI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QmhELE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUkyWSxPQUFPN1ksVUFBVSxDQUFDQyxPQUFPQztJQUN0QztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTJZLE9BQU9uWSxRQUFRLENBQUNDLFdBQVdUO0lBQ3hDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJMlksT0FBT2hZLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDL0M7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ21aLE1BQU1qVyxHQUFHQztJQUNyQztBQUNGO0FBQ0ErVixPQUFPL1ksT0FBTyxHQUFHMFc7QUFDakJxQyxPQUFPdGEsUUFBUSxHQUFHO0FBQ2xCc2EsT0FBT3hXLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzlDaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHK0s7WUFDSHBMLFVBQVU7UUFDWjtRQUFHO1lBQ0R6UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTStLLGNBQWMvWjtJQUNsQnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNrWCxJQUFJLEdBQUc7UUFDWjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCbkQsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXNaLFFBQVF4WixVQUFVLENBQUNDLE9BQU9DO0lBQ3ZDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJc1osUUFBUTlZLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDekM7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlzWixRQUFRM1ksY0FBYyxDQUFDQyxZQUFZWjtJQUNoRDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDOFosT0FBTzVXLEdBQUdDO0lBQ3RDO0FBQ0Y7QUFDQTJXLE1BQU0zWixPQUFPLEdBQUcwVztBQUNoQmlELE1BQU1sYixRQUFRLEdBQUc7QUFDakJrYixNQUFNcFgsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDN0NoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1rTCxxQkFBcUJsYTtJQUN6QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNxWCxPQUFPLEdBQUc7UUFDZjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1g7O0tBRUMsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYdkQsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXlaLGVBQWUzWixVQUFVLENBQUNDLE9BQU9DO0lBQzlDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJeVosZUFBZWpaLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDaEQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl5WixlQUFlOVksY0FBYyxDQUFDQyxZQUFZWjtJQUN2RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDaWEsY0FBYy9XLEdBQUdDO0lBQzdDO0FBQ0Y7QUFDQThXLGFBQWE5WixPQUFPLEdBQUcwVztBQUN2Qm9ELGFBQWFyYixRQUFRLEdBQUc7QUFDeEJxYixhQUFhdlgsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDcERoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNc0wsOEJBQThCdGE7SUFDbEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOzs7O0tBSUMsR0FDRCxJQUFJLENBQUN5WCxZQUFZLEdBQUc7UUFDcEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0Qjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxFQUFFO1FBQzNCOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6Qjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYmhFLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUk2Wix3QkFBd0IvWixVQUFVLENBQUNDLE9BQU9DO0lBQ3ZEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJNlosd0JBQXdCclosUUFBUSxDQUFDQyxXQUFXVDtJQUN6RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTZaLHdCQUF3QmxaLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDaEU7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3FhLHVCQUF1Qm5YLEdBQUdDO0lBQ3REO0FBQ0Y7QUFDQWtYLHNCQUFzQmxhLE9BQU8sR0FBRzBXO0FBQ2hDd0Qsc0JBQXNCemIsUUFBUSxHQUFHO0FBQ2pDeWIsc0JBQXNCM1gsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDN0RoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDa2E7WUFDdEJoSyxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU0rTCx3QkFBd0IvYTtJQUM1QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUN1VyxHQUFHLEdBQUc7UUFDWDs7S0FFQyxHQUNELElBQUksQ0FBQzJCLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxzQkFBc0JDLE9BQU87UUFDMUM7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDekIsUUFBUSxHQUFHO1FBQ2hCOzs7O0tBSUMsR0FDRCxJQUFJLENBQUMwQixRQUFRLEdBQUdqVCxXQUFXWCxJQUFJO1FBQy9COztLQUVDLEdBQ0QsSUFBSSxDQUFDbE8sSUFBSSxHQUFHO1FBQ1o7O0tBRUMsR0FDRCxJQUFJLENBQUMraEIsT0FBTyxHQUFHO1FBQ2Y7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7OztLQUtDLEdBQ0QsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIxRSxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJc2Esa0JBQWtCeGEsVUFBVSxDQUFDQyxPQUFPQztJQUNqRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXNhLGtCQUFrQjlaLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlzYSxrQkFBa0IzWixjQUFjLENBQUNDLFlBQVlaO0lBQzFEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUM4YSxpQkFBaUI1WCxHQUFHQztJQUNoRDtBQUNGO0FBQ0EyWCxnQkFBZ0IzYSxPQUFPLEdBQUcwVztBQUMxQmlFLGdCQUFnQmxjLFFBQVEsR0FBRztBQUMzQmtjLGdCQUFnQnBZLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3ZEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDeWM7UUFDeEI7UUFBRztZQUNEaGMsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHeU07WUFDSDlNLFVBQVU7UUFDWjtRQUFHO1lBQ0R6UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHc0w7UUFDTDtRQUFHO1lBQ0RwYixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUlrTTtBQUNILFVBQVVBLHFCQUFxQjtJQUM5Qjs7OztHQUlDLEdBQ0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEOzs7O0dBSUMsR0FDREEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDN0Q7Ozs7R0FJQyxHQUNEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUM3RDs7OztHQUlDLEdBQ0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0FBQ3JFLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDdEQseUVBQXlFO0FBQ3pFcEUsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ3NjLHVCQUF1QixpQ0FBaUM7SUFBQztRQUMvRWhjLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNbWlCLG1CQUFtQjFiO0lBQ3ZCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTGdVLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlpYixhQUFhbmIsVUFBVSxDQUFDQyxPQUFPQztJQUM1QztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSWliLGFBQWF6YSxRQUFRLENBQUNDLFdBQVdUO0lBQzlDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJaWIsYUFBYXRhLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDckQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3liLFlBQVl2WSxHQUFHQztJQUMzQztBQUNGO0FBQ0FzWSxXQUFXdGIsT0FBTyxHQUFHMFc7QUFDckI0RSxXQUFXN2MsUUFBUSxHQUFHO0FBQ3RCNmMsV0FBVy9ZLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTSxFQUFFO0FBQ3JEOztDQUVDLEdBQ0QsSUFBSXlZO0FBQ0gsVUFBVUEsZUFBZTtJQUN4Qjs7R0FFQyxHQUNEQSxlQUFlLENBQUNBLGVBQWUsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9DOztHQUVDLEdBQ0RBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDOUM7O0dBRUMsR0FDREEsZUFBZSxDQUFDQSxlQUFlLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNuRCxHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLG1FQUFtRTtBQUNuRTdFLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUMrYyxpQkFBaUIsMkJBQTJCO0lBQUM7UUFDbkV6YyxJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNcWlCLDJCQUEyQjViO0lBQy9CeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQytZLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ25XLEdBQUcsR0FBRztRQUNYOztLQUVDLEdBQ0QsSUFBSSxDQUFDb1csR0FBRyxHQUFHO1FBQ1g7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCakYsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSW1iLHFCQUFxQnJiLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDcEQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUltYixxQkFBcUIzYSxRQUFRLENBQUNDLFdBQVdUO0lBQ3REO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJbWIscUJBQXFCeGEsY0FBYyxDQUFDQyxZQUFZWjtJQUM3RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDMmIsb0JBQW9CelksR0FBR0M7SUFDbkQ7QUFDRjtBQUNBd1ksbUJBQW1CeGIsT0FBTyxHQUFHMFc7QUFDN0I4RSxtQkFBbUIvYyxRQUFRLEdBQUc7QUFDOUIrYyxtQkFBbUJqWixNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUMxRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2dOO1lBQ0hyTixVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTThNLGtCQUFrQnpiO0lBQ3RCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3VXLEdBQUcsR0FBRztRQUNYOztLQUVDLEdBQ0QsSUFBSSxDQUFDM1ksSUFBSSxHQUFHZ1ksVUFBVXVELEtBQUs7UUFDM0I7O0tBRUMsR0FDRCxJQUFJLENBQUMxaUIsSUFBSSxHQUFHO1FBQ1o7O0tBRUMsR0FDRCxJQUFJLENBQUMyaUIsS0FBSyxHQUFHO1FBQ2I7Ozs7O0tBS0MsR0FDRCxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ25JLE1BQU0sR0FBR3dFLFlBQVk0RCxPQUFPO1FBQ2pDOztLQUVDLEdBQ0QsSUFBSSxDQUFDUixNQUFNLEdBQUcsRUFBRTtRQUNoQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDRixRQUFRLEdBQUc7UUFDaEI7O0tBRUMsR0FDRCxJQUFJLENBQUNuVyxHQUFHLEdBQUc7UUFDWDs7S0FFQyxHQUNELElBQUksQ0FBQzhXLE1BQU0sR0FBRyxFQUFFO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFVBQVUsR0FBR2hCLGdCQUFnQmlCLElBQUk7UUFDdEM7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkL0YsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSWdiLFlBQVlsYixVQUFVLENBQUNDLE9BQU9DO0lBQzNDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJZ2IsWUFBWXhhLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDN0M7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlnYixZQUFZcmEsY0FBYyxDQUFDQyxZQUFZWjtJQUNwRDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDd2IsV0FBV3RZLEdBQUdDO0lBQzFDO0FBQ0Y7QUFDQXFZLFVBQVVyYixPQUFPLEdBQUcwVztBQUNwQjJFLFVBQVU1YyxRQUFRLEdBQUc7QUFDckI0YyxVQUFVOVksTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDakRoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQ2lhO1FBQ3hCO1FBQUc7WUFDRHhaLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNrYTtRQUN4QjtRQUFHO1lBQ0R6WixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdnTjtZQUNIck4sVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHNE07WUFDSGpOLFVBQVU7UUFDWjtRQUFHO1lBQ0R6UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNrZDtRQUN4QjtRQUFHO1lBQ0R6YyxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7S0FBRTtBQUNGOzs7O0NBSUMsR0FDRCxNQUFNZ04sbUJBQW1CaGM7SUFDdkJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNnYSxPQUFPLEdBQUdsRSxhQUFhbUUsR0FBRztRQUMvQjs7S0FFQyxHQUNELElBQUksQ0FBQ1osS0FBSyxHQUFHO1FBQ2I7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNZLE9BQU8sR0FBRztRQUNmOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWm5HLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl1YixhQUFhemIsVUFBVSxDQUFDQyxPQUFPQztJQUM1QztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXViLGFBQWEvYSxRQUFRLENBQUNDLFdBQVdUO0lBQzlDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJdWIsYUFBYTVhLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDckQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQytiLFlBQVk3WSxHQUFHQztJQUMzQztBQUNGO0FBQ0E0WSxXQUFXNWIsT0FBTyxHQUFHMFc7QUFDckJrRixXQUFXbmQsUUFBUSxHQUFHO0FBQ3RCbWQsV0FBV3JaLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2xEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQ21hO1FBQ3hCO1FBQUc7WUFDRDFaLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtLQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNELE1BQU1rTyxtQkFBbUJsZDtJQUN2QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNnTSxJQUFJLEdBQUdxTyxnQkFBZ0JDLFFBQVE7UUFDcEM7O0tBRUMsR0FDRCxJQUFJLENBQUMzZCxLQUFLLEdBQUc7WUFDWG9QLE1BQU1qVztRQUNSO1FBQ0FrZSxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJeWMsYUFBYTNjLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDNUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl5YyxhQUFhamMsUUFBUSxDQUFDQyxXQUFXVDtJQUM5QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXljLGFBQWE5YixjQUFjLENBQUNDLFlBQVlaO0lBQ3JEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNpZCxZQUFZL1osR0FBR0M7SUFDM0M7QUFDRjtBQUNBOFosV0FBVzljLE9BQU8sR0FBRzBXO0FBQ3JCb0csV0FBV3JlLFFBQVEsR0FBRztBQUN0QnFlLFdBQVd2YSxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNsRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUMwZTtRQUN4QjtRQUFHO1lBQ0RqZSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdxTztZQUNIek8sT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3NPO1lBQ0gxTyxPQUFPO1FBQ1Q7S0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSXVPO0FBQ0gsVUFBVUEsZUFBZTtJQUN4Qjs7R0FFQyxHQUNEQSxlQUFlLENBQUNBLGVBQWUsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ25EOztHQUVDLEdBQ0RBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQyxtRUFBbUU7QUFDbkVyRyxPQUFPelcsSUFBSSxDQUFDekIsV0FBVyxDQUFDdWUsaUJBQWlCLDJCQUEyQjtJQUFDO1FBQ25FamUsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNK2pCLDRCQUE0QnRkO0lBQ2hDeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3lhLFFBQVEsR0FBRyxFQUFFO1FBQ2xCekcsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTZjLHNCQUFzQi9jLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDckQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUk2YyxzQkFBc0JyYyxRQUFRLENBQUNDLFdBQVdUO0lBQ3ZEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJNmMsc0JBQXNCbGMsY0FBYyxDQUFDQyxZQUFZWjtJQUM5RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDcWQscUJBQXFCbmEsR0FBR0M7SUFDcEQ7QUFDRjtBQUNBa2Esb0JBQW9CbGQsT0FBTyxHQUFHMFc7QUFDOUJ3RyxvQkFBb0J6ZSxRQUFRLEdBQUc7QUFDL0J5ZSxvQkFBb0IzYSxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUMzRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3dPO1lBQ0g3TyxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTTZPLG9CQUFvQnhkO0lBQ3hCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3VXLEdBQUcsR0FBRztRQUNYOzs7O0tBSUMsR0FDRCxJQUFJLENBQUN2Z0IsS0FBSyxHQUFHO1FBQ2I7Ozs7S0FJQyxHQUNELElBQUksQ0FBQzJrQixNQUFNLEdBQUc7UUFDZDNHLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUkrYyxjQUFjamQsVUFBVSxDQUFDQyxPQUFPQztJQUM3QztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSStjLGNBQWN2YyxRQUFRLENBQUNDLFdBQVdUO0lBQy9DO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJK2MsY0FBY3BjLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDdEQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3VkLGFBQWFyYSxHQUFHQztJQUM1QztBQUNGO0FBQ0FvYSxZQUFZcGQsT0FBTyxHQUFHMFc7QUFDdEIwRyxZQUFZM2UsUUFBUSxHQUFHO0FBQ3ZCMmUsWUFBWTdhLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ25EaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXFPLG1CQUFtQnJkO0lBQ3ZCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDNGEsY0FBYyxHQUFHO1FBQ3RCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSWpWLFdBQVc7UUFDOUI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ2tWLGVBQWUsR0FBRyxFQUFFO1FBQ3pCOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLHFCQUFxQixHQUFHLEVBQUU7UUFDL0JoSCxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJNGMsYUFBYTljLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDNUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUk0YyxhQUFhcGMsUUFBUSxDQUFDQyxXQUFXVDtJQUM5QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTRjLGFBQWFqYyxjQUFjLENBQUNDLFlBQVlaO0lBQ3JEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNvZCxZQUFZbGEsR0FBR0M7SUFDM0M7QUFDRjtBQUNBaWEsV0FBV2pkLE9BQU8sR0FBRzBXO0FBQ3JCdUcsV0FBV3hlLFFBQVEsR0FBRztBQUN0QndlLFdBQVcxYSxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNsRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcsb0JBQW9CO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtZQUMxQkwsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtZQUMxQkwsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtZQUMxQmpRLEtBQUs7UUFDUDtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNZ2YsMEJBQTBCL2Q7SUFDOUJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOzs7O0tBSUMsR0FDRCxJQUFJLENBQUM0YSxjQUFjLEdBQUc7UUFDdEI7O0tBRUMsR0FDRCxJQUFJLENBQUNNLFNBQVMsR0FBRyxFQUFFO1FBQ25CbEgsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXNkLG9CQUFvQnhkLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDbkQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlzZCxvQkFBb0I5YyxRQUFRLENBQUNDLFdBQVdUO0lBQ3JEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJc2Qsb0JBQW9CM2MsY0FBYyxDQUFDQyxZQUFZWjtJQUM1RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDOGQsbUJBQW1CNWEsR0FBR0M7SUFDbEQ7QUFDRjtBQUNBMmEsa0JBQWtCM2QsT0FBTyxHQUFHMFc7QUFDNUJpSCxrQkFBa0JsZixRQUFRLEdBQUc7QUFDN0JrZixrQkFBa0JwYixNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN6RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7WUFDMUJMLFVBQVU7UUFDWjtLQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNELE1BQU1zUCxtQkFBbUJqZTtJQUN2QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNvYixPQUFPLEdBQUdDLG1CQUFtQkMsUUFBUTtRQUMxQzs7S0FFQyxHQUNELElBQUksQ0FBQzlDLE9BQU8sR0FBRztRQUNmOztLQUVDLEdBQ0QsSUFBSSxDQUFDK0MsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDOUMsTUFBTSxHQUFHO1FBQ2Q7O0tBRUMsR0FDRCxJQUFJLENBQUMrQyxNQUFNLEdBQUc7UUFDZDs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJ6SCxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJd2QsYUFBYTFkLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDNUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl3ZCxhQUFhaGQsUUFBUSxDQUFDQyxXQUFXVDtJQUM5QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXdkLGFBQWE3YyxjQUFjLENBQUNDLFlBQVlaO0lBQ3JEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNnZSxZQUFZOWEsR0FBR0M7SUFDM0M7QUFDRjtBQUNBNmEsV0FBVzdkLE9BQU8sR0FBRzBXO0FBQ3JCbUgsV0FBV3BmLFFBQVEsR0FBRztBQUN0Qm9mLFdBQVd0YixNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNsRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUMwZjtRQUN4QjtRQUFHO1lBQ0RqZixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUltUDtBQUNILFVBQVVBLGtCQUFrQjtJQUMzQjs7R0FFQyxHQUNEQSxrQkFBa0IsQ0FBQ0Esa0JBQWtCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUN6RDs7R0FFQyxHQUNEQSxrQkFBa0IsQ0FBQ0Esa0JBQWtCLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztBQUN4RCxHQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDO0FBQ2hELHNFQUFzRTtBQUN0RXJILE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUN1ZixvQkFBb0IsOEJBQThCO0lBQUM7UUFDekVqZixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0NBQUU7QUFDRjs7OztDQUlDLEdBQ0QsTUFBTWlsQixtQkFBbUJ4ZTtJQUN2QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUMyYixHQUFHLEdBQUdDLGVBQWVuQyxPQUFPO1FBQ2pDOztLQUVDLEdBQ0QsSUFBSSxDQUFDakIsT0FBTyxHQUFHO1FBQ2Y7O0tBRUMsR0FDRCxJQUFJLENBQUMrQyxRQUFRLEdBQUc7UUFDaEI7O0tBRUMsR0FDRCxJQUFJLENBQUNNLEVBQUUsR0FBRztRQUNWOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2Y7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0Qjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2Y7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2ZuSSxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJK2QsYUFBYWplLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDNUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUkrZCxhQUFhdmQsUUFBUSxDQUFDQyxXQUFXVDtJQUM5QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSStkLGFBQWFwZCxjQUFjLENBQUNDLFlBQVlaO0lBQ3JEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUN1ZSxZQUFZcmIsR0FBR0M7SUFDM0M7QUFDRjtBQUNBb2IsV0FBV3BlLE9BQU8sR0FBRzBXO0FBQ3JCMEgsV0FBVzNmLFFBQVEsR0FBRztBQUN0QjJmLFdBQVc3YixNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNsRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNpZ0I7UUFDeEI7UUFBRztZQUNEeGYsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSTBQO0FBQ0gsVUFBVUEsY0FBYztJQUN2Qjs7R0FFQyxHQUNEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ2hEOztHQUVDLEdBQ0RBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0M7O0dBRUMsR0FDREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUM5Qzs7R0FFQyxHQUNEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ2hEOztHQUVDLEdBQ0RBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaEQ7O0dBRUMsR0FDREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUMzQzs7R0FFQyxHQUNEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzlDOztHQUVDLEdBQ0RBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDckQ7O0dBRUMsR0FDREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUM3Qzs7R0FFQyxHQUNEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQy9DOztHQUVDLEdBQ0RBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUc7QUFDL0MsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUN4QyxrRUFBa0U7QUFDbEU1SCxPQUFPelcsSUFBSSxDQUFDekIsV0FBVyxDQUFDOGYsZ0JBQWdCLDBCQUEwQjtJQUFDO1FBQ2pFeGYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtDQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNELE1BQU0ybEIsNEJBQTRCbGY7SUFDaEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDcWMsZ0JBQWdCLEdBQUdwRyxvQkFBb0JxRyxLQUFLO1FBQ2pEOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUd0RyxvQkFBb0JxRyxLQUFLO1FBQzNDdEksT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXllLHNCQUFzQjNlLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDckQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl5ZSxzQkFBc0JqZSxRQUFRLENBQUNDLFdBQVdUO0lBQ3ZEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJeWUsc0JBQXNCOWQsY0FBYyxDQUFDQyxZQUFZWjtJQUM5RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDaWYscUJBQXFCL2IsR0FBR0M7SUFDcEQ7QUFDRjtBQUNBOGIsb0JBQW9COWUsT0FBTyxHQUFHMFc7QUFDOUJvSSxvQkFBb0JyZ0IsUUFBUSxHQUFHO0FBQy9CcWdCLG9CQUFvQnZjLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzNEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHc1E7UUFDTDtRQUFHO1lBQ0RwZ0IsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHc1E7UUFDTDtRQUFHO1lBQ0RwZ0IsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQ3NhO1FBQ3hCO1FBQUc7WUFDRDdaLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3VRO1FBQ0w7UUFBRztZQUNEcmdCLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNzYTtRQUN4QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNdUcsMkJBQTJCdGY7SUFDL0J5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDMGMsZUFBZSxHQUFHekcsb0JBQW9CcUcsS0FBSztRQUNoRHRJLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUk2ZSxxQkFBcUIvZSxVQUFVLENBQUNDLE9BQU9DO0lBQ3BEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJNmUscUJBQXFCcmUsUUFBUSxDQUFDQyxXQUFXVDtJQUN0RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTZlLHFCQUFxQmxlLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDN0Q7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3FmLG9CQUFvQm5jLEdBQUdDO0lBQ25EO0FBQ0Y7QUFDQWtjLG1CQUFtQmxmLE9BQU8sR0FBRzBXO0FBQzdCd0ksbUJBQW1CemdCLFFBQVEsR0FBRztBQUM5QnlnQixtQkFBbUIzYyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUMxRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNzYTtRQUN4QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNd0csdUJBQXVCdmY7SUFDM0J5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOzs7O0tBSUMsR0FDRCxJQUFJLENBQUMwWixNQUFNLEdBQUcsRUFBRTtRQUNoQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDaUQsT0FBTyxHQUFHLEVBQUU7UUFDakIzSSxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJOGUsaUJBQWlCaGYsVUFBVSxDQUFDQyxPQUFPQztJQUNoRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSThlLGlCQUFpQnRlLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbEQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUk4ZSxpQkFBaUJuZSxjQUFjLENBQUNDLFlBQVlaO0lBQ3pEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNzZixnQkFBZ0JwYyxHQUFHQztJQUMvQztBQUNGO0FBQ0FtYyxlQUFlbmYsT0FBTyxHQUFHMFc7QUFDekJ5SSxlQUFlMWdCLFFBQVEsR0FBRztBQUMxQjBnQixlQUFlNWMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDdERoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcrSztZQUNIcEwsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRytLO1lBQ0hwTCxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTStRLGlCQUFpQjFmO0lBQ3JCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQzZjLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsY0FBYyxHQUFHeFgsV0FBV1gsSUFBSTtRQUNyQzs7S0FFQyxHQUNELElBQUksQ0FBQ29ZLFlBQVksR0FBR3pYLFdBQVdYLElBQUk7UUFDbkM7O0tBRUMsR0FDRCxJQUFJLENBQUNxWSxhQUFhLEdBQUcxWCxXQUFXWCxJQUFJO1FBQ3BDOztLQUVDLEdBQ0QsSUFBSSxDQUFDc1ksWUFBWSxHQUFHM1gsV0FBV1gsSUFBSTtRQUNuQzs7S0FFQyxHQUNELElBQUksQ0FBQ3VZLE9BQU8sR0FBRztRQUNmOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJuSixPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJaWYsV0FBV25mLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDMUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlpZixXQUFXemUsUUFBUSxDQUFDQyxXQUFXVDtJQUM1QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSWlmLFdBQVd0ZSxjQUFjLENBQUNDLFlBQVlaO0lBQ25EO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUN5ZixVQUFVdmMsR0FBR0M7SUFDekM7QUFDRjtBQUNBc2MsU0FBU3RmLE9BQU8sR0FBRzBXO0FBQ25CNEksU0FBUzdnQixRQUFRLEdBQUc7QUFDcEI2Z0IsU0FBUy9jLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2hEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHcUk7UUFDTDtRQUFHO1lBQ0RuWSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdxSTtRQUNMO1FBQUc7WUFDRG5ZLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNa1IsaUJBQWlCbGdCO0lBQ3JCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQzZjLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ1EsT0FBTyxHQUFHO1FBQ2Y7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQjs7S0FFQyxHQUNELElBQUksQ0FBQzVmLEtBQUssR0FBRzRILFdBQVdYLElBQUk7UUFDNUI7O0tBRUMsR0FDRCxJQUFJLENBQUM0WSxXQUFXLEdBQUdqWSxXQUFXWCxJQUFJO1FBQ2xDOztLQUVDLEdBQ0QsSUFBSSxDQUFDdVYsT0FBTyxHQUFHO1FBQ2Y7O0tBRUMsR0FDRCxJQUFJLENBQUNzRCxXQUFXLEdBQUc7UUFDbkI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0Qjs7S0FFQyxHQUNELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7UUFDNUI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsY0FBYyxHQUFHdlksV0FBV1gsSUFBSTtRQUNyQzs7S0FFQyxHQUNELElBQUksQ0FBQ21aLG9CQUFvQixHQUFHeFksV0FBV1gsSUFBSTtRQUMzQzs7S0FFQyxHQUNELElBQUksQ0FBQ29aLGdCQUFnQixHQUFHO1FBQ3hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc1WSxXQUFXWCxJQUFJO1FBQ25DOztLQUVDLEdBQ0QsSUFBSSxDQUFDd1osa0JBQWtCLEdBQUc3WSxXQUFXWCxJQUFJO1FBQ3pDOztLQUVDLEdBQ0QsSUFBSSxDQUFDeVosY0FBYyxHQUFHO1FBQ3RCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6Qjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2Q7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1o7O0tBRUMsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQnBMLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl5ZixXQUFXM2YsVUFBVSxDQUFDQyxPQUFPQztJQUMxQztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXlmLFdBQVdqZixRQUFRLENBQUNDLFdBQVdUO0lBQzVDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJeWYsV0FBVzllLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDbkQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2lnQixVQUFVL2MsR0FBR0M7SUFDekM7QUFDRjtBQUNBOGMsU0FBUzlmLE9BQU8sR0FBRzBXO0FBQ25Cb0osU0FBU3JoQixRQUFRLEdBQUc7QUFDcEJxaEIsU0FBU3ZkLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2hEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHcUk7UUFDTDtRQUFHO1lBQ0RuWSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdxSTtRQUNMO1FBQUc7WUFDRG5ZLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTmdCLEdBQUcsRUFBRSxvQkFBb0I7WUFDekJDLEdBQUc7Z0JBQ0RqQixNQUFNO2dCQUNORSxHQUFHLEdBQUcscUJBQXFCO1lBQzdCO1FBQ0Y7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdxSTtRQUNMO1FBQUc7WUFDRG5ZLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdxSTtRQUNMO1FBQUc7WUFDRG5ZLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3FJO1FBQ0w7UUFBRztZQUNEblksSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3FJO1FBQ0w7UUFBRztZQUNEblksSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHMFE7UUFDTDtRQUFHO1lBQ0R4Z0IsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHMFE7UUFDTDtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNeUMscUJBQXFCbmlCO0lBQ3pCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3NmLFNBQVMsR0FBR2hhLFdBQVdYLElBQUk7UUFDaEM7O0tBRUMsR0FDRCxJQUFJLENBQUM0YSxLQUFLLEdBQUc7UUFDYnZMLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUkwaEIsZUFBZTVoQixVQUFVLENBQUNDLE9BQU9DO0lBQzlDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJMGhCLGVBQWVsaEIsUUFBUSxDQUFDQyxXQUFXVDtJQUNoRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTBoQixlQUFlL2dCLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDdkQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2tpQixjQUFjaGYsR0FBR0M7SUFDN0M7QUFDRjtBQUNBK2UsYUFBYS9oQixPQUFPLEdBQUcwVztBQUN2QnFMLGFBQWF0akIsUUFBUSxHQUFHO0FBQ3hCc2pCLGFBQWF4ZixNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNwRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7S0FBRTtBQUVGLE1BQU1zVCxnQkFBZ0I7QUFDdEIsTUFBTUMsNkJBQTZCO0lBQUM7SUFBRztJQUFLLElBQUksSUFBSTtJQUFLLElBQUksSUFBSTtJQUFLLElBQUksSUFBSTtJQUFLRDtJQUFlQTtJQUFlQTtJQUFlQTtJQUFlQTtDQUFjO0FBQzdKLE1BQU1FO0lBQ0ovZixZQUFZZ2dCLFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNDLFlBQVksR0FBR0QsZ0JBQWdCN3BCLFlBQVk7ZUFBSTZwQjtTQUFZLEdBQUdGO0lBQ3JFO0lBQ0FJLG1CQUFtQnBsQixPQUFPLEVBQUU7UUFDMUIsSUFBSUEsUUFBUXFsQixVQUFVLElBQUksSUFBSSxDQUFDRixZQUFZLENBQUN6cEIsTUFBTSxFQUFFLE9BQU87UUFDM0QsTUFBTTRwQixhQUFhLElBQUksQ0FBQ0gsWUFBWSxDQUFDbmxCLFFBQVFxbEIsVUFBVSxDQUFDO1FBQ3hELElBQUlybEIsUUFBUXFsQixVQUFVLElBQUksR0FBRyxPQUFPQztRQUNwQyxPQUFPQSxhQUFhOWMsS0FBSytjLE1BQU0sS0FBSztJQUN0QztBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLG9EQUFvRCxHQUdwRCxTQUFTQyxVQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ2hELFNBQVNDLE1BQU0zakIsS0FBSztRQUFJLE9BQU9BLGlCQUFpQnlqQixJQUFJempCLFFBQVEsSUFBSXlqQixFQUFFLFNBQVVHLE9BQU87WUFBSUEsUUFBUTVqQjtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLeWpCLENBQUFBLEtBQU1BLENBQUFBLElBQUlJLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVL2pCLEtBQUs7WUFBSSxJQUFJO2dCQUFFZ2tCLEtBQUtOLFVBQVVPLElBQUksQ0FBQ2prQjtZQUFTLEVBQUUsT0FBTzdKLEdBQUc7Z0JBQUUydEIsT0FBTzN0QjtZQUFJO1FBQUU7UUFDMUYsU0FBUyt0QixTQUFTbGtCLEtBQUs7WUFBSSxJQUFJO2dCQUFFZ2tCLEtBQUtOLFNBQVMsQ0FBQyxRQUFRLENBQUMxakI7WUFBUyxFQUFFLE9BQU83SixHQUFHO2dCQUFFMnRCLE9BQU8zdEI7WUFBSTtRQUFFO1FBQzdGLFNBQVM2dEIsS0FBS25lLE1BQU07WUFBSUEsT0FBT3NlLElBQUksR0FBR1AsUUFBUS9kLE9BQU83RixLQUFLLElBQUkyakIsTUFBTTlkLE9BQU83RixLQUFLLEVBQUVva0IsSUFBSSxDQUFDTCxXQUFXRztRQUFXO1FBQzdHRixLQUFLLENBQUNOLFlBQVlBLFVBQVU3cUIsS0FBSyxDQUFDMHFCLFNBQVNDLGNBQWMsRUFBRSxHQUFHUyxJQUFJO0lBQ3RFO0FBQ0o7QUFFQSxTQUFTSSxTQUFTck8sQ0FBQztJQUNmLElBQUkzSixJQUFJLE9BQU90TixXQUFXLGNBQWNBLE9BQU91bEIsUUFBUSxFQUFFcnVCLElBQUlvVyxLQUFLMkosQ0FBQyxDQUFDM0osRUFBRSxFQUFFOVMsSUFBSTtJQUM1RSxJQUFJdEQsR0FBRyxPQUFPQSxFQUFFd0IsSUFBSSxDQUFDdWU7SUFDckIsSUFBSUEsS0FBSyxPQUFPQSxFQUFFeGMsTUFBTSxLQUFLLFVBQVUsT0FBTztRQUMxQ3lxQixNQUFNO1lBQ0YsSUFBSWpPLEtBQUt6YyxLQUFLeWMsRUFBRXhjLE1BQU0sRUFBRXdjLElBQUksS0FBSztZQUNqQyxPQUFPO2dCQUFFaFcsT0FBT2dXLEtBQUtBLENBQUMsQ0FBQ3pjLElBQUk7Z0JBQUU0cUIsTUFBTSxDQUFDbk87WUFBRTtRQUMxQztJQUNKO0lBQ0EsTUFBTSxJQUFJOVosVUFBVW1RLElBQUksNEJBQTRCO0FBQ3hEO0FBRUEsU0FBU2tZLGNBQWN2TyxDQUFDO0lBQ3BCLElBQUksQ0FBQ2pYLE9BQU95bEIsYUFBYSxFQUFFLE1BQU0sSUFBSXRvQixVQUFVO0lBQy9DLElBQUlqRyxJQUFJK2YsQ0FBQyxDQUFDalgsT0FBT3lsQixhQUFhLENBQUMsRUFBRWpyQjtJQUNqQyxPQUFPdEQsSUFBSUEsRUFBRXdCLElBQUksQ0FBQ3VlLEtBQU1BLENBQUFBLElBQUksT0FBT3FPLGFBQWEsYUFBYUEsU0FBU3JPLEtBQUtBLENBQUMsQ0FBQ2pYLE9BQU91bEIsUUFBUSxDQUFDLElBQUkvcUIsSUFBSSxDQUFDLEdBQUdrckIsS0FBSyxTQUFTQSxLQUFLLFVBQVVBLEtBQUssV0FBV2xyQixDQUFDLENBQUN3RixPQUFPeWxCLGFBQWEsQ0FBQyxHQUFHO1FBQWMsT0FBTyxJQUFJO0lBQUUsR0FBR2pyQixDQUFBQTtJQUM5TSxTQUFTa3JCLEtBQUt6dUIsQ0FBQztRQUFJdUQsQ0FBQyxDQUFDdkQsRUFBRSxHQUFHZ2dCLENBQUMsQ0FBQ2hnQixFQUFFLElBQUksU0FBVXdKLENBQUM7WUFBSSxPQUFPLElBQUlxa0IsUUFBUSxTQUFVRCxPQUFPLEVBQUVFLE1BQU07Z0JBQUl0a0IsSUFBSXdXLENBQUMsQ0FBQ2hnQixFQUFFLENBQUN3SixJQUFJa2xCLE9BQU9kLFNBQVNFLFFBQVF0a0IsRUFBRTJrQixJQUFJLEVBQUUza0IsRUFBRVEsS0FBSztZQUFHO1FBQUk7SUFBRztJQUMvSixTQUFTMGtCLE9BQU9kLE9BQU8sRUFBRUUsTUFBTSxFQUFFcnRCLENBQUMsRUFBRStJLENBQUM7UUFBSXFrQixRQUFRRCxPQUFPLENBQUNwa0IsR0FBRzRrQixJQUFJLENBQUMsU0FBUzVrQixDQUFDO1lBQUlva0IsUUFBUTtnQkFBRTVqQixPQUFPUjtnQkFBRzJrQixNQUFNMXRCO1lBQUU7UUFBSSxHQUFHcXRCO0lBQVM7QUFDL0g7QUFFQSxPQUFPYSxvQkFBb0IsYUFBYUEsa0JBQWtCLFNBQVVDLEtBQUssRUFBRUMsVUFBVSxFQUFFN2lCLE9BQU87SUFDMUYsSUFBSTdMLElBQUksSUFBSThILE1BQU0rRDtJQUNsQixPQUFPN0wsRUFBRTJELElBQUksR0FBRyxtQkFBbUIzRCxFQUFFeXVCLEtBQUssR0FBR0EsT0FBT3p1QixFQUFFMHVCLFVBQVUsR0FBR0EsWUFBWTF1QjtBQUNuRjtBQUVBLElBQUkydUIsU0FBUztJQUFDbnRCLFNBQVMsQ0FBQztBQUFDO0FBRXpCLElBQUlvdEIsSUFBSSxPQUFPQyxZQUFZLFdBQVdBLFVBQVU7QUFDaEQsSUFBSUMsZUFBZUYsS0FBSyxPQUFPQSxFQUFFbHNCLEtBQUssS0FBSyxhQUFha3NCLEVBQUVsc0IsS0FBSyxHQUFHLFNBQVNvc0IsYUFBYWhXLE1BQU0sRUFBRWlXLFFBQVEsRUFBRUMsSUFBSTtJQUM1RyxPQUFPdnNCLFNBQVNyQixTQUFTLENBQUNzQixLQUFLLENBQUNwQixJQUFJLENBQUN3WCxRQUFRaVcsVUFBVUM7QUFDekQ7QUFDQSxJQUFJQztBQUNKLElBQUlMLEtBQUssT0FBT0EsRUFBRU0sT0FBTyxLQUFLLFlBQVk7SUFDeENELGlCQUFpQkwsRUFBRU0sT0FBTztBQUM1QixPQUFPLElBQUkvdUIsT0FBT2d2QixxQkFBcUIsRUFBRTtJQUN2Q0YsaUJBQWlCLFNBQVNBLGVBQWVuVyxNQUFNO1FBQzdDLE9BQU8zWSxPQUFPaXZCLG1CQUFtQixDQUFDdFcsUUFBUWxOLE1BQU0sQ0FBQ3pMLE9BQU9ndkIscUJBQXFCLENBQUNyVztJQUNoRjtBQUNGLE9BQU87SUFDTG1XLGlCQUFpQixTQUFTQSxlQUFlblcsTUFBTTtRQUM3QyxPQUFPM1ksT0FBT2l2QixtQkFBbUIsQ0FBQ3RXO0lBQ3BDO0FBQ0Y7QUFDQSxTQUFTdVcsbUJBQW1CQyxPQUFPO0lBQ2pDLElBQUl6c0IsV0FBV0EsUUFBUTBzQixJQUFJLEVBQUUxc0IsUUFBUTBzQixJQUFJLENBQUNEO0FBQzVDO0FBQ0EsSUFBSUUsY0FBY2xuQixPQUFPdVYsS0FBSyxJQUFJLFNBQVMyUixZQUFZM2xCLEtBQUs7SUFDMUQsT0FBT0EsVUFBVUE7QUFDbkI7QUFDQSxTQUFTNGxCO0lBQ1BBLGFBQWFDLElBQUksQ0FBQ3B1QixJQUFJLENBQUMsSUFBSTtBQUM3QjtBQUNBcXRCLE9BQU9udEIsT0FBTyxHQUFHaXVCO0FBQ2pCZCxPQUFPbnRCLE9BQU8sQ0FBQ211QixJQUFJLEdBQUdBO0FBRXRCLG9DQUFvQztBQUNwQ0YsYUFBYUEsWUFBWSxHQUFHQTtBQUM1QkEsYUFBYXJ1QixTQUFTLENBQUN3dUIsT0FBTyxHQUFHNXNCO0FBQ2pDeXNCLGFBQWFydUIsU0FBUyxDQUFDeXVCLFlBQVksR0FBRztBQUN0Q0osYUFBYXJ1QixTQUFTLENBQUMwdUIsYUFBYSxHQUFHOXNCO0FBRXZDLDhFQUE4RTtBQUM5RSwwRUFBMEU7QUFDMUUsSUFBSStzQixzQkFBc0I7QUFDMUIsU0FBU0MsY0FBY0MsUUFBUTtJQUM3QixJQUFJLE9BQU9BLGFBQWEsWUFBWTtRQUNsQyxNQUFNLElBQUlscUIsVUFBVSxxRUFBcUUsT0FBT2txQjtJQUNsRztBQUNGO0FBQ0E5dkIsT0FBT0ssY0FBYyxDQUFDaXZCLGNBQWMsdUJBQXVCO0lBQ3pEL3VCLFlBQVk7SUFDWkQsS0FBSztRQUNILE9BQU9zdkI7SUFDVDtJQUNBN2MsS0FBSyxTQUFVN0ssR0FBRztRQUNoQixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsTUFBTSxLQUFLbW5CLFlBQVlubkIsTUFBTTtZQUMxRCxNQUFNLElBQUkyTixXQUFXLG9HQUFvRzNOLE1BQU07UUFDakk7UUFDQTBuQixzQkFBc0IxbkI7SUFDeEI7QUFDRjtBQUNBb25CLGFBQWFDLElBQUksR0FBRztJQUNsQixJQUFJLElBQUksQ0FBQ0UsT0FBTyxLQUFLNXNCLGFBQWEsSUFBSSxDQUFDNHNCLE9BQU8sS0FBS3p2QixPQUFPeU0sY0FBYyxDQUFDLElBQUksRUFBRWdqQixPQUFPLEVBQUU7UUFDdEYsSUFBSSxDQUFDQSxPQUFPLEdBQUd6dkIsT0FBT3VKLE1BQU0sQ0FBQztRQUM3QixJQUFJLENBQUNtbUIsWUFBWSxHQUFHO0lBQ3RCO0lBQ0EsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUk5c0I7QUFDN0M7QUFFQSwyRUFBMkU7QUFDM0UsbURBQW1EO0FBQ25EeXNCLGFBQWFydUIsU0FBUyxDQUFDOHVCLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0Jyd0IsQ0FBQztJQUNqRSxJQUFJLE9BQU9BLE1BQU0sWUFBWUEsSUFBSSxLQUFLMnZCLFlBQVkzdkIsSUFBSTtRQUNwRCxNQUFNLElBQUltVyxXQUFXLGtGQUFrRm5XLElBQUk7SUFDN0c7SUFDQSxJQUFJLENBQUNpd0IsYUFBYSxHQUFHandCO0lBQ3JCLE9BQU8sSUFBSTtBQUNiO0FBQ0EsU0FBU3N3QixpQkFBaUJDLElBQUk7SUFDNUIsSUFBSUEsS0FBS04sYUFBYSxLQUFLOXNCLFdBQVcsT0FBT3lzQixhQUFhTSxtQkFBbUI7SUFDN0UsT0FBT0ssS0FBS04sYUFBYTtBQUMzQjtBQUNBTCxhQUFhcnVCLFNBQVMsQ0FBQ2l2QixlQUFlLEdBQUcsU0FBU0E7SUFDaEQsT0FBT0YsaUJBQWlCLElBQUk7QUFDOUI7QUFDQVYsYUFBYXJ1QixTQUFTLENBQUNrdkIsSUFBSSxHQUFHLFNBQVNBLEtBQUt4bEIsSUFBSTtJQUM5QyxJQUFJa2tCLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSTVyQixJQUFJLEdBQUdBLElBQUlULFVBQVVVLE1BQU0sRUFBRUQsSUFBSzRyQixLQUFLamxCLElBQUksQ0FBQ3BILFNBQVMsQ0FBQ1MsRUFBRTtJQUNqRSxJQUFJbXRCLFVBQVV6bEIsU0FBUztJQUN2QixJQUFJNmpCLFNBQVMsSUFBSSxDQUFDaUIsT0FBTztJQUN6QixJQUFJakIsV0FBVzNyQixXQUFXdXRCLFVBQVVBLFdBQVc1QixPQUFPRixLQUFLLEtBQUt6ckI7U0FBZSxJQUFJLENBQUN1dEIsU0FBUyxPQUFPO0lBRXBHLG9EQUFvRDtJQUNwRCxJQUFJQSxTQUFTO1FBQ1gsSUFBSUM7UUFDSixJQUFJeEIsS0FBSzNyQixNQUFNLEdBQUcsR0FBR210QixLQUFLeEIsSUFBSSxDQUFDLEVBQUU7UUFDakMsSUFBSXdCLGNBQWMxb0IsT0FBTztZQUN2QixxRUFBcUU7WUFDckUsaUVBQWlFO1lBQ2pFLE1BQU0wb0IsSUFBSSwwQkFBMEI7UUFDdEM7UUFDQSxpREFBaUQ7UUFDakQsSUFBSUMsTUFBTSxJQUFJM29CLE1BQU0scUJBQXNCMG9CLENBQUFBLEtBQUssT0FBT0EsR0FBRzNrQixPQUFPLEdBQUcsTUFBTSxFQUFDO1FBQzFFNGtCLElBQUk5b0IsT0FBTyxHQUFHNm9CO1FBQ2QsTUFBTUMsS0FBSywwQkFBMEI7SUFDdkM7SUFDQSxJQUFJQyxVQUFVL0IsTUFBTSxDQUFDN2pCLEtBQUs7SUFDMUIsSUFBSTRsQixZQUFZMXRCLFdBQVcsT0FBTztJQUNsQyxJQUFJLE9BQU8wdEIsWUFBWSxZQUFZO1FBQ2pDNUIsYUFBYTRCLFNBQVMsSUFBSSxFQUFFMUI7SUFDOUIsT0FBTztRQUNMLElBQUloYyxNQUFNMGQsUUFBUXJ0QixNQUFNO1FBQ3hCLElBQUlzdEIsWUFBWUMsV0FBV0YsU0FBUzFkO1FBQ3BDLElBQUssSUFBSTVQLElBQUksR0FBR0EsSUFBSTRQLEtBQUssRUFBRTVQLEVBQUcwckIsYUFBYTZCLFNBQVMsQ0FBQ3Z0QixFQUFFLEVBQUUsSUFBSSxFQUFFNHJCO0lBQ2pFO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUzZCLGFBQWEvWCxNQUFNLEVBQUVoTyxJQUFJLEVBQUVtbEIsUUFBUSxFQUFFYSxPQUFPO0lBQ25ELElBQUloeEI7SUFDSixJQUFJNnVCO0lBQ0osSUFBSW9DO0lBQ0pmLGNBQWNDO0lBQ2R0QixTQUFTN1YsT0FBTzhXLE9BQU87SUFDdkIsSUFBSWpCLFdBQVczckIsV0FBVztRQUN4QjJyQixTQUFTN1YsT0FBTzhXLE9BQU8sR0FBR3p2QixPQUFPdUosTUFBTSxDQUFDO1FBQ3hDb1AsT0FBTytXLFlBQVksR0FBRztJQUN4QixPQUFPO1FBQ0wscUVBQXFFO1FBQ3JFLHdEQUF3RDtRQUN4RCxJQUFJbEIsT0FBT3FDLFdBQVcsS0FBS2h1QixXQUFXO1lBQ3BDOFYsT0FBT3dYLElBQUksQ0FBQyxlQUFleGxCLE1BQU1tbEIsU0FBU0EsUUFBUSxHQUFHQSxTQUFTQSxRQUFRLEdBQUdBO1lBRXpFLHlFQUF5RTtZQUN6RSw4Q0FBOEM7WUFDOUN0QixTQUFTN1YsT0FBTzhXLE9BQU87UUFDekI7UUFDQW1CLFdBQVdwQyxNQUFNLENBQUM3akIsS0FBSztJQUN6QjtJQUNBLElBQUlpbUIsYUFBYS90QixXQUFXO1FBQzFCLHdFQUF3RTtRQUN4RSt0QixXQUFXcEMsTUFBTSxDQUFDN2pCLEtBQUssR0FBR21sQjtRQUMxQixFQUFFblgsT0FBTytXLFlBQVk7SUFDdkIsT0FBTztRQUNMLElBQUksT0FBT2tCLGFBQWEsWUFBWTtZQUNsQyxzREFBc0Q7WUFDdERBLFdBQVdwQyxNQUFNLENBQUM3akIsS0FBSyxHQUFHZ21CLFVBQVU7Z0JBQUNiO2dCQUFVYzthQUFTLEdBQUc7Z0JBQUNBO2dCQUFVZDthQUFTO1FBQy9FLDhDQUE4QztRQUNoRCxPQUFPLElBQUlhLFNBQVM7WUFDbEJDLFNBQVNFLE9BQU8sQ0FBQ2hCO1FBQ25CLE9BQU87WUFDTGMsU0FBU2huQixJQUFJLENBQUNrbUI7UUFDaEI7UUFFQSwwQkFBMEI7UUFDMUJud0IsSUFBSXF3QixpQkFBaUJyWDtRQUNyQixJQUFJaFosSUFBSSxLQUFLaXhCLFNBQVMxdEIsTUFBTSxHQUFHdkQsS0FBSyxDQUFDaXhCLFNBQVNHLE1BQU0sRUFBRTtZQUNwREgsU0FBU0csTUFBTSxHQUFHO1lBQ2xCLCtDQUErQztZQUMvQyxnREFBZ0Q7WUFDaEQsSUFBSUMsSUFBSSxJQUFJcnBCLE1BQU0saURBQWlEaXBCLFNBQVMxdEIsTUFBTSxHQUFHLE1BQU15SSxPQUFPaEIsUUFBUSxnQkFBZ0IsNkNBQTZDO1lBQ3ZLcW1CLEVBQUV4dEIsSUFBSSxHQUFHO1lBQ1R3dEIsRUFBRUMsT0FBTyxHQUFHdFk7WUFDWnFZLEVBQUVybUIsSUFBSSxHQUFHQTtZQUNUcW1CLEVBQUVFLEtBQUssR0FBR04sU0FBUzF0QixNQUFNO1lBQ3pCZ3NCLG1CQUFtQjhCO1FBQ3JCO0lBQ0Y7SUFDQSxPQUFPclk7QUFDVDtBQUNBMlcsYUFBYXJ1QixTQUFTLENBQUNrd0IsV0FBVyxHQUFHLFNBQVNBLFlBQVl4bUIsSUFBSSxFQUFFbWxCLFFBQVE7SUFDdEUsT0FBT1ksYUFBYSxJQUFJLEVBQUUvbEIsTUFBTW1sQixVQUFVO0FBQzVDO0FBQ0FSLGFBQWFydUIsU0FBUyxDQUFDbXdCLEVBQUUsR0FBRzlCLGFBQWFydUIsU0FBUyxDQUFDa3dCLFdBQVc7QUFDOUQ3QixhQUFhcnVCLFNBQVMsQ0FBQ293QixlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCMW1CLElBQUksRUFBRW1sQixRQUFRO0lBQzlFLE9BQU9ZLGFBQWEsSUFBSSxFQUFFL2xCLE1BQU1tbEIsVUFBVTtBQUM1QztBQUNBLFNBQVN3QjtJQUNQLElBQUksQ0FBQyxJQUFJLENBQUNDLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQzVZLE1BQU0sQ0FBQzZZLGNBQWMsQ0FBQyxJQUFJLENBQUM3bUIsSUFBSSxFQUFFLElBQUksQ0FBQzhtQixNQUFNO1FBQ2pELElBQUksQ0FBQ0YsS0FBSyxHQUFHO1FBQ2IsSUFBSS91QixVQUFVVSxNQUFNLEtBQUssR0FBRyxPQUFPLElBQUksQ0FBQzRzQixRQUFRLENBQUMzdUIsSUFBSSxDQUFDLElBQUksQ0FBQ3dYLE1BQU07UUFDakUsT0FBTyxJQUFJLENBQUNtWCxRQUFRLENBQUN2dEIsS0FBSyxDQUFDLElBQUksQ0FBQ29XLE1BQU0sRUFBRW5XO0lBQzFDO0FBQ0Y7QUFDQSxTQUFTa3ZCLFVBQVUvWSxNQUFNLEVBQUVoTyxJQUFJLEVBQUVtbEIsUUFBUTtJQUN2QyxJQUFJNUssUUFBUTtRQUNWcU0sT0FBTztRQUNQRSxRQUFRNXVCO1FBQ1I4VixRQUFRQTtRQUNSaE8sTUFBTUE7UUFDTm1sQixVQUFVQTtJQUNaO0lBQ0EsSUFBSTZCLFVBQVVMLFlBQVlqdkIsSUFBSSxDQUFDNmlCO0lBQy9CeU0sUUFBUTdCLFFBQVEsR0FBR0E7SUFDbkI1SyxNQUFNdU0sTUFBTSxHQUFHRTtJQUNmLE9BQU9BO0FBQ1Q7QUFDQXJDLGFBQWFydUIsU0FBUyxDQUFDdXVCLElBQUksR0FBRyxTQUFTQSxLQUFLN2tCLElBQUksRUFBRW1sQixRQUFRO0lBQ3hERCxjQUFjQztJQUNkLElBQUksQ0FBQ3NCLEVBQUUsQ0FBQ3ptQixNQUFNK21CLFVBQVUsSUFBSSxFQUFFL21CLE1BQU1tbEI7SUFDcEMsT0FBTyxJQUFJO0FBQ2I7QUFDQVIsYUFBYXJ1QixTQUFTLENBQUMyd0IsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQW9Cam5CLElBQUksRUFBRW1sQixRQUFRO0lBQ3RGRCxjQUFjQztJQUNkLElBQUksQ0FBQ3VCLGVBQWUsQ0FBQzFtQixNQUFNK21CLFVBQVUsSUFBSSxFQUFFL21CLE1BQU1tbEI7SUFDakQsT0FBTyxJQUFJO0FBQ2I7QUFFQSwwRUFBMEU7QUFDMUVSLGFBQWFydUIsU0FBUyxDQUFDdXdCLGNBQWMsR0FBRyxTQUFTQSxlQUFlN21CLElBQUksRUFBRW1sQixRQUFRO0lBQzVFLElBQUl6USxNQUFNbVAsUUFBUXFELFVBQVU1dUIsR0FBRzZ1QjtJQUMvQmpDLGNBQWNDO0lBQ2R0QixTQUFTLElBQUksQ0FBQ2lCLE9BQU87SUFDckIsSUFBSWpCLFdBQVczckIsV0FBVyxPQUFPLElBQUk7SUFDckN3YyxPQUFPbVAsTUFBTSxDQUFDN2pCLEtBQUs7SUFDbkIsSUFBSTBVLFNBQVN4YyxXQUFXLE9BQU8sSUFBSTtJQUNuQyxJQUFJd2MsU0FBU3lRLFlBQVl6USxLQUFLeVEsUUFBUSxLQUFLQSxVQUFVO1FBQ25ELElBQUksRUFBRSxJQUFJLENBQUNKLFlBQVksS0FBSyxHQUFHLElBQUksQ0FBQ0QsT0FBTyxHQUFHenZCLE9BQU91SixNQUFNLENBQUM7YUFBVztZQUNyRSxPQUFPaWxCLE1BQU0sQ0FBQzdqQixLQUFLO1lBQ25CLElBQUk2akIsT0FBT2dELGNBQWMsRUFBRSxJQUFJLENBQUNyQixJQUFJLENBQUMsa0JBQWtCeGxCLE1BQU0wVSxLQUFLeVEsUUFBUSxJQUFJQTtRQUNoRjtJQUNGLE9BQU8sSUFBSSxPQUFPelEsU0FBUyxZQUFZO1FBQ3JDd1MsV0FBVyxDQUFDO1FBQ1osSUFBSzV1QixJQUFJb2MsS0FBS25jLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDckMsSUFBSW9jLElBQUksQ0FBQ3BjLEVBQUUsS0FBSzZzQixZQUFZelEsSUFBSSxDQUFDcGMsRUFBRSxDQUFDNnNCLFFBQVEsS0FBS0EsVUFBVTtnQkFDekRnQyxtQkFBbUJ6UyxJQUFJLENBQUNwYyxFQUFFLENBQUM2c0IsUUFBUTtnQkFDbkMrQixXQUFXNXVCO2dCQUNYO1lBQ0Y7UUFDRjtRQUNBLElBQUk0dUIsV0FBVyxHQUFHLE9BQU8sSUFBSTtRQUM3QixJQUFJQSxhQUFhLEdBQUd4UyxLQUFLeFIsS0FBSzthQUFRO1lBQ3BDa2tCLFVBQVUxUyxNQUFNd1M7UUFDbEI7UUFDQSxJQUFJeFMsS0FBS25jLE1BQU0sS0FBSyxHQUFHc3JCLE1BQU0sQ0FBQzdqQixLQUFLLEdBQUcwVSxJQUFJLENBQUMsRUFBRTtRQUM3QyxJQUFJbVAsT0FBT2dELGNBQWMsS0FBSzN1QixXQUFXLElBQUksQ0FBQ3N0QixJQUFJLENBQUMsa0JBQWtCeGxCLE1BQU1tbkIsb0JBQW9CaEM7SUFDakc7SUFDQSxPQUFPLElBQUk7QUFDYjtBQUNBUixhQUFhcnVCLFNBQVMsQ0FBQyt3QixHQUFHLEdBQUcxQyxhQUFhcnVCLFNBQVMsQ0FBQ3V3QixjQUFjO0FBQ2xFbEMsYUFBYXJ1QixTQUFTLENBQUNneEIsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW1CdG5CLElBQUk7SUFDMUUsSUFBSTZsQixXQUFXaEMsUUFBUXZyQjtJQUN2QnVyQixTQUFTLElBQUksQ0FBQ2lCLE9BQU87SUFDckIsSUFBSWpCLFdBQVczckIsV0FBVyxPQUFPLElBQUk7SUFFckMsb0RBQW9EO0lBQ3BELElBQUkyckIsT0FBT2dELGNBQWMsS0FBSzN1QixXQUFXO1FBQ3ZDLElBQUlMLFVBQVVVLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ3VzQixPQUFPLEdBQUd6dkIsT0FBT3VKLE1BQU0sQ0FBQztZQUM3QixJQUFJLENBQUNtbUIsWUFBWSxHQUFHO1FBQ3RCLE9BQU8sSUFBSWxCLE1BQU0sQ0FBQzdqQixLQUFLLEtBQUs5SCxXQUFXO1lBQ3JDLElBQUksRUFBRSxJQUFJLENBQUM2c0IsWUFBWSxLQUFLLEdBQUcsSUFBSSxDQUFDRCxPQUFPLEdBQUd6dkIsT0FBT3VKLE1BQU0sQ0FBQztpQkFBVyxPQUFPaWxCLE1BQU0sQ0FBQzdqQixLQUFLO1FBQzVGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFFQSxzREFBc0Q7SUFDdEQsSUFBSW5JLFVBQVVVLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlqRCxPQUFPRCxPQUFPQyxJQUFJLENBQUN1dUI7UUFDdkIsSUFBSTNVO1FBQ0osSUFBSzVXLElBQUksR0FBR0EsSUFBSWhELEtBQUtpRCxNQUFNLEVBQUUsRUFBRUQsRUFBRztZQUNoQzRXLE1BQU01WixJQUFJLENBQUNnRCxFQUFFO1lBQ2IsSUFBSTRXLFFBQVEsa0JBQWtCO1lBQzlCLElBQUksQ0FBQ29ZLGtCQUFrQixDQUFDcFk7UUFDMUI7UUFDQSxJQUFJLENBQUNvWSxrQkFBa0IsQ0FBQztRQUN4QixJQUFJLENBQUN4QyxPQUFPLEdBQUd6dkIsT0FBT3VKLE1BQU0sQ0FBQztRQUM3QixJQUFJLENBQUNtbUIsWUFBWSxHQUFHO1FBQ3BCLE9BQU8sSUFBSTtJQUNiO0lBQ0FjLFlBQVloQyxNQUFNLENBQUM3akIsS0FBSztJQUN4QixJQUFJLE9BQU82bEIsY0FBYyxZQUFZO1FBQ25DLElBQUksQ0FBQ2dCLGNBQWMsQ0FBQzdtQixNQUFNNmxCO0lBQzVCLE9BQU8sSUFBSUEsY0FBYzN0QixXQUFXO1FBQ2xDLGFBQWE7UUFDYixJQUFLSSxJQUFJdXRCLFVBQVV0dEIsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztZQUMxQyxJQUFJLENBQUN1dUIsY0FBYyxDQUFDN21CLE1BQU02bEIsU0FBUyxDQUFDdnRCLEVBQUU7UUFDeEM7SUFDRjtJQUNBLE9BQU8sSUFBSTtBQUNiO0FBQ0EsU0FBU2l2QixXQUFXdlosTUFBTSxFQUFFaE8sSUFBSSxFQUFFd25CLE1BQU07SUFDdEMsSUFBSTNELFNBQVM3VixPQUFPOFcsT0FBTztJQUMzQixJQUFJakIsV0FBVzNyQixXQUFXLE9BQU8sRUFBRTtJQUNuQyxJQUFJdXZCLGFBQWE1RCxNQUFNLENBQUM3akIsS0FBSztJQUM3QixJQUFJeW5CLGVBQWV2dkIsV0FBVyxPQUFPLEVBQUU7SUFDdkMsSUFBSSxPQUFPdXZCLGVBQWUsWUFBWSxPQUFPRCxTQUFTO1FBQUNDLFdBQVd0QyxRQUFRLElBQUlzQztLQUFXLEdBQUc7UUFBQ0E7S0FBVztJQUN4RyxPQUFPRCxTQUFTRSxnQkFBZ0JELGNBQWMzQixXQUFXMkIsWUFBWUEsV0FBV2x2QixNQUFNO0FBQ3hGO0FBQ0Fvc0IsYUFBYXJ1QixTQUFTLENBQUN1dkIsU0FBUyxHQUFHLFNBQVNBLFVBQVU3bEIsSUFBSTtJQUN4RCxPQUFPdW5CLFdBQVcsSUFBSSxFQUFFdm5CLE1BQU07QUFDaEM7QUFDQTJrQixhQUFhcnVCLFNBQVMsQ0FBQ3F4QixZQUFZLEdBQUcsU0FBU0EsYUFBYTNuQixJQUFJO0lBQzlELE9BQU91bkIsV0FBVyxJQUFJLEVBQUV2bkIsTUFBTTtBQUNoQztBQUNBMmtCLGFBQWFpRCxhQUFhLEdBQUcsU0FBVXRCLE9BQU8sRUFBRXRtQixJQUFJO0lBQ2xELElBQUksT0FBT3NtQixRQUFRc0IsYUFBYSxLQUFLLFlBQVk7UUFDL0MsT0FBT3RCLFFBQVFzQixhQUFhLENBQUM1bkI7SUFDL0IsT0FBTztRQUNMLE9BQU80bkIsY0FBY3B4QixJQUFJLENBQUM4dkIsU0FBU3RtQjtJQUNyQztBQUNGO0FBQ0Eya0IsYUFBYXJ1QixTQUFTLENBQUNzeEIsYUFBYSxHQUFHQTtBQUN2QyxTQUFTQSxjQUFjNW5CLElBQUk7SUFDekIsSUFBSTZqQixTQUFTLElBQUksQ0FBQ2lCLE9BQU87SUFDekIsSUFBSWpCLFdBQVczckIsV0FBVztRQUN4QixJQUFJdXZCLGFBQWE1RCxNQUFNLENBQUM3akIsS0FBSztRQUM3QixJQUFJLE9BQU95bkIsZUFBZSxZQUFZO1lBQ3BDLE9BQU87UUFDVCxPQUFPLElBQUlBLGVBQWV2dkIsV0FBVztZQUNuQyxPQUFPdXZCLFdBQVdsdkIsTUFBTTtRQUMxQjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0Fvc0IsYUFBYXJ1QixTQUFTLENBQUN1eEIsVUFBVSxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sSUFBSSxDQUFDOUMsWUFBWSxHQUFHLElBQUlaLGVBQWUsSUFBSSxDQUFDVyxPQUFPLElBQUksRUFBRTtBQUNsRTtBQUNBLFNBQVNnQixXQUFXblgsR0FBRyxFQUFFNVosQ0FBQztJQUN4QixJQUFJOGUsT0FBTyxJQUFJMWUsTUFBTUo7SUFDckIsSUFBSyxJQUFJdUQsSUFBSSxHQUFHQSxJQUFJdkQsR0FBRyxFQUFFdUQsRUFBR3ViLElBQUksQ0FBQ3ZiLEVBQUUsR0FBR3FXLEdBQUcsQ0FBQ3JXLEVBQUU7SUFDNUMsT0FBT3ViO0FBQ1Q7QUFDQSxTQUFTdVQsVUFBVTFTLElBQUksRUFBRW9ULEtBQUs7SUFDNUIsTUFBT0EsUUFBUSxJQUFJcFQsS0FBS25jLE1BQU0sRUFBRXV2QixRQUFTcFQsSUFBSSxDQUFDb1QsTUFBTSxHQUFHcFQsSUFBSSxDQUFDb1QsUUFBUSxFQUFFO0lBQ3RFcFQsS0FBS2pNLEdBQUc7QUFDVjtBQUNBLFNBQVNpZixnQkFBZ0IvWSxHQUFHO0lBQzFCLElBQUlvWixNQUFNLElBQUk1eUIsTUFBTXdaLElBQUlwVyxNQUFNO0lBQzlCLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJeXZCLElBQUl4dkIsTUFBTSxFQUFFLEVBQUVELEVBQUc7UUFDbkN5dkIsR0FBRyxDQUFDenZCLEVBQUUsR0FBR3FXLEdBQUcsQ0FBQ3JXLEVBQUUsQ0FBQzZzQixRQUFRLElBQUl4VyxHQUFHLENBQUNyVyxFQUFFO0lBQ3BDO0lBQ0EsT0FBT3l2QjtBQUNUO0FBQ0EsU0FBU2xELEtBQUt5QixPQUFPLEVBQUV6dEIsSUFBSTtJQUN6QixPQUFPLElBQUkrcEIsUUFBUSxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDMUMsU0FBU21GLGNBQWNyQyxHQUFHO1lBQ3hCVyxRQUFRTyxjQUFjLENBQUNodUIsTUFBTW92QjtZQUM3QnBGLE9BQU84QztRQUNUO1FBQ0EsU0FBU3NDO1lBQ1AsSUFBSSxPQUFPM0IsUUFBUU8sY0FBYyxLQUFLLFlBQVk7Z0JBQ2hEUCxRQUFRTyxjQUFjLENBQUMsU0FBU21CO1lBQ2xDO1lBQ0FyRixRQUFRLEVBQUUsQ0FBQzNvQixLQUFLLENBQUN4RCxJQUFJLENBQUNxQjtRQUN4QjtRQUNBcXdCLCtCQUErQjVCLFNBQVN6dEIsTUFBTW92QixVQUFVO1lBQ3REcEQsTUFBTTtRQUNSO1FBQ0EsSUFBSWhzQixTQUFTLFNBQVM7WUFDcEJzdkIsOEJBQThCN0IsU0FBUzBCLGVBQWU7Z0JBQ3BEbkQsTUFBTTtZQUNSO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU3NELDhCQUE4QjdCLE9BQU8sRUFBRVYsT0FBTyxFQUFFd0MsS0FBSztJQUM1RCxJQUFJLE9BQU85QixRQUFRRyxFQUFFLEtBQUssWUFBWTtRQUNwQ3lCLCtCQUErQjVCLFNBQVMsU0FBU1YsU0FBU3dDO0lBQzVEO0FBQ0Y7QUFDQSxTQUFTRiwrQkFBK0I1QixPQUFPLEVBQUV6dEIsSUFBSSxFQUFFc3NCLFFBQVEsRUFBRWlELEtBQUs7SUFDcEUsSUFBSSxPQUFPOUIsUUFBUUcsRUFBRSxLQUFLLFlBQVk7UUFDcEMsSUFBSTJCLE1BQU12RCxJQUFJLEVBQUU7WUFDZHlCLFFBQVF6QixJQUFJLENBQUNoc0IsTUFBTXNzQjtRQUNyQixPQUFPO1lBQ0xtQixRQUFRRyxFQUFFLENBQUM1dEIsTUFBTXNzQjtRQUNuQjtJQUNGLE9BQU8sSUFBSSxPQUFPbUIsUUFBUStCLGdCQUFnQixLQUFLLFlBQVk7UUFDekQsOERBQThEO1FBQzlELDJEQUEyRDtRQUMzRC9CLFFBQVErQixnQkFBZ0IsQ0FBQ3h2QixNQUFNLFNBQVN5dkIsYUFBYS9xQixHQUFHO1lBQ3RELDBEQUEwRDtZQUMxRCwwQkFBMEI7WUFDMUIsSUFBSTZxQixNQUFNdkQsSUFBSSxFQUFFO2dCQUNkeUIsUUFBUWlDLG1CQUFtQixDQUFDMXZCLE1BQU15dkI7WUFDcEM7WUFDQW5ELFNBQVM1bkI7UUFDWDtJQUNGLE9BQU87UUFDTCxNQUFNLElBQUl0QyxVQUFVLHdFQUF3RSxPQUFPcXJCO0lBQ3JHO0FBQ0Y7QUFDQSxJQUFJa0MsZ0JBQWdCM0UsT0FBT250QixPQUFPO0FBRWxDOzs7Ozs7Q0FNQyxHQUNELG1CQUFtQixHQUVuQixJQUFJK3hCLGVBQWU7QUFDbkIsSUFBSUMsdUJBQXVCO0FBRTNCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxlQUFlQyxRQUFRLEVBQUVDLElBQUksRUFBRXpsQixHQUFHO0lBQ3pDLE1BQU0yVCxRQUFRNlIsU0FBUzdSLEtBQUssQ0FBQzhSO0lBQzdCLE9BQU85UixTQUFTQSxNQUFNeGUsTUFBTSxJQUFJNkssT0FBT3VNLFNBQVNvSCxLQUFLLENBQUMzVCxJQUFJLEVBQUU7QUFDOUQ7QUFFQSwrREFBK0Q7QUFDL0QsK0RBQStEO0FBQy9ELGNBQWM7QUFDZCxTQUFTMGxCLHdCQUF3Qjl5QixPQUFNLEVBQUUreUIsZUFBZSxFQUFFQyxPQUFPO0lBQy9ELElBQUksQ0FBQ2h6QixRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzdCO0lBQ0Y7SUFDQSxNQUFNQyxRQUFRbHpCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUztJQUNoRCxNQUFNNnlCLHlCQUF5QkQsTUFBTWIsZ0JBQWdCO0lBQ3JEYSxNQUFNYixnQkFBZ0IsR0FBRyxTQUFVZSxlQUFlLEVBQUVDLEVBQUU7UUFDcEQsSUFBSUQsb0JBQW9CTCxpQkFBaUI7WUFDdkMsT0FBT0ksdUJBQXVCdnhCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1FBQzVDO1FBQ0EsTUFBTXl4QixrQkFBa0JwMEIsQ0FBQUE7WUFDdEIsTUFBTXEwQixnQkFBZ0JQLFFBQVE5ekI7WUFDOUIsSUFBSXEwQixlQUFlO2dCQUNqQixJQUFJRixHQUFHRyxXQUFXLEVBQUU7b0JBQ2xCSCxHQUFHRyxXQUFXLENBQUNEO2dCQUNqQixPQUFPO29CQUNMRixHQUFHRTtnQkFDTDtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNFLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsSUFBSSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUNBLFNBQVMsQ0FBQ1YsZ0JBQWdCLEVBQUU7WUFDcEMsSUFBSSxDQUFDVSxTQUFTLENBQUNWLGdCQUFnQixHQUFHLElBQUlXO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDRCxTQUFTLENBQUNWLGdCQUFnQixDQUFDM2dCLEdBQUcsQ0FBQ2loQixJQUFJQztRQUN4QyxPQUFPSCx1QkFBdUJ2eEIsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDd3hCO1lBQWlCRTtTQUFnQjtJQUM5RTtJQUNBLE1BQU1LLDRCQUE0QlQsTUFBTVgsbUJBQW1CO0lBQzNEVyxNQUFNWCxtQkFBbUIsR0FBRyxTQUFVYSxlQUFlLEVBQUVDLEVBQUU7UUFDdkQsSUFBSUQsb0JBQW9CTCxtQkFBbUIsQ0FBQyxJQUFJLENBQUNVLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQ0EsU0FBUyxDQUFDVixnQkFBZ0IsRUFBRTtZQUM5RixPQUFPWSwwQkFBMEIveEIsS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDL0M7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDNHhCLFNBQVMsQ0FBQ1YsZ0JBQWdCLENBQUNoVCxHQUFHLENBQUNzVCxLQUFLO1lBQzVDLE9BQU9NLDBCQUEwQi94QixLQUFLLENBQUMsSUFBSSxFQUFFQztRQUMvQztRQUNBLE1BQU0reEIsY0FBYyxJQUFJLENBQUNILFNBQVMsQ0FBQ1YsZ0JBQWdCLENBQUNwekIsR0FBRyxDQUFDMHpCO1FBQ3hELElBQUksQ0FBQ0ksU0FBUyxDQUFDVixnQkFBZ0IsQ0FBQ2MsTUFBTSxDQUFDUjtRQUN2QyxJQUFJLElBQUksQ0FBQ0ksU0FBUyxDQUFDVixnQkFBZ0IsQ0FBQ2UsSUFBSSxLQUFLLEdBQUc7WUFDOUMsT0FBTyxJQUFJLENBQUNMLFNBQVMsQ0FBQ1YsZ0JBQWdCO1FBQ3hDO1FBQ0EsSUFBSTF6QixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDbTBCLFNBQVMsRUFBRWx4QixNQUFNLEtBQUssR0FBRztZQUM1QyxPQUFPLElBQUksQ0FBQ2t4QixTQUFTO1FBQ3ZCO1FBQ0EsT0FBT0UsMEJBQTBCL3hCLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQ3d4QjtZQUFpQlE7U0FBWTtJQUM3RTtJQUNBdjBCLE9BQU9LLGNBQWMsQ0FBQ3d6QixPQUFPLE9BQU9ILGlCQUFpQjtRQUNuRHB6QjtZQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVFvekIsZ0JBQWdCO1FBQ3RDO1FBQ0EzZ0IsS0FBSWloQixFQUFFO1lBQ0osSUFBSSxJQUFJLENBQUMsUUFBUU4sZ0JBQWdCLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQ1IsbUJBQW1CLENBQUNRLGlCQUFpQixJQUFJLENBQUMsUUFBUUEsZ0JBQWdCO2dCQUN2RSxPQUFPLElBQUksQ0FBQyxRQUFRQSxnQkFBZ0I7WUFDdEM7WUFDQSxJQUFJTSxJQUFJO2dCQUNOLElBQUksQ0FBQ2hCLGdCQUFnQixDQUFDVSxpQkFBaUIsSUFBSSxDQUFDLFFBQVFBLGdCQUFnQixHQUFHTTtZQUN6RTtRQUNGO1FBQ0F6ekIsWUFBWTtRQUNabTBCLGNBQWM7SUFDaEI7QUFDRjtBQUNBLFNBQVNDLFdBQVdqaEIsSUFBSTtJQUN0QixJQUFJLE9BQU9BLFNBQVMsV0FBVztRQUM3QixPQUFPLElBQUkvTCxNQUFNLG9CQUFvQixPQUFPK0wsT0FBTztJQUNyRDtJQUNBMGYsZUFBZTFmO0lBQ2YsT0FBT0EsT0FBTyxnQ0FBZ0M7QUFDaEQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTa2hCLGdCQUFnQmxoQixJQUFJO0lBQzNCLElBQUksT0FBT0EsU0FBUyxXQUFXO1FBQzdCLE9BQU8sSUFBSS9MLE1BQU0sb0JBQW9CLE9BQU8rTCxPQUFPO0lBQ3JEO0lBQ0EyZix1QkFBdUIsQ0FBQzNmO0lBQ3hCLE9BQU8scUNBQXNDQSxDQUFBQSxPQUFPLGFBQWEsU0FBUTtBQUMzRTtBQUNBLFNBQVNqUztJQUNQLElBQUksS0FBa0IsRUFBVSxFQU8vQjtBQUNIO0FBRUE7O0NBRUMsR0FDRCxTQUFTb3pCLFdBQVdDLFNBQVMsRUFBRUMsU0FBUztJQUN0QyxJQUFJLENBQUMxQixzQkFBc0I7UUFDekI7SUFDRjtJQUNBM3dCLFFBQVEwc0IsSUFBSSxDQUFDMEYsWUFBWSxnQ0FBZ0NDLFlBQVk7QUFDdkU7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGNBQWNyMEIsT0FBTTtJQUMzQiwwQkFBMEI7SUFDMUIsTUFBTTRPLFNBQVM7UUFDYndaLFNBQVM7UUFDVHhELFNBQVM7SUFDWDtJQUVBLG1DQUFtQztJQUNuQyxJQUFJLE9BQU81a0IsWUFBVyxlQUFlLENBQUNBLFFBQU9rQixTQUFTLElBQUksQ0FBQ2xCLFFBQU9rQixTQUFTLENBQUNFLFNBQVMsRUFBRTtRQUNyRndOLE9BQU93WixPQUFPLEdBQUc7UUFDakIsT0FBT3haO0lBQ1Q7SUFDQSxNQUFNLEVBQ0oxTixXQUFBQSxVQUFTLEVBQ1YsR0FBR2xCO0lBQ0osSUFBSWtCLFdBQVVvekIsZUFBZSxFQUFFO1FBQzdCLFdBQVc7UUFDWDFsQixPQUFPd1osT0FBTyxHQUFHO1FBQ2pCeFosT0FBT2dXLE9BQU8sR0FBRytOLGVBQWV6eEIsV0FBVUUsU0FBUyxFQUFFLG9CQUFvQjtJQUMzRSxPQUFPLElBQUlGLFdBQVVxekIsa0JBQWtCLElBQUl2MEIsUUFBT3cwQixlQUFlLEtBQUssU0FBU3gwQixRQUFPeTBCLHVCQUF1QixFQUFFO1FBQzdHLG9DQUFvQztRQUNwQyx5Q0FBeUM7UUFDekMsc0VBQXNFO1FBQ3RFLHdEQUF3RDtRQUN4RDdsQixPQUFPd1osT0FBTyxHQUFHO1FBQ2pCeFosT0FBT2dXLE9BQU8sR0FBRytOLGVBQWV6eEIsV0FBVUUsU0FBUyxFQUFFLHlCQUF5QjtJQUNoRixPQUFPLElBQUlwQixRQUFPaXpCLGlCQUFpQixJQUFJL3hCLFdBQVVFLFNBQVMsQ0FBQzJmLEtBQUssQ0FBQyx5QkFBeUI7UUFDeEYsVUFBVTtRQUNWblMsT0FBT3daLE9BQU8sR0FBRztRQUNqQnhaLE9BQU9nVyxPQUFPLEdBQUcrTixlQUFlenhCLFdBQVVFLFNBQVMsRUFBRSx3QkFBd0I7UUFDN0V3TixPQUFPOGxCLG1CQUFtQixHQUFHMTBCLFFBQU8yMEIsaUJBQWlCLElBQUksc0JBQXNCMzBCLFFBQU8yMEIsaUJBQWlCLENBQUNyMEIsU0FBUztJQUNuSCxPQUFPO1FBQ0wsc0NBQXNDO1FBQ3RDc08sT0FBT3daLE9BQU8sR0FBRztRQUNqQixPQUFPeFo7SUFDVDtJQUNBLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNnbUIsU0FBU3piLEdBQUc7SUFDbkIsT0FBTzlaLE9BQU9pQixTQUFTLENBQUNpUCxRQUFRLENBQUMvTyxJQUFJLENBQUMyWSxTQUFTO0FBQ2pEO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMwYixjQUFjem9CLElBQUk7SUFDekIsSUFBSSxDQUFDd29CLFNBQVN4b0IsT0FBTztRQUNuQixPQUFPQTtJQUNUO0lBQ0EsT0FBTy9NLE9BQU9DLElBQUksQ0FBQzhNLE1BQU0wb0IsTUFBTSxDQUFDLFNBQVVDLFdBQVcsRUFBRTdiLEdBQUc7UUFDeEQsTUFBTThiLFFBQVFKLFNBQVN4b0IsSUFBSSxDQUFDOE0sSUFBSTtRQUNoQyxNQUFNblEsUUFBUWlzQixRQUFRSCxjQUFjem9CLElBQUksQ0FBQzhNLElBQUksSUFBSTlNLElBQUksQ0FBQzhNLElBQUk7UUFDMUQsTUFBTStiLGdCQUFnQkQsU0FBUyxDQUFDMzFCLE9BQU9DLElBQUksQ0FBQ3lKLE9BQU94RyxNQUFNO1FBQ3pELElBQUl3RyxVQUFVN0csYUFBYSt5QixlQUFlO1lBQ3hDLE9BQU9GO1FBQ1Q7UUFDQSxPQUFPMTFCLE9BQU9nSyxNQUFNLENBQUMwckIsYUFBYTtZQUNoQyxDQUFDN2IsSUFBSSxFQUFFblE7UUFDVDtJQUNGLEdBQUcsQ0FBQztBQUNOO0FBRUEseUNBQXlDLEdBQ3pDLFNBQVNtc0IsVUFBVUMsS0FBSyxFQUFFam5CLElBQUksRUFBRWtuQixTQUFTO0lBQ3ZDLElBQUksQ0FBQ2xuQixRQUFRa25CLFVBQVVyVixHQUFHLENBQUM3UixLQUFLbW5CLEVBQUUsR0FBRztRQUNuQztJQUNGO0lBQ0FELFVBQVVoakIsR0FBRyxDQUFDbEUsS0FBS21uQixFQUFFLEVBQUVubkI7SUFDdkI3TyxPQUFPQyxJQUFJLENBQUM0TyxNQUFNalAsT0FBTyxDQUFDNEQsQ0FBQUE7UUFDeEIsSUFBSUEsS0FBS3l5QixRQUFRLENBQUMsT0FBTztZQUN2QkosVUFBVUMsT0FBT0EsTUFBTXgxQixHQUFHLENBQUN1TyxJQUFJLENBQUNyTCxLQUFLLEdBQUd1eUI7UUFDMUMsT0FBTyxJQUFJdnlCLEtBQUt5eUIsUUFBUSxDQUFDLFFBQVE7WUFDL0JwbkIsSUFBSSxDQUFDckwsS0FBSyxDQUFDNUQsT0FBTyxDQUFDbzJCLENBQUFBO2dCQUNqQkgsVUFBVUMsT0FBT0EsTUFBTXgxQixHQUFHLENBQUMwMUIsS0FBS0Q7WUFDbEM7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxnREFBZ0QsR0FDaEQsU0FBU0csWUFBWTNtQixNQUFNLEVBQUU0bUIsS0FBSyxFQUFFQyxRQUFRO0lBQzFDLE1BQU1DLGtCQUFrQkQsV0FBVyxpQkFBaUI7SUFDcEQsTUFBTUUsaUJBQWlCLElBQUlqQztJQUMzQixJQUFJOEIsVUFBVSxNQUFNO1FBQ2xCLE9BQU9HO0lBQ1Q7SUFDQSxNQUFNQyxhQUFhLEVBQUU7SUFDckJobkIsT0FBTzNQLE9BQU8sQ0FBQzhKLENBQUFBO1FBQ2IsSUFBSUEsTUFBTWlCLElBQUksS0FBSyxXQUFXakIsTUFBTThzQixlQUFlLEtBQUtMLE1BQU1ILEVBQUUsRUFBRTtZQUNoRU8sV0FBVzNzQixJQUFJLENBQUNGO1FBQ2xCO0lBQ0Y7SUFDQTZzQixXQUFXMzJCLE9BQU8sQ0FBQzYyQixDQUFBQTtRQUNqQmxuQixPQUFPM1AsT0FBTyxDQUFDazJCLENBQUFBO1lBQ2IsSUFBSUEsTUFBTW5yQixJQUFJLEtBQUswckIsbUJBQW1CUCxNQUFNWSxPQUFPLEtBQUtELFVBQVVULEVBQUUsRUFBRTtnQkFDcEVILFVBQVV0bUIsUUFBUXVtQixPQUFPUTtZQUMzQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPQTtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsbUJBQW1CLEdBQ25CLE1BQU1LLFVBQVVsMUI7QUFDaEIsU0FBU20xQixtQkFBbUJqMkIsT0FBTSxFQUFFazJCLGNBQWM7SUFDaEQsTUFBTWgxQixhQUFZbEIsV0FBVUEsUUFBT2tCLFNBQVM7SUFDNUMsSUFBSSxDQUFDQSxXQUFVaTFCLFlBQVksRUFBRTtRQUMzQjtJQUNGO0lBQ0EsTUFBTUMsdUJBQXVCLFNBQVUxZSxDQUFDO1FBQ3RDLElBQUksT0FBT0EsTUFBTSxZQUFZQSxFQUFFMmUsU0FBUyxJQUFJM2UsRUFBRTRlLFFBQVEsRUFBRTtZQUN0RCxPQUFPNWU7UUFDVDtRQUNBLE1BQU02ZSxLQUFLLENBQUM7UUFDWmwzQixPQUFPQyxJQUFJLENBQUNvWSxHQUFHelksT0FBTyxDQUFDaWEsQ0FBQUE7WUFDckIsSUFBSUEsUUFBUSxhQUFhQSxRQUFRLGNBQWNBLFFBQVEsZUFBZTtnQkFDcEU7WUFDRjtZQUNBLE1BQU11RCxJQUFJLE9BQU8vRSxDQUFDLENBQUN3QixJQUFJLEtBQUssV0FBV3hCLENBQUMsQ0FBQ3dCLElBQUksR0FBRztnQkFDOUNzZCxPQUFPOWUsQ0FBQyxDQUFDd0IsSUFBSTtZQUNmO1lBQ0EsSUFBSXVELEVBQUVnYSxLQUFLLEtBQUt2MEIsYUFBYSxPQUFPdWEsRUFBRWdhLEtBQUssS0FBSyxVQUFVO2dCQUN4RGhhLEVBQUVpSCxHQUFHLEdBQUdqSCxFQUFFa0gsR0FBRyxHQUFHbEgsRUFBRWdhLEtBQUs7WUFDekI7WUFDQSxNQUFNQyxXQUFXLFNBQVVDLE1BQU0sRUFBRTl6QixJQUFJO2dCQUNyQyxJQUFJOHpCLFFBQVE7b0JBQ1YsT0FBT0EsU0FBUzl6QixLQUFLNmMsTUFBTSxDQUFDLEdBQUdyYyxXQUFXLEtBQUtSLEtBQUttQixLQUFLLENBQUM7Z0JBQzVEO2dCQUNBLE9BQU9uQixTQUFTLGFBQWEsYUFBYUE7WUFDNUM7WUFDQSxJQUFJNFosRUFBRStaLEtBQUssS0FBS3QwQixXQUFXO2dCQUN6QnEwQixHQUFHRCxRQUFRLEdBQUdDLEdBQUdELFFBQVEsSUFBSSxFQUFFO2dCQUMvQixJQUFJTSxLQUFLLENBQUM7Z0JBQ1YsSUFBSSxPQUFPbmEsRUFBRStaLEtBQUssS0FBSyxVQUFVO29CQUMvQkksRUFBRSxDQUFDRixTQUFTLE9BQU94ZCxLQUFLLEdBQUd1RCxFQUFFK1osS0FBSztvQkFDbENELEdBQUdELFFBQVEsQ0FBQ3J0QixJQUFJLENBQUMydEI7b0JBQ2pCQSxLQUFLLENBQUM7b0JBQ05BLEVBQUUsQ0FBQ0YsU0FBUyxPQUFPeGQsS0FBSyxHQUFHdUQsRUFBRStaLEtBQUs7b0JBQ2xDRCxHQUFHRCxRQUFRLENBQUNydEIsSUFBSSxDQUFDMnRCO2dCQUNuQixPQUFPO29CQUNMQSxFQUFFLENBQUNGLFNBQVMsSUFBSXhkLEtBQUssR0FBR3VELEVBQUUrWixLQUFLO29CQUMvQkQsR0FBR0QsUUFBUSxDQUFDcnRCLElBQUksQ0FBQzJ0QjtnQkFDbkI7WUFDRjtZQUNBLElBQUluYSxFQUFFZ2EsS0FBSyxLQUFLdjBCLGFBQWEsT0FBT3VhLEVBQUVnYSxLQUFLLEtBQUssVUFBVTtnQkFDeERGLEdBQUdGLFNBQVMsR0FBR0UsR0FBR0YsU0FBUyxJQUFJLENBQUM7Z0JBQ2hDRSxHQUFHRixTQUFTLENBQUNLLFNBQVMsSUFBSXhkLEtBQUssR0FBR3VELEVBQUVnYSxLQUFLO1lBQzNDLE9BQU87Z0JBQ0w7b0JBQUM7b0JBQU87aUJBQU0sQ0FBQ3gzQixPQUFPLENBQUM0M0IsQ0FBQUE7b0JBQ3JCLElBQUlwYSxDQUFDLENBQUNvYSxJQUFJLEtBQUszMEIsV0FBVzt3QkFDeEJxMEIsR0FBR0YsU0FBUyxHQUFHRSxHQUFHRixTQUFTLElBQUksQ0FBQzt3QkFDaENFLEdBQUdGLFNBQVMsQ0FBQ0ssU0FBU0csS0FBSzNkLEtBQUssR0FBR3VELENBQUMsQ0FBQ29hLElBQUk7b0JBQzNDO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUluZixFQUFFb2YsUUFBUSxFQUFFO1lBQ2RQLEdBQUdELFFBQVEsR0FBRyxDQUFDQyxHQUFHRCxRQUFRLElBQUksRUFBRSxFQUFFeHJCLE1BQU0sQ0FBQzRNLEVBQUVvZixRQUFRO1FBQ3JEO1FBQ0EsT0FBT1A7SUFDVDtJQUNBLE1BQU1RLG1CQUFtQixTQUFVQyxXQUFXLEVBQUVDLElBQUk7UUFDbEQsSUFBSWYsZUFBZXRSLE9BQU8sSUFBSSxJQUFJO1lBQ2hDLE9BQU9xUyxLQUFLRDtRQUNkO1FBQ0FBLGNBQWNwc0IsS0FBS0MsS0FBSyxDQUFDRCxLQUFLYyxTQUFTLENBQUNzckI7UUFDeEMsSUFBSUEsZUFBZSxPQUFPQSxZQUFZRSxLQUFLLEtBQUssVUFBVTtZQUN4RCxNQUFNQyxRQUFRLFNBQVU1MUIsR0FBRyxFQUFFa0wsQ0FBQyxFQUFFQyxDQUFDO2dCQUMvQixJQUFJRCxLQUFLbEwsT0FBTyxDQUFFbUwsQ0FBQUEsS0FBS25MLEdBQUUsR0FBSTtvQkFDM0JBLEdBQUcsQ0FBQ21MLEVBQUUsR0FBR25MLEdBQUcsQ0FBQ2tMLEVBQUU7b0JBQ2YsT0FBT2xMLEdBQUcsQ0FBQ2tMLEVBQUU7Z0JBQ2Y7WUFDRjtZQUNBdXFCLGNBQWNwc0IsS0FBS0MsS0FBSyxDQUFDRCxLQUFLYyxTQUFTLENBQUNzckI7WUFDeENHLE1BQU1ILFlBQVlFLEtBQUssRUFBRSxtQkFBbUI7WUFDNUNDLE1BQU1ILFlBQVlFLEtBQUssRUFBRSxvQkFBb0I7WUFDN0NGLFlBQVlFLEtBQUssR0FBR2QscUJBQXFCWSxZQUFZRSxLQUFLO1FBQzVEO1FBQ0EsSUFBSUYsZUFBZSxPQUFPQSxZQUFZSSxLQUFLLEtBQUssVUFBVTtZQUN4RCw0Q0FBNEM7WUFDNUMsSUFBSUMsT0FBT0wsWUFBWUksS0FBSyxDQUFDRSxVQUFVO1lBQ3ZDRCxPQUFPQSxRQUFTLFFBQU9BLFNBQVMsV0FBV0EsT0FBTztnQkFDaERiLE9BQU9hO1lBQ1Q7WUFDQSxNQUFNRSw2QkFBNkJyQixlQUFldFIsT0FBTyxHQUFHO1lBQzVELElBQUl5UyxRQUFTQSxDQUFBQSxLQUFLWixLQUFLLEtBQUssVUFBVVksS0FBS1osS0FBSyxLQUFLLGlCQUFpQlksS0FBS2IsS0FBSyxLQUFLLFVBQVVhLEtBQUtiLEtBQUssS0FBSyxhQUFZLEtBQU0sQ0FBRXQxQixDQUFBQSxXQUFVaTFCLFlBQVksQ0FBQ3FCLHVCQUF1QixJQUFJdDJCLFdBQVVpMUIsWUFBWSxDQUFDcUIsdUJBQXVCLEdBQUdGLFVBQVUsSUFBSSxDQUFDQywwQkFBeUIsR0FBSTtnQkFDL1EsT0FBT1AsWUFBWUksS0FBSyxDQUFDRSxVQUFVO2dCQUNuQyxJQUFJeFc7Z0JBQ0osSUFBSXVXLEtBQUtaLEtBQUssS0FBSyxpQkFBaUJZLEtBQUtiLEtBQUssS0FBSyxlQUFlO29CQUNoRTFWLFVBQVU7d0JBQUM7d0JBQVE7cUJBQU87Z0JBQzVCLE9BQU8sSUFBSXVXLEtBQUtaLEtBQUssS0FBSyxVQUFVWSxLQUFLYixLQUFLLEtBQUssUUFBUTtvQkFDekQxVixVQUFVO3dCQUFDO3FCQUFRO2dCQUNyQjtnQkFDQSxJQUFJQSxTQUFTO29CQUNYLGlFQUFpRTtvQkFDakUsT0FBTzVmLFdBQVVpMUIsWUFBWSxDQUFDc0IsZ0JBQWdCLEdBQUd0SyxJQUFJLENBQUN1SyxDQUFBQTt3QkFDcERBLFVBQVVBLFFBQVE3eEIsTUFBTSxDQUFDckcsQ0FBQUEsSUFBS0EsRUFBRTRZLElBQUksS0FBSzt3QkFDekMsSUFBSXVmLE1BQU1ELFFBQVEzZixJQUFJLENBQUN2WSxDQUFBQSxJQUFLc2hCLFFBQVE4VyxJQUFJLENBQUM3VyxDQUFBQSxRQUFTdmhCLEVBQUVxNEIsS0FBSyxDQUFDOWdCLFdBQVcsR0FBRytnQixRQUFRLENBQUMvVzt3QkFDakYsSUFBSSxDQUFDNFcsT0FBT0QsUUFBUW4xQixNQUFNLElBQUl1ZSxRQUFRZ1gsUUFBUSxDQUFDLFNBQVM7NEJBQ3RESCxNQUFNRCxPQUFPLENBQUNBLFFBQVFuMUIsTUFBTSxHQUFHLEVBQUUsRUFBRSwyQkFBMkI7d0JBQ2hFO3dCQUNBLElBQUlvMUIsS0FBSzs0QkFDUFgsWUFBWUksS0FBSyxDQUFDVyxRQUFRLEdBQUdWLEtBQUtaLEtBQUssR0FBRztnQ0FDeENBLE9BQU9rQixJQUFJSSxRQUFROzRCQUNyQixJQUFJO2dDQUNGdkIsT0FBT21CLElBQUlJLFFBQVE7NEJBQ3JCO3dCQUNGO3dCQUNBZixZQUFZSSxLQUFLLEdBQUdoQixxQkFBcUJZLFlBQVlJLEtBQUs7d0JBQzFEcEIsUUFBUSxhQUFhcHJCLEtBQUtjLFNBQVMsQ0FBQ3NyQjt3QkFDcEMsT0FBT0MsS0FBS0Q7b0JBQ2Q7Z0JBQ0Y7WUFDRjtZQUNBQSxZQUFZSSxLQUFLLEdBQUdoQixxQkFBcUJZLFlBQVlJLEtBQUs7UUFDNUQ7UUFDQXBCLFFBQVEsYUFBYXByQixLQUFLYyxTQUFTLENBQUNzckI7UUFDcEMsT0FBT0MsS0FBS0Q7SUFDZDtJQUNBLE1BQU1nQixhQUFhLFNBQVU5NEIsQ0FBQztRQUM1QixJQUFJZzNCLGVBQWV0UixPQUFPLElBQUksSUFBSTtZQUNoQyxPQUFPMWxCO1FBQ1Q7UUFDQSxPQUFPO1lBQ0wyRCxNQUFNO2dCQUNKbzFCLHVCQUF1QjtnQkFDdkJDLDBCQUEwQjtnQkFDMUJDLG1CQUFtQjtnQkFDbkJDLHNCQUFzQjtnQkFDdEJDLDZCQUE2QjtnQkFDN0JDLGlCQUFpQjtnQkFDakJDLGdDQUFnQztnQkFDaENDLHlCQUF5QjtnQkFDekJDLGlCQUFpQjtnQkFDakJDLG9CQUFvQjtnQkFDcEJDLG9CQUFvQjtZQUN0QixFQUFDLENBQUN6NUIsRUFBRTJELElBQUksQ0FBQyxJQUFJM0QsRUFBRTJELElBQUk7WUFDbkJrSSxTQUFTN0wsRUFBRTZMLE9BQU87WUFDbEI2dEIsWUFBWTE1QixFQUFFMDVCLFVBQVUsSUFBSTE1QixFQUFFMjVCLGNBQWM7WUFDNUN0cEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMxTSxJQUFJLEdBQUksS0FBSSxDQUFDa0ksT0FBTyxJQUFJLElBQUcsSUFBSyxJQUFJLENBQUNBLE9BQU87WUFDMUQ7UUFDRjtJQUNGO0lBQ0EsTUFBTSt0QixnQkFBZ0IsU0FBVTlCLFdBQVcsRUFBRStCLFNBQVMsRUFBRUMsT0FBTztRQUM3RGpDLGlCQUFpQkMsYUFBYXRmLENBQUFBO1lBQzVCeFcsV0FBVXF6QixrQkFBa0IsQ0FBQzdjLEdBQUdxaEIsV0FBVzc1QixDQUFBQTtnQkFDekMsSUFBSTg1QixTQUFTO29CQUNYQSxRQUFRaEIsV0FBVzk0QjtnQkFDckI7WUFDRjtRQUNGO0lBQ0Y7SUFDQWdDLFdBQVUrM0IsWUFBWSxHQUFHSCxjQUFjcDNCLElBQUksQ0FBQ1I7SUFFNUMsc0VBQXNFO0lBQ3RFLGtFQUFrRTtJQUNsRSxlQUFlO0lBQ2YsSUFBSUEsV0FBVWkxQixZQUFZLENBQUM4QyxZQUFZLEVBQUU7UUFDdkMsTUFBTUMsbUJBQW1CaDRCLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxDQUFDdjNCLElBQUksQ0FBQ1IsV0FBVWkxQixZQUFZO1FBQ3hGajFCLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxHQUFHLFNBQVVFLEVBQUU7WUFDaEQsT0FBT3BDLGlCQUFpQm9DLElBQUl6aEIsQ0FBQUEsSUFBS3doQixpQkFBaUJ4aEIsR0FBR3lWLElBQUksQ0FBQ2hILENBQUFBO29CQUN4RCxJQUFJek8sRUFBRXdmLEtBQUssSUFBSSxDQUFDL1EsT0FBT2lULGNBQWMsR0FBRzcyQixNQUFNLElBQUltVixFQUFFMGYsS0FBSyxJQUFJLENBQUNqUixPQUFPa1QsY0FBYyxHQUFHOTJCLE1BQU0sRUFBRTt3QkFDNUY0akIsT0FBT21ULFNBQVMsR0FBR3I2QixPQUFPLENBQUN1MkIsQ0FBQUE7NEJBQ3pCQSxNQUFNK0QsSUFBSTt3QkFDWjt3QkFDQSxNQUFNLElBQUlDLGFBQWEsSUFBSTtvQkFDN0I7b0JBQ0EsT0FBT3JUO2dCQUNULEdBQUdqbkIsQ0FBQUEsSUFBSzB0QixRQUFRQyxNQUFNLENBQUNtTCxXQUFXOTRCO1FBQ3BDO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELG1CQUFtQixHQUVuQixTQUFTdTZCLHNCQUFzQno1QixPQUFNLEVBQUUwNUIsV0FBVztJQUNoRCxJQUFJMTVCLFFBQU9rQixTQUFTLENBQUNpMUIsWUFBWSxJQUFJLHFCQUFxQm4yQixRQUFPa0IsU0FBUyxDQUFDaTFCLFlBQVksRUFBRTtRQUN2RjtJQUNGO0lBQ0EsSUFBSSxDQUFDbjJCLFFBQU9rQixTQUFTLENBQUNpMUIsWUFBWSxFQUFFO1FBQ2xDO0lBQ0Y7SUFDQSxrRUFBa0U7SUFDbEUsc0RBQXNEO0lBQ3RELElBQUksT0FBT3VELGdCQUFnQixZQUFZO1FBQ3JDMzNCLFFBQVE0ckIsS0FBSyxDQUFDLHNEQUFzRDtRQUNwRTtJQUNGO0lBQ0EzdEIsUUFBT2tCLFNBQVMsQ0FBQ2kxQixZQUFZLENBQUN3RCxlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCM0MsV0FBVztRQUNsRixPQUFPMEMsWUFBWTFDLGFBQWE3SixJQUFJLENBQUN5TSxDQUFBQTtZQUNuQyxNQUFNQyxpQkFBaUI3QyxZQUFZSSxLQUFLLElBQUlKLFlBQVlJLEtBQUssQ0FBQzNSLEtBQUs7WUFDbkUsTUFBTXFVLGtCQUFrQjlDLFlBQVlJLEtBQUssSUFBSUosWUFBWUksS0FBSyxDQUFDMVIsTUFBTTtZQUNyRSxNQUFNcVUscUJBQXFCL0MsWUFBWUksS0FBSyxJQUFJSixZQUFZSSxLQUFLLENBQUN6TSxTQUFTO1lBQzNFcU0sWUFBWUksS0FBSyxHQUFHO2dCQUNsQmYsV0FBVztvQkFDVDJELG1CQUFtQjtvQkFDbkJDLHFCQUFxQkw7b0JBQ3JCTSxjQUFjSCxzQkFBc0I7Z0JBQ3RDO1lBQ0Y7WUFDQSxJQUFJRixnQkFBZ0I7Z0JBQ2xCN0MsWUFBWUksS0FBSyxDQUFDZixTQUFTLENBQUM4RCxRQUFRLEdBQUdOO1lBQ3pDO1lBQ0EsSUFBSUMsaUJBQWlCO2dCQUNuQjlDLFlBQVlJLEtBQUssQ0FBQ2YsU0FBUyxDQUFDK0QsU0FBUyxHQUFHTjtZQUMxQztZQUNBLE9BQU85NUIsUUFBT2tCLFNBQVMsQ0FBQ2kxQixZQUFZLENBQUM4QyxZQUFZLENBQUNqQztRQUNwRDtJQUNGO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxtQkFBbUIsR0FDbkIsU0FBU3FELGdCQUFnQnI2QixPQUFNO0lBQzdCQSxRQUFPczZCLFdBQVcsR0FBR3Q2QixRQUFPczZCLFdBQVcsSUFBSXQ2QixRQUFPdTZCLGlCQUFpQjtBQUNyRTtBQUNBLFNBQVNDLGNBQWN4NkIsT0FBTTtJQUMzQixJQUFJLE9BQU9BLFlBQVcsWUFBWUEsUUFBT2l6QixpQkFBaUIsSUFBSSxDQUFFLGNBQWFqekIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEdBQUc7UUFDaEhqQixPQUFPSyxjQUFjLENBQUNNLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxFQUFFLFdBQVc7WUFDbkVYO2dCQUNFLE9BQU8sSUFBSSxDQUFDODZCLFFBQVE7WUFDdEI7WUFDQXJvQixLQUFJdUYsQ0FBQztnQkFDSCxJQUFJLElBQUksQ0FBQzhpQixRQUFRLEVBQUU7b0JBQ2pCLElBQUksQ0FBQ2xJLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDa0ksUUFBUTtnQkFDakQ7Z0JBQ0EsSUFBSSxDQUFDcEksZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUNvSSxRQUFRLEdBQUc5aUI7WUFDakQ7WUFDQS9YLFlBQVk7WUFDWm0wQixjQUFjO1FBQ2hCO1FBQ0EsTUFBTTJHLDJCQUEyQjE2QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E2QixvQkFBb0I7UUFDeEYzNkIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNxNkIsb0JBQW9CLEdBQUcsU0FBU0E7WUFDakUsSUFBSSxDQUFDLElBQUksQ0FBQ0MsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLFlBQVksR0FBRzE3QixDQUFBQTtvQkFDbEIsaUVBQWlFO29CQUNqRSwrREFBK0Q7b0JBQy9EQSxFQUFFaW5CLE1BQU0sQ0FBQ2tNLGdCQUFnQixDQUFDLFlBQVl3SSxDQUFBQTt3QkFDcEMsSUFBSTVNO3dCQUNKLElBQUlqdUIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3NkIsWUFBWSxFQUFFOzRCQUNuRDdNLFdBQVcsSUFBSSxDQUFDNk0sWUFBWSxHQUFHL2lCLElBQUksQ0FBQzBFLENBQUFBLElBQUtBLEVBQUUrWSxLQUFLLElBQUkvWSxFQUFFK1ksS0FBSyxDQUFDSCxFQUFFLEtBQUt3RixHQUFHckYsS0FBSyxDQUFDSCxFQUFFO3dCQUNoRixPQUFPOzRCQUNMcEgsV0FBVztnQ0FDVHVILE9BQU9xRixHQUFHckYsS0FBSzs0QkFDakI7d0JBQ0Y7d0JBQ0EsTUFBTXVGLFFBQVEsSUFBSUMsTUFBTTt3QkFDeEJELE1BQU12RixLQUFLLEdBQUdxRixHQUFHckYsS0FBSzt3QkFDdEJ1RixNQUFNOU0sUUFBUSxHQUFHQTt3QkFDakI4TSxNQUFNRSxXQUFXLEdBQUc7NEJBQ2xCaE47d0JBQ0Y7d0JBQ0E4TSxNQUFNRyxPQUFPLEdBQUc7NEJBQUNoOEIsRUFBRWluQixNQUFNO3lCQUFDO3dCQUMxQixJQUFJLENBQUNnVixhQUFhLENBQUNKO29CQUNyQjtvQkFDQTc3QixFQUFFaW5CLE1BQU0sQ0FBQ21ULFNBQVMsR0FBR3I2QixPQUFPLENBQUN1MkIsQ0FBQUE7d0JBQzNCLElBQUl2SDt3QkFDSixJQUFJanVCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzZCLFlBQVksRUFBRTs0QkFDbkQ3TSxXQUFXLElBQUksQ0FBQzZNLFlBQVksR0FBRy9pQixJQUFJLENBQUMwRSxDQUFBQSxJQUFLQSxFQUFFK1ksS0FBSyxJQUFJL1ksRUFBRStZLEtBQUssQ0FBQ0gsRUFBRSxLQUFLRyxNQUFNSCxFQUFFO3dCQUM3RSxPQUFPOzRCQUNMcEgsV0FBVztnQ0FDVHVIOzRCQUNGO3dCQUNGO3dCQUNBLE1BQU11RixRQUFRLElBQUlDLE1BQU07d0JBQ3hCRCxNQUFNdkYsS0FBSyxHQUFHQTt3QkFDZHVGLE1BQU05TSxRQUFRLEdBQUdBO3dCQUNqQjhNLE1BQU1FLFdBQVcsR0FBRzs0QkFDbEJoTjt3QkFDRjt3QkFDQThNLE1BQU1HLE9BQU8sR0FBRzs0QkFBQ2g4QixFQUFFaW5CLE1BQU07eUJBQUM7d0JBQzFCLElBQUksQ0FBQ2dWLGFBQWEsQ0FBQ0o7b0JBQ3JCO2dCQUNGO2dCQUNBLElBQUksQ0FBQzFJLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDdUksWUFBWTtZQUN0RDtZQUNBLE9BQU9GLHlCQUF5Qjk0QixLQUFLLENBQUMsSUFBSSxFQUFFQztRQUM5QztJQUNGLE9BQU87UUFDTCw4REFBOEQ7UUFDOUQsNERBQTREO1FBQzVELHFDQUFxQztRQUNyQ2l4Qix3QkFBd0I5eUIsU0FBUSxTQUFTZCxDQUFBQTtZQUN2QyxJQUFJLENBQUNBLEVBQUUrN0IsV0FBVyxFQUFFO2dCQUNsQjU3QixPQUFPSyxjQUFjLENBQUNSLEdBQUcsZUFBZTtvQkFDdEM2SixPQUFPO3dCQUNMa2xCLFVBQVUvdUIsRUFBRSt1QixRQUFRO29CQUN0QjtnQkFDRjtZQUNGO1lBQ0EsT0FBTy91QjtRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVNrOEIsdUJBQXVCcDdCLE9BQU07SUFDcEMsc0VBQXNFO0lBQ3RFLElBQUksT0FBT0EsWUFBVyxZQUFZQSxRQUFPaXpCLGlCQUFpQixJQUFJLENBQUUsaUJBQWdCanpCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxLQUFLLHNCQUFzQk4sUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEVBQUU7UUFDL0ssTUFBTSs2QixxQkFBcUIsU0FBVUMsRUFBRSxFQUFFOUYsS0FBSztZQUM1QyxPQUFPO2dCQUNMQTtnQkFDQSxJQUFJK0YsUUFBTztvQkFDVCxJQUFJLElBQUksQ0FBQ0MsS0FBSyxLQUFLdDVCLFdBQVc7d0JBQzVCLElBQUlzekIsTUFBTXBkLElBQUksS0FBSyxTQUFTOzRCQUMxQixJQUFJLENBQUNvakIsS0FBSyxHQUFHRixHQUFHRyxnQkFBZ0IsQ0FBQ2pHO3dCQUNuQyxPQUFPOzRCQUNMLElBQUksQ0FBQ2dHLEtBQUssR0FBRzt3QkFDZjtvQkFDRjtvQkFDQSxPQUFPLElBQUksQ0FBQ0EsS0FBSztnQkFDbkI7Z0JBQ0FFLEtBQUtKO1lBQ1A7UUFDRjtRQUVBLHFEQUFxRDtRQUNyRCxJQUFJLENBQUN0N0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNxN0IsVUFBVSxFQUFFO1lBQ2xEMzdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDcTdCLFVBQVUsR0FBRyxTQUFTQTtnQkFDdkQsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLElBQUksRUFBRTtnQkFDbkMsT0FBTyxJQUFJLENBQUNBLFFBQVEsQ0FBQzUzQixLQUFLLElBQUksdUNBQXVDO1lBQ3ZFO1lBQ0EsTUFBTTYzQixlQUFlNzdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzdCLFFBQVE7WUFDaEU5N0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3N0IsUUFBUSxHQUFHLFNBQVNBLFNBQVN0RyxLQUFLLEVBQUVyUCxNQUFNO2dCQUMzRSxJQUFJNFYsU0FBU0YsYUFBYWo2QixLQUFLLENBQUMsSUFBSSxFQUFFQztnQkFDdEMsSUFBSSxDQUFDazZCLFFBQVE7b0JBQ1hBLFNBQVNWLG1CQUFtQixJQUFJLEVBQUU3RjtvQkFDbEMsSUFBSSxDQUFDb0csUUFBUSxDQUFDM3lCLElBQUksQ0FBQzh5QjtnQkFDckI7Z0JBQ0EsT0FBT0E7WUFDVDtZQUNBLE1BQU1DLGtCQUFrQmg4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQzI3QixXQUFXO1lBQ3RFajhCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDMjdCLFdBQVcsR0FBRyxTQUFTQSxZQUFZRixNQUFNO2dCQUMxRUMsZ0JBQWdCcDZCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUM1QixNQUFNcTZCLE1BQU0sSUFBSSxDQUFDTixRQUFRLENBQUM5M0IsT0FBTyxDQUFDaTRCO2dCQUNsQyxJQUFJRyxRQUFRLENBQUMsR0FBRztvQkFDZCxJQUFJLENBQUNOLFFBQVEsQ0FBQ08sTUFBTSxDQUFDRCxLQUFLO2dCQUM1QjtZQUNGO1FBQ0Y7UUFDQSxNQUFNRSxnQkFBZ0JwOEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUMrN0IsU0FBUztRQUNsRXI4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQys3QixTQUFTLEdBQUcsU0FBU0EsVUFBVWxXLE1BQU07WUFDdEUsSUFBSSxDQUFDeVYsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxJQUFJLEVBQUU7WUFDbkNRLGNBQWN4NkIsS0FBSyxDQUFDLElBQUksRUFBRTtnQkFBQ3VrQjthQUFPO1lBQ2xDQSxPQUFPbVQsU0FBUyxHQUFHcjZCLE9BQU8sQ0FBQ3UyQixDQUFBQTtnQkFDekIsSUFBSSxDQUFDb0csUUFBUSxDQUFDM3lCLElBQUksQ0FBQ295QixtQkFBbUIsSUFBSSxFQUFFN0Y7WUFDOUM7UUFDRjtRQUNBLE1BQU04RyxtQkFBbUJ0OEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNpOEIsWUFBWTtRQUN4RXY4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ2k4QixZQUFZLEdBQUcsU0FBU0EsYUFBYXBXLE1BQU07WUFDNUUsSUFBSSxDQUFDeVYsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxJQUFJLEVBQUU7WUFDbkNVLGlCQUFpQjE2QixLQUFLLENBQUMsSUFBSSxFQUFFO2dCQUFDdWtCO2FBQU87WUFDckNBLE9BQU9tVCxTQUFTLEdBQUdyNkIsT0FBTyxDQUFDdTJCLENBQUFBO2dCQUN6QixNQUFNdUcsU0FBUyxJQUFJLENBQUNILFFBQVEsQ0FBQzdqQixJQUFJLENBQUMzQyxDQUFBQSxJQUFLQSxFQUFFb2dCLEtBQUssS0FBS0E7Z0JBQ25ELElBQUl1RyxRQUFRO29CQUNWLGdCQUFnQjtvQkFDaEIsSUFBSSxDQUFDSCxRQUFRLENBQUNPLE1BQU0sQ0FBQyxJQUFJLENBQUNQLFFBQVEsQ0FBQzkzQixPQUFPLENBQUNpNEIsU0FBUztnQkFDdEQ7WUFDRjtRQUNGO0lBQ0YsT0FBTyxJQUFJLE9BQU8vN0IsWUFBVyxZQUFZQSxRQUFPaXpCLGlCQUFpQixJQUFJLGdCQUFnQmp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsSUFBSSxzQkFBc0JOLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxJQUFJTixRQUFPdzhCLFlBQVksSUFBSSxDQUFFLFdBQVV4OEIsUUFBT3c4QixZQUFZLENBQUNsOEIsU0FBUyxHQUFHO1FBQ3hQLE1BQU1tOEIsaUJBQWlCejhCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDcTdCLFVBQVU7UUFDcEUzN0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNxN0IsVUFBVSxHQUFHLFNBQVNBO1lBQ3ZELE1BQU1lLFVBQVVELGVBQWU3NkIsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQzdDODZCLFFBQVF6OUIsT0FBTyxDQUFDODhCLENBQUFBLFNBQVVBLE9BQU9MLEdBQUcsR0FBRyxJQUFJO1lBQzNDLE9BQU9nQjtRQUNUO1FBQ0FyOUIsT0FBT0ssY0FBYyxDQUFDTSxRQUFPdzhCLFlBQVksQ0FBQ2w4QixTQUFTLEVBQUUsUUFBUTtZQUMzRFg7Z0JBQ0UsSUFBSSxJQUFJLENBQUM2N0IsS0FBSyxLQUFLdDVCLFdBQVc7b0JBQzVCLElBQUksSUFBSSxDQUFDc3pCLEtBQUssQ0FBQ3BkLElBQUksS0FBSyxTQUFTO3dCQUMvQixJQUFJLENBQUNvakIsS0FBSyxHQUFHLElBQUksQ0FBQ0UsR0FBRyxDQUFDRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNqRyxLQUFLO29CQUNuRCxPQUFPO3dCQUNMLElBQUksQ0FBQ2dHLEtBQUssR0FBRztvQkFDZjtnQkFDRjtnQkFDQSxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNuQjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNtQixhQUFhMzhCLE9BQU07SUFDMUIsSUFBSSxDQUFDQSxRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzdCO0lBQ0Y7SUFDQSxNQUFNMkosZUFBZTU4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3U4QixRQUFRO0lBQ2hFNzhCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdThCLFFBQVEsR0FBRyxTQUFTQTtRQUNyRCxNQUFNLENBQUNDLFVBQVVDLFFBQVFDLE1BQU0sR0FBR243QjtRQUVsQyx1RUFBdUU7UUFDdkUsc0VBQXNFO1FBQ3RFLElBQUlBLFVBQVVVLE1BQU0sR0FBRyxLQUFLLE9BQU91NkIsYUFBYSxZQUFZO1lBQzFELE9BQU9GLGFBQWFoN0IsS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDbEM7UUFFQSx1RUFBdUU7UUFDdkUsd0RBQXdEO1FBQ3hELElBQUkrNkIsYUFBYXI2QixNQUFNLEtBQUssS0FBTVYsQ0FBQUEsVUFBVVUsTUFBTSxLQUFLLEtBQUssT0FBT3U2QixhQUFhLFVBQVMsR0FBSTtZQUMzRixPQUFPRixhQUFhaDdCLEtBQUssQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNwQztRQUNBLE1BQU1xN0Isa0JBQWtCLFNBQVVDLFFBQVE7WUFDeEMsTUFBTUMsaUJBQWlCLENBQUM7WUFDeEIsTUFBTUMsVUFBVUYsU0FBU3R1QixNQUFNO1lBQy9Cd3VCLFFBQVFuK0IsT0FBTyxDQUFDbytCLENBQUFBO2dCQUNkLE1BQU1DLGdCQUFnQjtvQkFDcEJqSSxJQUFJZ0ksT0FBT2hJLEVBQUU7b0JBQ2JrSSxXQUFXRixPQUFPRSxTQUFTO29CQUMzQnZ6QixNQUFNO3dCQUNKd3pCLGdCQUFnQjt3QkFDaEJDLGlCQUFpQjtvQkFDbkIsQ0FBQyxDQUFDSixPQUFPcnpCLElBQUksQ0FBQyxJQUFJcXpCLE9BQU9yekIsSUFBSTtnQkFDL0I7Z0JBQ0FxekIsT0FBTzEwQixLQUFLLEdBQUcxSixPQUFPLENBQUM0RCxDQUFBQTtvQkFDckJ5NkIsYUFBYSxDQUFDejZCLEtBQUssR0FBR3c2QixPQUFPSyxJQUFJLENBQUM3NkI7Z0JBQ3BDO2dCQUNBczZCLGNBQWMsQ0FBQ0csY0FBY2pJLEVBQUUsQ0FBQyxHQUFHaUk7WUFDckM7WUFDQSxPQUFPSDtRQUNUO1FBRUEscUNBQXFDO1FBQ3JDLE1BQU1RLGVBQWUsU0FBVXhJLEtBQUs7WUFDbEMsT0FBTyxJQUFJekIsSUFBSXIwQixPQUFPQyxJQUFJLENBQUM2MUIsT0FBT2x2QixHQUFHLENBQUNpVCxDQUFBQSxNQUFPO29CQUFDQTtvQkFBS2ljLEtBQUssQ0FBQ2pjLElBQUk7aUJBQUM7UUFDaEU7UUFDQSxJQUFJclgsVUFBVVUsTUFBTSxJQUFJLEdBQUc7WUFDekIsTUFBTXE3QiwwQkFBMEIsU0FBVVYsUUFBUTtnQkFDaERILE9BQU9ZLGFBQWFWLGdCQUFnQkM7WUFDdEM7WUFDQSxPQUFPTixhQUFhaDdCLEtBQUssQ0FBQyxJQUFJLEVBQUU7Z0JBQUNnOEI7Z0JBQXlCZDthQUFTO1FBQ3JFO1FBRUEsa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSWxRLFFBQVEsQ0FBQ0QsU0FBU0U7WUFDM0IrUCxhQUFhaDdCLEtBQUssQ0FBQyxJQUFJLEVBQUU7Z0JBQUMsU0FBVXM3QixRQUFRO29CQUMxQ3ZRLFFBQVFnUixhQUFhVixnQkFBZ0JDO2dCQUN2QztnQkFBR3JRO2FBQU87UUFDWixHQUFHTSxJQUFJLENBQUM0UCxRQUFRQztJQUNsQjtBQUNGO0FBQ0EsU0FBU2EsMkJBQTJCNzlCLE9BQU07SUFDeEMsSUFBSSxDQUFFLFFBQU9BLFlBQVcsWUFBWUEsUUFBT2l6QixpQkFBaUIsSUFBSWp6QixRQUFPdzhCLFlBQVksSUFBSXg4QixRQUFPODlCLGNBQWMsR0FBRztRQUM3RztJQUNGO0lBRUEscUJBQXFCO0lBQ3JCLElBQUksQ0FBRSxlQUFjOTlCLFFBQU93OEIsWUFBWSxDQUFDbDhCLFNBQVMsR0FBRztRQUNsRCxNQUFNbThCLGlCQUFpQno4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E3QixVQUFVO1FBQ3BFLElBQUljLGdCQUFnQjtZQUNsQno4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E3QixVQUFVLEdBQUcsU0FBU0E7Z0JBQ3ZELE1BQU1lLFVBQVVELGVBQWU3NkIsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUM3Qzg2QixRQUFRejlCLE9BQU8sQ0FBQzg4QixDQUFBQSxTQUFVQSxPQUFPTCxHQUFHLEdBQUcsSUFBSTtnQkFDM0MsT0FBT2dCO1lBQ1Q7UUFDRjtRQUNBLE1BQU1iLGVBQWU3N0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3N0IsUUFBUTtRQUNoRSxJQUFJRCxjQUFjO1lBQ2hCNzdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzdCLFFBQVEsR0FBRyxTQUFTQTtnQkFDckQsTUFBTUMsU0FBU0YsYUFBYWo2QixLQUFLLENBQUMsSUFBSSxFQUFFQztnQkFDeENrNkIsT0FBT0wsR0FBRyxHQUFHLElBQUk7Z0JBQ2pCLE9BQU9LO1lBQ1Q7UUFDRjtRQUNBLzdCLFFBQU93OEIsWUFBWSxDQUFDbDhCLFNBQVMsQ0FBQ3U4QixRQUFRLEdBQUcsU0FBU0E7WUFDaEQsTUFBTWQsU0FBUyxJQUFJO1lBQ25CLE9BQU8sSUFBSSxDQUFDTCxHQUFHLENBQUNtQixRQUFRLEdBQUcxUCxJQUFJLENBQUN2ZSxDQUFBQSxTQUNoQzs7O09BR0MsR0FDRDJtQixZQUFZM21CLFFBQVFtdEIsT0FBT3ZHLEtBQUssRUFBRTtRQUNwQztJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLElBQUksQ0FBRSxlQUFjeDFCLFFBQU84OUIsY0FBYyxDQUFDeDlCLFNBQVMsR0FBRztRQUNwRCxNQUFNeTlCLG1CQUFtQi85QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3c2QixZQUFZO1FBQ3hFLElBQUlpRCxrQkFBa0I7WUFDcEIvOUIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3NkIsWUFBWSxHQUFHLFNBQVNBO2dCQUN6RCxNQUFNa0QsWUFBWUQsaUJBQWlCbjhCLEtBQUssQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDakRvOEIsVUFBVS8rQixPQUFPLENBQUNndkIsQ0FBQUEsV0FBWUEsU0FBU3lOLEdBQUcsR0FBRyxJQUFJO2dCQUNqRCxPQUFPc0M7WUFDVDtRQUNGO1FBQ0FsTCx3QkFBd0I5eUIsU0FBUSxTQUFTZCxDQUFBQTtZQUN2Q0EsRUFBRSt1QixRQUFRLENBQUN5TixHQUFHLEdBQUd4OEIsRUFBRSsrQixVQUFVO1lBQzdCLE9BQU8vK0I7UUFDVDtRQUNBYyxRQUFPODlCLGNBQWMsQ0FBQ3g5QixTQUFTLENBQUN1OEIsUUFBUSxHQUFHLFNBQVNBO1lBQ2xELE1BQU01TyxXQUFXLElBQUk7WUFDckIsT0FBTyxJQUFJLENBQUN5TixHQUFHLENBQUNtQixRQUFRLEdBQUcxUCxJQUFJLENBQUN2ZSxDQUFBQSxTQUFVMm1CLFlBQVkzbUIsUUFBUXFmLFNBQVN1SCxLQUFLLEVBQUU7UUFDaEY7SUFDRjtJQUNBLElBQUksQ0FBRSxlQUFjeDFCLFFBQU93OEIsWUFBWSxDQUFDbDhCLFNBQVMsSUFBSSxjQUFjTixRQUFPODlCLGNBQWMsQ0FBQ3g5QixTQUFTLEdBQUc7UUFDbkc7SUFDRjtJQUVBLDBDQUEwQztJQUMxQyxNQUFNczhCLGVBQWU1OEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN1OEIsUUFBUTtJQUNoRTc4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3U4QixRQUFRLEdBQUcsU0FBU0E7UUFDckQsSUFBSWg3QixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsWUFBWTdCLFFBQU9rK0IsZ0JBQWdCLEVBQUU7WUFDM0UsTUFBTTFJLFFBQVEzekIsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSWs2QjtZQUNKLElBQUk5TjtZQUNKLElBQUkwQjtZQUNKLElBQUksQ0FBQ2dNLFVBQVUsR0FBRzE4QixPQUFPLENBQUNtVyxDQUFBQTtnQkFDeEIsSUFBSUEsRUFBRW9nQixLQUFLLEtBQUtBLE9BQU87b0JBQ3JCLElBQUl1RyxRQUFRO3dCQUNWcE0sTUFBTTtvQkFDUixPQUFPO3dCQUNMb00sU0FBUzNtQjtvQkFDWDtnQkFDRjtZQUNGO1lBQ0EsSUFBSSxDQUFDMGxCLFlBQVksR0FBRzc3QixPQUFPLENBQUN3ZCxDQUFBQTtnQkFDMUIsSUFBSUEsRUFBRStZLEtBQUssS0FBS0EsT0FBTztvQkFDckIsSUFBSXZILFVBQVU7d0JBQ1owQixNQUFNO29CQUNSLE9BQU87d0JBQ0wxQixXQUFXeFI7b0JBQ2I7Z0JBQ0Y7Z0JBQ0EsT0FBT0EsRUFBRStZLEtBQUssS0FBS0E7WUFDckI7WUFDQSxJQUFJN0YsT0FBT29NLFVBQVU5TixVQUFVO2dCQUM3QixPQUFPckIsUUFBUUMsTUFBTSxDQUFDLElBQUkyTSxhQUFhLDZEQUE2RDtZQUN0RyxPQUFPLElBQUl1QyxRQUFRO2dCQUNqQixPQUFPQSxPQUFPYyxRQUFRO1lBQ3hCLE9BQU8sSUFBSTVPLFVBQVU7Z0JBQ25CLE9BQU9BLFNBQVM0TyxRQUFRO1lBQzFCO1lBQ0EsT0FBT2pRLFFBQVFDLE1BQU0sQ0FBQyxJQUFJMk0sYUFBYSxpREFBaUQ7UUFDMUY7UUFDQSxPQUFPb0QsYUFBYWg3QixLQUFLLENBQUMsSUFBSSxFQUFFQztJQUNsQztBQUNGO0FBQ0EsU0FBU3M4QixrQ0FBa0NuK0IsT0FBTTtJQUMvQyxrRUFBa0U7SUFDbEUsNEVBQTRFO0lBQzVFLHVEQUF1RDtJQUN2REEsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUM4OUIsZUFBZSxHQUFHLFNBQVNBO1FBQzVELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0IsSUFBSSxDQUFDO1FBQzFELE9BQU9oL0IsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQysrQixvQkFBb0IsRUFBRXA0QixHQUFHLENBQUNxNEIsQ0FBQUEsV0FBWSxJQUFJLENBQUNELG9CQUFvQixDQUFDQyxTQUFTLENBQUMsRUFBRTtJQUN0RztJQUNBLE1BQU16QyxlQUFlNzdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzdCLFFBQVE7SUFDaEU5N0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3N0IsUUFBUSxHQUFHLFNBQVNBLFNBQVN0RyxLQUFLLEVBQUVyUCxNQUFNO1FBQzNFLElBQUksQ0FBQ0EsUUFBUTtZQUNYLE9BQU8wVixhQUFhajZCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDdzhCLG9CQUFvQixHQUFHLElBQUksQ0FBQ0Esb0JBQW9CLElBQUksQ0FBQztRQUMxRCxNQUFNdEMsU0FBU0YsYUFBYWo2QixLQUFLLENBQUMsSUFBSSxFQUFFQztRQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDdzhCLG9CQUFvQixDQUFDbFksT0FBT2tQLEVBQUUsQ0FBQyxFQUFFO1lBQ3pDLElBQUksQ0FBQ2dKLG9CQUFvQixDQUFDbFksT0FBT2tQLEVBQUUsQ0FBQyxHQUFHO2dCQUFDbFA7Z0JBQVE0VjthQUFPO1FBQ3pELE9BQU8sSUFBSSxJQUFJLENBQUNzQyxvQkFBb0IsQ0FBQ2xZLE9BQU9rUCxFQUFFLENBQUMsQ0FBQ3Z4QixPQUFPLENBQUNpNEIsWUFBWSxDQUFDLEdBQUc7WUFDdEUsSUFBSSxDQUFDc0Msb0JBQW9CLENBQUNsWSxPQUFPa1AsRUFBRSxDQUFDLENBQUNwc0IsSUFBSSxDQUFDOHlCO1FBQzVDO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE1BQU1LLGdCQUFnQnA4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQys3QixTQUFTO0lBQ2xFcjhCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDKzdCLFNBQVMsR0FBRyxTQUFTQSxVQUFVbFcsTUFBTTtRQUN0RSxJQUFJLENBQUNrWSxvQkFBb0IsR0FBRyxJQUFJLENBQUNBLG9CQUFvQixJQUFJLENBQUM7UUFDMURsWSxPQUFPbVQsU0FBUyxHQUFHcjZCLE9BQU8sQ0FBQ3UyQixDQUFBQTtZQUN6QixNQUFNK0ksZ0JBQWdCLElBQUksQ0FBQzVDLFVBQVUsR0FBRzVqQixJQUFJLENBQUMzQyxDQUFBQSxJQUFLQSxFQUFFb2dCLEtBQUssS0FBS0E7WUFDOUQsSUFBSStJLGVBQWU7Z0JBQ2pCLE1BQU0sSUFBSS9FLGFBQWEseUJBQXlCO1lBQ2xEO1FBQ0Y7UUFDQSxNQUFNZ0Ysa0JBQWtCLElBQUksQ0FBQzdDLFVBQVU7UUFDdkNTLGNBQWN4NkIsS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDMUIsTUFBTTQ4QixhQUFhLElBQUksQ0FBQzlDLFVBQVUsR0FBRzkxQixNQUFNLENBQUM2NEIsQ0FBQUEsWUFBYUYsZ0JBQWdCMTZCLE9BQU8sQ0FBQzQ2QixlQUFlLENBQUM7UUFDakcsSUFBSSxDQUFDTCxvQkFBb0IsQ0FBQ2xZLE9BQU9rUCxFQUFFLENBQUMsR0FBRztZQUFDbFA7U0FBTyxDQUFDcmIsTUFBTSxDQUFDMnpCO0lBQ3pEO0lBQ0EsTUFBTW5DLG1CQUFtQnQ4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ2k4QixZQUFZO0lBQ3hFdjhCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDaThCLFlBQVksR0FBRyxTQUFTQSxhQUFhcFcsTUFBTTtRQUM1RSxJQUFJLENBQUNrWSxvQkFBb0IsR0FBRyxJQUFJLENBQUNBLG9CQUFvQixJQUFJLENBQUM7UUFDMUQsT0FBTyxJQUFJLENBQUNBLG9CQUFvQixDQUFDbFksT0FBT2tQLEVBQUUsQ0FBQztRQUMzQyxPQUFPaUgsaUJBQWlCMTZCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQ3RDO0lBQ0EsTUFBTW02QixrQkFBa0JoOEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUMyN0IsV0FBVztJQUN0RWo4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQzI3QixXQUFXLEdBQUcsU0FBU0EsWUFBWUYsTUFBTTtRQUMxRSxJQUFJLENBQUNzQyxvQkFBb0IsR0FBRyxJQUFJLENBQUNBLG9CQUFvQixJQUFJLENBQUM7UUFDMUQsSUFBSXRDLFFBQVE7WUFDVjE4QixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDKytCLG9CQUFvQixFQUFFcC9CLE9BQU8sQ0FBQ3EvQixDQUFBQTtnQkFDN0MsTUFBTXBDLE1BQU0sSUFBSSxDQUFDbUMsb0JBQW9CLENBQUNDLFNBQVMsQ0FBQ3g2QixPQUFPLENBQUNpNEI7Z0JBQ3hELElBQUlHLFFBQVEsQ0FBQyxHQUFHO29CQUNkLElBQUksQ0FBQ21DLG9CQUFvQixDQUFDQyxTQUFTLENBQUNuQyxNQUFNLENBQUNELEtBQUs7Z0JBQ2xEO2dCQUNBLElBQUksSUFBSSxDQUFDbUMsb0JBQW9CLENBQUNDLFNBQVMsQ0FBQy83QixNQUFNLEtBQUssR0FBRztvQkFDcEQsT0FBTyxJQUFJLENBQUM4N0Isb0JBQW9CLENBQUNDLFNBQVM7Z0JBQzVDO1lBQ0Y7UUFDRjtRQUNBLE9BQU90QyxnQkFBZ0JwNkIsS0FBSyxDQUFDLElBQUksRUFBRUM7SUFDckM7QUFDRjtBQUNBLFNBQVM4OEIsd0JBQXdCMytCLE9BQU0sRUFBRWsyQixjQUFjO0lBQ3JELElBQUksQ0FBQ2wyQixRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzdCO0lBQ0Y7SUFDQSxpQ0FBaUM7SUFDakMsSUFBSWp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3c3QixRQUFRLElBQUk1RixlQUFldFIsT0FBTyxJQUFJLElBQUk7UUFDL0UsT0FBT3VaLGtDQUFrQ24rQjtJQUMzQztJQUVBLHdEQUF3RDtJQUN4RCxrQ0FBa0M7SUFDbEMsTUFBTTQrQixzQkFBc0I1K0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUM4OUIsZUFBZTtJQUM5RXArQixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQzg5QixlQUFlLEdBQUcsU0FBU0E7UUFDNUQsTUFBTVMsZ0JBQWdCRCxvQkFBb0JoOUIsS0FBSyxDQUFDLElBQUk7UUFDcEQsSUFBSSxDQUFDazlCLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsSUFBSSxDQUFDO1FBQ2hELE9BQU9ELGNBQWM1NEIsR0FBRyxDQUFDa2dCLENBQUFBLFNBQVUsSUFBSSxDQUFDMlksZUFBZSxDQUFDM1ksT0FBT2tQLEVBQUUsQ0FBQztJQUNwRTtJQUNBLE1BQU0rRyxnQkFBZ0JwOEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUMrN0IsU0FBUztJQUNsRXI4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQys3QixTQUFTLEdBQUcsU0FBU0EsVUFBVWxXLE1BQU07UUFDdEUsSUFBSSxDQUFDNFksUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxJQUFJLENBQUM7UUFDbEMsSUFBSSxDQUFDRCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLElBQUksQ0FBQztRQUNoRDNZLE9BQU9tVCxTQUFTLEdBQUdyNkIsT0FBTyxDQUFDdTJCLENBQUFBO1lBQ3pCLE1BQU0rSSxnQkFBZ0IsSUFBSSxDQUFDNUMsVUFBVSxHQUFHNWpCLElBQUksQ0FBQzNDLENBQUFBLElBQUtBLEVBQUVvZ0IsS0FBSyxLQUFLQTtZQUM5RCxJQUFJK0ksZUFBZTtnQkFDakIsTUFBTSxJQUFJL0UsYUFBYSx5QkFBeUI7WUFDbEQ7UUFDRjtRQUNBLHNEQUFzRDtRQUN0RCx5REFBeUQ7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQ3NGLGVBQWUsQ0FBQzNZLE9BQU9rUCxFQUFFLENBQUMsRUFBRTtZQUNwQyxNQUFNMkosWUFBWSxJQUFJaC9CLFFBQU9zNkIsV0FBVyxDQUFDblUsT0FBT21ULFNBQVM7WUFDekQsSUFBSSxDQUFDeUYsUUFBUSxDQUFDNVksT0FBT2tQLEVBQUUsQ0FBQyxHQUFHMko7WUFDM0IsSUFBSSxDQUFDRixlQUFlLENBQUNFLFVBQVUzSixFQUFFLENBQUMsR0FBR2xQO1lBQ3JDQSxTQUFTNlk7UUFDWDtRQUNBNUMsY0FBY3g2QixLQUFLLENBQUMsSUFBSSxFQUFFO1lBQUN1a0I7U0FBTztJQUNwQztJQUNBLE1BQU1tVyxtQkFBbUJ0OEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNpOEIsWUFBWTtJQUN4RXY4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ2k4QixZQUFZLEdBQUcsU0FBU0EsYUFBYXBXLE1BQU07UUFDNUUsSUFBSSxDQUFDNFksUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxJQUFJLENBQUM7UUFDbEMsSUFBSSxDQUFDRCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLElBQUksQ0FBQztRQUNoRHhDLGlCQUFpQjE2QixLQUFLLENBQUMsSUFBSSxFQUFFO1lBQUMsSUFBSSxDQUFDbTlCLFFBQVEsQ0FBQzVZLE9BQU9rUCxFQUFFLENBQUMsSUFBSWxQO1NBQU87UUFDakUsT0FBTyxJQUFJLENBQUMyWSxlQUFlLENBQUMsSUFBSSxDQUFDQyxRQUFRLENBQUM1WSxPQUFPa1AsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDMEosUUFBUSxDQUFDNVksT0FBT2tQLEVBQUUsQ0FBQyxDQUFDQSxFQUFFLEdBQUdsUCxPQUFPa1AsRUFBRSxDQUFDO1FBQy9GLE9BQU8sSUFBSSxDQUFDMEosUUFBUSxDQUFDNVksT0FBT2tQLEVBQUUsQ0FBQztJQUNqQztJQUNBcjFCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzdCLFFBQVEsR0FBRyxTQUFTQSxTQUFTdEcsS0FBSyxFQUFFclAsTUFBTTtRQUMzRSxJQUFJLElBQUksQ0FBQzhZLGNBQWMsS0FBSyxVQUFVO1lBQ3BDLE1BQU0sSUFBSXpGLGFBQWEsdURBQTBEO1FBQ25GO1FBQ0EsTUFBTTBCLFVBQVUsRUFBRSxDQUFDbDNCLEtBQUssQ0FBQ3hELElBQUksQ0FBQ3FCLFdBQVc7UUFDekMsSUFBSXE1QixRQUFRMzRCLE1BQU0sS0FBSyxLQUFLLENBQUMyNEIsT0FBTyxDQUFDLEVBQUUsQ0FBQzVCLFNBQVMsR0FBR3ZoQixJQUFJLENBQUM5UCxDQUFBQSxJQUFLQSxNQUFNdXRCLFFBQVE7WUFDMUUsMERBQTBEO1lBQzFELDZDQUE2QztZQUM3QyxNQUFNLElBQUlnRSxhQUFhLDZEQUE2RCx5REFBeUQ7UUFDL0k7UUFDQSxNQUFNK0UsZ0JBQWdCLElBQUksQ0FBQzVDLFVBQVUsR0FBRzVqQixJQUFJLENBQUMzQyxDQUFBQSxJQUFLQSxFQUFFb2dCLEtBQUssS0FBS0E7UUFDOUQsSUFBSStJLGVBQWU7WUFDakIsTUFBTSxJQUFJL0UsYUFBYSx5QkFBeUI7UUFDbEQ7UUFDQSxJQUFJLENBQUN1RixRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLElBQUksQ0FBQztRQUNsQyxJQUFJLENBQUNELGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsSUFBSSxDQUFDO1FBQ2hELE1BQU1JLFlBQVksSUFBSSxDQUFDSCxRQUFRLENBQUM1WSxPQUFPa1AsRUFBRSxDQUFDO1FBQzFDLElBQUk2SixXQUFXO1lBQ2Isd0RBQXdEO1lBQ3hELDJEQUEyRDtZQUMzRCx3REFBd0Q7WUFDeEQsd0NBQXdDO1lBQ3hDQSxVQUFVcEQsUUFBUSxDQUFDdEc7WUFFbkIscUJBQXFCO1lBQ3JCNUksUUFBUUQsT0FBTyxHQUFHUSxJQUFJLENBQUM7Z0JBQ3JCLElBQUksQ0FBQ2dPLGFBQWEsQ0FBQyxJQUFJSCxNQUFNO1lBQy9CO1FBQ0YsT0FBTztZQUNMLE1BQU1nRSxZQUFZLElBQUloL0IsUUFBT3M2QixXQUFXLENBQUM7Z0JBQUM5RTthQUFNO1lBQ2hELElBQUksQ0FBQ3VKLFFBQVEsQ0FBQzVZLE9BQU9rUCxFQUFFLENBQUMsR0FBRzJKO1lBQzNCLElBQUksQ0FBQ0YsZUFBZSxDQUFDRSxVQUFVM0osRUFBRSxDQUFDLEdBQUdsUDtZQUNyQyxJQUFJLENBQUNrVyxTQUFTLENBQUMyQztRQUNqQjtRQUNBLE9BQU8sSUFBSSxDQUFDckQsVUFBVSxHQUFHNWpCLElBQUksQ0FBQzNDLENBQUFBLElBQUtBLEVBQUVvZ0IsS0FBSyxLQUFLQTtJQUNqRDtJQUVBLDJEQUEyRDtJQUMzRCxjQUFjO0lBQ2QsU0FBUzJKLHdCQUF3QjdELEVBQUUsRUFBRThELFdBQVc7UUFDOUMsSUFBSUMsTUFBTUQsWUFBWUMsR0FBRztRQUN6QmhnQyxPQUFPQyxJQUFJLENBQUNnOEIsR0FBR3dELGVBQWUsSUFBSSxFQUFFLEVBQUU3L0IsT0FBTyxDQUFDcWdDLENBQUFBO1lBQzVDLE1BQU1DLGlCQUFpQmpFLEdBQUd3RCxlQUFlLENBQUNRLFdBQVc7WUFDckQsTUFBTUUsaUJBQWlCbEUsR0FBR3lELFFBQVEsQ0FBQ1EsZUFBZWxLLEVBQUUsQ0FBQztZQUNyRGdLLE1BQU1BLElBQUkvZCxPQUFPLENBQUMsSUFBSW1lLE9BQU9ELGVBQWVuSyxFQUFFLEVBQUUsTUFBTWtLLGVBQWVsSyxFQUFFO1FBQ3pFO1FBQ0EsT0FBTyxJQUFJcUssc0JBQXNCO1lBQy9CMTFCLE1BQU1vMUIsWUFBWXAxQixJQUFJO1lBQ3RCcTFCO1FBQ0Y7SUFDRjtJQUNBLFNBQVNNLHdCQUF3QnJFLEVBQUUsRUFBRThELFdBQVc7UUFDOUMsSUFBSUMsTUFBTUQsWUFBWUMsR0FBRztRQUN6QmhnQyxPQUFPQyxJQUFJLENBQUNnOEIsR0FBR3dELGVBQWUsSUFBSSxFQUFFLEVBQUU3L0IsT0FBTyxDQUFDcWdDLENBQUFBO1lBQzVDLE1BQU1DLGlCQUFpQmpFLEdBQUd3RCxlQUFlLENBQUNRLFdBQVc7WUFDckQsTUFBTUUsaUJBQWlCbEUsR0FBR3lELFFBQVEsQ0FBQ1EsZUFBZWxLLEVBQUUsQ0FBQztZQUNyRGdLLE1BQU1BLElBQUkvZCxPQUFPLENBQUMsSUFBSW1lLE9BQU9GLGVBQWVsSyxFQUFFLEVBQUUsTUFBTW1LLGVBQWVuSyxFQUFFO1FBQ3pFO1FBQ0EsT0FBTyxJQUFJcUssc0JBQXNCO1lBQy9CMTFCLE1BQU1vMUIsWUFBWXAxQixJQUFJO1lBQ3RCcTFCO1FBQ0Y7SUFDRjtJQUNBO1FBQUM7UUFBZTtLQUFlLENBQUNwZ0MsT0FBTyxDQUFDLFNBQVV3QyxNQUFNO1FBQ3RELE1BQU1tK0IsZUFBZTUvQixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ21CLE9BQU87UUFDL0QsTUFBTW8rQixZQUFZO1lBQ2hCLENBQUNwK0IsT0FBTztnQkFDTixNQUFNeXNCLE9BQU9yc0I7Z0JBQ2IsTUFBTWkrQixlQUFlaitCLFVBQVVVLE1BQU0sSUFBSSxPQUFPVixTQUFTLENBQUMsRUFBRSxLQUFLO2dCQUNqRSxJQUFJaStCLGNBQWM7b0JBQ2hCLE9BQU9GLGFBQWFoK0IsS0FBSyxDQUFDLElBQUksRUFBRTt3QkFBQ3c5QixDQUFBQTs0QkFDL0IsTUFBTVcsT0FBT1osd0JBQXdCLElBQUksRUFBRUM7NEJBQzNDbFIsSUFBSSxDQUFDLEVBQUUsQ0FBQ3RzQixLQUFLLENBQUMsTUFBTTtnQ0FBQ20rQjs2QkFBSzt3QkFDNUI7d0JBQUdwUSxDQUFBQTs0QkFDRCxJQUFJekIsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQ0FDWEEsSUFBSSxDQUFDLEVBQUUsQ0FBQ3RzQixLQUFLLENBQUMsTUFBTSt0Qjs0QkFDdEI7d0JBQ0Y7d0JBQUc5dEIsU0FBUyxDQUFDLEVBQUU7cUJBQUM7Z0JBQ2xCO2dCQUNBLE9BQU8rOUIsYUFBYWgrQixLQUFLLENBQUMsSUFBSSxFQUFFQyxXQUFXc3JCLElBQUksQ0FBQ2lTLENBQUFBLGNBQWVELHdCQUF3QixJQUFJLEVBQUVDO1lBQy9GO1FBQ0Y7UUFDQXAvQixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ21CLE9BQU8sR0FBR28rQixTQUFTLENBQUNwK0IsT0FBTztJQUNoRTtJQUNBLE1BQU11K0IsMEJBQTBCaGdDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDMi9CLG1CQUFtQjtJQUN0RmpnQyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQzIvQixtQkFBbUIsR0FBRyxTQUFTQTtRQUNoRSxJQUFJLENBQUNwK0IsVUFBVVUsTUFBTSxJQUFJLENBQUNWLFNBQVMsQ0FBQyxFQUFFLENBQUNtSSxJQUFJLEVBQUU7WUFDM0MsT0FBT2cyQix3QkFBd0JwK0IsS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDN0M7UUFDQUEsU0FBUyxDQUFDLEVBQUUsR0FBRzg5Qix3QkFBd0IsSUFBSSxFQUFFOTlCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pELE9BQU9tK0Isd0JBQXdCcCtCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQzdDO0lBRUEsc0dBQXNHO0lBRXRHLE1BQU1xK0IsdUJBQXVCN2dDLE9BQU9JLHdCQUF3QixDQUFDTyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsRUFBRTtJQUNqR2pCLE9BQU9LLGNBQWMsQ0FBQ00sUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEVBQUUsb0JBQW9CO1FBQzVFWDtZQUNFLE1BQU15L0IsY0FBY2MscUJBQXFCdmdDLEdBQUcsQ0FBQ2lDLEtBQUssQ0FBQyxJQUFJO1lBQ3ZELElBQUl3OUIsWUFBWXAxQixJQUFJLEtBQUssSUFBSTtnQkFDM0IsT0FBT28xQjtZQUNUO1lBQ0EsT0FBT0Qsd0JBQXdCLElBQUksRUFBRUM7UUFDdkM7SUFDRjtJQUNBcC9CLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDMjdCLFdBQVcsR0FBRyxTQUFTQSxZQUFZRixNQUFNO1FBQzFFLElBQUksSUFBSSxDQUFDa0QsY0FBYyxLQUFLLFVBQVU7WUFDcEMsTUFBTSxJQUFJekYsYUFBYSx1REFBMEQ7UUFDbkY7UUFDQSwwREFBMEQ7UUFDMUQsNkRBQTZEO1FBQzdELElBQUksQ0FBQ3VDLE9BQU9MLEdBQUcsRUFBRTtZQUNmLE1BQU0sSUFBSWxDLGFBQWEsaURBQWlELDhDQUE4QztRQUN4SDtRQUNBLE1BQU0yRyxVQUFVcEUsT0FBT0wsR0FBRyxLQUFLLElBQUk7UUFDbkMsSUFBSSxDQUFDeUUsU0FBUztZQUNaLE1BQU0sSUFBSTNHLGFBQWEsOENBQThDO1FBQ3ZFO1FBRUEsNkRBQTZEO1FBQzdELElBQUksQ0FBQ3VGLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVEsSUFBSSxDQUFDO1FBQ2xDLElBQUk1WTtRQUNKOW1CLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUN5L0IsUUFBUSxFQUFFOS9CLE9BQU8sQ0FBQ21oQyxDQUFBQTtZQUNqQyxNQUFNQyxXQUFXLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ3FCLFNBQVMsQ0FBQzlHLFNBQVMsR0FBR3ZoQixJQUFJLENBQUN5ZCxDQUFBQSxRQUFTdUcsT0FBT3ZHLEtBQUssS0FBS0E7WUFDcEYsSUFBSTZLLFVBQVU7Z0JBQ1psYSxTQUFTLElBQUksQ0FBQzRZLFFBQVEsQ0FBQ3FCLFNBQVM7WUFDbEM7UUFDRjtRQUNBLElBQUlqYSxRQUFRO1lBQ1YsSUFBSUEsT0FBT21ULFNBQVMsR0FBRy8yQixNQUFNLEtBQUssR0FBRztnQkFDbkMsbUVBQW1FO2dCQUNuRSxzQ0FBc0M7Z0JBQ3RDLElBQUksQ0FBQ2c2QixZQUFZLENBQUMsSUFBSSxDQUFDdUMsZUFBZSxDQUFDM1ksT0FBT2tQLEVBQUUsQ0FBQztZQUNuRCxPQUFPO2dCQUNMLHFEQUFxRDtnQkFDckRsUCxPQUFPOFYsV0FBVyxDQUFDRixPQUFPdkcsS0FBSztZQUNqQztZQUNBLElBQUksQ0FBQzJGLGFBQWEsQ0FBQyxJQUFJSCxNQUFNO1FBQy9CO0lBQ0Y7QUFDRjtBQUNBLFNBQVNzRixxQkFBcUJ0Z0MsT0FBTSxFQUFFazJCLGNBQWM7SUFDbEQsSUFBSSxDQUFDbDJCLFFBQU9pekIsaUJBQWlCLElBQUlqekIsUUFBT3kwQix1QkFBdUIsRUFBRTtRQUMvRCx1Q0FBdUM7UUFDdkN6MEIsUUFBT2l6QixpQkFBaUIsR0FBR2p6QixRQUFPeTBCLHVCQUF1QjtJQUMzRDtJQUNBLElBQUksQ0FBQ3owQixRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzdCO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsSUFBSWlELGVBQWV0UixPQUFPLEdBQUcsSUFBSTtRQUMvQjtZQUFDO1lBQXVCO1lBQXdCO1NBQWtCLENBQUMzbEIsT0FBTyxDQUFDLFNBQVV3QyxNQUFNO1lBQ3pGLE1BQU1tK0IsZUFBZTUvQixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ21CLE9BQU87WUFDL0QsTUFBTW8rQixZQUFZO2dCQUNoQixDQUFDcCtCLE9BQU87b0JBQ05JLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBS0osQ0FBQUEsV0FBVyxvQkFBb0J6QixRQUFPdWdDLGVBQWUsR0FBR3ZnQyxRQUFPMC9CLHFCQUFxQixFQUFFNzlCLFNBQVMsQ0FBQyxFQUFFO29CQUN0SCxPQUFPKzlCLGFBQWFoK0IsS0FBSyxDQUFDLElBQUksRUFBRUM7Z0JBQ2xDO1lBQ0Y7WUFDQTdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDbUIsT0FBTyxHQUFHbytCLFNBQVMsQ0FBQ3ArQixPQUFPO1FBQ2hFO0lBQ0Y7QUFDRjtBQUVBLHFDQUFxQztBQUNyQyxTQUFTKytCLHFCQUFxQnhnQyxPQUFNLEVBQUVrMkIsY0FBYztJQUNsRHBELHdCQUF3Qjl5QixTQUFRLHFCQUFxQmQsQ0FBQUE7UUFDbkQsTUFBTW84QixLQUFLcDhCLEVBQUU4WSxNQUFNO1FBQ25CLElBQUlrZSxlQUFldFIsT0FBTyxHQUFHLE1BQU0wVyxHQUFHbUYsZ0JBQWdCLElBQUluRixHQUFHbUYsZ0JBQWdCLEdBQUdDLFlBQVksS0FBSyxVQUFVO1lBQ3pHLElBQUlwRixHQUFHMkQsY0FBYyxLQUFLLFVBQVU7Z0JBQ2xDO1lBQ0Y7UUFDRjtRQUNBLE9BQU8vL0I7SUFDVDtBQUNGO0FBRUEsSUFBSXloQyxhQUFhLFdBQVcsR0FBRXRoQyxPQUFPUSxNQUFNLENBQUM7SUFDM0MrZ0MsV0FBVztJQUNYSixzQkFBc0JBO0lBQ3RCN0IseUJBQXlCQTtJQUN6QlIsbUNBQW1DQTtJQUNuQzBDLHFCQUFxQnBIO0lBQ3JCMkIsd0JBQXdCQTtJQUN4QnVCLGNBQWNBO0lBQ2RtRSxrQkFBa0I3SztJQUNsQm9FLGlCQUFpQkE7SUFDakIwRyxhQUFhdkc7SUFDYndHLG9CQUFvQlY7SUFDcEJ6Qyw0QkFBNEJBO0FBQzdCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsbUJBQW1CLEdBQ25CLFNBQVNvRCxtQkFBbUJqaEMsT0FBTSxFQUFFazJCLGNBQWM7SUFDaEQsTUFBTWgxQixhQUFZbEIsV0FBVUEsUUFBT2tCLFNBQVM7SUFDNUMsTUFBTWc5QixvQkFBbUJsK0IsV0FBVUEsUUFBT2srQixnQkFBZ0I7SUFDMURoOUIsV0FBVSszQixZQUFZLEdBQUcsU0FBVWpDLFdBQVcsRUFBRStCLFNBQVMsRUFBRUMsT0FBTztRQUNoRSxxRUFBcUU7UUFDckU5RSxXQUFXLDBCQUEwQjtRQUNyQ2h6QixXQUFVaTFCLFlBQVksQ0FBQzhDLFlBQVksQ0FBQ2pDLGFBQWE3SixJQUFJLENBQUM0TCxXQUFXQztJQUNuRTtJQUNBLElBQUksQ0FBRTlDLENBQUFBLGVBQWV0UixPQUFPLEdBQUcsTUFBTSxxQkFBcUIxakIsV0FBVWkxQixZQUFZLENBQUNxQix1QkFBdUIsRUFBQyxHQUFJO1FBQzNHLE1BQU1MLFFBQVEsU0FBVTUxQixHQUFHLEVBQUVrTCxDQUFDLEVBQUVDLENBQUM7WUFDL0IsSUFBSUQsS0FBS2xMLE9BQU8sQ0FBRW1MLENBQUFBLEtBQUtuTCxHQUFFLEdBQUk7Z0JBQzNCQSxHQUFHLENBQUNtTCxFQUFFLEdBQUduTCxHQUFHLENBQUNrTCxFQUFFO2dCQUNmLE9BQU9sTCxHQUFHLENBQUNrTCxFQUFFO1lBQ2Y7UUFDRjtRQUNBLE1BQU15MEIscUJBQXFCaGdDLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxDQUFDdjNCLElBQUksQ0FBQ1IsV0FBVWkxQixZQUFZO1FBQzFGajFCLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxHQUFHLFNBQVV2aEIsQ0FBQztZQUMvQyxJQUFJLE9BQU9BLE1BQU0sWUFBWSxPQUFPQSxFQUFFd2YsS0FBSyxLQUFLLFVBQVU7Z0JBQ3hEeGYsSUFBSTlNLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS2MsU0FBUyxDQUFDZ007Z0JBQzlCeWYsTUFBTXpmLEVBQUV3ZixLQUFLLEVBQUUsbUJBQW1CO2dCQUNsQ0MsTUFBTXpmLEVBQUV3ZixLQUFLLEVBQUUsb0JBQW9CO1lBQ3JDO1lBQ0EsT0FBT2dLLG1CQUFtQnhwQjtRQUM1QjtRQUNBLElBQUl3bUIscUJBQW9CQSxrQkFBaUI1OUIsU0FBUyxDQUFDNmdDLFdBQVcsRUFBRTtZQUM5RCxNQUFNQyxvQkFBb0JsRCxrQkFBaUI1OUIsU0FBUyxDQUFDNmdDLFdBQVc7WUFDaEVqRCxrQkFBaUI1OUIsU0FBUyxDQUFDNmdDLFdBQVcsR0FBRztnQkFDdkMsTUFBTTUvQixNQUFNNi9CLGtCQUFrQngvQixLQUFLLENBQUMsSUFBSSxFQUFFQztnQkFDMUNzMUIsTUFBTTUxQixLQUFLLHNCQUFzQjtnQkFDakM0MUIsTUFBTTUxQixLQUFLLHVCQUF1QjtnQkFDbEMsT0FBT0E7WUFDVDtRQUNGO1FBQ0EsSUFBSTI4QixxQkFBb0JBLGtCQUFpQjU5QixTQUFTLENBQUMrZ0MsZ0JBQWdCLEVBQUU7WUFDbkUsTUFBTUMseUJBQXlCcEQsa0JBQWlCNTlCLFNBQVMsQ0FBQytnQyxnQkFBZ0I7WUFDMUVuRCxrQkFBaUI1OUIsU0FBUyxDQUFDK2dDLGdCQUFnQixHQUFHLFNBQVUzcEIsQ0FBQztnQkFDdkQsSUFBSSxJQUFJLENBQUNVLElBQUksS0FBSyxXQUFXLE9BQU9WLE1BQU0sVUFBVTtvQkFDbERBLElBQUk5TSxLQUFLQyxLQUFLLENBQUNELEtBQUtjLFNBQVMsQ0FBQ2dNO29CQUM5QnlmLE1BQU16ZixHQUFHLG1CQUFtQjtvQkFDNUJ5ZixNQUFNemYsR0FBRyxvQkFBb0I7Z0JBQy9CO2dCQUNBLE9BQU80cEIsdUJBQXVCMS9CLEtBQUssQ0FBQyxJQUFJLEVBQUU7b0JBQUM4VjtpQkFBRTtZQUMvQztRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELG1CQUFtQixHQUVuQixTQUFTbXBCLG9CQUFvQjdnQyxPQUFNLEVBQUV1aEMsb0JBQW9CO0lBQ3ZELElBQUl2aEMsUUFBT2tCLFNBQVMsQ0FBQ2kxQixZQUFZLElBQUkscUJBQXFCbjJCLFFBQU9rQixTQUFTLENBQUNpMUIsWUFBWSxFQUFFO1FBQ3ZGO0lBQ0Y7SUFDQSxJQUFJLENBQUNuMkIsUUFBT2tCLFNBQVMsQ0FBQ2kxQixZQUFZLEVBQUU7UUFDbEM7SUFDRjtJQUNBbjJCLFFBQU9rQixTQUFTLENBQUNpMUIsWUFBWSxDQUFDd0QsZUFBZSxHQUFHLFNBQVNBLGdCQUFnQjNDLFdBQVc7UUFDbEYsSUFBSSxDQUFFQSxDQUFBQSxlQUFlQSxZQUFZSSxLQUFLLEdBQUc7WUFDdkMsTUFBTXpILE1BQU0sSUFBSTZKLGFBQWEsbUNBQW1DO1lBQ2hFN0osSUFBSTlzQixJQUFJLEdBQUc7WUFDWCxxRUFBcUU7WUFDckU4c0IsSUFBSTZSLElBQUksR0FBRztZQUNYLE9BQU81VSxRQUFRQyxNQUFNLENBQUM4QztRQUN4QjtRQUNBLElBQUlxSCxZQUFZSSxLQUFLLEtBQUssTUFBTTtZQUM5QkosWUFBWUksS0FBSyxHQUFHO2dCQUNsQnFLLGFBQWFGO1lBQ2Y7UUFDRixPQUFPO1lBQ0x2SyxZQUFZSSxLQUFLLENBQUNxSyxXQUFXLEdBQUdGO1FBQ2xDO1FBQ0EsT0FBT3ZoQyxRQUFPa0IsU0FBUyxDQUFDaTFCLFlBQVksQ0FBQzhDLFlBQVksQ0FBQ2pDO0lBQ3BEO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxtQkFBbUIsR0FDbkIsU0FBUytKLFlBQVkvZ0MsT0FBTTtJQUN6QixJQUFJLE9BQU9BLFlBQVcsWUFBWUEsUUFBTzBoQyxhQUFhLElBQUksY0FBYzFoQyxRQUFPMGhDLGFBQWEsQ0FBQ3BoQyxTQUFTLElBQUksQ0FBRSxrQkFBaUJOLFFBQU8waEMsYUFBYSxDQUFDcGhDLFNBQVMsR0FBRztRQUM1SmpCLE9BQU9LLGNBQWMsQ0FBQ00sUUFBTzBoQyxhQUFhLENBQUNwaEMsU0FBUyxFQUFFLGVBQWU7WUFDbkVYO2dCQUNFLE9BQU87b0JBQ0xzdUIsVUFBVSxJQUFJLENBQUNBLFFBQVE7Z0JBQ3pCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTK1MsbUJBQW1CaGhDLE9BQU0sRUFBRWsyQixjQUFjO0lBQ2hELElBQUksT0FBT2wyQixZQUFXLFlBQVksQ0FBRUEsQ0FBQUEsUUFBT2l6QixpQkFBaUIsSUFBSWp6QixRQUFPMmhDLG9CQUFvQixHQUFHO1FBQzVGLFFBQVEsOERBQThEO0lBQ3hFO0lBQ0EsSUFBSSxDQUFDM2hDLFFBQU9pekIsaUJBQWlCLElBQUlqekIsUUFBTzJoQyxvQkFBb0IsRUFBRTtRQUM1RCx1Q0FBdUM7UUFDdkMzaEMsUUFBT2l6QixpQkFBaUIsR0FBR2p6QixRQUFPMmhDLG9CQUFvQjtJQUN4RDtJQUNBLElBQUl6TCxlQUFldFIsT0FBTyxHQUFHLElBQUk7UUFDL0IscUVBQXFFO1FBQ3JFO1lBQUM7WUFBdUI7WUFBd0I7U0FBa0IsQ0FBQzNsQixPQUFPLENBQUMsU0FBVXdDLE1BQU07WUFDekYsTUFBTW0rQixlQUFlNS9CLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDbUIsT0FBTztZQUMvRCxNQUFNbytCLFlBQVk7Z0JBQ2hCLENBQUNwK0IsT0FBTztvQkFDTkksU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFLSixDQUFBQSxXQUFXLG9CQUFvQnpCLFFBQU91Z0MsZUFBZSxHQUFHdmdDLFFBQU8wL0IscUJBQXFCLEVBQUU3OUIsU0FBUyxDQUFDLEVBQUU7b0JBQ3RILE9BQU8rOUIsYUFBYWgrQixLQUFLLENBQUMsSUFBSSxFQUFFQztnQkFDbEM7WUFDRjtZQUNBN0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNtQixPQUFPLEdBQUdvK0IsU0FBUyxDQUFDcCtCLE9BQU87UUFDaEU7SUFDRjtJQUNBLE1BQU1tZ0MsbUJBQW1CO1FBQ3ZCQyxZQUFZO1FBQ1pDLGFBQWE7UUFDYkMsZUFBZTtRQUNmdkUsZ0JBQWdCO1FBQ2hCQyxpQkFBaUI7SUFDbkI7SUFDQSxNQUFNdUUsaUJBQWlCaGlDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdThCLFFBQVE7SUFDbEU3OEIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN1OEIsUUFBUSxHQUFHLFNBQVNBO1FBQ3JELE1BQU0sQ0FBQ0MsVUFBVUMsUUFBUUMsTUFBTSxHQUFHbjdCO1FBQ2xDLE9BQU9tZ0MsZUFBZXBnQyxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQUNrN0IsWUFBWTtTQUFLLEVBQUUzUCxJQUFJLENBQUNnSSxDQUFBQTtZQUN6RCxJQUFJZSxlQUFldFIsT0FBTyxHQUFHLE1BQU0sQ0FBQ21ZLFFBQVE7Z0JBQzFDLDZEQUE2RDtnQkFDN0Qsb0VBQW9FO2dCQUNwRSxJQUFJO29CQUNGNUgsTUFBTWwyQixPQUFPLENBQUN5K0IsQ0FBQUE7d0JBQ1pBLEtBQUsxekIsSUFBSSxHQUFHNDNCLGdCQUFnQixDQUFDbEUsS0FBSzF6QixJQUFJLENBQUMsSUFBSTB6QixLQUFLMXpCLElBQUk7b0JBQ3REO2dCQUNGLEVBQUUsT0FBTzlLLEdBQUc7b0JBQ1YsSUFBSUEsRUFBRTJELElBQUksS0FBSyxhQUFhO3dCQUMxQixNQUFNM0Q7b0JBQ1I7b0JBQ0Esa0VBQWtFO29CQUNsRWkyQixNQUFNbDJCLE9BQU8sQ0FBQyxDQUFDeStCLE1BQU1wN0I7d0JBQ25CNnlCLE1BQU0vaUIsR0FBRyxDQUFDOVAsR0FBR2pELE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHcTBCLE1BQU07NEJBQ25DMXpCLE1BQU00M0IsZ0JBQWdCLENBQUNsRSxLQUFLMXpCLElBQUksQ0FBQyxJQUFJMHpCLEtBQUsxekIsSUFBSTt3QkFDaEQ7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU9tckI7UUFDVCxHQUFHaEksSUFBSSxDQUFDNFAsUUFBUUM7SUFDbEI7QUFDRjtBQUNBLFNBQVNpRixtQkFBbUJqaUMsT0FBTTtJQUNoQyxJQUFJLENBQUUsUUFBT0EsWUFBVyxZQUFZQSxRQUFPaXpCLGlCQUFpQixJQUFJanpCLFFBQU93OEIsWUFBWSxHQUFHO1FBQ3BGO0lBQ0Y7SUFDQSxJQUFJeDhCLFFBQU93OEIsWUFBWSxJQUFJLGNBQWN4OEIsUUFBT3c4QixZQUFZLENBQUNsOEIsU0FBUyxFQUFFO1FBQ3RFO0lBQ0Y7SUFDQSxNQUFNbThCLGlCQUFpQno4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E3QixVQUFVO0lBQ3BFLElBQUljLGdCQUFnQjtRQUNsQno4QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E3QixVQUFVLEdBQUcsU0FBU0E7WUFDdkQsTUFBTWUsVUFBVUQsZUFBZTc2QixLQUFLLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDN0M4NkIsUUFBUXo5QixPQUFPLENBQUM4OEIsQ0FBQUEsU0FBVUEsT0FBT0wsR0FBRyxHQUFHLElBQUk7WUFDM0MsT0FBT2dCO1FBQ1Q7SUFDRjtJQUNBLE1BQU1iLGVBQWU3N0IsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3N0IsUUFBUTtJQUNoRSxJQUFJRCxjQUFjO1FBQ2hCNzdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdzdCLFFBQVEsR0FBRyxTQUFTQTtZQUNyRCxNQUFNQyxTQUFTRixhQUFhajZCLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1lBQ3hDazZCLE9BQU9MLEdBQUcsR0FBRyxJQUFJO1lBQ2pCLE9BQU9LO1FBQ1Q7SUFDRjtJQUNBLzdCLFFBQU93OEIsWUFBWSxDQUFDbDhCLFNBQVMsQ0FBQ3U4QixRQUFRLEdBQUcsU0FBU0E7UUFDaEQsT0FBTyxJQUFJLENBQUNySCxLQUFLLEdBQUcsSUFBSSxDQUFDa0csR0FBRyxDQUFDbUIsUUFBUSxDQUFDLElBQUksQ0FBQ3JILEtBQUssSUFBSTVJLFFBQVFELE9BQU8sQ0FBQyxJQUFJK0c7SUFDMUU7QUFDRjtBQUNBLFNBQVN3TyxxQkFBcUJsaUMsT0FBTTtJQUNsQyxJQUFJLENBQUUsUUFBT0EsWUFBVyxZQUFZQSxRQUFPaXpCLGlCQUFpQixJQUFJanpCLFFBQU93OEIsWUFBWSxHQUFHO1FBQ3BGO0lBQ0Y7SUFDQSxJQUFJeDhCLFFBQU93OEIsWUFBWSxJQUFJLGNBQWN4OEIsUUFBTzg5QixjQUFjLENBQUN4OUIsU0FBUyxFQUFFO1FBQ3hFO0lBQ0Y7SUFDQSxNQUFNeTlCLG1CQUFtQi85QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3c2QixZQUFZO0lBQ3hFLElBQUlpRCxrQkFBa0I7UUFDcEIvOUIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3NkIsWUFBWSxHQUFHLFNBQVNBO1lBQ3pELE1BQU1rRCxZQUFZRCxpQkFBaUJuOEIsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ2pEbzhCLFVBQVUvK0IsT0FBTyxDQUFDZ3ZCLENBQUFBLFdBQVlBLFNBQVN5TixHQUFHLEdBQUcsSUFBSTtZQUNqRCxPQUFPc0M7UUFDVDtJQUNGO0lBQ0FsTCx3QkFBd0I5eUIsU0FBUSxTQUFTZCxDQUFBQTtRQUN2Q0EsRUFBRSt1QixRQUFRLENBQUN5TixHQUFHLEdBQUd4OEIsRUFBRSsrQixVQUFVO1FBQzdCLE9BQU8vK0I7SUFDVDtJQUNBYyxRQUFPODlCLGNBQWMsQ0FBQ3g5QixTQUFTLENBQUN1OEIsUUFBUSxHQUFHLFNBQVNBO1FBQ2xELE9BQU8sSUFBSSxDQUFDbkIsR0FBRyxDQUFDbUIsUUFBUSxDQUFDLElBQUksQ0FBQ3JILEtBQUs7SUFDckM7QUFDRjtBQUNBLFNBQVMyTSxpQkFBaUJuaUMsT0FBTTtJQUM5QixJQUFJLENBQUNBLFFBQU9pekIsaUJBQWlCLElBQUksa0JBQWtCanpCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxFQUFFO1FBQ3JGO0lBQ0Y7SUFDQU4sUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNpOEIsWUFBWSxHQUFHLFNBQVNBLGFBQWFwVyxNQUFNO1FBQzVFK04sV0FBVyxnQkFBZ0I7UUFDM0IsSUFBSSxDQUFDeUgsVUFBVSxHQUFHMThCLE9BQU8sQ0FBQzg4QixDQUFBQTtZQUN4QixJQUFJQSxPQUFPdkcsS0FBSyxJQUFJclAsT0FBT21ULFNBQVMsR0FBR3hCLFFBQVEsQ0FBQ2lFLE9BQU92RyxLQUFLLEdBQUc7Z0JBQzdELElBQUksQ0FBQ3lHLFdBQVcsQ0FBQ0Y7WUFDbkI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTcUcsbUJBQW1CcGlDLE9BQU07SUFDaEMsNkRBQTZEO0lBQzdELHVEQUF1RDtJQUN2RCxJQUFJQSxRQUFPcWlDLFdBQVcsSUFBSSxDQUFDcmlDLFFBQU9zaUMsY0FBYyxFQUFFO1FBQ2hEdGlDLFFBQU9zaUMsY0FBYyxHQUFHdGlDLFFBQU9xaUMsV0FBVztJQUM1QztBQUNGO0FBQ0EsU0FBU0UsbUJBQW1CdmlDLE9BQU07SUFDaEMsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSx1REFBdUQ7SUFDdkQsSUFBSSxDQUFFLFFBQU9BLFlBQVcsWUFBWUEsUUFBT2l6QixpQkFBaUIsR0FBRztRQUM3RDtJQUNGO0lBQ0EsTUFBTXVQLHFCQUFxQnhpQyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ21pQyxjQUFjO0lBQzVFLElBQUlELG9CQUFvQjtRQUN0QnhpQyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ21pQyxjQUFjLEdBQUcsU0FBU0E7WUFDM0QsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRyxFQUFFO1lBQy9CLHVDQUF1QztZQUN2QyxJQUFJQyxnQkFBZ0I5Z0MsU0FBUyxDQUFDLEVBQUUsSUFBSUEsU0FBUyxDQUFDLEVBQUUsQ0FBQzhnQyxhQUFhO1lBQzlELElBQUlBLGtCQUFrQnpnQyxXQUFXO2dCQUMvQnlnQyxnQkFBZ0IsRUFBRTtZQUNwQjtZQUNBQSxnQkFBZ0I7bUJBQUlBO2FBQWM7WUFDbEMsTUFBTUMscUJBQXFCRCxjQUFjcGdDLE1BQU0sR0FBRztZQUNsRCxJQUFJcWdDLG9CQUFvQjtnQkFDdEIseURBQXlEO2dCQUN6REQsY0FBYzFqQyxPQUFPLENBQUM0akMsQ0FBQUE7b0JBQ3BCLElBQUksU0FBU0EsZUFBZTt3QkFDMUIsTUFBTUMsV0FBVzt3QkFDakIsSUFBSSxDQUFDQSxTQUFTM2hDLElBQUksQ0FBQzBoQyxjQUFjRSxHQUFHLEdBQUc7NEJBQ3JDLE1BQU0sSUFBSTk5QixVQUFVO3dCQUN0QjtvQkFDRjtvQkFDQSxJQUFJLDJCQUEyQjQ5QixlQUFlO3dCQUM1QyxJQUFJLENBQUVHLENBQUFBLFdBQVdILGNBQWNJLHFCQUFxQixLQUFLLEdBQUUsR0FBSTs0QkFDN0QsTUFBTSxJQUFJL3RCLFdBQVc7d0JBQ3ZCO29CQUNGO29CQUNBLElBQUksa0JBQWtCMnRCLGVBQWU7d0JBQ25DLElBQUksQ0FBRUcsQ0FBQUEsV0FBV0gsY0FBY0ssWUFBWSxLQUFLLElBQUk7NEJBQ2xELE1BQU0sSUFBSWh1QixXQUFXO3dCQUN2QjtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsTUFBTStsQixjQUFjdUgsbUJBQW1CNWdDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1lBQ25ELElBQUkrZ0Msb0JBQW9CO2dCQUN0QixrRUFBa0U7Z0JBQ2xFLHNFQUFzRTtnQkFDdEUscUVBQXFFO2dCQUNyRSxrRUFBa0U7Z0JBQ2xFLGlFQUFpRTtnQkFDakUsOERBQThEO2dCQUM5RCxpQ0FBaUM7Z0JBQ2pDLE1BQU0sRUFDSjdHLE1BQU0sRUFDUCxHQUFHZDtnQkFDSixNQUFNa0ksU0FBU3BILE9BQU9xSCxhQUFhO2dCQUNuQyxJQUFJLENBQUUsZ0JBQWVELE1BQUssS0FDMUIsdURBQXVEO2dCQUN2REEsT0FBT0UsU0FBUyxDQUFDOWdDLE1BQU0sS0FBSyxLQUFLbEQsT0FBT0MsSUFBSSxDQUFDNmpDLE9BQU9FLFNBQVMsQ0FBQyxFQUFFLEVBQUU5Z0MsTUFBTSxLQUFLLEdBQUc7b0JBQzlFNGdDLE9BQU9FLFNBQVMsR0FBR1Y7b0JBQ25CNUcsT0FBTzRHLGFBQWEsR0FBR0E7b0JBQ3ZCLElBQUksQ0FBQ0QscUJBQXFCLENBQUN6NUIsSUFBSSxDQUFDOHlCLE9BQU91SCxhQUFhLENBQUNILFFBQVFoVyxJQUFJLENBQUM7d0JBQ2hFLE9BQU80TyxPQUFPNEcsYUFBYTtvQkFDN0IsR0FBR1ksS0FBSyxDQUFDO3dCQUNQLE9BQU94SCxPQUFPNEcsYUFBYTtvQkFDN0I7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU8xSDtRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVN1SSxrQkFBa0J4akMsT0FBTTtJQUMvQixJQUFJLENBQUUsUUFBT0EsWUFBVyxZQUFZQSxRQUFPdzhCLFlBQVksR0FBRztRQUN4RDtJQUNGO0lBQ0EsTUFBTWlILG9CQUFvQnpqQyxRQUFPdzhCLFlBQVksQ0FBQ2w4QixTQUFTLENBQUM4aUMsYUFBYTtJQUNyRSxJQUFJSyxtQkFBbUI7UUFDckJ6akMsUUFBT3c4QixZQUFZLENBQUNsOEIsU0FBUyxDQUFDOGlDLGFBQWEsR0FBRyxTQUFTQTtZQUNyRCxNQUFNRCxTQUFTTSxrQkFBa0I3aEMsS0FBSyxDQUFDLElBQUksRUFBRUM7WUFDN0MsSUFBSSxDQUFFLGdCQUFlc2hDLE1BQUssR0FBSTtnQkFDNUJBLE9BQU9FLFNBQVMsR0FBRyxFQUFFLENBQUN2NEIsTUFBTSxDQUFDLElBQUksQ0FBQzYzQixhQUFhLElBQUk7b0JBQUMsQ0FBQztpQkFBRTtZQUN6RDtZQUNBLE9BQU9RO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsU0FBU08sZ0JBQWdCMWpDLE9BQU07SUFDN0IsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSx1REFBdUQ7SUFDdkQsSUFBSSxDQUFFLFFBQU9BLFlBQVcsWUFBWUEsUUFBT2l6QixpQkFBaUIsR0FBRztRQUM3RDtJQUNGO0lBQ0EsTUFBTTBRLGtCQUFrQjNqQyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3NqQyxXQUFXO0lBQ3RFNWpDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDc2pDLFdBQVcsR0FBRyxTQUFTQTtRQUN4RCxJQUFJLElBQUksQ0FBQ2xCLHFCQUFxQixJQUFJLElBQUksQ0FBQ0EscUJBQXFCLENBQUNuZ0MsTUFBTSxFQUFFO1lBQ25FLE9BQU9xcUIsUUFBUWpPLEdBQUcsQ0FBQyxJQUFJLENBQUMrakIscUJBQXFCLEVBQUV2VixJQUFJLENBQUM7Z0JBQ2xELE9BQU93VyxnQkFBZ0IvaEMsS0FBSyxDQUFDLElBQUksRUFBRUM7WUFDckMsR0FBR2dpQyxPQUFPLENBQUM7Z0JBQ1QsSUFBSSxDQUFDbkIscUJBQXFCLEdBQUcsRUFBRTtZQUNqQztRQUNGO1FBQ0EsT0FBT2lCLGdCQUFnQi9oQyxLQUFLLENBQUMsSUFBSSxFQUFFQztJQUNyQztBQUNGO0FBQ0EsU0FBU2lpQyxpQkFBaUI5akMsT0FBTTtJQUM5QiwyRUFBMkU7SUFDM0UsMEVBQTBFO0lBQzFFLHVEQUF1RDtJQUN2RCxJQUFJLENBQUUsUUFBT0EsWUFBVyxZQUFZQSxRQUFPaXpCLGlCQUFpQixHQUFHO1FBQzdEO0lBQ0Y7SUFDQSxNQUFNOFEsbUJBQW1CL2pDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDMGpDLFlBQVk7SUFDeEVoa0MsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUMwakMsWUFBWSxHQUFHLFNBQVNBO1FBQ3pELElBQUksSUFBSSxDQUFDdEIscUJBQXFCLElBQUksSUFBSSxDQUFDQSxxQkFBcUIsQ0FBQ25nQyxNQUFNLEVBQUU7WUFDbkUsT0FBT3FxQixRQUFRak8sR0FBRyxDQUFDLElBQUksQ0FBQytqQixxQkFBcUIsRUFBRXZWLElBQUksQ0FBQztnQkFDbEQsT0FBTzRXLGlCQUFpQm5pQyxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUN0QyxHQUFHZ2lDLE9BQU8sQ0FBQztnQkFDVCxJQUFJLENBQUNuQixxQkFBcUIsR0FBRyxFQUFFO1lBQ2pDO1FBQ0Y7UUFDQSxPQUFPcUIsaUJBQWlCbmlDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQ3RDO0FBQ0Y7QUFFQSxJQUFJb2lDLGNBQWMsV0FBVyxHQUFFNWtDLE9BQU9RLE1BQU0sQ0FBQztJQUM1QytnQyxXQUFXO0lBQ1gyQixvQkFBb0JBO0lBQ3BCdUIsa0JBQWtCQTtJQUNsQkosaUJBQWlCQTtJQUNqQjdDLHFCQUFxQkE7SUFDckIyQyxtQkFBbUJBO0lBQ25CMUMsa0JBQWtCRztJQUNsQkYsYUFBYUE7SUFDYkMsb0JBQW9CQTtJQUNwQm9CLG9CQUFvQkE7SUFDcEJGLHNCQUFzQkE7SUFDdEJDLGtCQUFrQkE7SUFDbEJGLG9CQUFvQkE7QUFDckI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTaUMsb0JBQW9CbGtDLE9BQU07SUFDakMsSUFBSSxPQUFPQSxZQUFXLFlBQVksQ0FBQ0EsUUFBT2l6QixpQkFBaUIsRUFBRTtRQUMzRDtJQUNGO0lBQ0EsSUFBSSxDQUFFLHNCQUFxQmp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsR0FBRztRQUM5RE4sUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUM4OUIsZUFBZSxHQUFHLFNBQVNBO1lBQzVELElBQUksQ0FBQyxJQUFJLENBQUMrRixhQUFhLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLEVBQUU7WUFDekI7WUFDQSxPQUFPLElBQUksQ0FBQ0EsYUFBYTtRQUMzQjtJQUNGO0lBQ0EsSUFBSSxDQUFFLGdCQUFlbmtDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxHQUFHO1FBQ3hELE1BQU04akMsWUFBWXBrQyxRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3c3QixRQUFRO1FBQzdEOTdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDKzdCLFNBQVMsR0FBRyxTQUFTQSxVQUFVbFcsTUFBTTtZQUN0RSxJQUFJLENBQUMsSUFBSSxDQUFDZ2UsYUFBYSxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGFBQWEsR0FBRyxFQUFFO1lBQ3pCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0EsYUFBYSxDQUFDck0sUUFBUSxDQUFDM1IsU0FBUztnQkFDeEMsSUFBSSxDQUFDZ2UsYUFBYSxDQUFDbDdCLElBQUksQ0FBQ2tkO1lBQzFCO1lBQ0Esb0VBQW9FO1lBQ3BFLDZCQUE2QjtZQUM3QkEsT0FBT2lULGNBQWMsR0FBR242QixPQUFPLENBQUN1MkIsQ0FBQUEsUUFBUzRPLFVBQVU1akMsSUFBSSxDQUFDLElBQUksRUFBRWcxQixPQUFPclA7WUFDckVBLE9BQU9rVCxjQUFjLEdBQUdwNkIsT0FBTyxDQUFDdTJCLENBQUFBLFFBQVM0TyxVQUFVNWpDLElBQUksQ0FBQyxJQUFJLEVBQUVnMUIsT0FBT3JQO1FBQ3ZFO1FBQ0FubUIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN3N0IsUUFBUSxHQUFHLFNBQVNBLFNBQVN0RyxLQUFLO1lBQ25FLElBQUssSUFBSTZPLE9BQU94aUMsVUFBVVUsTUFBTSxFQUFFMjRCLFVBQVUsSUFBSS83QixNQUFNa2xDLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlDLE9BQU8sR0FBR0EsT0FBT0QsTUFBTUMsT0FBUTtnQkFDN0dwSixPQUFPLENBQUNvSixPQUFPLEVBQUUsR0FBR3ppQyxTQUFTLENBQUN5aUMsS0FBSztZQUNyQztZQUNBLElBQUlwSixTQUFTO2dCQUNYQSxRQUFRajhCLE9BQU8sQ0FBQ2tuQixDQUFBQTtvQkFDZCxJQUFJLENBQUMsSUFBSSxDQUFDZ2UsYUFBYSxFQUFFO3dCQUN2QixJQUFJLENBQUNBLGFBQWEsR0FBRzs0QkFBQ2hlO3lCQUFPO29CQUMvQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNnZSxhQUFhLENBQUNyTSxRQUFRLENBQUMzUixTQUFTO3dCQUMvQyxJQUFJLENBQUNnZSxhQUFhLENBQUNsN0IsSUFBSSxDQUFDa2Q7b0JBQzFCO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPaWUsVUFBVXhpQyxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUMvQjtJQUNGO0lBQ0EsSUFBSSxDQUFFLG1CQUFrQjdCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxHQUFHO1FBQzNETixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ2k4QixZQUFZLEdBQUcsU0FBU0EsYUFBYXBXLE1BQU07WUFDNUUsSUFBSSxDQUFDLElBQUksQ0FBQ2dlLGFBQWEsRUFBRTtnQkFDdkIsSUFBSSxDQUFDQSxhQUFhLEdBQUcsRUFBRTtZQUN6QjtZQUNBLE1BQU1yUyxRQUFRLElBQUksQ0FBQ3FTLGFBQWEsQ0FBQ3JnQyxPQUFPLENBQUNxaUI7WUFDekMsSUFBSTJMLFVBQVUsQ0FBQyxHQUFHO2dCQUNoQjtZQUNGO1lBQ0EsSUFBSSxDQUFDcVMsYUFBYSxDQUFDaEksTUFBTSxDQUFDckssT0FBTztZQUNqQyxNQUFNcE4sU0FBU3lCLE9BQU9tVCxTQUFTO1lBQy9CLElBQUksQ0FBQ3FDLFVBQVUsR0FBRzE4QixPQUFPLENBQUM4OEIsQ0FBQUE7Z0JBQ3hCLElBQUlyWCxPQUFPb1QsUUFBUSxDQUFDaUUsT0FBT3ZHLEtBQUssR0FBRztvQkFDakMsSUFBSSxDQUFDeUcsV0FBVyxDQUFDRjtnQkFDbkI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVN3SSxxQkFBcUJ2a0MsT0FBTTtJQUNsQyxJQUFJLE9BQU9BLFlBQVcsWUFBWSxDQUFDQSxRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzNEO0lBQ0Y7SUFDQSxJQUFJLENBQUUsdUJBQXNCanpCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxHQUFHO1FBQy9ETixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ2trQyxnQkFBZ0IsR0FBRyxTQUFTQTtZQUM3RCxPQUFPLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxHQUFHLEVBQUU7UUFDdkQ7SUFDRjtJQUNBLElBQUksQ0FBRSxrQkFBaUJ6a0MsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEdBQUc7UUFDMURqQixPQUFPSyxjQUFjLENBQUNNLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxFQUFFLGVBQWU7WUFDdkVYO2dCQUNFLE9BQU8sSUFBSSxDQUFDK2tDLFlBQVk7WUFDMUI7WUFDQXR5QixLQUFJdUYsQ0FBQztnQkFDSCxJQUFJLElBQUksQ0FBQytzQixZQUFZLEVBQUU7b0JBQ3JCLElBQUksQ0FBQ25TLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDbVMsWUFBWTtvQkFDdkQsSUFBSSxDQUFDblMsbUJBQW1CLENBQUMsU0FBUyxJQUFJLENBQUNvUyxnQkFBZ0I7Z0JBQ3pEO2dCQUNBLElBQUksQ0FBQ3RTLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDcVMsWUFBWSxHQUFHL3NCO2dCQUN2RCxJQUFJLENBQUMwYSxnQkFBZ0IsQ0FBQyxTQUFTLElBQUksQ0FBQ3NTLGdCQUFnQixHQUFHemxDLENBQUFBO29CQUNyREEsRUFBRWc4QixPQUFPLENBQUNqOEIsT0FBTyxDQUFDa25CLENBQUFBO3dCQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDc2UsY0FBYyxFQUFFOzRCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRyxFQUFFO3dCQUMxQjt3QkFDQSxJQUFJLElBQUksQ0FBQ0EsY0FBYyxDQUFDM00sUUFBUSxDQUFDM1IsU0FBUzs0QkFDeEM7d0JBQ0Y7d0JBQ0EsSUFBSSxDQUFDc2UsY0FBYyxDQUFDeDdCLElBQUksQ0FBQ2tkO3dCQUN6QixNQUFNNFUsUUFBUSxJQUFJQyxNQUFNO3dCQUN4QkQsTUFBTTVVLE1BQU0sR0FBR0E7d0JBQ2YsSUFBSSxDQUFDZ1YsYUFBYSxDQUFDSjtvQkFDckI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsTUFBTUwsMkJBQTJCMTZCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDcTZCLG9CQUFvQjtRQUN4RjM2QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E2QixvQkFBb0IsR0FBRyxTQUFTQTtZQUNqRSxNQUFNVyxLQUFLLElBQUk7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDcUosZ0JBQWdCLEVBQUU7Z0JBQzFCLElBQUksQ0FBQ3RTLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDc1MsZ0JBQWdCLEdBQUcsU0FBVXpsQyxDQUFDO29CQUNoRUEsRUFBRWc4QixPQUFPLENBQUNqOEIsT0FBTyxDQUFDa25CLENBQUFBO3dCQUNoQixJQUFJLENBQUNtVixHQUFHbUosY0FBYyxFQUFFOzRCQUN0Qm5KLEdBQUdtSixjQUFjLEdBQUcsRUFBRTt3QkFDeEI7d0JBQ0EsSUFBSW5KLEdBQUdtSixjQUFjLENBQUMzZ0MsT0FBTyxDQUFDcWlCLFdBQVcsR0FBRzs0QkFDMUM7d0JBQ0Y7d0JBQ0FtVixHQUFHbUosY0FBYyxDQUFDeDdCLElBQUksQ0FBQ2tkO3dCQUN2QixNQUFNNFUsUUFBUSxJQUFJQyxNQUFNO3dCQUN4QkQsTUFBTTVVLE1BQU0sR0FBR0E7d0JBQ2ZtVixHQUFHSCxhQUFhLENBQUNKO29CQUNuQjtnQkFDRjtZQUNGO1lBQ0EsT0FBT0wseUJBQXlCOTRCLEtBQUssQ0FBQzA1QixJQUFJejVCO1FBQzVDO0lBQ0Y7QUFDRjtBQUNBLFNBQVMraUMsaUJBQWlCNWtDLE9BQU07SUFDOUIsSUFBSSxPQUFPQSxZQUFXLFlBQVksQ0FBQ0EsUUFBT2l6QixpQkFBaUIsRUFBRTtRQUMzRDtJQUNGO0lBQ0EsTUFBTTN5QixZQUFZTixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVM7SUFDcEQsTUFBTXFqQyxrQkFBa0JyakMsVUFBVXNqQyxXQUFXO0lBQzdDLE1BQU1HLG1CQUFtQnpqQyxVQUFVMGpDLFlBQVk7SUFDL0MsTUFBTS9ELHNCQUFzQjMvQixVQUFVMi9CLG1CQUFtQjtJQUN6RCxNQUFNdEYsdUJBQXVCcjZCLFVBQVVxNkIsb0JBQW9CO0lBQzNELE1BQU1rSyxrQkFBa0J2a0MsVUFBVXVrQyxlQUFlO0lBQ2pEdmtDLFVBQVVzakMsV0FBVyxHQUFHLFNBQVNBLFlBQVlrQixlQUFlLEVBQUVDLGVBQWU7UUFDM0UsTUFBTWg3QixVQUFVbEksVUFBVVUsTUFBTSxJQUFJLElBQUlWLFNBQVMsQ0FBQyxFQUFFLEdBQUdBLFNBQVMsQ0FBQyxFQUFFO1FBQ25FLE1BQU1takMsVUFBVXJCLGdCQUFnQi9oQyxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQUNtSTtTQUFRO1FBQ3JELElBQUksQ0FBQ2c3QixpQkFBaUI7WUFDcEIsT0FBT0M7UUFDVDtRQUNBQSxRQUFRN1gsSUFBSSxDQUFDMlgsaUJBQWlCQztRQUM5QixPQUFPblksUUFBUUQsT0FBTztJQUN4QjtJQUNBcnNCLFVBQVUwakMsWUFBWSxHQUFHLFNBQVNBLGFBQWFjLGVBQWUsRUFBRUMsZUFBZTtRQUM3RSxNQUFNaDdCLFVBQVVsSSxVQUFVVSxNQUFNLElBQUksSUFBSVYsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUU7UUFDbkUsTUFBTW1qQyxVQUFVakIsaUJBQWlCbmlDLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQ21JO1NBQVE7UUFDdEQsSUFBSSxDQUFDZzdCLGlCQUFpQjtZQUNwQixPQUFPQztRQUNUO1FBQ0FBLFFBQVE3WCxJQUFJLENBQUMyWCxpQkFBaUJDO1FBQzlCLE9BQU9uWSxRQUFRRCxPQUFPO0lBQ3hCO0lBQ0EsSUFBSXNZLGVBQWUsU0FBVTdGLFdBQVcsRUFBRTBGLGVBQWUsRUFBRUMsZUFBZTtRQUN4RSxNQUFNQyxVQUFVL0Usb0JBQW9CcitCLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQ3c5QjtTQUFZO1FBQzdELElBQUksQ0FBQzJGLGlCQUFpQjtZQUNwQixPQUFPQztRQUNUO1FBQ0FBLFFBQVE3WCxJQUFJLENBQUMyWCxpQkFBaUJDO1FBQzlCLE9BQU9uWSxRQUFRRCxPQUFPO0lBQ3hCO0lBQ0Fyc0IsVUFBVTIvQixtQkFBbUIsR0FBR2dGO0lBQ2hDQSxlQUFlLFNBQVU3RixXQUFXLEVBQUUwRixlQUFlLEVBQUVDLGVBQWU7UUFDcEUsTUFBTUMsVUFBVXJLLHFCQUFxQi80QixLQUFLLENBQUMsSUFBSSxFQUFFO1lBQUN3OUI7U0FBWTtRQUM5RCxJQUFJLENBQUMyRixpQkFBaUI7WUFDcEIsT0FBT0M7UUFDVDtRQUNBQSxRQUFRN1gsSUFBSSxDQUFDMlgsaUJBQWlCQztRQUM5QixPQUFPblksUUFBUUQsT0FBTztJQUN4QjtJQUNBcnNCLFVBQVVxNkIsb0JBQW9CLEdBQUdzSztJQUNqQ0EsZUFBZSxTQUFVQyxTQUFTLEVBQUVKLGVBQWUsRUFBRUMsZUFBZTtRQUNsRSxNQUFNQyxVQUFVSCxnQkFBZ0JqakMsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDc2pDO1NBQVU7UUFDdkQsSUFBSSxDQUFDSCxpQkFBaUI7WUFDcEIsT0FBT0M7UUFDVDtRQUNBQSxRQUFRN1gsSUFBSSxDQUFDMlgsaUJBQWlCQztRQUM5QixPQUFPblksUUFBUUQsT0FBTztJQUN4QjtJQUNBcnNCLFVBQVV1a0MsZUFBZSxHQUFHSTtBQUM5QjtBQUNBLFNBQVNuRSxpQkFBaUI5Z0MsT0FBTTtJQUM5QixNQUFNa0IsYUFBWWxCLFdBQVVBLFFBQU9rQixTQUFTO0lBQzVDLElBQUlBLFdBQVVpMUIsWUFBWSxJQUFJajFCLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxFQUFFO1FBQ2pFLGlDQUFpQztRQUNqQyxNQUFNOUMsZUFBZWoxQixXQUFVaTFCLFlBQVk7UUFDM0MsTUFBTWdQLGdCQUFnQmhQLGFBQWE4QyxZQUFZLENBQUN2M0IsSUFBSSxDQUFDeTBCO1FBQ3JEajFCLFdBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxHQUFHakMsQ0FBQUE7WUFDcEMsT0FBT21PLGNBQWNDLGdCQUFnQnBPO1FBQ3ZDO0lBQ0Y7SUFDQSxJQUFJLENBQUM5MUIsV0FBVSszQixZQUFZLElBQUkvM0IsV0FBVWkxQixZQUFZLElBQUlqMUIsV0FBVWkxQixZQUFZLENBQUM4QyxZQUFZLEVBQUU7UUFDNUYvM0IsV0FBVSszQixZQUFZLEdBQUcsVUFBU0EsYUFBYWpDLFdBQVcsRUFBRTNELEVBQUUsRUFBRWdTLEtBQUs7WUFDbkVua0MsV0FBVWkxQixZQUFZLENBQUM4QyxZQUFZLENBQUNqQyxhQUFhN0osSUFBSSxDQUFDa0csSUFBSWdTO1FBQzVELEdBQUUzakMsSUFBSSxDQUFDUjtJQUNUO0FBQ0Y7QUFDQSxTQUFTa2tDLGdCQUFnQnBPLFdBQVc7SUFDbEMsSUFBSUEsZUFBZUEsWUFBWUksS0FBSyxLQUFLbDFCLFdBQVc7UUFDbEQsT0FBTzdDLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHMnRCLGFBQWE7WUFDcENJLE9BQU92QyxjQUFjbUMsWUFBWUksS0FBSztRQUN4QztJQUNGO0lBQ0EsT0FBT0o7QUFDVDtBQUNBLFNBQVNzTyxxQkFBcUJ0bEMsT0FBTTtJQUNsQyxJQUFJLENBQUNBLFFBQU9pekIsaUJBQWlCLEVBQUU7UUFDN0I7SUFDRjtJQUNBLDhEQUE4RDtJQUM5RCxNQUFNc1MscUJBQXFCdmxDLFFBQU9pekIsaUJBQWlCO0lBQ25EanpCLFFBQU9pekIsaUJBQWlCLEdBQUcsU0FBU0EsbUJBQWtCdVMsUUFBUSxFQUFFQyxhQUFhO1FBQzNFLElBQUlELFlBQVlBLFNBQVNFLFVBQVUsRUFBRTtZQUNuQyxNQUFNQyxnQkFBZ0IsRUFBRTtZQUN4QixJQUFLLElBQUlyakMsSUFBSSxHQUFHQSxJQUFJa2pDLFNBQVNFLFVBQVUsQ0FBQ25qQyxNQUFNLEVBQUVELElBQUs7Z0JBQ25ELElBQUlzakMsU0FBU0osU0FBU0UsVUFBVSxDQUFDcGpDLEVBQUU7Z0JBQ25DLElBQUlzakMsT0FBT0MsSUFBSSxLQUFLM2pDLGFBQWEwakMsT0FBT0UsR0FBRyxFQUFFO29CQUMzQzVSLFdBQVcsb0JBQW9CO29CQUMvQjBSLFNBQVNoN0IsS0FBS0MsS0FBSyxDQUFDRCxLQUFLYyxTQUFTLENBQUNrNkI7b0JBQ25DQSxPQUFPQyxJQUFJLEdBQUdELE9BQU9FLEdBQUc7b0JBQ3hCLE9BQU9GLE9BQU9FLEdBQUc7b0JBQ2pCSCxjQUFjMThCLElBQUksQ0FBQzI4QjtnQkFDckIsT0FBTztvQkFDTEQsY0FBYzE4QixJQUFJLENBQUN1OEIsU0FBU0UsVUFBVSxDQUFDcGpDLEVBQUU7Z0JBQzNDO1lBQ0Y7WUFDQWtqQyxTQUFTRSxVQUFVLEdBQUdDO1FBQ3hCO1FBQ0EsT0FBTyxJQUFJSixtQkFBbUJDLFVBQVVDO0lBQzFDO0lBQ0F6bEMsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEdBQUdpbEMsbUJBQW1CamxDLFNBQVM7SUFDakUsMkRBQTJEO0lBQzNELElBQUkseUJBQXlCaWxDLG9CQUFvQjtRQUMvQ2xtQyxPQUFPSyxjQUFjLENBQUNNLFFBQU9pekIsaUJBQWlCLEVBQUUsdUJBQXVCO1lBQ3JFdHpCO2dCQUNFLE9BQU80bEMsbUJBQW1CUSxtQkFBbUI7WUFDL0M7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTQywwQkFBMEJobUMsT0FBTTtJQUN2Qyw4REFBOEQ7SUFDOUQsSUFBSSxPQUFPQSxZQUFXLFlBQVlBLFFBQU8waEMsYUFBYSxJQUFJLGNBQWMxaEMsUUFBTzBoQyxhQUFhLENBQUNwaEMsU0FBUyxJQUFJLENBQUUsa0JBQWlCTixRQUFPMGhDLGFBQWEsQ0FBQ3BoQyxTQUFTLEdBQUc7UUFDNUpqQixPQUFPSyxjQUFjLENBQUNNLFFBQU8waEMsYUFBYSxDQUFDcGhDLFNBQVMsRUFBRSxlQUFlO1lBQ25FWDtnQkFDRSxPQUFPO29CQUNMc3VCLFVBQVUsSUFBSSxDQUFDQSxRQUFRO2dCQUN6QjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU2dZLHNCQUFzQmptQyxPQUFNO0lBQ25DLE1BQU0yakMsa0JBQWtCM2pDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDc2pDLFdBQVc7SUFDdEU1akMsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNzakMsV0FBVyxHQUFHLFNBQVNBLFlBQVlzQyxZQUFZO1FBQ2hGLElBQUlBLGNBQWM7WUFDaEIsSUFBSSxPQUFPQSxhQUFhQyxtQkFBbUIsS0FBSyxhQUFhO2dCQUMzRCxxQkFBcUI7Z0JBQ3JCRCxhQUFhQyxtQkFBbUIsR0FBRyxDQUFDLENBQUNELGFBQWFDLG1CQUFtQjtZQUN2RTtZQUNBLE1BQU1DLG1CQUFtQixJQUFJLENBQUNDLGVBQWUsR0FBR3R1QixJQUFJLENBQUNrakIsQ0FBQUEsY0FBZUEsWUFBWWhOLFFBQVEsQ0FBQ3VILEtBQUssQ0FBQ3BkLElBQUksS0FBSztZQUN4RyxJQUFJOHRCLGFBQWFDLG1CQUFtQixLQUFLLFNBQVNDLGtCQUFrQjtnQkFDbEUsSUFBSUEsaUJBQWlCRSxTQUFTLEtBQUssWUFBWTtvQkFDN0MsSUFBSUYsaUJBQWlCRyxZQUFZLEVBQUU7d0JBQ2pDSCxpQkFBaUJHLFlBQVksQ0FBQztvQkFDaEMsT0FBTzt3QkFDTEgsaUJBQWlCRSxTQUFTLEdBQUc7b0JBQy9CO2dCQUNGLE9BQU8sSUFBSUYsaUJBQWlCRSxTQUFTLEtBQUssWUFBWTtvQkFDcEQsSUFBSUYsaUJBQWlCRyxZQUFZLEVBQUU7d0JBQ2pDSCxpQkFBaUJHLFlBQVksQ0FBQztvQkFDaEMsT0FBTzt3QkFDTEgsaUJBQWlCRSxTQUFTLEdBQUc7b0JBQy9CO2dCQUNGO1lBQ0YsT0FBTyxJQUFJSixhQUFhQyxtQkFBbUIsS0FBSyxRQUFRLENBQUNDLGtCQUFrQjtnQkFDekUsSUFBSSxDQUFDM0QsY0FBYyxDQUFDLFNBQVM7b0JBQzNCNkQsV0FBVztnQkFDYjtZQUNGO1lBQ0EsSUFBSSxPQUFPSixhQUFhTSxtQkFBbUIsS0FBSyxhQUFhO2dCQUMzRCxxQkFBcUI7Z0JBQ3JCTixhQUFhTSxtQkFBbUIsR0FBRyxDQUFDLENBQUNOLGFBQWFNLG1CQUFtQjtZQUN2RTtZQUNBLE1BQU1DLG1CQUFtQixJQUFJLENBQUNKLGVBQWUsR0FBR3R1QixJQUFJLENBQUNrakIsQ0FBQUEsY0FBZUEsWUFBWWhOLFFBQVEsQ0FBQ3VILEtBQUssQ0FBQ3BkLElBQUksS0FBSztZQUN4RyxJQUFJOHRCLGFBQWFNLG1CQUFtQixLQUFLLFNBQVNDLGtCQUFrQjtnQkFDbEUsSUFBSUEsaUJBQWlCSCxTQUFTLEtBQUssWUFBWTtvQkFDN0MsSUFBSUcsaUJBQWlCRixZQUFZLEVBQUU7d0JBQ2pDRSxpQkFBaUJGLFlBQVksQ0FBQztvQkFDaEMsT0FBTzt3QkFDTEUsaUJBQWlCSCxTQUFTLEdBQUc7b0JBQy9CO2dCQUNGLE9BQU8sSUFBSUcsaUJBQWlCSCxTQUFTLEtBQUssWUFBWTtvQkFDcEQsSUFBSUcsaUJBQWlCRixZQUFZLEVBQUU7d0JBQ2pDRSxpQkFBaUJGLFlBQVksQ0FBQztvQkFDaEMsT0FBTzt3QkFDTEUsaUJBQWlCSCxTQUFTLEdBQUc7b0JBQy9CO2dCQUNGO1lBQ0YsT0FBTyxJQUFJSixhQUFhTSxtQkFBbUIsS0FBSyxRQUFRLENBQUNDLGtCQUFrQjtnQkFDekUsSUFBSSxDQUFDaEUsY0FBYyxDQUFDLFNBQVM7b0JBQzNCNkQsV0FBVztnQkFDYjtZQUNGO1FBQ0Y7UUFDQSxPQUFPM0MsZ0JBQWdCL2hDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQ3JDO0FBQ0Y7QUFDQSxTQUFTNmtDLGlCQUFpQjFtQyxPQUFNO0lBQzlCLElBQUksT0FBT0EsWUFBVyxZQUFZQSxRQUFPMm1DLFlBQVksRUFBRTtRQUNyRDtJQUNGO0lBQ0EzbUMsUUFBTzJtQyxZQUFZLEdBQUczbUMsUUFBTzRtQyxrQkFBa0I7QUFDakQ7QUFFQSxJQUFJQyxhQUFhLFdBQVcsR0FBRXhuQyxPQUFPUSxNQUFNLENBQUM7SUFDM0MrZ0MsV0FBVztJQUNYOEYsa0JBQWtCQTtJQUNsQjlCLGtCQUFrQkE7SUFDbEJRLGlCQUFpQkE7SUFDakJhLHVCQUF1QkE7SUFDdkJuRixrQkFBa0JBO0lBQ2xCb0QscUJBQXFCQTtJQUNyQm9CLHNCQUFzQkE7SUFDdEJmLHNCQUFzQkE7SUFDdEJ5QiwyQkFBMkJBO0FBQzVCO0FBRUEsSUFBSWMsUUFBUTtJQUFDcG1DLFNBQVMsQ0FBQztBQUFDO0FBRXhCLG1CQUFtQixHQUNsQixVQUFVQyxNQUFNO0lBRWYsZUFBZTtJQUNmLE1BQU1vbUMsV0FBVyxDQUFDO0lBRWxCLHlEQUF5RDtJQUN6RCw4REFBOEQ7SUFDOURBLFNBQVNDLGtCQUFrQixHQUFHO1FBQzVCLE9BQU8zM0IsS0FBSytjLE1BQU0sR0FBRzdjLFFBQVEsQ0FBQyxJQUFJckQsU0FBUyxDQUFDLEdBQUc7SUFDakQ7SUFFQSwrREFBK0Q7SUFDL0Q2NkIsU0FBU0UsVUFBVSxHQUFHRixTQUFTQyxrQkFBa0I7SUFFakQsd0RBQXdEO0lBQ3hERCxTQUFTRyxVQUFVLEdBQUcsU0FBVUMsSUFBSTtRQUNsQyxPQUFPQSxLQUFLcnFCLElBQUksR0FBR3pDLEtBQUssQ0FBQyxNQUFNcFUsR0FBRyxDQUFDbWhDLENBQUFBLE9BQVFBLEtBQUt0cUIsSUFBSTtJQUN0RDtJQUNBLCtEQUErRDtJQUMvRGlxQixTQUFTTSxhQUFhLEdBQUcsU0FBVUYsSUFBSTtRQUNyQyxNQUFNRyxRQUFRSCxLQUFLOXNCLEtBQUssQ0FBQztRQUN6QixPQUFPaXRCLE1BQU1yaEMsR0FBRyxDQUFDLENBQUNzaEMsTUFBTXpWLFFBQVUsQ0FBQ0EsUUFBUSxJQUFJLE9BQU95VixPQUFPQSxJQUFHLEVBQUd6cUIsSUFBSSxLQUFLO0lBQzlFO0lBRUEsbUNBQW1DO0lBQ25DaXFCLFNBQVNTLGNBQWMsR0FBRyxTQUFVTCxJQUFJO1FBQ3RDLE1BQU1NLFdBQVdWLFNBQVNNLGFBQWEsQ0FBQ0Y7UUFDeEMsT0FBT00sWUFBWUEsUUFBUSxDQUFDLEVBQUU7SUFDaEM7SUFFQSx5Q0FBeUM7SUFDekNWLFNBQVNXLGdCQUFnQixHQUFHLFNBQVVQLElBQUk7UUFDeEMsTUFBTU0sV0FBV1YsU0FBU00sYUFBYSxDQUFDRjtRQUN4Q00sU0FBU3Y2QixLQUFLO1FBQ2QsT0FBT3U2QjtJQUNUO0lBRUEsa0RBQWtEO0lBQ2xEVixTQUFTWSxXQUFXLEdBQUcsU0FBVVIsSUFBSSxFQUFFeFEsTUFBTTtRQUMzQyxPQUFPb1EsU0FBU0csVUFBVSxDQUFDQyxNQUFNdGhDLE1BQU0sQ0FBQ3VoQyxDQUFBQSxPQUFRQSxLQUFLdGpDLE9BQU8sQ0FBQzZ5QixZQUFZO0lBQzNFO0lBRUEsOENBQThDO0lBQzlDLDJFQUEyRTtJQUMzRSxlQUFlO0lBQ2YsaUNBQWlDO0lBQ2pDb1EsU0FBU2EsY0FBYyxHQUFHLFNBQVVSLElBQUk7UUFDdEMsSUFBSUU7UUFDSix1QkFBdUI7UUFDdkIsSUFBSUYsS0FBS3RqQyxPQUFPLENBQUMsb0JBQW9CLEdBQUc7WUFDdEN3akMsUUFBUUYsS0FBS2w3QixTQUFTLENBQUMsSUFBSW1PLEtBQUssQ0FBQztRQUNuQyxPQUFPO1lBQ0xpdEIsUUFBUUYsS0FBS2w3QixTQUFTLENBQUMsSUFBSW1PLEtBQUssQ0FBQztRQUNuQztRQUNBLE1BQU02cUIsWUFBWTtZQUNoQjJDLFlBQVlQLEtBQUssQ0FBQyxFQUFFO1lBQ3BCUSxXQUFXO2dCQUNULEdBQUc7Z0JBQ0gsR0FBRztZQUNMLENBQUMsQ0FBQ1IsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJQSxLQUFLLENBQUMsRUFBRTtZQUN2QjNmLFVBQVUyZixLQUFLLENBQUMsRUFBRSxDQUFDdndCLFdBQVc7WUFDOUJneEIsVUFBVXB1QixTQUFTMnRCLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDN0JVLElBQUlWLEtBQUssQ0FBQyxFQUFFO1lBQ1poZixTQUFTZ2YsS0FBSyxDQUFDLEVBQUU7WUFDakIsOEJBQThCO1lBQzlCVyxNQUFNdHVCLFNBQVMydEIsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN6Qix5QkFBeUI7WUFDekJ0OUIsTUFBTXM5QixLQUFLLENBQUMsRUFBRTtRQUNoQjtRQUNBLElBQUssSUFBSWhsQyxJQUFJLEdBQUdBLElBQUlnbEMsTUFBTS9rQyxNQUFNLEVBQUVELEtBQUssRUFBRztZQUN4QyxPQUFRZ2xDLEtBQUssQ0FBQ2hsQyxFQUFFO2dCQUNkLEtBQUs7b0JBQ0g0aUMsVUFBVWdELGNBQWMsR0FBR1osS0FBSyxDQUFDaGxDLElBQUksRUFBRTtvQkFDdkM7Z0JBQ0YsS0FBSztvQkFDSDRpQyxVQUFVaUQsV0FBVyxHQUFHeHVCLFNBQVMydEIsS0FBSyxDQUFDaGxDLElBQUksRUFBRSxFQUFFO29CQUMvQztnQkFDRixLQUFLO29CQUNINGlDLFVBQVVrRCxPQUFPLEdBQUdkLEtBQUssQ0FBQ2hsQyxJQUFJLEVBQUU7b0JBQ2hDO2dCQUNGLEtBQUs7b0JBQ0g0aUMsVUFBVW1ELEtBQUssR0FBR2YsS0FBSyxDQUFDaGxDLElBQUksRUFBRSxFQUFFLDhCQUE4QjtvQkFDOUQ0aUMsVUFBVW9ELGdCQUFnQixHQUFHaEIsS0FBSyxDQUFDaGxDLElBQUksRUFBRTtvQkFDekM7Z0JBQ0Y7b0JBQ0UsNERBQTREO29CQUM1RCxJQUFJNGlDLFNBQVMsQ0FBQ29DLEtBQUssQ0FBQ2hsQyxFQUFFLENBQUMsS0FBS0osV0FBVzt3QkFDckNnakMsU0FBUyxDQUFDb0MsS0FBSyxDQUFDaGxDLEVBQUUsQ0FBQyxHQUFHZ2xDLEtBQUssQ0FBQ2hsQyxJQUFJLEVBQUU7b0JBQ3BDO29CQUNBO1lBQ0o7UUFDRjtRQUNBLE9BQU80aUM7SUFDVDtJQUVBLDhEQUE4RDtJQUM5RCx1Q0FBdUM7SUFDdkM2QixTQUFTd0IsY0FBYyxHQUFHLFNBQVVyRCxTQUFTO1FBQzNDLE1BQU03RixNQUFNLEVBQUU7UUFDZEEsSUFBSXAyQixJQUFJLENBQUNpOEIsVUFBVTJDLFVBQVU7UUFDN0IsTUFBTUMsWUFBWTVDLFVBQVU0QyxTQUFTO1FBQ3JDLElBQUlBLGNBQWMsT0FBTztZQUN2QnpJLElBQUlwMkIsSUFBSSxDQUFDO1FBQ1gsT0FBTyxJQUFJNitCLGNBQWMsUUFBUTtZQUMvQnpJLElBQUlwMkIsSUFBSSxDQUFDO1FBQ1gsT0FBTztZQUNMbzJCLElBQUlwMkIsSUFBSSxDQUFDNitCO1FBQ1g7UUFDQXpJLElBQUlwMkIsSUFBSSxDQUFDaThCLFVBQVV2ZCxRQUFRLENBQUN0a0IsV0FBVztRQUN2Q2c4QixJQUFJcDJCLElBQUksQ0FBQ2k4QixVQUFVNkMsUUFBUTtRQUMzQjFJLElBQUlwMkIsSUFBSSxDQUFDaThCLFVBQVU1YyxPQUFPLElBQUk0YyxVQUFVOEMsRUFBRTtRQUMxQzNJLElBQUlwMkIsSUFBSSxDQUFDaThCLFVBQVUrQyxJQUFJO1FBQ3ZCLE1BQU1qK0IsT0FBT2s3QixVQUFVbDdCLElBQUk7UUFDM0JxMUIsSUFBSXAyQixJQUFJLENBQUM7UUFDVG8yQixJQUFJcDJCLElBQUksQ0FBQ2U7UUFDVCxJQUFJQSxTQUFTLFVBQVVrN0IsVUFBVWdELGNBQWMsSUFBSWhELFVBQVVpRCxXQUFXLEVBQUU7WUFDeEU5SSxJQUFJcDJCLElBQUksQ0FBQztZQUNUbzJCLElBQUlwMkIsSUFBSSxDQUFDaThCLFVBQVVnRCxjQUFjO1lBQ2pDN0ksSUFBSXAyQixJQUFJLENBQUM7WUFDVG8yQixJQUFJcDJCLElBQUksQ0FBQ2k4QixVQUFVaUQsV0FBVztRQUNoQztRQUNBLElBQUlqRCxVQUFVa0QsT0FBTyxJQUFJbEQsVUFBVXZkLFFBQVEsQ0FBQzVRLFdBQVcsT0FBTyxPQUFPO1lBQ25Fc29CLElBQUlwMkIsSUFBSSxDQUFDO1lBQ1RvMkIsSUFBSXAyQixJQUFJLENBQUNpOEIsVUFBVWtELE9BQU87UUFDNUI7UUFDQSxJQUFJbEQsVUFBVW9ELGdCQUFnQixJQUFJcEQsVUFBVW1ELEtBQUssRUFBRTtZQUNqRGhKLElBQUlwMkIsSUFBSSxDQUFDO1lBQ1RvMkIsSUFBSXAyQixJQUFJLENBQUNpOEIsVUFBVW9ELGdCQUFnQixJQUFJcEQsVUFBVW1ELEtBQUs7UUFDeEQ7UUFDQSxPQUFPLGVBQWVoSixJQUFJL3NCLElBQUksQ0FBQztJQUNqQztJQUVBLCtEQUErRDtJQUMvRCxnQkFBZ0I7SUFDaEIsd0JBQXdCO0lBQ3hCeTBCLFNBQVN5QixlQUFlLEdBQUcsU0FBVXBCLElBQUk7UUFDdkMsT0FBT0EsS0FBS2w3QixTQUFTLENBQUMsSUFBSW1PLEtBQUssQ0FBQztJQUNsQztJQUVBLHNFQUFzRTtJQUN0RSw0QkFBNEI7SUFDNUIwc0IsU0FBUzBCLFdBQVcsR0FBRyxTQUFVckIsSUFBSTtRQUNuQyxJQUFJRSxRQUFRRixLQUFLbDdCLFNBQVMsQ0FBQyxHQUFHbU8sS0FBSyxDQUFDO1FBQ3BDLE1BQU1xdUIsU0FBUztZQUNiQyxhQUFhaHZCLFNBQVMydEIsTUFBTXA2QixLQUFLLElBQUksSUFBSSxVQUFVO1FBQ3JEO1FBQ0FvNkIsUUFBUUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ2p0QixLQUFLLENBQUM7UUFDdkJxdUIsT0FBTzdsQyxJQUFJLEdBQUd5a0MsS0FBSyxDQUFDLEVBQUU7UUFDdEJvQixPQUFPbmYsU0FBUyxHQUFHNVAsU0FBUzJ0QixLQUFLLENBQUMsRUFBRSxFQUFFLEtBQUssaUJBQWlCO1FBQzVEb0IsT0FBT0UsUUFBUSxHQUFHdEIsTUFBTS9rQyxNQUFNLEtBQUssSUFBSW9YLFNBQVMydEIsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNO1FBQ2hFLHNEQUFzRDtRQUN0RG9CLE9BQU9HLFdBQVcsR0FBR0gsT0FBT0UsUUFBUTtRQUNwQyxPQUFPRjtJQUNUO0lBRUEsd0RBQXdEO0lBQ3hELHlCQUF5QjtJQUN6QjNCLFNBQVMrQixXQUFXLEdBQUcsU0FBVUMsS0FBSztRQUNwQyxJQUFJQyxLQUFLRCxNQUFNSixXQUFXO1FBQzFCLElBQUlJLE1BQU1FLG9CQUFvQixLQUFLL21DLFdBQVc7WUFDNUM4bUMsS0FBS0QsTUFBTUUsb0JBQW9CO1FBQ2pDO1FBQ0EsTUFBTUwsV0FBV0csTUFBTUgsUUFBUSxJQUFJRyxNQUFNRixXQUFXLElBQUk7UUFDeEQsT0FBTyxjQUFjRyxLQUFLLE1BQU1ELE1BQU1sbUMsSUFBSSxHQUFHLE1BQU1rbUMsTUFBTXhmLFNBQVMsR0FBSXFmLENBQUFBLGFBQWEsSUFBSSxNQUFNQSxXQUFXLEVBQUMsSUFBSztJQUNoSDtJQUVBLHNFQUFzRTtJQUN0RSxnREFBZ0Q7SUFDaEQseURBQXlEO0lBQ3pEN0IsU0FBU21DLFdBQVcsR0FBRyxTQUFVOUIsSUFBSTtRQUNuQyxNQUFNRSxRQUFRRixLQUFLbDdCLFNBQVMsQ0FBQyxHQUFHbU8sS0FBSyxDQUFDO1FBQ3RDLE9BQU87WUFDTGdiLElBQUkxYixTQUFTMnRCLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDdkJoQixXQUFXZ0IsS0FBSyxDQUFDLEVBQUUsQ0FBQ3hqQyxPQUFPLENBQUMsT0FBTyxJQUFJd2pDLEtBQUssQ0FBQyxFQUFFLENBQUNqdEIsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUc7WUFDaEU4dUIsS0FBSzdCLEtBQUssQ0FBQyxFQUFFO1lBQ2I4QixZQUFZOUIsTUFBTXRqQyxLQUFLLENBQUMsR0FBR3NPLElBQUksQ0FBQztRQUNsQztJQUNGO0lBRUEsbUVBQW1FO0lBQ25FLHlCQUF5QjtJQUN6QnkwQixTQUFTc0MsV0FBVyxHQUFHLFNBQVVDLGVBQWU7UUFDOUMsT0FBTyxjQUFlQSxDQUFBQSxnQkFBZ0JqVSxFQUFFLElBQUlpVSxnQkFBZ0JDLFdBQVcsSUFBS0QsQ0FBQUEsZ0JBQWdCaEQsU0FBUyxJQUFJZ0QsZ0JBQWdCaEQsU0FBUyxLQUFLLGFBQWEsTUFBTWdELGdCQUFnQmhELFNBQVMsR0FBRyxFQUFDLElBQUssTUFBTWdELGdCQUFnQkgsR0FBRyxHQUFJRyxDQUFBQSxnQkFBZ0JGLFVBQVUsR0FBRyxNQUFNRSxnQkFBZ0JGLFVBQVUsR0FBRyxFQUFDLElBQUs7SUFDalM7SUFFQSx3REFBd0Q7SUFDeEQsMEJBQTBCO0lBQzFCLGlDQUFpQztJQUNqQ3JDLFNBQVN5QyxTQUFTLEdBQUcsU0FBVXBDLElBQUk7UUFDakMsTUFBTXNCLFNBQVMsQ0FBQztRQUNoQixJQUFJZTtRQUNKLE1BQU1uQyxRQUFRRixLQUFLbDdCLFNBQVMsQ0FBQ2s3QixLQUFLdGpDLE9BQU8sQ0FBQyxPQUFPLEdBQUd1VyxLQUFLLENBQUM7UUFDMUQsSUFBSyxJQUFJcXZCLElBQUksR0FBR0EsSUFBSXBDLE1BQU0va0MsTUFBTSxFQUFFbW5DLElBQUs7WUFDckNELEtBQUtuQyxLQUFLLENBQUNvQyxFQUFFLENBQUM1c0IsSUFBSSxHQUFHekMsS0FBSyxDQUFDO1lBQzNCcXVCLE1BQU0sQ0FBQ2UsRUFBRSxDQUFDLEVBQUUsQ0FBQzNzQixJQUFJLEdBQUcsR0FBRzJzQixFQUFFLENBQUMsRUFBRTtRQUM5QjtRQUNBLE9BQU9mO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0UzQixTQUFTNEMsU0FBUyxHQUFHLFNBQVVaLEtBQUs7UUFDbEMsSUFBSTNCLE9BQU87UUFDWCxJQUFJNEIsS0FBS0QsTUFBTUosV0FBVztRQUMxQixJQUFJSSxNQUFNRSxvQkFBb0IsS0FBSy9tQyxXQUFXO1lBQzVDOG1DLEtBQUtELE1BQU1FLG9CQUFvQjtRQUNqQztRQUNBLElBQUlGLE1BQU1hLFVBQVUsSUFBSXZxQyxPQUFPQyxJQUFJLENBQUN5cEMsTUFBTWEsVUFBVSxFQUFFcm5DLE1BQU0sRUFBRTtZQUM1RCxNQUFNNGdDLFNBQVMsRUFBRTtZQUNqQjlqQyxPQUFPQyxJQUFJLENBQUN5cEMsTUFBTWEsVUFBVSxFQUFFM3FDLE9BQU8sQ0FBQzRxQyxDQUFBQTtnQkFDcEMsSUFBSWQsTUFBTWEsVUFBVSxDQUFDQyxNQUFNLEtBQUszbkMsV0FBVztvQkFDekNpaEMsT0FBT2w2QixJQUFJLENBQUM0Z0MsUUFBUSxNQUFNZCxNQUFNYSxVQUFVLENBQUNDLE1BQU07Z0JBQ25ELE9BQU87b0JBQ0wxRyxPQUFPbDZCLElBQUksQ0FBQzRnQztnQkFDZDtZQUNGO1lBQ0F6QyxRQUFRLFlBQVk0QixLQUFLLE1BQU03RixPQUFPN3dCLElBQUksQ0FBQyxPQUFPO1FBQ3BEO1FBQ0EsT0FBTzgwQjtJQUNUO0lBRUEsd0VBQXdFO0lBQ3hFLHlCQUF5QjtJQUN6QkwsU0FBUytDLFdBQVcsR0FBRyxTQUFVMUMsSUFBSTtRQUNuQyxNQUFNRSxRQUFRRixLQUFLbDdCLFNBQVMsQ0FBQ2s3QixLQUFLdGpDLE9BQU8sQ0FBQyxPQUFPLEdBQUd1VyxLQUFLLENBQUM7UUFDMUQsT0FBTztZQUNMclEsTUFBTXM5QixNQUFNcDZCLEtBQUs7WUFDakI2OEIsV0FBV3pDLE1BQU1oMUIsSUFBSSxDQUFDO1FBQ3hCO0lBQ0Y7SUFFQSxnRkFBZ0Y7SUFDaEZ5MEIsU0FBU2lELFdBQVcsR0FBRyxTQUFVakIsS0FBSztRQUNwQyxJQUFJa0IsUUFBUTtRQUNaLElBQUlqQixLQUFLRCxNQUFNSixXQUFXO1FBQzFCLElBQUlJLE1BQU1FLG9CQUFvQixLQUFLL21DLFdBQVc7WUFDNUM4bUMsS0FBS0QsTUFBTUUsb0JBQW9CO1FBQ2pDO1FBQ0EsSUFBSUYsTUFBTW1CLFlBQVksSUFBSW5CLE1BQU1tQixZQUFZLENBQUMzbkMsTUFBTSxFQUFFO1lBQ25ELHVDQUF1QztZQUN2Q3dtQyxNQUFNbUIsWUFBWSxDQUFDanJDLE9BQU8sQ0FBQ2tyQyxDQUFBQTtnQkFDekJGLFNBQVMsZUFBZWpCLEtBQUssTUFBTW1CLEdBQUduZ0MsSUFBSSxHQUFJbWdDLENBQUFBLEdBQUdKLFNBQVMsSUFBSUksR0FBR0osU0FBUyxDQUFDeG5DLE1BQU0sR0FBRyxNQUFNNG5DLEdBQUdKLFNBQVMsR0FBRyxFQUFDLElBQUs7WUFDakg7UUFDRjtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSx3REFBd0Q7SUFDeEQsb0NBQW9DO0lBQ3BDbEQsU0FBU3FELGNBQWMsR0FBRyxTQUFVaEQsSUFBSTtRQUN0QyxNQUFNaUQsS0FBS2pELEtBQUt0akMsT0FBTyxDQUFDO1FBQ3hCLE1BQU13akMsUUFBUTtZQUNaL2dCLE1BQU01TSxTQUFTeXRCLEtBQUtsN0IsU0FBUyxDQUFDLEdBQUdtK0IsS0FBSztRQUN4QztRQUNBLE1BQU1DLFFBQVFsRCxLQUFLdGpDLE9BQU8sQ0FBQyxLQUFLdW1DO1FBQ2hDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO1lBQ2RoRCxNQUFNaUQsU0FBUyxHQUFHbkQsS0FBS2w3QixTQUFTLENBQUNtK0IsS0FBSyxHQUFHQztZQUN6Q2hELE1BQU12K0IsS0FBSyxHQUFHcStCLEtBQUtsN0IsU0FBUyxDQUFDbytCLFFBQVE7UUFDdkMsT0FBTztZQUNMaEQsTUFBTWlELFNBQVMsR0FBR25ELEtBQUtsN0IsU0FBUyxDQUFDbStCLEtBQUs7UUFDeEM7UUFDQSxPQUFPL0M7SUFDVDtJQUVBLHdEQUF3RDtJQUN4RCwrQkFBK0I7SUFDL0JQLFNBQVN5RCxjQUFjLEdBQUcsU0FBVXBELElBQUk7UUFDdEMsTUFBTUUsUUFBUUYsS0FBS2w3QixTQUFTLENBQUMsSUFBSW1PLEtBQUssQ0FBQztRQUN2QyxPQUFPO1lBQ0xvd0IsV0FBV25ELE1BQU1wNkIsS0FBSztZQUN0Qnc5QixPQUFPcEQsTUFBTXJoQyxHQUFHLENBQUNzZ0IsQ0FBQUEsT0FBUTVNLFNBQVM0TSxNQUFNO1FBQzFDO0lBQ0Y7SUFFQSxvREFBb0Q7SUFDcEQseURBQXlEO0lBQ3pEd2dCLFNBQVM0RCxNQUFNLEdBQUcsU0FBVUMsWUFBWTtRQUN0QyxNQUFNNTdCLE1BQU0rM0IsU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxTQUFTLENBQUMsRUFBRTtRQUMzRCxJQUFJNTdCLEtBQUs7WUFDUCxPQUFPQSxJQUFJOUMsU0FBUyxDQUFDO1FBQ3ZCO0lBQ0Y7SUFFQSwyQ0FBMkM7SUFDM0M2NkIsU0FBUzhELGdCQUFnQixHQUFHLFNBQVV6RCxJQUFJO1FBQ3hDLE1BQU1FLFFBQVFGLEtBQUtsN0IsU0FBUyxDQUFDLElBQUltTyxLQUFLLENBQUM7UUFDdkMsT0FBTztZQUNMeXdCLFdBQVd4RCxLQUFLLENBQUMsRUFBRSxDQUFDdndCLFdBQVc7WUFDL0IsdUNBQXVDO1lBQ3ZDaE8sT0FBT3UrQixLQUFLLENBQUMsRUFBRSxDQUFDamtDLFdBQVcsR0FBRyw0Q0FBNEM7UUFDNUU7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSwrREFBK0Q7SUFDL0Qsa0VBQWtFO0lBQ2xFMGpDLFNBQVNnRSxpQkFBaUIsR0FBRyxTQUFVSCxZQUFZLEVBQUVJLFdBQVc7UUFDOUQsTUFBTWYsUUFBUWxELFNBQVNZLFdBQVcsQ0FBQ2lELGVBQWVJLGFBQWE7UUFDL0Qsc0VBQXNFO1FBQ3RFLE9BQU87WUFDTEMsTUFBTTtZQUNOQyxjQUFjakIsTUFBTWhrQyxHQUFHLENBQUM4Z0MsU0FBUzhELGdCQUFnQjtRQUNuRDtJQUNGO0lBRUEscUNBQXFDO0lBQ3JDOUQsU0FBU29FLG1CQUFtQixHQUFHLFNBQVVoSSxNQUFNLEVBQUVpSSxTQUFTO1FBQ3hELElBQUkvTCxNQUFNLGFBQWErTCxZQUFZO1FBQ25DakksT0FBTytILFlBQVksQ0FBQ2pzQyxPQUFPLENBQUNvc0MsQ0FBQUE7WUFDMUJoTSxPQUFPLG1CQUFtQmdNLEdBQUdQLFNBQVMsR0FBRyxNQUFNTyxHQUFHdGlDLEtBQUssR0FBRztRQUM1RDtRQUNBLE9BQU9zMkI7SUFDVDtJQUVBLDZCQUE2QjtJQUM3QixxR0FBcUc7SUFDckcwSCxTQUFTdUUsZUFBZSxHQUFHLFNBQVVsRSxJQUFJO1FBQ3ZDLE1BQU1FLFFBQVFGLEtBQUtsN0IsU0FBUyxDQUFDLEdBQUdtTyxLQUFLLENBQUM7UUFDdEMsT0FBTztZQUNMekgsS0FBSytHLFNBQVMydEIsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN4QmlFLGFBQWFqRSxLQUFLLENBQUMsRUFBRTtZQUNyQmtFLFdBQVdsRSxLQUFLLENBQUMsRUFBRTtZQUNuQm1FLGVBQWVuRSxNQUFNdGpDLEtBQUssQ0FBQztRQUM3QjtJQUNGO0lBQ0EraUMsU0FBUzJFLGVBQWUsR0FBRyxTQUFVOUIsVUFBVTtRQUM3QyxPQUFPLGNBQWNBLFdBQVdoM0IsR0FBRyxHQUFHLE1BQU1nM0IsV0FBVzJCLFdBQVcsR0FBRyxNQUFPLFFBQU8zQixXQUFXNEIsU0FBUyxLQUFLLFdBQVd6RSxTQUFTNEUsb0JBQW9CLENBQUMvQixXQUFXNEIsU0FBUyxJQUFJNUIsV0FBVzRCLFNBQVMsSUFBSzVCLENBQUFBLFdBQVc2QixhQUFhLEdBQUcsTUFBTTdCLFdBQVc2QixhQUFhLENBQUNuNUIsSUFBSSxDQUFDLE9BQU8sRUFBQyxJQUFLO0lBQ3BSO0lBRUEsd0NBQXdDO0lBQ3hDLDZFQUE2RTtJQUM3RXkwQixTQUFTNkUsb0JBQW9CLEdBQUcsU0FBVUosU0FBUztRQUNqRCxJQUFJQSxVQUFVMW5DLE9BQU8sQ0FBQyxlQUFlLEdBQUc7WUFDdEMsT0FBTztRQUNUO1FBQ0EsTUFBTXdqQyxRQUFRa0UsVUFBVXQvQixTQUFTLENBQUMsR0FBR21PLEtBQUssQ0FBQztRQUMzQyxPQUFPO1lBQ0x3eEIsV0FBVztZQUNYQyxTQUFTeEUsS0FBSyxDQUFDLEVBQUU7WUFDakJ5RSxVQUFVekUsS0FBSyxDQUFDLEVBQUU7WUFDbEIwRSxVQUFVMUUsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ2p0QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBR25ZO1lBQzlDK3BDLFdBQVczRSxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxDQUFDanRCLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHblk7UUFDakQ7SUFDRjtJQUNBNmtDLFNBQVM0RSxvQkFBb0IsR0FBRyxTQUFVSCxTQUFTO1FBQ2pELE9BQU9BLFVBQVVLLFNBQVMsR0FBRyxNQUFNTCxVQUFVTSxPQUFPLEdBQUlOLENBQUFBLFVBQVVPLFFBQVEsR0FBRyxNQUFNUCxVQUFVTyxRQUFRLEdBQUcsRUFBQyxJQUFNUCxDQUFBQSxVQUFVUSxRQUFRLElBQUlSLFVBQVVTLFNBQVMsR0FBRyxNQUFNVCxVQUFVUSxRQUFRLEdBQUcsTUFBTVIsVUFBVVMsU0FBUyxHQUFHLEVBQUM7SUFDck47SUFFQSxnQ0FBZ0M7SUFDaENsRixTQUFTbUYsbUJBQW1CLEdBQUcsU0FBVXRCLFlBQVksRUFBRUksV0FBVztRQUNoRSxNQUFNZixRQUFRbEQsU0FBU1ksV0FBVyxDQUFDaUQsZUFBZUksYUFBYTtRQUMvRCxPQUFPZixNQUFNaGtDLEdBQUcsQ0FBQzhnQyxTQUFTdUUsZUFBZTtJQUMzQztJQUVBLGdFQUFnRTtJQUNoRSwrREFBK0Q7SUFDL0Qsa0RBQWtEO0lBQ2xEdkUsU0FBU29GLGdCQUFnQixHQUFHLFNBQVV2QixZQUFZLEVBQUVJLFdBQVc7UUFDN0QsTUFBTTNDLFFBQVF0QixTQUFTWSxXQUFXLENBQUNpRCxlQUFlSSxhQUFhLGVBQWUsQ0FBQyxFQUFFO1FBQ2pGLE1BQU1vQixNQUFNckYsU0FBU1ksV0FBVyxDQUFDaUQsZUFBZUksYUFBYSxhQUFhLENBQUMsRUFBRTtRQUM3RSxJQUFJLENBQUUzQyxDQUFBQSxTQUFTK0QsR0FBRSxHQUFJO1lBQ25CLE9BQU87UUFDVDtRQUNBLE9BQU87WUFDTDlELGtCQUFrQkQsTUFBTW44QixTQUFTLENBQUM7WUFDbENtZ0MsVUFBVUQsSUFBSWxnQyxTQUFTLENBQUM7UUFDMUI7SUFDRjtJQUVBLG9DQUFvQztJQUNwQzY2QixTQUFTdUYsa0JBQWtCLEdBQUcsU0FBVW5KLE1BQU07UUFDNUMsSUFBSTlELE1BQU0saUJBQWlCOEQsT0FBT21GLGdCQUFnQixHQUFHLFNBQVMsZUFBZW5GLE9BQU9rSixRQUFRLEdBQUc7UUFDL0YsSUFBSWxKLE9BQU9vSixPQUFPLEVBQUU7WUFDbEJsTixPQUFPO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBRUEsNkRBQTZEO0lBQzdEMEgsU0FBU3lGLGtCQUFrQixHQUFHLFNBQVU1QixZQUFZO1FBQ2xELE1BQU14TCxjQUFjO1lBQ2xCdFosUUFBUSxFQUFFO1lBQ1YybUIsa0JBQWtCLEVBQUU7WUFDcEJDLGVBQWUsRUFBRTtZQUNqQkMsTUFBTSxFQUFFO1FBQ1Y7UUFDQSxNQUFNMUMsUUFBUWxELFNBQVNHLFVBQVUsQ0FBQzBEO1FBQ2xDLE1BQU1nQyxRQUFRM0MsS0FBSyxDQUFDLEVBQUUsQ0FBQzV2QixLQUFLLENBQUM7UUFDN0Ira0IsWUFBWXlOLE9BQU8sR0FBR0QsS0FBSyxDQUFDLEVBQUU7UUFDOUIsSUFBSyxJQUFJdHFDLElBQUksR0FBR0EsSUFBSXNxQyxNQUFNcnFDLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxrQ0FBa0M7WUFDbEMsTUFBTTBtQyxLQUFLNEQsS0FBSyxDQUFDdHFDLEVBQUU7WUFDbkIsTUFBTXdxQyxhQUFhL0YsU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxjQUFjNUIsS0FBSyxJQUFJLENBQUMsRUFBRTtZQUNoRixJQUFJOEQsWUFBWTtnQkFDZCxNQUFNL0QsUUFBUWhDLFNBQVMwQixXQUFXLENBQUNxRTtnQkFDbkMsTUFBTUMsUUFBUWhHLFNBQVNZLFdBQVcsQ0FBQ2lELGNBQWMsWUFBWTVCLEtBQUs7Z0JBQ2xFLDRDQUE0QztnQkFDNUNELE1BQU1hLFVBQVUsR0FBR21ELE1BQU14cUMsTUFBTSxHQUFHd2tDLFNBQVN5QyxTQUFTLENBQUN1RCxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUM7Z0JBQ2xFaEUsTUFBTW1CLFlBQVksR0FBR25ELFNBQVNZLFdBQVcsQ0FBQ2lELGNBQWMsZUFBZTVCLEtBQUssS0FBSy9pQyxHQUFHLENBQUM4Z0MsU0FBUytDLFdBQVc7Z0JBQ3pHMUssWUFBWXRaLE1BQU0sQ0FBQzdjLElBQUksQ0FBQzgvQjtnQkFDeEIsMENBQTBDO2dCQUMxQyxPQUFRQSxNQUFNbG1DLElBQUksQ0FBQ1EsV0FBVztvQkFDNUIsS0FBSztvQkFDTCxLQUFLO3dCQUNIKzdCLFlBQVlzTixhQUFhLENBQUN6akMsSUFBSSxDQUFDOC9CLE1BQU1sbUMsSUFBSSxDQUFDUSxXQUFXO3dCQUNyRDtnQkFDSjtZQUNGO1FBQ0Y7UUFDQTBqQyxTQUFTWSxXQUFXLENBQUNpRCxjQUFjLGFBQWEzckMsT0FBTyxDQUFDbW9DLENBQUFBO1lBQ3REaEksWUFBWXFOLGdCQUFnQixDQUFDeGpDLElBQUksQ0FBQzg5QixTQUFTbUMsV0FBVyxDQUFDOUI7UUFDekQ7UUFDQSxNQUFNNEYsaUJBQWlCakcsU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxnQkFBZ0Iza0MsR0FBRyxDQUFDOGdDLFNBQVMrQyxXQUFXO1FBQ2xHMUssWUFBWXRaLE1BQU0sQ0FBQzdtQixPQUFPLENBQUM4cEMsQ0FBQUE7WUFDekJpRSxlQUFlL3RDLE9BQU8sQ0FBQ2tyQyxDQUFBQTtnQkFDckIsTUFBTThDLFlBQVlsRSxNQUFNbUIsWUFBWSxDQUFDbnlCLElBQUksQ0FBQ20xQixDQUFBQTtvQkFDeEMsT0FBT0EsaUJBQWlCbGpDLElBQUksS0FBS21nQyxHQUFHbmdDLElBQUksSUFBSWtqQyxpQkFBaUJuRCxTQUFTLEtBQUtJLEdBQUdKLFNBQVM7Z0JBQ3pGO2dCQUNBLElBQUksQ0FBQ2tELFdBQVc7b0JBQ2RsRSxNQUFNbUIsWUFBWSxDQUFDamhDLElBQUksQ0FBQ2toQztnQkFDMUI7WUFDRjtRQUNGO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8vSztJQUNUO0lBRUEseUVBQXlFO0lBQ3pFLGNBQWM7SUFDZDJILFNBQVNvRyxtQkFBbUIsR0FBRyxTQUFVLzBCLElBQUksRUFBRWcxQixJQUFJO1FBQ2pELElBQUkvTixNQUFNO1FBRVYsbUJBQW1CO1FBQ25CQSxPQUFPLE9BQU9qbkIsT0FBTztRQUNyQmluQixPQUFPK04sS0FBS3RuQixNQUFNLENBQUN2akIsTUFBTSxHQUFHLElBQUksTUFBTSxLQUFLLHVCQUF1QjtRQUNsRTg4QixPQUFPLE1BQU8rTixDQUFBQSxLQUFLUCxPQUFPLElBQUksbUJBQWtCLElBQUs7UUFDckR4TixPQUFPK04sS0FBS3RuQixNQUFNLENBQUM3ZixHQUFHLENBQUM4aUMsQ0FBQUE7WUFDckIsSUFBSUEsTUFBTUUsb0JBQW9CLEtBQUsvbUMsV0FBVztnQkFDNUMsT0FBTzZtQyxNQUFNRSxvQkFBb0I7WUFDbkM7WUFDQSxPQUFPRixNQUFNSixXQUFXO1FBQzFCLEdBQUdyMkIsSUFBSSxDQUFDLE9BQU87UUFDZitzQixPQUFPO1FBQ1BBLE9BQU87UUFFUCw0REFBNEQ7UUFDNUQrTixLQUFLdG5CLE1BQU0sQ0FBQzdtQixPQUFPLENBQUM4cEMsQ0FBQUE7WUFDbEIxSixPQUFPMEgsU0FBUytCLFdBQVcsQ0FBQ0M7WUFDNUIxSixPQUFPMEgsU0FBUzRDLFNBQVMsQ0FBQ1o7WUFDMUIxSixPQUFPMEgsU0FBU2lELFdBQVcsQ0FBQ2pCO1FBQzlCO1FBQ0EsSUFBSXNFLFdBQVc7UUFDZkQsS0FBS3RuQixNQUFNLENBQUM3bUIsT0FBTyxDQUFDOHBDLENBQUFBO1lBQ2xCLElBQUlBLE1BQU1zRSxRQUFRLEdBQUdBLFVBQVU7Z0JBQzdCQSxXQUFXdEUsTUFBTXNFLFFBQVE7WUFDM0I7UUFDRjtRQUNBLElBQUlBLFdBQVcsR0FBRztZQUNoQmhPLE9BQU8sZ0JBQWdCZ08sV0FBVztRQUNwQztRQUNBLElBQUlELEtBQUtYLGdCQUFnQixFQUFFO1lBQ3pCVyxLQUFLWCxnQkFBZ0IsQ0FBQ3h0QyxPQUFPLENBQUNvSCxDQUFBQTtnQkFDNUJnNUIsT0FBTzBILFNBQVNzQyxXQUFXLENBQUNoakM7WUFDOUI7UUFDRjtRQUNBLDhCQUE4QjtRQUM5QixPQUFPZzVCO0lBQ1Q7SUFFQSx1REFBdUQ7SUFDdkQsNEJBQTRCO0lBQzVCMEgsU0FBU3VHLDBCQUEwQixHQUFHLFNBQVUxQyxZQUFZO1FBQzFELE1BQU0yQyxxQkFBcUIsRUFBRTtRQUM3QixNQUFNbk8sY0FBYzJILFNBQVN5RixrQkFBa0IsQ0FBQzVCO1FBQ2hELE1BQU00QyxTQUFTcE8sWUFBWXNOLGFBQWEsQ0FBQzVvQyxPQUFPLENBQUMsV0FBVyxDQUFDO1FBQzdELE1BQU0ycEMsWUFBWXJPLFlBQVlzTixhQUFhLENBQUM1b0MsT0FBTyxDQUFDLGNBQWMsQ0FBQztRQUVuRSw4Q0FBOEM7UUFDOUMsTUFBTTRtQyxRQUFRM0QsU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxXQUFXM2tDLEdBQUcsQ0FBQ21oQyxDQUFBQSxPQUFRTCxTQUFTcUQsY0FBYyxDQUFDaEQsT0FBT3ZoQyxNQUFNLENBQUN5aEMsQ0FBQUEsUUFBU0EsTUFBTWlELFNBQVMsS0FBSztRQUMzSSxNQUFNbUQsY0FBY2hELE1BQU1ub0MsTUFBTSxHQUFHLEtBQUttb0MsS0FBSyxDQUFDLEVBQUUsQ0FBQ25rQixJQUFJO1FBQ3JELElBQUlvbkI7UUFDSixNQUFNQyxRQUFRN0csU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxvQkFBb0Iza0MsR0FBRyxDQUFDbWhDLENBQUFBO1lBQ3ZFLE1BQU1FLFFBQVFGLEtBQUtsN0IsU0FBUyxDQUFDLElBQUltTyxLQUFLLENBQUM7WUFDdkMsT0FBT2l0QixNQUFNcmhDLEdBQUcsQ0FBQ3NoQyxDQUFBQSxPQUFRNXRCLFNBQVM0dEIsTUFBTTtRQUMxQztRQUNBLElBQUlxRyxNQUFNcnJDLE1BQU0sR0FBRyxLQUFLcXJDLEtBQUssQ0FBQyxFQUFFLENBQUNyckMsTUFBTSxHQUFHLEtBQUtxckMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUtGLGFBQWE7WUFDMUVDLGdCQUFnQkMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQzdCO1FBQ0F4TyxZQUFZdFosTUFBTSxDQUFDN21CLE9BQU8sQ0FBQzhwQyxDQUFBQTtZQUN6QixJQUFJQSxNQUFNbG1DLElBQUksQ0FBQ1EsV0FBVyxPQUFPLFNBQVMwbEMsTUFBTWEsVUFBVSxDQUFDaUUsR0FBRyxFQUFFO2dCQUM5RCxJQUFJQyxXQUFXO29CQUNidm5CLE1BQU1tbkI7b0JBQ05LLGtCQUFrQnAwQixTQUFTb3ZCLE1BQU1hLFVBQVUsQ0FBQ2lFLEdBQUcsRUFBRTtnQkFDbkQ7Z0JBQ0EsSUFBSUgsZUFBZUMsZUFBZTtvQkFDaENHLFNBQVNFLEdBQUcsR0FBRzt3QkFDYnpuQixNQUFNb25CO29CQUNSO2dCQUNGO2dCQUNBSixtQkFBbUJ0a0MsSUFBSSxDQUFDNmtDO2dCQUN4QixJQUFJTixRQUFRO29CQUNWTSxXQUFXbGpDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS2MsU0FBUyxDQUFDb2lDO29CQUNyQ0EsU0FBU0csR0FBRyxHQUFHO3dCQUNiMW5CLE1BQU1tbkI7d0JBQ05RLFdBQVdULFlBQVksZUFBZTtvQkFDeEM7b0JBQ0FGLG1CQUFtQnRrQyxJQUFJLENBQUM2a0M7Z0JBQzFCO1lBQ0Y7UUFDRjtRQUNBLElBQUlQLG1CQUFtQmhyQyxNQUFNLEtBQUssS0FBS21yQyxhQUFhO1lBQ2xESCxtQkFBbUJ0a0MsSUFBSSxDQUFDO2dCQUN0QnNkLE1BQU1tbkI7WUFDUjtRQUNGO1FBRUEsNERBQTREO1FBQzVELElBQUlTLFlBQVlwSCxTQUFTWSxXQUFXLENBQUNpRCxjQUFjO1FBQ25ELElBQUl1RCxVQUFVNXJDLE1BQU0sRUFBRTtZQUNwQixJQUFJNHJDLFNBQVMsQ0FBQyxFQUFFLENBQUNycUMsT0FBTyxDQUFDLGVBQWUsR0FBRztnQkFDekNxcUMsWUFBWXgwQixTQUFTdzBCLFNBQVMsQ0FBQyxFQUFFLENBQUNqaUMsU0FBUyxDQUFDLElBQUk7WUFDbEQsT0FBTyxJQUFJaWlDLFNBQVMsQ0FBQyxFQUFFLENBQUNycUMsT0FBTyxDQUFDLGFBQWEsR0FBRztnQkFDOUMsdURBQXVEO2dCQUN2RHFxQyxZQUFZeDBCLFNBQVN3MEIsU0FBUyxDQUFDLEVBQUUsQ0FBQ2ppQyxTQUFTLENBQUMsSUFBSSxNQUFNLE9BQU8sT0FBTyxLQUFLLEtBQUs7WUFDaEYsT0FBTztnQkFDTGlpQyxZQUFZanNDO1lBQ2Q7WUFDQXFyQyxtQkFBbUJ0dUMsT0FBTyxDQUFDa2tDLENBQUFBO2dCQUN6QkEsT0FBT2lMLFVBQVUsR0FBR0Q7WUFDdEI7UUFDRjtRQUNBLE9BQU9aO0lBQ1Q7SUFFQSxtREFBbUQ7SUFDbkR4RyxTQUFTc0gsbUJBQW1CLEdBQUcsU0FBVXpELFlBQVk7UUFDbkQsTUFBTTBELGlCQUFpQixDQUFDO1FBRXhCLGtFQUFrRTtRQUNsRSxTQUFTO1FBQ1QsTUFBTUMsYUFBYXhILFNBQVNZLFdBQVcsQ0FBQ2lELGNBQWMsV0FBVzNrQyxHQUFHLENBQUNtaEMsQ0FBQUEsT0FBUUwsU0FBU3FELGNBQWMsQ0FBQ2hELE9BQU92aEMsTUFBTSxDQUFDdEUsQ0FBQUEsTUFBT0EsSUFBSWdwQyxTQUFTLEtBQUssUUFBUSxDQUFDLEVBQUU7UUFDdkosSUFBSWdFLFlBQVk7WUFDZEQsZUFBZUUsS0FBSyxHQUFHRCxXQUFXeGxDLEtBQUs7WUFDdkN1bEMsZUFBZS9uQixJQUFJLEdBQUdnb0IsV0FBV2hvQixJQUFJO1FBQ3ZDO1FBRUEsMERBQTBEO1FBQzFELDJCQUEyQjtRQUMzQixNQUFNa29CLFFBQVExSCxTQUFTWSxXQUFXLENBQUNpRCxjQUFjO1FBQ2pEMEQsZUFBZUksV0FBVyxHQUFHRCxNQUFNbHNDLE1BQU0sR0FBRztRQUM1QytyQyxlQUFlSyxRQUFRLEdBQUdGLE1BQU1sc0MsTUFBTSxLQUFLO1FBRTNDLGlDQUFpQztRQUNqQyxnREFBZ0Q7UUFDaEQsTUFBTXFzQyxNQUFNN0gsU0FBU1ksV0FBVyxDQUFDaUQsY0FBYztRQUMvQzBELGVBQWVNLEdBQUcsR0FBR0EsSUFBSXJzQyxNQUFNLEdBQUc7UUFDbEMsT0FBTytyQztJQUNUO0lBQ0F2SCxTQUFTOEgsbUJBQW1CLEdBQUcsU0FBVVAsY0FBYztRQUNyRCxJQUFJalAsTUFBTTtRQUNWLElBQUlpUCxlQUFlSSxXQUFXLEVBQUU7WUFDOUJyUCxPQUFPO1FBQ1Q7UUFDQSxJQUFJaVAsZUFBZU0sR0FBRyxFQUFFO1lBQ3RCdlAsT0FBTztRQUNUO1FBQ0EsSUFBSWlQLGVBQWUvbkIsSUFBSSxLQUFLcmtCLGFBQWFvc0MsZUFBZUUsS0FBSyxFQUFFO1lBQzdEblAsT0FBTyxZQUFZaVAsZUFBZS9uQixJQUFJLEdBQUcsWUFBWStuQixlQUFlRSxLQUFLLEdBQUc7UUFDOUU7UUFDQSxPQUFPblA7SUFDVDtJQUVBLDZEQUE2RDtJQUM3RCxrREFBa0Q7SUFDbEQwSCxTQUFTK0gsU0FBUyxHQUFHLFNBQVVsRSxZQUFZO1FBQ3pDLElBQUl0RDtRQUNKLE1BQU15SCxPQUFPaEksU0FBU1ksV0FBVyxDQUFDaUQsY0FBYztRQUNoRCxJQUFJbUUsS0FBS3hzQyxNQUFNLEtBQUssR0FBRztZQUNyQitrQyxRQUFReUgsSUFBSSxDQUFDLEVBQUUsQ0FBQzdpQyxTQUFTLENBQUMsR0FBR21PLEtBQUssQ0FBQztZQUNuQyxPQUFPO2dCQUNMOEwsUUFBUW1oQixLQUFLLENBQUMsRUFBRTtnQkFDaEI5UixPQUFPOFIsS0FBSyxDQUFDLEVBQUU7WUFDakI7UUFDRjtRQUNBLE1BQU0wSCxRQUFRakksU0FBU1ksV0FBVyxDQUFDaUQsY0FBYyxXQUFXM2tDLEdBQUcsQ0FBQ21oQyxDQUFBQSxPQUFRTCxTQUFTcUQsY0FBYyxDQUFDaEQsT0FBT3ZoQyxNQUFNLENBQUNvcEMsQ0FBQUEsWUFBYUEsVUFBVTFFLFNBQVMsS0FBSztRQUNuSixJQUFJeUUsTUFBTXpzQyxNQUFNLEdBQUcsR0FBRztZQUNwQitrQyxRQUFRMEgsS0FBSyxDQUFDLEVBQUUsQ0FBQ2ptQyxLQUFLLENBQUNzUixLQUFLLENBQUM7WUFDN0IsT0FBTztnQkFDTDhMLFFBQVFtaEIsS0FBSyxDQUFDLEVBQUU7Z0JBQ2hCOVIsT0FBTzhSLEtBQUssQ0FBQyxFQUFFO1lBQ2pCO1FBQ0Y7SUFDRjtJQUVBLE9BQU87SUFDUCw0REFBNEQ7SUFDNUQsbUNBQW1DO0lBQ25DUCxTQUFTbUksb0JBQW9CLEdBQUcsU0FBVXRFLFlBQVk7UUFDcEQsTUFBTWdDLFFBQVE3RixTQUFTb0ksVUFBVSxDQUFDdkU7UUFDbEMsTUFBTXdFLGNBQWNySSxTQUFTWSxXQUFXLENBQUNpRCxjQUFjO1FBQ3ZELElBQUl5RTtRQUNKLElBQUlELFlBQVk3c0MsTUFBTSxHQUFHLEdBQUc7WUFDMUI4c0MsaUJBQWlCMTFCLFNBQVN5MUIsV0FBVyxDQUFDLEVBQUUsQ0FBQ2xqQyxTQUFTLENBQUMsS0FBSztRQUMxRDtRQUNBLElBQUk2USxNQUFNc3lCLGlCQUFpQjtZQUN6QkEsaUJBQWlCO1FBQ25CO1FBQ0EsTUFBTUMsV0FBV3ZJLFNBQVNZLFdBQVcsQ0FBQ2lELGNBQWM7UUFDcEQsSUFBSTBFLFNBQVMvc0MsTUFBTSxHQUFHLEdBQUc7WUFDdkIsT0FBTztnQkFDTDBsQyxNQUFNdHVCLFNBQVMyMUIsUUFBUSxDQUFDLEVBQUUsQ0FBQ3BqQyxTQUFTLENBQUMsS0FBSztnQkFDMUN5YixVQUFVaWxCLE1BQU0yQyxHQUFHO2dCQUNuQkY7WUFDRjtRQUNGO1FBQ0EsTUFBTUcsZUFBZXpJLFNBQVNZLFdBQVcsQ0FBQ2lELGNBQWM7UUFDeEQsSUFBSTRFLGFBQWFqdEMsTUFBTSxHQUFHLEdBQUc7WUFDM0IsTUFBTStrQyxRQUFRa0ksWUFBWSxDQUFDLEVBQUUsQ0FBQ3RqQyxTQUFTLENBQUMsSUFBSW1PLEtBQUssQ0FBQztZQUNsRCxPQUFPO2dCQUNMNHRCLE1BQU10dUIsU0FBUzJ0QixLQUFLLENBQUMsRUFBRSxFQUFFO2dCQUN6QjNmLFVBQVUyZixLQUFLLENBQUMsRUFBRTtnQkFDbEIrSDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU87SUFDUCxzRUFBc0U7SUFDdEUsdUVBQXVFO0lBQ3ZFLHVFQUF1RTtJQUN2RSxpREFBaUQ7SUFDakR0SSxTQUFTMEksb0JBQW9CLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxJQUFJO1FBQ25ELElBQUlDLFNBQVMsRUFBRTtRQUNmLElBQUlGLE1BQU0vbkIsUUFBUSxLQUFLLGFBQWE7WUFDbENpb0IsU0FBUztnQkFBQyxPQUFPRixNQUFNdDNCLElBQUksR0FBRyxRQUFRczNCLE1BQU0vbkIsUUFBUSxHQUFHLE1BQU1nb0IsS0FBS2hvQixRQUFRLEdBQUc7Z0JBQVE7Z0JBQXdCLGlCQUFpQmdvQixLQUFLMUgsSUFBSSxHQUFHO2FBQU87UUFDbkosT0FBTztZQUNMMkgsU0FBUztnQkFBQyxPQUFPRixNQUFNdDNCLElBQUksR0FBRyxRQUFRczNCLE1BQU0vbkIsUUFBUSxHQUFHLE1BQU1nb0IsS0FBSzFILElBQUksR0FBRztnQkFBUTtnQkFBd0IsZUFBZTBILEtBQUsxSCxJQUFJLEdBQUcsTUFBTTBILEtBQUtob0IsUUFBUSxHQUFHO2FBQWE7UUFDeks7UUFDQSxJQUFJZ29CLEtBQUtOLGNBQWMsS0FBS250QyxXQUFXO1lBQ3JDMHRDLE9BQU8zbUMsSUFBSSxDQUFDLHdCQUF3QjBtQyxLQUFLTixjQUFjLEdBQUc7UUFDNUQ7UUFDQSxPQUFPTyxPQUFPdDlCLElBQUksQ0FBQztJQUNyQjtJQUVBLGlDQUFpQztJQUNqQyxzRUFBc0U7SUFDdEUsK0RBQStEO0lBQy9ELHFFQUFxRTtJQUNyRXkwQixTQUFTOEksaUJBQWlCLEdBQUc7UUFDM0IsT0FBT3hnQyxLQUFLK2MsTUFBTSxHQUFHN2MsUUFBUSxHQUFHdWdDLE1BQU0sQ0FBQyxHQUFHO0lBQzVDO0lBRUEsc0NBQXNDO0lBQ3RDLHdEQUF3RDtJQUN4RCx3QkFBd0I7SUFDeEIsNENBQTRDO0lBQzVDLDJEQUEyRDtJQUMzRC9JLFNBQVNnSix1QkFBdUIsR0FBRyxTQUFVQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtRQUNwRSxJQUFJQztRQUNKLE1BQU12ckIsVUFBVXFyQixZQUFZL3RDLFlBQVkrdEMsVUFBVTtRQUNsRCxJQUFJRCxRQUFRO1lBQ1ZHLFlBQVlIO1FBQ2QsT0FBTztZQUNMRyxZQUFZcEosU0FBUzhJLGlCQUFpQjtRQUN4QztRQUNBLE1BQU1PLE9BQU9GLFlBQVk7UUFDekIsNkNBQTZDO1FBQzdDLE9BQU8sWUFBWSxPQUFPRSxPQUFPLE1BQU1ELFlBQVksTUFBTXZyQixVQUFVLDBCQUEwQixZQUFZO0lBQzNHO0lBRUEsK0RBQStEO0lBQy9EbWlCLFNBQVNzSixZQUFZLEdBQUcsU0FBVXpGLFlBQVksRUFBRUksV0FBVztRQUN6RCx3RUFBd0U7UUFDeEUsTUFBTWYsUUFBUWxELFNBQVNHLFVBQVUsQ0FBQzBEO1FBQ2xDLElBQUssSUFBSXRvQyxJQUFJLEdBQUdBLElBQUkybkMsTUFBTTFuQyxNQUFNLEVBQUVELElBQUs7WUFDckMsT0FBUTJuQyxLQUFLLENBQUMzbkMsRUFBRTtnQkFDZCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNILE9BQU8ybkMsS0FBSyxDQUFDM25DLEVBQUUsQ0FBQzRKLFNBQVMsQ0FBQztZQUU5QjtRQUNGO1FBQ0EsSUFBSTgrQixhQUFhO1lBQ2YsT0FBT2pFLFNBQVNzSixZQUFZLENBQUNyRjtRQUMvQjtRQUNBLE9BQU87SUFDVDtJQUNBakUsU0FBU3VKLE9BQU8sR0FBRyxTQUFVMUYsWUFBWTtRQUN2QyxNQUFNWCxRQUFRbEQsU0FBU0csVUFBVSxDQUFDMEQ7UUFDbEMsTUFBTWdDLFFBQVEzQyxLQUFLLENBQUMsRUFBRSxDQUFDNXZCLEtBQUssQ0FBQztRQUM3QixPQUFPdXlCLEtBQUssQ0FBQyxFQUFFLENBQUMxZ0MsU0FBUyxDQUFDO0lBQzVCO0lBQ0E2NkIsU0FBU3dKLFVBQVUsR0FBRyxTQUFVM0YsWUFBWTtRQUMxQyxPQUFPQSxhQUFhdndCLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUs7SUFDM0M7SUFDQTBzQixTQUFTb0ksVUFBVSxHQUFHLFNBQVV2RSxZQUFZO1FBQzFDLE1BQU1YLFFBQVFsRCxTQUFTRyxVQUFVLENBQUMwRDtRQUNsQyxNQUFNdEQsUUFBUTJDLEtBQUssQ0FBQyxFQUFFLENBQUMvOUIsU0FBUyxDQUFDLEdBQUdtTyxLQUFLLENBQUM7UUFDMUMsT0FBTztZQUNMakMsTUFBTWt2QixLQUFLLENBQUMsRUFBRTtZQUNkVyxNQUFNdHVCLFNBQVMydEIsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN6QjNmLFVBQVUyZixLQUFLLENBQUMsRUFBRTtZQUNsQmlJLEtBQUtqSSxNQUFNdGpDLEtBQUssQ0FBQyxHQUFHc08sSUFBSSxDQUFDO1FBQzNCO0lBQ0Y7SUFDQXkwQixTQUFTeUosVUFBVSxHQUFHLFNBQVU1RixZQUFZO1FBQzFDLE1BQU14RCxPQUFPTCxTQUFTWSxXQUFXLENBQUNpRCxjQUFjLEtBQUssQ0FBQyxFQUFFO1FBQ3hELE1BQU10RCxRQUFRRixLQUFLbDdCLFNBQVMsQ0FBQyxHQUFHbU8sS0FBSyxDQUFDO1FBQ3RDLE9BQU87WUFDTG8yQixVQUFVbkosS0FBSyxDQUFDLEVBQUU7WUFDbEI2SSxXQUFXN0ksS0FBSyxDQUFDLEVBQUU7WUFDbkJvSixnQkFBZ0IvMkIsU0FBUzJ0QixLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ25DcUosU0FBU3JKLEtBQUssQ0FBQyxFQUFFO1lBQ2pCc0osYUFBYXRKLEtBQUssQ0FBQyxFQUFFO1lBQ3JCaGYsU0FBU2dmLEtBQUssQ0FBQyxFQUFFO1FBQ25CO0lBQ0Y7SUFFQSw4Q0FBOEM7SUFDOUNQLFNBQVM4SixVQUFVLEdBQUcsU0FBVTFKLElBQUk7UUFDbEMsSUFBSSxPQUFPQSxTQUFTLFlBQVlBLEtBQUs1a0MsTUFBTSxLQUFLLEdBQUc7WUFDakQsT0FBTztRQUNUO1FBQ0EsTUFBTTBuQyxRQUFRbEQsU0FBU0csVUFBVSxDQUFDQztRQUNsQyxJQUFLLElBQUk3a0MsSUFBSSxHQUFHQSxJQUFJMm5DLE1BQU0xbkMsTUFBTSxFQUFFRCxJQUFLO1lBQ3JDLElBQUkybkMsS0FBSyxDQUFDM25DLEVBQUUsQ0FBQ0MsTUFBTSxHQUFHLEtBQUswbkMsS0FBSyxDQUFDM25DLEVBQUUsQ0FBQ29kLE1BQU0sQ0FBQyxPQUFPLEtBQUs7Z0JBQ3JELE9BQU87WUFDVDtRQUNBLHVDQUF1QztRQUN6QztRQUNBLE9BQU87SUFDVDtJQUVBLHlCQUF5QjtJQUN6QjtRQUNFL2UsT0FBT0QsT0FBTyxHQUFHcW1DO0lBQ25CO0FBQ0YsR0FBR0Q7QUFDSCxJQUFJZ0ssYUFBYWhLLE1BQU1wbUMsT0FBTztBQUM5QixJQUFJcW1DLFdBQVcsV0FBVyxHQUFFNW1DLHdCQUF3QjJ3QztBQUVwRCxJQUFJelIsTUFBTSxXQUFXLEdBQUV2Z0MsaUJBQWlCO0lBQ3ZDOGhDLFdBQVc7SUFDWDNnQixTQUFTOG1CO0FBQ1YsR0FBRztJQUFDK0o7Q0FBVztBQUVmOzs7Ozs7Q0FNQyxHQUNELG1CQUFtQixHQUNuQixTQUFTQyxvQkFBb0Ivd0MsT0FBTTtJQUNqQyx3RUFBd0U7SUFDeEUsNkRBQTZEO0lBQzdELElBQUksQ0FBQ0EsUUFBT3VnQyxlQUFlLElBQUl2Z0MsUUFBT3VnQyxlQUFlLElBQUksZ0JBQWdCdmdDLFFBQU91Z0MsZUFBZSxDQUFDamdDLFNBQVMsRUFBRTtRQUN6RztJQUNGO0lBQ0EsTUFBTTB3Qyx3QkFBd0JoeEMsUUFBT3VnQyxlQUFlO0lBQ3BEdmdDLFFBQU91Z0MsZUFBZSxHQUFHLFNBQVNBLGlCQUFnQnJTLElBQUk7UUFDcEQsaUVBQWlFO1FBQ2pFLElBQUksT0FBT0EsU0FBUyxZQUFZQSxLQUFLZ1gsU0FBUyxJQUFJaFgsS0FBS2dYLFNBQVMsQ0FBQ3BoQyxPQUFPLENBQUMsVUFBVSxHQUFHO1lBQ3BGb3FCLE9BQU90akIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLYyxTQUFTLENBQUN3aUI7WUFDakNBLEtBQUtnWCxTQUFTLEdBQUdoWCxLQUFLZ1gsU0FBUyxDQUFDaDVCLFNBQVMsQ0FBQztRQUM1QztRQUNBLElBQUlnaUIsS0FBS2dYLFNBQVMsSUFBSWhYLEtBQUtnWCxTQUFTLENBQUMzaUMsTUFBTSxFQUFFO1lBQzNDLHVEQUF1RDtZQUN2RCxNQUFNMHVDLGtCQUFrQixJQUFJRCxzQkFBc0I5aUI7WUFDbEQsTUFBTWdqQixrQkFBa0JuSyxTQUFTYSxjQUFjLENBQUMxWixLQUFLZ1gsU0FBUztZQUM5RCxJQUFLLE1BQU1oc0IsT0FBT2c0QixnQkFBaUI7Z0JBQ2pDLElBQUksQ0FBRWg0QixDQUFBQSxPQUFPKzNCLGVBQWMsR0FBSTtvQkFDN0I1eEMsT0FBT0ssY0FBYyxDQUFDdXhDLGlCQUFpQi8zQixLQUFLO3dCQUMxQ25RLE9BQU9tb0MsZUFBZSxDQUFDaDRCLElBQUk7b0JBQzdCO2dCQUNGO1lBQ0Y7WUFFQSw2REFBNkQ7WUFDN0QrM0IsZ0JBQWdCcmxDLE1BQU0sR0FBRyxTQUFTQTtnQkFDaEMsT0FBTztvQkFDTHM1QixXQUFXK0wsZ0JBQWdCL0wsU0FBUztvQkFDcENpTSxRQUFRRixnQkFBZ0JFLE1BQU07b0JBQzlCQyxlQUFlSCxnQkFBZ0JHLGFBQWE7b0JBQzVDOUksa0JBQWtCMkksZ0JBQWdCM0ksZ0JBQWdCO2dCQUNwRDtZQUNGO1lBQ0EsT0FBTzJJO1FBQ1Q7UUFDQSxPQUFPLElBQUlELHNCQUFzQjlpQjtJQUNuQztJQUNBbHVCLFFBQU91Z0MsZUFBZSxDQUFDamdDLFNBQVMsR0FBRzB3QyxzQkFBc0Ixd0MsU0FBUztJQUVsRSx3REFBd0Q7SUFDeEQsd0NBQXdDO0lBQ3hDd3lCLHdCQUF3Qjl5QixTQUFRLGdCQUFnQmQsQ0FBQUE7UUFDOUMsSUFBSUEsRUFBRWdtQyxTQUFTLEVBQUU7WUFDZjdsQyxPQUFPSyxjQUFjLENBQUNSLEdBQUcsYUFBYTtnQkFDcEM2SixPQUFPLElBQUkvSSxRQUFPdWdDLGVBQWUsQ0FBQ3JoQyxFQUFFZ21DLFNBQVM7Z0JBQzdDbU0sVUFBVTtZQUNaO1FBQ0Y7UUFDQSxPQUFPbnlDO0lBQ1Q7QUFDRjtBQUNBLFNBQVNveUMsaUNBQWlDdHhDLE9BQU07SUFDOUMsSUFBSSxDQUFDQSxRQUFPdWdDLGVBQWUsSUFBSXZnQyxRQUFPdWdDLGVBQWUsSUFBSSxtQkFBbUJ2Z0MsUUFBT3VnQyxlQUFlLENBQUNqZ0MsU0FBUyxFQUFFO1FBQzVHO0lBQ0Y7SUFFQSx3REFBd0Q7SUFDeEQsd0NBQXdDO0lBQ3hDd3lCLHdCQUF3Qjl5QixTQUFRLGdCQUFnQmQsQ0FBQUE7UUFDOUMsSUFBSUEsRUFBRWdtQyxTQUFTLEVBQUU7WUFDZixNQUFNZ00sa0JBQWtCbkssU0FBU2EsY0FBYyxDQUFDMW9DLEVBQUVnbUMsU0FBUyxDQUFDQSxTQUFTO1lBQ3JFLElBQUlnTSxnQkFBZ0JsbkMsSUFBSSxLQUFLLFNBQVM7Z0JBQ3BDLGdFQUFnRTtnQkFDaEUsb0JBQW9CO2dCQUNwQjlLLEVBQUVnbUMsU0FBUyxDQUFDcU0sYUFBYSxHQUFHO29CQUMxQixHQUFHO29CQUNILEdBQUc7b0JBQ0gsR0FBRztnQkFDTCxFQUFDLENBQUNMLGdCQUFnQm5KLFFBQVEsSUFBSSxHQUFHO1lBQ25DO1FBQ0Y7UUFDQSxPQUFPN29DO0lBQ1Q7QUFDRjtBQUNBLFNBQVNzeUMsbUJBQW1CeHhDLE9BQU0sRUFBRWsyQixjQUFjO0lBQ2hELElBQUksQ0FBQ2wyQixRQUFPaXpCLGlCQUFpQixFQUFFO1FBQzdCO0lBQ0Y7SUFDQSxJQUFJLENBQUUsV0FBVWp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsR0FBRztRQUNuRGpCLE9BQU9LLGNBQWMsQ0FBQ00sUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEVBQUUsUUFBUTtZQUNoRVg7Z0JBQ0UsT0FBTyxPQUFPLElBQUksQ0FBQzh4QyxLQUFLLEtBQUssY0FBYyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUM5RDtRQUNGO0lBQ0Y7SUFDQSxNQUFNQyxvQkFBb0IsU0FBVXRTLFdBQVc7UUFDN0MsSUFBSSxDQUFDQSxlQUFlLENBQUNBLFlBQVlDLEdBQUcsRUFBRTtZQUNwQyxPQUFPO1FBQ1Q7UUFDQSxNQUFNb0ksV0FBV1YsU0FBU00sYUFBYSxDQUFDakksWUFBWUMsR0FBRztRQUN2RG9JLFNBQVN2NkIsS0FBSztRQUNkLE9BQU91NkIsU0FBUzdQLElBQUksQ0FBQ2dULENBQUFBO1lBQ25CLE1BQU0rRyxRQUFRNUssU0FBU29JLFVBQVUsQ0FBQ3ZFO1lBQ2xDLE9BQU8rRyxTQUFTQSxNQUFNdjVCLElBQUksS0FBSyxpQkFBaUJ1NUIsTUFBTWhxQixRQUFRLENBQUM3akIsT0FBTyxDQUFDLFlBQVksQ0FBQztRQUN0RjtJQUNGO0lBQ0EsTUFBTTh0QywwQkFBMEIsU0FBVXhTLFdBQVc7UUFDbkQsMERBQTBEO1FBQzFELE1BQU1yZSxRQUFRcWUsWUFBWUMsR0FBRyxDQUFDdGUsS0FBSyxDQUFDO1FBQ3BDLElBQUlBLFVBQVUsUUFBUUEsTUFBTXhlLE1BQU0sR0FBRyxHQUFHO1lBQ3RDLE9BQU8sQ0FBQztRQUNWO1FBQ0EsTUFBTXFpQixVQUFVakwsU0FBU29ILEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDbkMsbUNBQW1DO1FBQ25DLE9BQU82RCxZQUFZQSxVQUFVLENBQUMsSUFBSUE7SUFDcEM7SUFDQSxNQUFNaXRCLDJCQUEyQixTQUFVQyxlQUFlO1FBQ3hELHlEQUF5RDtRQUN6RCx1RUFBdUU7UUFDdkUscURBQXFEO1FBQ3JELHNFQUFzRTtRQUN0RSxJQUFJQyx3QkFBd0I7UUFDNUIsSUFBSTdiLGVBQWU5TixPQUFPLEtBQUssV0FBVztZQUN4QyxJQUFJOE4sZUFBZXRSLE9BQU8sR0FBRyxJQUFJO2dCQUMvQixJQUFJa3RCLG9CQUFvQixDQUFDLEdBQUc7b0JBQzFCLCtEQUErRDtvQkFDL0QsaUJBQWlCO29CQUNqQkMsd0JBQXdCO2dCQUMxQixPQUFPO29CQUNMLGdFQUFnRTtvQkFDaEUsa0RBQWtEO29CQUNsREEsd0JBQXdCO2dCQUMxQjtZQUNGLE9BQU8sSUFBSTdiLGVBQWV0UixPQUFPLEdBQUcsSUFBSTtnQkFDdEMscUVBQXFFO2dCQUNyRSxpRUFBaUU7Z0JBQ2pFLFlBQVk7Z0JBQ1osNERBQTREO2dCQUM1RG10Qix3QkFBd0I3YixlQUFldFIsT0FBTyxLQUFLLEtBQUssUUFBUTtZQUNsRSxPQUFPO2dCQUNMLG1DQUFtQztnQkFDbkNtdEIsd0JBQXdCO1lBQzFCO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsTUFBTUMsb0JBQW9CLFNBQVU1UyxXQUFXLEVBQUUwUyxlQUFlO1FBQzlELGtFQUFrRTtRQUNsRSxxRUFBcUU7UUFDckUsSUFBSXpDLGlCQUFpQjtRQUVyQixxRUFBcUU7UUFDckUsNkRBQTZEO1FBQzdELDREQUE0RDtRQUM1RCxJQUFJblosZUFBZTlOLE9BQU8sS0FBSyxhQUFhOE4sZUFBZXRSLE9BQU8sS0FBSyxJQUFJO1lBQ3pFeXFCLGlCQUFpQjtRQUNuQjtRQUNBLE1BQU10dUIsUUFBUWdtQixTQUFTWSxXQUFXLENBQUN2SSxZQUFZQyxHQUFHLEVBQUU7UUFDcEQsSUFBSXRlLE1BQU14ZSxNQUFNLEdBQUcsR0FBRztZQUNwQjhzQyxpQkFBaUIxMUIsU0FBU29ILEtBQUssQ0FBQyxFQUFFLENBQUM3VSxTQUFTLENBQUMsS0FBSztRQUNwRCxPQUFPLElBQUlncUIsZUFBZTlOLE9BQU8sS0FBSyxhQUFhMHBCLG9CQUFvQixDQUFDLEdBQUc7WUFDekUsbUVBQW1FO1lBQ25FLGlFQUFpRTtZQUNqRSxVQUFVO1lBQ1Z6QyxpQkFBaUI7UUFDbkI7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsTUFBTTNVLDJCQUEyQjE2QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E2QixvQkFBb0I7SUFDeEYzNkIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNxNkIsb0JBQW9CLEdBQUcsU0FBU0E7UUFDakUsSUFBSSxDQUFDOFcsS0FBSyxHQUFHO1FBQ2IscURBQXFEO1FBQ3JELHVEQUF1RDtRQUN2RCx3QkFBd0I7UUFDeEIsSUFBSXZiLGVBQWU5TixPQUFPLEtBQUssWUFBWThOLGVBQWV0UixPQUFPLElBQUksSUFBSTtZQUN2RSxNQUFNLEVBQ0o4YixZQUFZLEVBQ2IsR0FBRyxJQUFJLENBQUNELGdCQUFnQjtZQUN6QixJQUFJQyxpQkFBaUIsVUFBVTtnQkFDN0JyaEMsT0FBT0ssY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO29CQUNsQ0M7d0JBQ0UsT0FBTyxPQUFPLElBQUksQ0FBQzh4QyxLQUFLLEtBQUssY0FBYyxPQUFPLElBQUksQ0FBQ0EsS0FBSztvQkFDOUQ7b0JBQ0E3eEMsWUFBWTtvQkFDWm0wQixjQUFjO2dCQUNoQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJMmQsa0JBQWtCN3ZDLFNBQVMsQ0FBQyxFQUFFLEdBQUc7WUFDbkMsNkJBQTZCO1lBQzdCLE1BQU1vd0MsWUFBWUwsd0JBQXdCL3ZDLFNBQVMsQ0FBQyxFQUFFO1lBRXRELG9FQUFvRTtZQUNwRSxNQUFNcXdDLGFBQWFMLHlCQUF5Qkk7WUFFNUMsbURBQW1EO1lBQ25ELE1BQU1FLFlBQVlILGtCQUFrQm53QyxTQUFTLENBQUMsRUFBRSxFQUFFb3dDO1lBRWxELHVDQUF1QztZQUN2QyxJQUFJNUM7WUFDSixJQUFJNkMsZUFBZSxLQUFLQyxjQUFjLEdBQUc7Z0JBQ3ZDOUMsaUJBQWlCN25DLE9BQU9vVixpQkFBaUI7WUFDM0MsT0FBTyxJQUFJczFCLGVBQWUsS0FBS0MsY0FBYyxHQUFHO2dCQUM5QzlDLGlCQUFpQmhnQyxLQUFLc1UsR0FBRyxDQUFDdXVCLFlBQVlDO1lBQ3hDLE9BQU87Z0JBQ0w5QyxpQkFBaUJoZ0MsS0FBS3FVLEdBQUcsQ0FBQ3d1QixZQUFZQztZQUN4QztZQUVBLGtFQUFrRTtZQUNsRSxhQUFhO1lBQ2IsTUFBTXhDLE9BQU8sQ0FBQztZQUNkdHdDLE9BQU9LLGNBQWMsQ0FBQ2l3QyxNQUFNLGtCQUFrQjtnQkFDNUNod0M7b0JBQ0UsT0FBTzB2QztnQkFDVDtZQUNGO1lBQ0EsSUFBSSxDQUFDb0MsS0FBSyxHQUFHOUI7UUFDZjtRQUNBLE9BQU9qVix5QkFBeUI5NEIsS0FBSyxDQUFDLElBQUksRUFBRUM7SUFDOUM7QUFDRjtBQUNBLFNBQVN1d0MsdUJBQXVCcHlDLE9BQU07SUFDcEMsSUFBSSxDQUFFQSxDQUFBQSxRQUFPaXpCLGlCQUFpQixJQUFJLHVCQUF1Qmp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsR0FBRztRQUM1RjtJQUNGO0lBRUEsd0VBQXdFO0lBQ3hFLDBFQUEwRTtJQUMxRSxrRUFBa0U7SUFFbEUsU0FBUyt4QyxXQUFXQyxFQUFFLEVBQUVoWCxFQUFFO1FBQ3hCLE1BQU1pWCxzQkFBc0JELEdBQUdFLElBQUk7UUFDbkNGLEdBQUdFLElBQUksR0FBRyxTQUFTQTtZQUNqQixNQUFNcG1DLE9BQU92SyxTQUFTLENBQUMsRUFBRTtZQUN6QixNQUFNVSxTQUFTNkosS0FBSzdKLE1BQU0sSUFBSTZKLEtBQUswbkIsSUFBSSxJQUFJMW5CLEtBQUs5QixVQUFVO1lBQzFELElBQUlnb0MsR0FBR0csVUFBVSxLQUFLLFVBQVVuWCxHQUFHcVUsSUFBSSxJQUFJcHRDLFNBQVMrNEIsR0FBR3FVLElBQUksQ0FBQ04sY0FBYyxFQUFFO2dCQUMxRSxNQUFNLElBQUlwcUMsVUFBVSw4Q0FBOENxMkIsR0FBR3FVLElBQUksQ0FBQ04sY0FBYyxHQUFHO1lBQzdGO1lBQ0EsT0FBT2tELG9CQUFvQjN3QyxLQUFLLENBQUMwd0MsSUFBSXp3QztRQUN2QztJQUNGO0lBQ0EsTUFBTTZ3Qyx3QkFBd0IxeUMsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUNxeUMsaUJBQWlCO0lBQ2xGM3lDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDcXlDLGlCQUFpQixHQUFHLFNBQVNBO1FBQzlELE1BQU1DLGNBQWNGLHNCQUFzQjl3QyxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUN0RHd3QyxXQUFXTyxhQUFhLElBQUk7UUFDNUIsT0FBT0E7SUFDVDtJQUNBOWYsd0JBQXdCOXlCLFNBQVEsZUFBZWQsQ0FBQUE7UUFDN0NtekMsV0FBV256QyxFQUFFMnpDLE9BQU8sRUFBRTN6QyxFQUFFOFksTUFBTTtRQUM5QixPQUFPOVk7SUFDVDtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBUzR6QyxvQkFBb0I5eUMsT0FBTTtJQUNqQyxJQUFJLENBQUNBLFFBQU9pekIsaUJBQWlCLElBQUkscUJBQXFCanpCLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxFQUFFO1FBQ3hGO0lBQ0Y7SUFDQSxNQUFNNHlCLFFBQVFsekIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTO0lBQ2hEakIsT0FBT0ssY0FBYyxDQUFDd3pCLE9BQU8sbUJBQW1CO1FBQzlDdnpCO1lBQ0UsT0FBTztnQkFDTG96QyxXQUFXO2dCQUNYQyxVQUFVO1lBQ1osRUFBQyxDQUFDLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxJQUFJLENBQUNBLGtCQUFrQjtRQUN2RDtRQUNBcnpDLFlBQVk7UUFDWm0wQixjQUFjO0lBQ2hCO0lBQ0ExMEIsT0FBT0ssY0FBYyxDQUFDd3pCLE9BQU8sMkJBQTJCO1FBQ3REdnpCO1lBQ0UsT0FBTyxJQUFJLENBQUN1ekMsd0JBQXdCLElBQUk7UUFDMUM7UUFDQTlnQyxLQUFJaWhCLEVBQUU7WUFDSixJQUFJLElBQUksQ0FBQzZmLHdCQUF3QixFQUFFO2dCQUNqQyxJQUFJLENBQUMzZ0IsbUJBQW1CLENBQUMseUJBQXlCLElBQUksQ0FBQzJnQix3QkFBd0I7Z0JBQy9FLE9BQU8sSUFBSSxDQUFDQSx3QkFBd0I7WUFDdEM7WUFDQSxJQUFJN2YsSUFBSTtnQkFDTixJQUFJLENBQUNoQixnQkFBZ0IsQ0FBQyx5QkFBeUIsSUFBSSxDQUFDNmdCLHdCQUF3QixHQUFHN2Y7WUFDakY7UUFDRjtRQUNBenpCLFlBQVk7UUFDWm0wQixjQUFjO0lBQ2hCO0lBQ0E7UUFBQztRQUF1QjtLQUF1QixDQUFDOTBCLE9BQU8sQ0FBQ3dDLENBQUFBO1FBQ3RELE1BQU0weEMsYUFBYWpnQixLQUFLLENBQUN6eEIsT0FBTztRQUNoQ3l4QixLQUFLLENBQUN6eEIsT0FBTyxHQUFHO1lBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQzJ4QywwQkFBMEIsRUFBRTtnQkFDcEMsSUFBSSxDQUFDQSwwQkFBMEIsR0FBR2wwQyxDQUFBQTtvQkFDaEMsTUFBTW84QixLQUFLcDhCLEVBQUU4WSxNQUFNO29CQUNuQixJQUFJc2pCLEdBQUcrWCxvQkFBb0IsS0FBSy9YLEdBQUdnWSxlQUFlLEVBQUU7d0JBQ2xEaFksR0FBRytYLG9CQUFvQixHQUFHL1gsR0FBR2dZLGVBQWU7d0JBQzVDLE1BQU1DLFdBQVcsSUFBSXZZLE1BQU0seUJBQXlCOTdCO3dCQUNwRG84QixHQUFHSCxhQUFhLENBQUNvWTtvQkFDbkI7b0JBQ0EsT0FBT3IwQztnQkFDVDtnQkFDQSxJQUFJLENBQUNtekIsZ0JBQWdCLENBQUMsNEJBQTRCLElBQUksQ0FBQytnQiwwQkFBMEI7WUFDbkY7WUFDQSxPQUFPRCxXQUFXdnhDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1FBQ2hDO0lBQ0Y7QUFDRjtBQUNBLFNBQVMyeEMsdUJBQXVCeHpDLE9BQU0sRUFBRWsyQixjQUFjO0lBQ3BELG9EQUFvRCxHQUNwRCxJQUFJLENBQUNsMkIsUUFBT2l6QixpQkFBaUIsRUFBRTtRQUM3QjtJQUNGO0lBQ0EsSUFBSWlELGVBQWU5TixPQUFPLEtBQUssWUFBWThOLGVBQWV0UixPQUFPLElBQUksSUFBSTtRQUN2RTtJQUNGO0lBQ0EsSUFBSXNSLGVBQWU5TixPQUFPLEtBQUssWUFBWThOLGVBQWV0UixPQUFPLElBQUksS0FBSztRQUN4RTtJQUNGO0lBQ0EsTUFBTTZ1QixZQUFZenpDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDcTZCLG9CQUFvQjtJQUN6RTM2QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsQ0FBQ3E2QixvQkFBb0IsR0FBRyxTQUFTQSxxQkFBcUJvRixJQUFJO1FBQzFGLElBQUlBLFFBQVFBLEtBQUtWLEdBQUcsSUFBSVUsS0FBS1YsR0FBRyxDQUFDdjdCLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQyxHQUFHO1lBQ3pFLE1BQU11N0IsTUFBTVUsS0FBS1YsR0FBRyxDQUFDaGxCLEtBQUssQ0FBQyxNQUFNeFUsTUFBTSxDQUFDdWhDLENBQUFBO2dCQUN0QyxPQUFPQSxLQUFLdHFCLElBQUksT0FBTztZQUN6QixHQUFHeEssSUFBSSxDQUFDO1lBQ1Isa0VBQWtFO1lBQ2xFLElBQUl0UyxRQUFPMC9CLHFCQUFxQixJQUFJSyxnQkFBZ0IvL0IsUUFBTzAvQixxQkFBcUIsRUFBRTtnQkFDaEY3OUIsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJN0IsUUFBTzAvQixxQkFBcUIsQ0FBQztvQkFDOUMxMUIsTUFBTSsxQixLQUFLLzFCLElBQUk7b0JBQ2ZxMUI7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMVSxLQUFLVixHQUFHLEdBQUdBO1lBQ2I7UUFDRjtRQUNBLE9BQU9vVSxVQUFVN3hDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQy9CO0FBQ0Y7QUFDQSxTQUFTNnhDLCtCQUErQjF6QyxPQUFNLEVBQUVrMkIsY0FBYztJQUM1RCxpREFBaUQ7SUFDakQsbURBQW1EO0lBQ25ELCtEQUErRDtJQUMvRCwwRUFBMEU7SUFDMUUsSUFBSSxDQUFFbDJCLENBQUFBLFFBQU9pekIsaUJBQWlCLElBQUlqekIsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLEdBQUc7UUFDckU7SUFDRjtJQUNBLE1BQU1xekMsd0JBQXdCM3pDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDdWtDLGVBQWU7SUFDaEYsSUFBSSxDQUFDOE8seUJBQXlCQSxzQkFBc0JweEMsTUFBTSxLQUFLLEdBQUc7UUFDaEU7SUFDRjtJQUNBdkMsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUN1a0MsZUFBZSxHQUFHLFNBQVNBO1FBQzVELElBQUksQ0FBQ2hqQyxTQUFTLENBQUMsRUFBRSxFQUFFO1lBQ2pCLElBQUlBLFNBQVMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hCQSxTQUFTLENBQUMsRUFBRSxDQUFDRCxLQUFLLENBQUM7WUFDckI7WUFDQSxPQUFPZ3JCLFFBQVFELE9BQU87UUFDeEI7UUFDQSwrREFBK0Q7UUFDL0QscUJBQXFCO1FBQ3JCLHNEQUFzRDtRQUN0RCxzRUFBc0U7UUFDdEUsbURBQW1EO1FBQ25ELElBQUksQ0FBQ3VKLGVBQWU5TixPQUFPLEtBQUssWUFBWThOLGVBQWV0UixPQUFPLEdBQUcsTUFBTXNSLGVBQWU5TixPQUFPLEtBQUssYUFBYThOLGVBQWV0UixPQUFPLEdBQUcsTUFBTXNSLGVBQWU5TixPQUFPLEtBQUssUUFBTyxLQUFNdm1CLFNBQVMsQ0FBQyxFQUFFLElBQUlBLFNBQVMsQ0FBQyxFQUFFLENBQUNxakMsU0FBUyxLQUFLLElBQUk7WUFDdk8sT0FBT3RZLFFBQVFELE9BQU87UUFDeEI7UUFDQSxPQUFPZ25CLHNCQUFzQi94QyxLQUFLLENBQUMsSUFBSSxFQUFFQztJQUMzQztBQUNGO0FBRUEseURBQXlEO0FBQ3pELDZCQUE2QjtBQUM3QixTQUFTK3hDLHFDQUFxQzV6QyxPQUFNLEVBQUVrMkIsY0FBYztJQUNsRSxJQUFJLENBQUVsMkIsQ0FBQUEsUUFBT2l6QixpQkFBaUIsSUFBSWp6QixRQUFPaXpCLGlCQUFpQixDQUFDM3lCLFNBQVMsR0FBRztRQUNyRTtJQUNGO0lBQ0EsTUFBTXV6Qyw0QkFBNEI3ekMsUUFBT2l6QixpQkFBaUIsQ0FBQzN5QixTQUFTLENBQUMyL0IsbUJBQW1CO0lBQ3hGLElBQUksQ0FBQzRULDZCQUE2QkEsMEJBQTBCdHhDLE1BQU0sS0FBSyxHQUFHO1FBQ3hFO0lBQ0Y7SUFDQXZDLFFBQU9pekIsaUJBQWlCLENBQUMzeUIsU0FBUyxDQUFDMi9CLG1CQUFtQixHQUFHLFNBQVNBO1FBQ2hFLElBQUlGLE9BQU9sK0IsU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDO1FBQzVCLElBQUksT0FBT2srQixTQUFTLFlBQVlBLEtBQUsvMUIsSUFBSSxJQUFJKzFCLEtBQUtWLEdBQUcsRUFBRTtZQUNyRCxPQUFPd1UsMEJBQTBCanlDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1FBQy9DO1FBQ0EsdUVBQXVFO1FBQ3ZFLHVFQUF1RTtRQUN2RSxvRUFBb0U7UUFDcEUsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSx3RUFBd0U7UUFDeEUsc0VBQXNFO1FBQ3RFaytCLE9BQU87WUFDTC8xQixNQUFNKzFCLEtBQUsvMUIsSUFBSTtZQUNmcTFCLEtBQUtVLEtBQUtWLEdBQUc7UUFDZjtRQUNBLElBQUksQ0FBQ1UsS0FBSy8xQixJQUFJLEVBQUU7WUFDZCxPQUFRLElBQUksQ0FBQ2kxQixjQUFjO2dCQUN6QixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSGMsS0FBSy8xQixJQUFJLEdBQUc7b0JBQ1o7Z0JBQ0Y7b0JBQ0UrMUIsS0FBSy8xQixJQUFJLEdBQUc7b0JBQ1o7WUFDSjtRQUNGO1FBQ0EsSUFBSSsxQixLQUFLVixHQUFHLElBQUlVLEtBQUsvMUIsSUFBSSxLQUFLLFdBQVcrMUIsS0FBSy8xQixJQUFJLEtBQUssVUFBVTtZQUMvRCxPQUFPNnBDLDBCQUEwQmp5QyxLQUFLLENBQUMsSUFBSSxFQUFFO2dCQUFDbStCO2FBQUs7UUFDckQ7UUFDQSxNQUFNOUksT0FBTzhJLEtBQUsvMUIsSUFBSSxLQUFLLFVBQVUsSUFBSSxDQUFDNDVCLFdBQVcsR0FBRyxJQUFJLENBQUNJLFlBQVk7UUFDekUsT0FBTy9NLEtBQUtyMUIsS0FBSyxDQUFDLElBQUksRUFBRXVyQixJQUFJLENBQUMzdEIsQ0FBQUEsSUFBS3EwQywwQkFBMEJqeUMsS0FBSyxDQUFDLElBQUksRUFBRTtnQkFBQ3BDO2FBQUU7SUFDN0U7QUFDRjtBQUVBLElBQUlzMEMsYUFBYSxXQUFXLEdBQUV6MEMsT0FBT1EsTUFBTSxDQUFDO0lBQzNDK2dDLFdBQVc7SUFDWDRTLHdCQUF3QkE7SUFDeEJFLGdDQUFnQ0E7SUFDaENaLHFCQUFxQkE7SUFDckJ0QixvQkFBb0JBO0lBQ3BCb0Msc0NBQXNDQTtJQUN0QzdDLHFCQUFxQkE7SUFDckJPLGtDQUFrQ0E7SUFDbENjLHdCQUF3QkE7QUFDekI7QUFFQTs7Ozs7O0NBTUMsR0FFRCx3QkFBd0I7QUFDeEIsU0FBUzJCO0lBQ1AsSUFBSSxFQUNGL3pDLFFBQUFBLE9BQU0sRUFDUCxHQUFHNkIsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJa0ksVUFBVWxJLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ2hGbXlDLFlBQVk7UUFDWkMsYUFBYTtRQUNiQyxZQUFZO0lBQ2Q7SUFDQSxTQUFTO0lBQ1QsTUFBTWxlLFVBQVVsMUI7SUFDaEIsTUFBTW8xQixpQkFBaUI3QixjQUFjcjBCO0lBQ3JDLE1BQU1tMEMsVUFBVTtRQUNkamU7UUFDQTRkO1FBQ0FuaEIsZ0JBQWdCQTtRQUNoQnFCLFlBQVlBO1FBQ1pDLGlCQUFpQkE7UUFDakIscUVBQXFFO1FBQ3JFb0w7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QixPQUFRbkosZUFBZTlOLE9BQU87UUFDNUIsS0FBSztZQUNILElBQUksQ0FBQ3VZLGNBQWMsQ0FBQ0wsd0JBQXdCLENBQUN2MkIsUUFBUWlxQyxVQUFVLEVBQUU7Z0JBQy9EaGUsUUFBUTtnQkFDUixPQUFPbWU7WUFDVDtZQUNBLElBQUlqZSxlQUFldFIsT0FBTyxLQUFLLE1BQU07Z0JBQ25Db1IsUUFBUTtnQkFDUixPQUFPbWU7WUFDVDtZQUNBbmUsUUFBUTtZQUNSLDhEQUE4RDtZQUM5RG1lLFFBQVFDLFdBQVcsR0FBR3pUO1lBRXRCLDRDQUE0QztZQUM1QytTLCtCQUErQjF6QyxTQUFRazJCO1lBQ3ZDMGQscUNBQXFDNXpDO1lBQ3JDaTJCLG1CQUFtQmoyQixTQUFRazJCO1lBQzNCbUUsZ0JBQWdCcjZCO1lBQ2hCc2dDLHFCQUFxQnRnQyxTQUFRazJCO1lBQzdCc0UsY0FBY3g2QjtZQUNkMitCLHdCQUF3QjMrQixTQUFRazJCO1lBQ2hDa0YsdUJBQXVCcDdCO1lBQ3ZCMjhCLGFBQWEzOEI7WUFDYjY5QiwyQkFBMkI3OUI7WUFDM0J3Z0MscUJBQXFCeGdDLFNBQVFrMkI7WUFDN0I2YSxvQkFBb0Ivd0M7WUFDcEJzeEMsaUNBQWlDdHhDO1lBQ2pDOHlDLG9CQUFvQjl5QztZQUNwQnd4QyxtQkFBbUJ4eEMsU0FBUWsyQjtZQUMzQmtjLHVCQUF1QnB5QztZQUN2Qnd6Qyx1QkFBdUJ4ekMsU0FBUWsyQjtZQUMvQjtRQUNGLEtBQUs7WUFDSCxJQUFJLENBQUMrTixlQUFlLENBQUNqRCxzQkFBc0IsQ0FBQ2ozQixRQUFRa3FDLFdBQVcsRUFBRTtnQkFDL0RqZSxRQUFRO2dCQUNSLE9BQU9tZTtZQUNUO1lBQ0FuZSxRQUFRO1lBQ1IsOERBQThEO1lBQzlEbWUsUUFBUUMsV0FBVyxHQUFHblE7WUFFdEIsNENBQTRDO1lBQzVDeVAsK0JBQStCMXpDLFNBQVFrMkI7WUFDdkMwZCxxQ0FBcUM1ekM7WUFDckNpaEMsbUJBQW1CamhDLFNBQVFrMkI7WUFDM0I4SyxtQkFBbUJoaEMsU0FBUWsyQjtZQUMzQjZLLFlBQVkvZ0M7WUFDWm1pQyxpQkFBaUJuaUM7WUFDakJpaUMsbUJBQW1CamlDO1lBQ25Ca2lDLHFCQUFxQmxpQztZQUNyQm9pQyxtQkFBbUJwaUM7WUFDbkJ1aUMsbUJBQW1CdmlDO1lBQ25Cd2pDLGtCQUFrQnhqQztZQUNsQjBqQyxnQkFBZ0IxakM7WUFDaEI4akMsaUJBQWlCOWpDO1lBQ2pCK3dDLG9CQUFvQi93QztZQUNwQjh5QyxvQkFBb0I5eUM7WUFDcEJ3eEMsbUJBQW1CeHhDLFNBQVFrMkI7WUFDM0JrYyx1QkFBdUJweUM7WUFDdkI7UUFDRixLQUFLO1lBQ0gsSUFBSSxDQUFDNm1DLGNBQWMsQ0FBQzk4QixRQUFRbXFDLFVBQVUsRUFBRTtnQkFDdENsZSxRQUFRO2dCQUNSLE9BQU9tZTtZQUNUO1lBQ0FuZSxRQUFRO1lBQ1IsOERBQThEO1lBQzlEbWUsUUFBUUMsV0FBVyxHQUFHdk47WUFFdEIseUNBQXlDO1lBQ3pDNk0sK0JBQStCMXpDLFNBQVFrMkI7WUFDdkMwZCxxQ0FBcUM1ekM7WUFDckNzbEMscUJBQXFCdGxDO1lBQ3JCaW1DLHNCQUFzQmptQztZQUN0QjRrQyxpQkFBaUI1a0M7WUFDakJra0Msb0JBQW9CbGtDO1lBQ3BCdWtDLHFCQUFxQnZrQztZQUNyQmdtQywwQkFBMEJobUM7WUFDMUI4Z0MsaUJBQWlCOWdDO1lBQ2pCMG1DLGlCQUFpQjFtQztZQUNqQit3QyxvQkFBb0Ivd0M7WUFDcEJzeEMsaUNBQWlDdHhDO1lBQ2pDd3hDLG1CQUFtQnh4QyxTQUFRazJCO1lBQzNCa2MsdUJBQXVCcHlDO1lBQ3ZCd3pDLHVCQUF1Qnh6QyxTQUFRazJCO1lBQy9CO1FBQ0Y7WUFDRUYsUUFBUTtZQUNSO0lBQ0o7SUFDQSxPQUFPbWU7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELG1CQUFtQixHQUVuQkosZUFBZTtJQUNiL3pDLFFBQVEsS0FBa0IsR0FBY2tDLFlBQVlsQyxDQUFNQTtBQUM1RDtBQUVBLE1BQU1xMEMsdUJBQXVCO0FBQzdCLGlHQUFpRztBQUNqRyxNQUFNQywrQkFBK0I7QUFDckMscUVBQXFFO0FBQ3JFLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsT0FBTztBQUNiLE1BQU1DLHdCQUF3QjtJQUM1QkMsV0FBVztJQUNYQyxhQUFhSDtJQUNiSSxtQkFBbUI7SUFDbkJDLGtCQUFrQlA7QUFDcEI7QUFFQSxJQUFJUTtBQUNILFVBQVVBLGdCQUFnQjtJQUN6QkEsZ0JBQWdCLENBQUMsU0FBUyxHQUFHO0lBQzdCQSxnQkFBZ0IsQ0FBQyxpQkFBaUIsR0FBRztJQUNyQ0EsZ0JBQWdCLENBQUMsZUFBZSxHQUFHO0FBQ3JDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsSUFBSUM7QUFDSCxVQUFVQSxlQUFlO0lBQ3hCQSxlQUFlLENBQUMsZUFBZSxHQUFHO0FBQ3BDLEdBQUdBLG1CQUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7QUFDMUMsSUFBSUM7QUFDSCxVQUFVQSxlQUFlO0lBQ3hCQSxlQUFlLENBQUMscUNBQXFDLEdBQUc7SUFDeERBLGVBQWUsQ0FBQyxrQkFBa0IsR0FBRztBQUN2QyxHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNyQkEsWUFBWSxDQUFDLFFBQVEsR0FBRztBQUMxQixHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUVwQyxTQUFTQztJQUNQLE9BQU9DLGlDQUFpQ0M7QUFDMUM7QUFDQSxTQUFTQTtJQUNQLGFBQWE7SUFDYixPQUFPLE9BQU9wMUMsT0FBT3ExQyxxQkFBcUIsS0FBSztBQUNqRDtBQUNBLFNBQVNGO0lBQ1AsT0FBTyxPQUFPbjFDLE9BQU93OEIsWUFBWSxLQUFLLGVBQ3RDLGFBQWE7SUFDYixPQUFPeDhCLE9BQU93OEIsWUFBWSxDQUFDbDhCLFNBQVMsQ0FBQ2cxQyxvQkFBb0IsS0FBSztBQUNoRTtBQUNBLFNBQVNDLGFBQWFDLEtBQUs7SUFDekIsT0FBTyxVQUFVQTtBQUNuQjtBQUNBLFNBQVNDLFVBQVVDLFFBQVE7SUFDekIsSUFBSTVLLFlBQVlqcEMsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDbEZnQixNQUFNd3hDO0lBQ1I7SUFDQSxJQUFJc0IsUUFBUTl6QyxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNoRixPQUFPd3FCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDckMsMEVBQTBFO1FBQzFFLE9BQU91cEIsT0FBT0MsTUFBTSxDQUFDSixTQUFTLENBQUMsT0FBT0MsVUFBVTVLLFdBQVcsT0FBTzZLLFVBQVUsV0FBVztZQUFDO1lBQWM7U0FBWSxHQUFHO1lBQUM7WUFBVztTQUFVO0lBQzdJO0FBQ0Y7QUFDQSxTQUFTRyw0QkFBNEJ6SixRQUFRO0lBQzNDLE9BQU9oZ0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxJQUFJbGIsTUFBTSxJQUFJWTtRQUNkLE1BQU1na0MsY0FBYyxNQUFNSCxPQUFPQyxNQUFNLENBQUNKLFNBQVMsQ0FBQyxPQUFPdGtDLElBQUk4QixNQUFNLENBQUNvNUIsV0FBVztZQUM3RXhwQyxNQUFNO1FBQ1IsR0FBRyxPQUFPO1lBQUM7WUFBYztTQUFZO1FBQ3JDLE9BQU9rekM7SUFDVDtBQUNGO0FBQ0EsU0FBU0MsNEJBQTRCQyxZQUFZO0lBQy9DLE9BQU81cEIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxNQUFNMHBCLGNBQWMsTUFBTUgsT0FBT0MsTUFBTSxDQUFDSixTQUFTLENBQUMsT0FBT1EsY0FBYyxRQUFRLE9BQU87WUFBQztZQUFjO1NBQVk7UUFDakgsT0FBT0Y7SUFDVDtBQUNGO0FBQ0EsU0FBU0csZUFBZUMsYUFBYSxFQUFFQyxJQUFJO0lBQ3pDLE1BQU12a0MsY0FBYyxJQUFJRTtJQUN4QixNQUFNc2tDLGNBQWN4a0MsWUFBWW9CLE1BQU0sQ0FBQ21qQztJQUN2QyxPQUFRRDtRQUNOLEtBQUs7WUFDSCxPQUFPO2dCQUNMdHpDLE1BQU07Z0JBQ051ekMsTUFBTUM7Z0JBQ05DLE1BQU07Z0JBQ041d0MsTUFBTSxJQUFJdUssWUFBWTtZQUN4QjtRQUNGLEtBQUs7WUFDSDtnQkFDRSxPQUFPO29CQUNMcE4sTUFBTTtvQkFDTnV6QyxNQUFNQztvQkFDTkMsTUFBTTtvQkFDTkMsWUFBWTtnQkFDZDtZQUNGO1FBQ0Y7WUFDRSxNQUFNLElBQUl2dkMsTUFBTSxhQUFhOEQsTUFBTSxDQUFDcXJDLGVBQWU7SUFDdkQ7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNLLFdBQVdDLFFBQVEsRUFBRUwsSUFBSTtJQUNoQyxPQUFPL3BCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDckMsTUFBTXFxQixtQkFBbUJSLGVBQWVPLFNBQVMzTCxTQUFTLENBQUNqb0MsSUFBSSxFQUFFdXpDO1FBQ2pFLCtFQUErRTtRQUMvRSw4REFBOEQ7UUFDOUQsTUFBTU8sZ0JBQWdCLE1BQU1mLE9BQU9DLE1BQU0sQ0FBQ2UsU0FBUyxDQUFDRixrQkFBa0JELFVBQVU7WUFDOUU1ekMsTUFBTXd4QztZQUNOOXhDLFFBQVE7UUFDVixHQUFHLE9BQU87WUFBQztZQUFXO1NBQVU7UUFDaEMsT0FBTztZQUNMazBDO1lBQ0FFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0U7SUFDUCxPQUFPNzJDLE9BQU80MUMsTUFBTSxDQUFDa0IsZUFBZSxDQUFDLElBQUk3a0MsV0FBVztBQUN0RDtBQUNBOzs7Q0FHQyxHQUNELFNBQVM4a0MsUUFBUU4sUUFBUSxFQUFFTCxJQUFJO0lBQzdCLE9BQU8vcEIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxNQUFNcXFCLG1CQUFtQlIsZUFBZU8sU0FBUzNMLFNBQVMsQ0FBQ2pvQyxJQUFJLEVBQUV1ekM7UUFDakUsMkVBQTJFO1FBQzNFLE9BQU9SLE9BQU9DLE1BQU0sQ0FBQ21CLFVBQVUsQ0FBQ04sa0JBQWtCRCxVQUFVO0lBQzlEO0FBQ0Y7QUFDQSxTQUFTUSxvQkFBb0JDLFNBQVM7SUFDcEMsSUFBSyxJQUFJNTBDLElBQUksR0FBR0EsSUFBSTQwQyxVQUFVMzBDLE1BQU0sR0FBRyxHQUFHRCxJQUFLO1FBQzdDLElBQUk0MEMsU0FBUyxDQUFDNTBDLEVBQUUsSUFBSSxLQUFLNDBDLFNBQVMsQ0FBQzUwQyxJQUFJLEVBQUUsSUFBSSxLQUFLNDBDLFNBQVMsQ0FBQzUwQyxJQUFJLEVBQUUsSUFBSSxHQUFHLE9BQU87SUFDbEY7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTNjBDLFVBQVVoeEIsTUFBTTtJQUN2QixNQUFNaXhCLFVBQVUsRUFBRTtJQUNsQixJQUFJNzBDLFNBQVM0akIsT0FBTzVqQixNQUFNO0lBQzFCLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJNmpCLE9BQU81akIsTUFBTSxFQUFHO1FBQ2xDLDRFQUE0RTtRQUM1RSwyRUFBMkU7UUFDM0Usc0VBQXNFO1FBQ3RFLHNDQUFzQztRQUN0QyxJQUFJQSxTQUFTRCxLQUFLLEtBQUssQ0FBQzZqQixNQUFNLENBQUM3akIsRUFBRSxJQUFJLENBQUM2akIsTUFBTSxDQUFDN2pCLElBQUksRUFBRSxJQUFJNmpCLE1BQU0sQ0FBQzdqQixJQUFJLEVBQUUsSUFBSSxHQUFHO1lBQ3pFLGtCQUFrQjtZQUNsQjgwQyxRQUFRbnVDLElBQUksQ0FBQ2tkLE1BQU0sQ0FBQzdqQixJQUFJO1lBQ3hCODBDLFFBQVFudUMsSUFBSSxDQUFDa2QsTUFBTSxDQUFDN2pCLElBQUk7WUFDeEIsMkJBQTJCO1lBQzNCQTtRQUNGLE9BQU87WUFDTCxvQkFBb0I7WUFDcEI4MEMsUUFBUW51QyxJQUFJLENBQUNrZCxNQUFNLENBQUM3akIsSUFBSTtRQUMxQjtJQUNGO0lBQ0EsT0FBTyxJQUFJMlAsV0FBV21sQztBQUN4QjtBQUNBLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyxpQkFBaUI7QUFDdkIsU0FBU0MsVUFBVUMsT0FBTztJQUN4QixNQUFNSixVQUFVLEVBQUU7SUFDbEIsSUFBSUssc0JBQXNCO0lBQzFCLElBQUssSUFBSW4xQyxJQUFJLEdBQUdBLElBQUlrMUMsUUFBUWoxQyxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUN2QyxJQUFJcUwsT0FBTzZwQyxPQUFPLENBQUNsMUMsRUFBRTtRQUNyQixJQUFJcUwsUUFBUTJwQyxrQkFBa0JHLHVCQUF1QkosdUJBQXVCO1lBQzFFLGtCQUFrQjtZQUNsQkQsUUFBUW51QyxJQUFJLENBQUNxdUM7WUFDYkcsc0JBQXNCO1FBQ3hCO1FBQ0FMLFFBQVFudUMsSUFBSSxDQUFDMEU7UUFDYixJQUFJQSxRQUFRLEdBQUc7WUFDYixFQUFFOHBDO1FBQ0osT0FBTztZQUNMQSxzQkFBc0I7UUFDeEI7SUFDRjtJQUNBLE9BQU8sSUFBSXhsQyxXQUFXbWxDO0FBQ3hCO0FBRUE7O0NBRUMsR0FDRCxNQUFNTSx3QkFBd0JsbEIsY0FBYzdELFlBQVk7SUFDdEQ1aUIsYUFBYztRQUNaLElBQUloQyxVQUFVbEksVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixLQUFLO1FBQ0w7Ozs7O0tBS0MsR0FDRCxJQUFJLENBQUM4MUMsY0FBYyxHQUFHLENBQUNsQixVQUFVbUI7WUFDL0JueUMsY0FBY2hELEtBQUssQ0FBQyxnQ0FBZ0M7Z0JBQ2xEZzBDO2dCQUNBbUI7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSW5rQjtRQUN0QixJQUFJLENBQUMzcEIsT0FBTyxHQUFHMUssT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHb3JDLHdCQUF3QjFxQztRQUN2RSxJQUFJLENBQUMwbUIsRUFBRSxDQUFDcWtCLGlCQUFpQmdELFlBQVksRUFBRSxJQUFJLENBQUNILGNBQWM7SUFDNUQ7SUFDQTs7Ozs7R0FLQyxHQUNESSxtQkFBbUI3K0IsR0FBRyxFQUFFK04sbUJBQW1CLEVBQUUyd0IsUUFBUSxFQUFFO1FBQ3JELE1BQU1JLFVBQVU7WUFDZDkrQjtZQUNBK047WUFDQTJ3QjtRQUNGO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLENBQUN6bEMsR0FBRyxDQUFDLEdBQUd0SCxNQUFNLENBQUNtYyx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLFVBQVUsS0FBS25jLE1BQU0sQ0FBQzhzQyxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJQSxXQUFXLElBQUlJO1FBQ3JNLElBQUksQ0FBQ3hvQixJQUFJLENBQUNzbEIsaUJBQWlCbUQsTUFBTSxFQUFFRDtJQUNyQztJQUNBRSxVQUFVO1FBQ1IsT0FBTy80QyxNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUNOLFVBQVUsQ0FBQ3p2QyxNQUFNO0lBQzFDO0lBQ0Fnd0MsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDcnVDLE9BQU87SUFDckI7SUFDQXN1QyxXQUFXcHhCLG1CQUFtQixFQUFFMndCLFFBQVEsRUFBRTtRQUN4QyxJQUFJLENBQUNwb0IsSUFBSSxDQUFDc2xCLGlCQUFpQndELGNBQWMsRUFBRXJ4QixxQkFBcUIyd0I7SUFDbEU7QUFDRjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNVyxnQ0FBZ0NiO0lBQ3BDM3JDLGFBQWM7UUFDWixJQUFJaEMsVUFBVWxJLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsTUFBTTIyQyxPQUFPbjVDLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBR1UsVUFBVTtZQUNyRDJxQyxXQUFXO1lBQ1gsMEVBQTBFO1lBQzFFLHNFQUFzRTtZQUN0RSxnQ0FBZ0M7WUFDaENFLG1CQUFtQjtZQUNuQkMsa0JBQWtCLENBQUM7UUFDckI7UUFDQSxLQUFLLENBQUMyRDtJQUNSO0lBQ0E7Ozs7O0dBS0MsR0FDREMsT0FBT3YvQixHQUFHLEVBQUU7UUFDVixPQUFPbVQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNcXNCLGFBQWEsT0FBT3gvQixRQUFRLFdBQVcsTUFBTTQ4Qiw0QkFBNEI1OEIsT0FBTyxNQUFNODhCLDRCQUE0Qjk4QjtZQUN4SCxJQUFJLENBQUM2K0Isa0JBQWtCLENBQUNXO1FBQzFCO0lBQ0Y7QUFDRjtBQUVBLE1BQU1DLHFCQUFxQjN4QztJQUN6QitFLFlBQVl5MUIsSUFBSSxFQUFFejJCLE9BQU8sQ0FBRTtRQUN6QixLQUFLLENBQUNBLFdBQVc7UUFDakIsSUFBSSxDQUFDeTJCLElBQUksR0FBR0E7SUFDZDtBQUNGO0FBQ0EsTUFBTW9YLHdCQUF3QkQ7SUFDNUI1c0MsWUFBWWhCLE9BQU8sRUFBRTh0QyxNQUFNLEVBQUVDLE1BQU0sQ0FBRTtRQUNuQyxLQUFLLENBQUMsR0FBRy90QztRQUNULElBQUksQ0FBQyt0QyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO0lBQ2hCO0FBQ0Y7QUFDQSxNQUFNRSwrQkFBK0JKO0lBQ25DNXNDLFlBQVloQixPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDLElBQUlBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVU7SUFDL0Q7QUFDRjtBQUNBLE1BQU1pdUMsMEJBQTBCTDtJQUM5QjVzQyxZQUFZaEIsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxJQUFJQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVO0lBQy9EO0FBQ0Y7QUFDQSxNQUFNa3VDLDBCQUEwQk47SUFDOUI1c0MsWUFBWWhCLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUMsSUFBSUEsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVTtJQUMvRDtBQUNGO0FBQ0EsTUFBTW11QyxrQ0FBa0NQO0lBQ3RDNXNDLFlBQVloQixPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDLElBQUlBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVU7SUFDL0Q7QUFDRjtBQUNBLE1BQU1vdUMseUJBQXlCUjtJQUM3QjVzQyxZQUFZaEIsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxJQUFJQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVO0lBQy9EO0FBQ0Y7QUFDQSxNQUFNcXVDLHlCQUF5QlQ7SUFDN0I1c0MsWUFBWWhCLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUMsSUFBSUEsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVTtJQUMvRDtBQUNGO0FBQ0EsSUFBSXN1QztBQUNILFVBQVVBLGtCQUFrQjtJQUMzQiw0QkFBNEI7SUFDNUJBLGtCQUFrQixDQUFDLG1CQUFtQixHQUFHO0lBQ3pDLDBCQUEwQjtJQUMxQkEsa0JBQWtCLENBQUMsV0FBVyxHQUFHO0lBQ2pDLHdGQUF3RjtJQUN4RkEsa0JBQWtCLENBQUMsY0FBYyxHQUFHO0lBQ3BDQSxrQkFBa0IsQ0FBQyxRQUFRLEdBQUc7QUFDaEMsR0FBR0Esc0JBQXVCQSxDQUFBQSxxQkFBcUIsQ0FBQztBQUMvQyxVQUFVQSxrQkFBa0I7SUFDM0IsU0FBU0MsV0FBVzNyQixLQUFLO1FBQ3ZCLElBQUlBLFNBQVMsVUFBVUEsT0FBTztZQUM1QixJQUFJQSxNQUFNOXFCLElBQUksS0FBSyxtQkFBbUI4cUIsTUFBTTlxQixJQUFJLEtBQUssd0JBQXdCO2dCQUMzRSxPQUFPdzJDLG1CQUFtQkUsUUFBUTtZQUNwQztZQUNBLElBQUk1ckIsTUFBTTlxQixJQUFJLEtBQUsscUJBQXFCOHFCLE1BQU05cUIsSUFBSSxLQUFLLHlCQUF5QjtnQkFDOUUsT0FBT3cyQyxtQkFBbUJHLGdCQUFnQjtZQUM1QztZQUNBLElBQUk3ckIsTUFBTTlxQixJQUFJLEtBQUssc0JBQXNCOHFCLE1BQU05cUIsSUFBSSxLQUFLLG1CQUFtQjtnQkFDekUsT0FBT3cyQyxtQkFBbUJJLFdBQVc7WUFDdkM7WUFDQSxPQUFPSixtQkFBbUJLLEtBQUs7UUFDakM7SUFDRjtJQUNBTCxtQkFBbUJDLFVBQVUsR0FBR0E7QUFDbEMsR0FBR0Qsc0JBQXVCQSxDQUFBQSxxQkFBcUIsQ0FBQztBQUVoRDs7Ozs7Ozs7Q0FRQyxHQUNELElBQUlNO0FBQ0gsVUFBVUEsU0FBUztJQUNsQjs7R0FFQyxHQUNEQSxTQUFTLENBQUMsWUFBWSxHQUFHO0lBQ3pCOzs7R0FHQyxHQUNEQSxTQUFTLENBQUMsZUFBZSxHQUFHO0lBQzVCOztHQUVDLEdBQ0RBLFNBQVMsQ0FBQyxjQUFjLEdBQUc7SUFDM0I7OztHQUdDLEdBQ0RBLFNBQVMsQ0FBQyxlQUFlLEdBQUc7SUFDNUI7Ozs7R0FJQyxHQUNEQSxTQUFTLENBQUMseUJBQXlCLEdBQUc7SUFDdEM7O0dBRUMsR0FDREEsU0FBUyxDQUFDLGVBQWUsR0FBRztJQUM1Qjs7R0FFQyxHQUNEQSxTQUFTLENBQUMsc0JBQXNCLEdBQUc7SUFDbkM7Ozs7OztHQU1DLEdBQ0RBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRztJQUNwQzs7Ozs7R0FLQyxHQUNEQSxTQUFTLENBQUMsMEJBQTBCLEdBQUc7SUFDdkM7Ozs7Ozs7O0dBUUMsR0FDREEsU0FBUyxDQUFDLGlCQUFpQixHQUFHO0lBQzlCOzs7OztHQUtDLEdBQ0RBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRztJQUMvQjs7OztHQUlDLEdBQ0RBLFNBQVMsQ0FBQywwQkFBMEIsR0FBRztJQUN2Qzs7OztHQUlDLEdBQ0RBLFNBQVMsQ0FBQyxtQkFBbUIsR0FBRztJQUNoQzs7Ozs7R0FLQyxHQUNEQSxTQUFTLENBQUMsb0JBQW9CLEdBQUc7SUFDakM7Ozs7R0FJQyxHQUNEQSxTQUFTLENBQUMsYUFBYSxHQUFHO0lBQzFCOzs7O0dBSUMsR0FDREEsU0FBUyxDQUFDLGVBQWUsR0FBRztJQUM1Qjs7Ozs7R0FLQyxHQUNEQSxTQUFTLENBQUMsc0JBQXNCLEdBQUc7SUFDbkM7Ozs7Ozs7O0dBUUMsR0FDREEsU0FBUyxDQUFDLHdCQUF3QixHQUFHO0lBQ3JDOzs7OztHQUtDLEdBQ0RBLFNBQVMsQ0FBQyw0QkFBNEIsR0FBRztJQUN6Qzs7Ozs7OztHQU9DLEdBQ0RBLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRztJQUNyQzs7Ozs7Ozs7R0FRQyxHQUNEQSxTQUFTLENBQUMsNkJBQTZCLEdBQUc7SUFDMUM7Ozs7O0dBS0MsR0FDREEsU0FBUyxDQUFDLHlCQUF5QixHQUFHO0lBQ3RDOzs7Ozs7O0dBT0MsR0FDREEsU0FBUyxDQUFDLHNCQUFzQixHQUFHO0lBQ25DOzs7Ozs7R0FNQyxHQUNEQSxTQUFTLENBQUMsZUFBZSxHQUFHO0lBQzVCOzs7Ozs7R0FNQyxHQUNEQSxTQUFTLENBQUMsMkJBQTJCLEdBQUc7SUFDeEM7Ozs7Ozs7OztHQVNDLEdBQ0RBLFNBQVMsQ0FBQywwQkFBMEIsR0FBRztJQUN2Qzs7Ozs7Ozs7O0dBU0MsR0FDREEsU0FBUyxDQUFDLHFDQUFxQyxHQUFHO0lBQ2xEOzs7Ozs7O0dBT0MsR0FDREEsU0FBUyxDQUFDLGlDQUFpQyxHQUFHO0lBQzlDOzs7O0dBSUMsR0FDREEsU0FBUyxDQUFDLDZCQUE2QixHQUFHO0lBQzFDOzs7O0dBSUMsR0FDREEsU0FBUyxDQUFDLDZCQUE2QixHQUFHO0lBQzFDOzs7Ozs7OztHQVFDLEdBQ0RBLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRztJQUNqQzs7O0dBR0MsR0FDREEsU0FBUyxDQUFDLGdDQUFnQyxHQUFHO0lBQzdDOztHQUVDLEdBQ0RBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRztJQUMvQjs7O0dBR0MsR0FDREEsU0FBUyxDQUFDLHlCQUF5QixHQUFHO0lBQ3RDQSxTQUFTLENBQUMscUNBQXFDLEdBQUc7SUFDbERBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRztJQUMvQjs7O0dBR0MsR0FDREEsU0FBUyxDQUFDLHdCQUF3QixHQUFHO0lBQ3JDOzs7R0FHQyxHQUNEQSxTQUFTLENBQUMsc0JBQXNCLEdBQUc7QUFDckMsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLElBQUlDO0FBQ0gsVUFBVUEsZ0JBQWdCO0lBQ3pCOzs7Ozs7OztHQVFDLEdBQ0RBLGdCQUFnQixDQUFDLGlCQUFpQixHQUFHO0lBQ3JDOzs7OztHQUtDLEdBQ0RBLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHO0lBQ3RDOzs7O0dBSUMsR0FDREEsZ0JBQWdCLENBQUMsMEJBQTBCLEdBQUc7SUFDOUM7Ozs7R0FJQyxHQUNEQSxnQkFBZ0IsQ0FBQyxtQkFBbUIsR0FBRztJQUN2Qzs7Ozs7R0FLQyxHQUNEQSxnQkFBZ0IsQ0FBQyxvQkFBb0IsR0FBRztJQUN4Qzs7OztHQUlDLEdBQ0RBLGdCQUFnQixDQUFDLGFBQWEsR0FBRztJQUNqQzs7OztHQUlDLEdBQ0RBLGdCQUFnQixDQUFDLGVBQWUsR0FBRztJQUNuQzs7Ozs7R0FLQyxHQUNEQSxnQkFBZ0IsQ0FBQyxzQkFBc0IsR0FBRztJQUMxQzs7Ozs7Ozs7R0FRQyxHQUNEQSxnQkFBZ0IsQ0FBQyx3QkFBd0IsR0FBRztJQUM1Qzs7Ozs7Ozs7O0dBU0MsR0FDREEsZ0JBQWdCLENBQUMsNkJBQTZCLEdBQUc7SUFDakQ7Ozs7O0dBS0MsR0FDREEsZ0JBQWdCLENBQUMseUJBQXlCLEdBQUc7SUFDN0M7Ozs7OztHQU1DLEdBQ0RBLGdCQUFnQixDQUFDLGVBQWUsR0FBRztJQUNuQzs7OztHQUlDLEdBQ0RBLGdCQUFnQixDQUFDLG9CQUFvQixHQUFHO0lBQ3hDOzs7Ozs7R0FNQyxHQUNEQSxnQkFBZ0IsQ0FBQywyQkFBMkIsR0FBRztJQUMvQzs7Ozs7Ozs7R0FRQyxHQUNEQSxnQkFBZ0IsQ0FBQywwQkFBMEIsR0FBRztJQUM5Qzs7Ozs7Ozs7R0FRQyxHQUNEQSxnQkFBZ0IsQ0FBQyxxQ0FBcUMsR0FBRztJQUN6RDs7O0dBR0MsR0FDREEsZ0JBQWdCLENBQUMsaUNBQWlDLEdBQUc7SUFDckQsaUNBQWlDO0lBQ2pDLGNBQWMsR0FDZEEsZ0JBQWdCLENBQUMsb0JBQW9CLEdBQUc7SUFDeEMsaUNBQWlDO0lBQ2pDLGNBQWMsR0FDZEEsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUc7SUFDMUM7OztHQUdDLEdBQ0RBLGdCQUFnQixDQUFDLGdDQUFnQyxHQUFHO0lBQ3BELGNBQWMsR0FDZEEsZ0JBQWdCLENBQUMsZUFBZSxHQUFHO0FBQ3JDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsY0FBYyxHQUNkLElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNwQkEsV0FBVyxDQUFDLG9CQUFvQixHQUFHO0lBQ25DQSxXQUFXLENBQUMsWUFBWSxHQUFHO0lBQzNCQSxXQUFXLENBQUMsZUFBZSxHQUFHO0lBQzlCQSxXQUFXLENBQUMsV0FBVyxHQUFHO0lBQzFCQSxXQUFXLENBQUMsVUFBVSxHQUFHO0lBQ3pCQSxXQUFXLENBQUMsYUFBYSxHQUFHO0lBQzVCQSxXQUFXLENBQUMsWUFBWSxHQUFHO0lBQzNCQSxXQUFXLENBQUMsZ0JBQWdCLEdBQUc7SUFDL0JBLFdBQVcsQ0FBQyxrQkFBa0IsR0FBRztJQUNqQ0EsV0FBVyxDQUFDLFVBQVUsR0FBRztJQUN6QkEsV0FBVyxDQUFDLGtCQUFrQixHQUFHO0lBQ2pDQSxXQUFXLENBQUMsdUJBQXVCLEdBQUc7SUFDdENBLFdBQVcsQ0FBQyxxQkFBcUIsR0FBRztJQUNwQ0EsV0FBVyxDQUFDLG9CQUFvQixHQUFHO0lBQ25DQSxXQUFXLENBQUMsd0JBQXdCLEdBQUc7SUFDdkNBLFdBQVcsQ0FBQyxvQkFBb0IsR0FBRztJQUNuQ0EsV0FBVyxDQUFDLGFBQWEsR0FBRztJQUM1QkEsV0FBVyxDQUFDLGtCQUFrQixHQUFHO0lBQ2pDQSxXQUFXLENBQUMscUJBQXFCLEdBQUc7SUFDcENBLFdBQVcsQ0FBQywwQkFBMEIsR0FBRztJQUN6Q0EsV0FBVyxDQUFDLG9CQUFvQixHQUFHO0lBQ25DQSxXQUFXLENBQUMsK0JBQStCLEdBQUc7SUFDOUNBLFdBQVcsQ0FBQyxhQUFhLEdBQUc7SUFDNUJBLFdBQVcsQ0FBQywwQkFBMEIsR0FBRztJQUN6Q0EsV0FBVyxDQUFDLHdCQUF3QixHQUFHO0FBQ3pDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsSUFBSUM7QUFDSCxVQUFVQSxVQUFVO0lBQ25CQSxVQUFVLENBQUMsVUFBVSxHQUFHO0lBQ3hCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0lBQ3RCQSxVQUFVLENBQUMsVUFBVSxHQUFHO0lBQ3hCOztHQUVDLEdBQ0RBLFVBQVUsQ0FBQyxZQUFZLEdBQUc7SUFDMUJBLFVBQVUsQ0FBQyxRQUFRLEdBQUc7SUFDdEJBLFVBQVUsQ0FBQyxhQUFhLEdBQUc7SUFDM0JBLFVBQVUsQ0FBQyxlQUFlLEdBQUc7SUFDN0IsY0FBYyxHQUNkQSxVQUFVLENBQUMsaUJBQWlCLEdBQUc7SUFDL0IsY0FBYyxHQUNkQSxVQUFVLENBQUMscUJBQXFCLEdBQUc7SUFDbkMsY0FBYyxHQUNkQSxVQUFVLENBQUMsdUJBQXVCLEdBQUc7SUFDckMsY0FBYyxHQUNkQSxVQUFVLENBQUMsc0JBQXNCLEdBQUc7SUFDcEM7OztHQUdDLEdBQ0RBLFVBQVUsQ0FBQyx1QkFBdUIsR0FBRztJQUNyQyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRztJQUNsQyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyx5QkFBeUIsR0FBRztJQUN2QyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyx1QkFBdUIsR0FBRztJQUNyQyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyxzQkFBc0IsR0FBRztJQUNwQyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyxrQkFBa0IsR0FBRztJQUNoQyxjQUFjLEdBQ2RBLFVBQVUsQ0FBQyxrQkFBa0IsR0FBRztJQUNoQzs7O0dBR0MsR0FDREEsVUFBVSxDQUFDLGlCQUFpQixHQUFHO0lBQy9COzs7R0FHQyxHQUNEQSxVQUFVLENBQUMsa0JBQWtCLEdBQUc7SUFDaEM7OztHQUdDLEdBQ0RBLFVBQVUsQ0FBQyxnQ0FBZ0MsR0FBRztJQUM5Qzs7R0FFQyxHQUNEQSxVQUFVLENBQUMsNEJBQTRCLEdBQUc7SUFDMUM7O0dBRUMsR0FDREEsVUFBVSxDQUFDLHFCQUFxQixHQUFHO0FBQ3JDLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUVoQyxTQUFTcjlCLEVBQUVBLENBQUMsRUFBRXZkLENBQUMsRUFBRUgsQ0FBQztJQUNoQixJQUFJdUQsR0FBRzJGLEdBQUc4VztJQUNWLEtBQUssTUFBTTdmLEtBQU1BLENBQUFBLElBQUksRUFBQyxHQUFJLEtBQUssTUFBTUgsS0FBTUEsQ0FBQUEsSUFBSSxDQUFDO0lBQ2hELElBQUkwTixJQUFJLFFBQVNuSyxDQUFBQSxJQUFJdkQsRUFBRWc3QyxXQUFXLEtBQUt6M0MsR0FDckMwM0MsSUFBSSxRQUFTL3hDLENBQUFBLElBQUlsSixFQUFFazdDLFFBQVEsS0FBS2h5QyxHQUNoQ3lQLElBQUkzWSxFQUFFbTdDLE9BQU8sRUFDYjN4QyxJQUFJMFksS0FBS1EsR0FBRyxJQUNaMDRCLElBQUksRUFBRTtJQUNSLFNBQVN4aUM7UUFDUCxJQUFJLEtBQUssTUFBTUQsR0FBRztZQUNoQixJQUFJK0UsSUFBSXdFLEtBQUtRLEdBQUcsS0FBS2xaO1lBQ3JCLElBQUlrVSxJQUFJdmQsS0FBS3dZLEdBQUcsT0FBT0EsSUFBSStFO1FBQzdCO1FBQ0EsT0FBT3ZkO0lBQ1Q7SUFDQSxJQUFJTSxJQUFJO1FBQ04sSUFBSU4sSUFBSSxFQUFFLENBQUM4RSxLQUFLLENBQUN4RCxJQUFJLENBQUNxQixZQUNwQjlDLElBQUksSUFBSTtRQUNWLE9BQU8sSUFBSTZ0QixRQUFRLFNBQVV0cUIsQ0FBQyxFQUFFMkYsQ0FBQztZQUMvQixJQUFJeVAsSUFBSWpMLEtBQUssS0FBSyxNQUFNc1M7WUFDeEIsSUFBSSxLQUFLLE1BQU1BLEtBQUtxN0IsYUFBYXI3QixJQUFJQSxJQUFJczdCLFdBQVc7Z0JBQ2xELElBQUl0N0IsSUFBSSxLQUFLLEdBQUd4VyxJQUFJMFksS0FBS1EsR0FBRyxJQUFJLENBQUNoVixHQUFHO29CQUNsQyxJQUFJbkssSUFBSW1hLEVBQUU3YSxLQUFLLENBQUM3QyxHQUFHRztvQkFDbkI4NkMsS0FBS0EsRUFBRTEzQyxJQUFJNjNDLEVBQUVsN0MsT0FBTyxDQUFDLFNBQVV3ZCxDQUFDO3dCQUM5QixPQUFPLENBQUMsR0FBR0EsRUFBRWtRLE9BQU8sRUFBRXJxQjtvQkFDeEIsSUFBSTYzQyxJQUFJLEVBQUU7Z0JBQ1o7WUFDRixHQUFHeGlDLE1BQU1ELEdBQUc7Z0JBQ1YsSUFBSWxZLElBQUlpZCxFQUFFN2EsS0FBSyxDQUFDN0MsR0FBR0c7Z0JBQ25CLE9BQU84NkMsS0FBS0EsRUFBRXg2QyxJQUFJOEMsRUFBRTlDO1lBQ3RCO1lBQ0EyNkMsRUFBRWx4QyxJQUFJLENBQUM7Z0JBQ0wwakIsU0FBU3JxQjtnQkFDVHVxQixRQUFRNWtCO1lBQ1Y7UUFDRjtJQUNGO0lBQ0EsT0FBT3pJLEVBQUU4NkMsTUFBTSxHQUFHLFNBQVU3OUIsQ0FBQztRQUMzQixLQUFLLE1BQU1zQyxLQUFLcTdCLGFBQWFyN0IsSUFBSW83QixFQUFFbDdDLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ3BELE9BQU8sQ0FBQyxHQUFHQSxFQUFFMnRCLE1BQU0sRUFBRXBRO1FBQ3ZCLElBQUkwOUIsSUFBSSxFQUFFO0lBQ1osR0FBRzM2QztBQUNMO0FBRUEsdUdBQXVHO0FBQ3ZHLDhFQUE4RTtBQUM5RSxNQUFNKzZDLDBCQUEwQjtBQUNoQyxJQUFJcmtCO0FBQ0o7O0NBRUMsR0FDRCxTQUFTc2tCLFdBQVdwNUMsU0FBUztJQUMzQixJQUFJcTVDLFFBQVE1NEMsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDaEYsSUFBSSxPQUFPVCxjQUFjLGVBQWUsT0FBT0YsY0FBYyxhQUFhO1FBQ3hFO0lBQ0Y7SUFDQSxNQUFNdzVDLEtBQUssQ0FBQ3Q1QyxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJQSxZQUFZRixVQUFVRSxTQUFTLEVBQUUyVixXQUFXO0lBQ3JHLElBQUltZixtQkFBbUJoMEIsYUFBYXU0QyxPQUFPO1FBQ3pDLE1BQU1yeUIsVUFBVXV5QixhQUFhNWlDLElBQUksQ0FBQ2pTLENBQUFBO1lBQ2hDLElBQUksRUFDRjNFLElBQUksRUFDTCxHQUFHMkU7WUFDSixPQUFPM0UsS0FBS0EsSUFBSSxDQUFDdTVDO1FBQ25CO1FBQ0F4a0IsaUJBQWlCOU4sWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF3eUIsUUFBUSxDQUFDRjtJQUN0RjtJQUNBLE9BQU94a0I7QUFDVDtBQUNBLE1BQU15a0IsZUFBZTtJQUFDO1FBQ3BCeDVDLE1BQU07UUFDTnk1QyxVQUFTRixFQUFFO1lBQ1QsTUFBTXR5QixVQUFVO2dCQUNkdmxCLE1BQU07Z0JBQ04raEIsU0FBU2kyQixTQUFTLHFEQUFxREg7Z0JBQ3ZFenlCLElBQUl5eUIsR0FBRzNqQyxXQUFXLEdBQUcrZ0IsUUFBUSxDQUFDLFdBQVcsUUFBUTUxQjtZQUNuRDtZQUNBLE9BQU9rbUI7UUFDVDtJQUNGO0lBQUc7UUFDRGpuQixNQUFNO1FBQ055NUMsVUFBU0YsRUFBRTtZQUNULE1BQU10eUIsVUFBVTtnQkFDZHZsQixNQUFNO2dCQUNOK2hCLFNBQVNpMkIsU0FBUyxxREFBcURIO2dCQUN2RXp5QixJQUFJeXlCLEdBQUczakMsV0FBVyxHQUFHK2dCLFFBQVEsQ0FBQyxXQUFXLFFBQVE1MUI7WUFDbkQ7WUFDQSxPQUFPa21CO1FBQ1Q7SUFDRjtJQUFHLFVBQVUsR0FDYjtRQUNFam5CLE1BQU07UUFDTnk1QyxVQUFTRixFQUFFO1lBQ1QsTUFBTXR5QixVQUFVO2dCQUNkdmxCLE1BQU07Z0JBQ04raEIsU0FBU2kyQixTQUFTTix5QkFBeUJHO2dCQUMzQ3p5QixJQUFJeXlCLEdBQUc1aUIsUUFBUSxDQUFDLGFBQWEsUUFBUTtZQUN2QztZQUNBLE9BQU8xUDtRQUNUO0lBQ0Y7Q0FBRTtBQUNGLFNBQVN5eUIsU0FBU0MsR0FBRyxFQUFFSixFQUFFO0lBQ3ZCLElBQUlybEIsS0FBS3h6QixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUM3RSxNQUFNa2YsUUFBUTI1QixHQUFHMzVCLEtBQUssQ0FBQys1QjtJQUN2QixPQUFPLzVCLFNBQVNBLE1BQU14ZSxNQUFNLElBQUk4eUIsTUFBTXRVLEtBQUssQ0FBQ3NVLEdBQUcsSUFBSTtBQUNyRDtBQUVBLElBQUkwbEIsWUFBWTtBQUVoQixNQUFNbjJCLFVBQVVtMkI7QUFDaEIsTUFBTUMsa0JBQWtCO0FBRXhCOzs7O0NBSUMsR0FDRCxNQUFNQztBQUFnQjtBQUN0Qiw4REFBOEQ7QUFDOURBLGVBQWVaLFVBQVUsR0FBRztJQUMxQixPQUFPQSxjQUFjeDRDO0FBQ3ZCO0FBQ0EsOERBQThEO0FBQzlEbzVDLGVBQWVDLFdBQVcsR0FBRztJQUMzQixPQUFPQSxlQUFlcjVDO0FBQ3hCO0FBQ0FvNUMsZUFBZWIsWUFBWSxHQUFHO0lBQzVCLE9BQU9BLGdCQUFnQnY0QztBQUN6QjtBQUNBbzVDLGVBQWVFLGFBQWEsR0FBRztJQUM3QixPQUFPQSxpQkFBaUJ0NUM7QUFDMUI7QUFFQSxNQUFNdTVDO0lBQ0pydkMsWUFBWTBaLEtBQUssRUFBRUMsTUFBTSxFQUFFMG9CLFVBQVUsRUFBRWxMLFlBQVksRUFBRTZFLFFBQVEsQ0FBRTtRQUM3RCxJQUFJLENBQUN0aUIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzIxQixRQUFRLEdBQUc7WUFDZGpOO1lBQ0FsTDtZQUNBNkU7UUFDRjtJQUNGO0lBQ0EsSUFBSXVULGFBQWE7UUFDZixPQUFPO1lBQ0w3MUIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CaUYsV0FBVyxJQUFJLENBQUMwd0IsUUFBUSxDQUFDblksWUFBWTtZQUNyQ3FZLGFBQWEsSUFBSSxDQUFDOTFCLEtBQUssR0FBRyxJQUFJLENBQUNDLE1BQU07UUFDdkM7SUFDRjtBQUNGO0FBQ0EsTUFBTTgxQixlQUFlO0lBQUM7SUFBTztDQUFPO0FBQ3BDLE1BQU1DLGNBQWM7SUFBQztJQUFPO0lBQVE7SUFBTztDQUFNO0FBQ2pELFNBQVNDLGNBQWMzUyxLQUFLO0lBQzFCLE9BQU8sQ0FBQyxDQUFDeVMsYUFBYXpqQyxJQUFJLENBQUM0akMsQ0FBQUEsU0FBVUEsV0FBVzVTO0FBQ2xEO0FBQ0EsSUFBSTZTO0FBQ0gsVUFBVUEsWUFBWTtJQUNyQkEsYUFBYUMsU0FBUyxHQUFHO1FBQ3ZCek4sWUFBWTtJQUNkO0lBQ0F3TixhQUFhRSxNQUFNLEdBQUc7UUFDcEIxTixZQUFZO0lBQ2Q7SUFDQXdOLGFBQWFHLEtBQUssR0FBRztRQUNuQjNOLFlBQVk7SUFDZDtJQUNBd04sYUFBYUksV0FBVyxHQUFHO1FBQ3pCNU4sWUFBWTtJQUNkO0lBQ0F3TixhQUFhSyxnQkFBZ0IsR0FBRztRQUM5QjdOLFlBQVk7SUFDZDtJQUNBd04sYUFBYU0sc0JBQXNCLEdBQUc7UUFDcEM5TixZQUFZO0lBQ2Q7QUFDRixHQUFHd04sZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEM7O0NBRUMsR0FDRCxNQUFNTyxlQUFlO0lBQ25CQyxLQUFLLElBQUloQixZQUFZLEtBQUssSUFBSSxPQUFPO0lBQ3JDaUIsTUFBTSxJQUFJakIsWUFBWSxLQUFLLEtBQUssUUFBUTtJQUN4Q2tCLE1BQU0sSUFBSWxCLFlBQVksS0FBSyxLQUFLLFFBQVE7SUFDeENtQixNQUFNLElBQUluQixZQUFZLEtBQUssS0FBSyxRQUFRO0lBQ3hDb0IsTUFBTSxJQUFJcEIsWUFBWSxLQUFLLEtBQUssUUFBUTtJQUN4Q3FCLE1BQU0sSUFBSXJCLFlBQVksTUFBTSxLQUFLLFNBQVM7SUFDMUNzQixPQUFPLElBQUl0QixZQUFZLE1BQU0sTUFBTSxTQUFTO0lBQzVDdUIsT0FBTyxJQUFJdkIsWUFBWSxNQUFNLE1BQU0sU0FBUztJQUM1Q3dCLE9BQU8sSUFBSXhCLFlBQVksTUFBTSxNQUFNLFNBQVM7QUFDOUM7QUFDQTs7Q0FFQyxHQUNELE1BQU15QixpQkFBaUI7SUFDckJDLE1BQU0sSUFBSTFCLFlBQVksS0FBSyxLQUFLLE9BQU87SUFDdkNpQixNQUFNLElBQUlqQixZQUFZLEtBQUssS0FBSyxRQUFRO0lBQ3hDMkIsTUFBTSxJQUFJM0IsWUFBWSxLQUFLLEtBQUssUUFBUTtJQUN4Q21CLE1BQU0sSUFBSW5CLFlBQVksS0FBSyxLQUFLLFFBQVE7SUFDeEM0QixNQUFNLElBQUk1QixZQUFZLEtBQUssS0FBSyxRQUFRO0lBQ3hDb0IsTUFBTSxJQUFJcEIsWUFBWSxLQUFLLEtBQUssUUFBUTtJQUN4Q3FCLE1BQU0sSUFBSXJCLFlBQVksS0FBSyxLQUFLLFNBQVM7SUFDekNzQixPQUFPLElBQUl0QixZQUFZLE1BQU0sTUFBTSxTQUFTO0lBQzVDdUIsT0FBTyxJQUFJdkIsWUFBWSxNQUFNLE1BQU0sU0FBUztBQUM5QztBQUNBLE1BQU02QixxQkFBcUI7SUFDekJDLFVBQVUsSUFBSTlCLFlBQVksS0FBSyxLQUFLLFFBQVEsR0FBRztJQUMvQytCLFdBQVcsSUFBSS9CLFlBQVksS0FBSyxLQUFLLFFBQVEsSUFBSTtJQUNqRGdDLFVBQVUsSUFBSWhDLFlBQVksTUFBTSxLQUFLLFFBQVEsR0FBRztJQUNoRGlDLFdBQVcsSUFBSWpDLFlBQVksTUFBTSxLQUFLLFNBQVMsSUFBSTtJQUNuRGtDLFdBQVcsSUFBSWxDLFlBQVksTUFBTSxLQUFLLFNBQVMsSUFBSTtJQUNuRG1DLFlBQVksSUFBSW5DLFlBQVksTUFBTSxNQUFNLFNBQVMsSUFBSTtJQUNyRG9DLFlBQVksSUFBSXBDLFlBQVksTUFBTSxNQUFNLFNBQVMsSUFBSTtJQUNyRCx3Q0FBd0M7SUFDeENxQyxVQUFVLElBQUlyQyxZQUFZLEdBQUcsR0FBRyxTQUFTLElBQUk7QUFDL0M7QUFFQSwrQkFBK0I7QUFDL0IsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixpREFBaUQ7QUFDakQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakM7O0NBRUMsR0FDRCxJQUFJc0M7QUFDSCxVQUFVQSxZQUFZO0lBQ3JCOztHQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDOUM7O0dBRUMsR0FDREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNqRCxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQyxnRUFBZ0U7QUFDaEV0OUIsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ3cxQyxjQUFjLHdCQUF3QjtJQUFDO1FBQzdEbDFDLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsSUFBSTg2QztBQUNILFVBQVVBLFdBQVc7SUFDcEI7O0dBRUMsR0FDREEsV0FBVyxDQUFDQSxXQUFXLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUN6Qzs7R0FFQyxHQUNEQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQzNDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsK0RBQStEO0FBQy9EdjlCLE9BQU96VyxJQUFJLENBQUN6QixXQUFXLENBQUN5MUMsYUFBYSx1QkFBdUI7SUFBQztRQUMzRG4xQyxJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7SUFBRztRQUNEMkYsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0NBQUU7QUFDRjs7Q0FFQyxHQUNELElBQUkrNkM7QUFDSCxVQUFVQSxpQkFBaUI7SUFDMUI7O0dBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDbEQ7O0dBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDbEQ7O0dBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7QUFDcEQsR0FBR0EscUJBQXNCQSxDQUFBQSxvQkFBb0IsQ0FBQztBQUM5QyxxRUFBcUU7QUFDckV4OUIsT0FBT3pXLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQzAxQyxtQkFBbUIsNkJBQTZCO0lBQUM7UUFDdkVwMUMsSUFBSTtRQUNKM0YsTUFBTTtJQUNSO0lBQUc7UUFDRDJGLElBQUk7UUFDSjNGLE1BQU07SUFDUjtJQUFHO1FBQ0QyRixJQUFJO1FBQ0ozRixNQUFNO0lBQ1I7Q0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTWc3QyxzQkFBc0J2MEM7SUFDMUJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDckIsT0FBTyxHQUFHO1lBQ2JvTixNQUFNalc7UUFDUjtRQUNBa2UsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTh6QyxnQkFBZ0JoMEMsVUFBVSxDQUFDQyxPQUFPQztJQUMvQztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTh6QyxnQkFBZ0J0ekMsUUFBUSxDQUFDQyxXQUFXVDtJQUNqRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTh6QyxnQkFBZ0JuekMsY0FBYyxDQUFDQyxZQUFZWjtJQUN4RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDczBDLGVBQWVweEMsR0FBR0M7SUFDOUM7QUFDRjtBQUNBbXhDLGNBQWNuMEMsT0FBTyxHQUFHMFc7QUFDeEJ5OUIsY0FBYzExQyxRQUFRLEdBQUc7QUFDekIwMUMsY0FBYzV4QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNyRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3dsQztZQUNINWxDLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUd3bEM7WUFDSDVsQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHeWxDO1lBQ0g3bEMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzBsQztZQUNIOWxDLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcybEM7WUFDSC9sQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHNGxDO1lBQ0hobUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzZsQztZQUNIam1DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4bEM7WUFDSGxtQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHK2xDO1lBQ0hubUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2dtQztZQUNIcG1DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdpbUM7WUFDSHJtQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHa21DO1lBQ0h0bUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtZQUN6QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR21tQztZQUNIdm1DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdvbUM7WUFDSHhtQyxPQUFPO1FBQ1Q7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXltQyx1QkFBdUJyMUM7SUFDM0J5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDckIsT0FBTyxHQUFHO1lBQ2JvTixNQUFNalc7UUFDUjtRQUNBa2UsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTQwQyxpQkFBaUI5MEMsVUFBVSxDQUFDQyxPQUFPQztJQUNoRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTQwQyxpQkFBaUJwMEMsUUFBUSxDQUFDQyxXQUFXVDtJQUNsRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTQwQyxpQkFBaUJqMEMsY0FBYyxDQUFDQyxZQUFZWjtJQUN6RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDbzFDLGdCQUFnQmx5QyxHQUFHQztJQUMvQztBQUNGO0FBQ0FpeUMsZUFBZWoxQyxPQUFPLEdBQUcwVztBQUN6QnUrQixlQUFleDJDLFFBQVEsR0FBRztBQUMxQncyQyxlQUFlMXlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3REaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHc21DO1lBQ0gxbUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3dsQztZQUNINWxDLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUd3bEM7WUFDSDVsQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHeWxDO1lBQ0g3bEMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3VtQztZQUNIM21DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUd3bUM7WUFDSDVtQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOGxDO1lBQ0hsbUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzJsQztZQUNIL2xDLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUd5bUM7WUFDSDdtQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHMG1DO1lBQ0g5bUMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzJtQztZQUNIL21DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc0bUM7WUFDSGhuQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHNm1DO1lBQ0hqbkMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhtQztZQUNIbG5DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7WUFDMUJKLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcrbUM7WUFDSG5uQyxPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1lBQ3pCSixPQUFPO1FBQ1Q7UUFBRztZQUNEMVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHZ25DO1lBQ0hwbkMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2luQztZQUNIcm5DLE9BQU87UUFDVDtRQUFHO1lBQ0QxUCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdrbkM7WUFDSHRuQyxPQUFPO1FBQ1Q7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXVuQyx1QkFBdUJuMkM7SUFDM0J5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDMjhCLEtBQUssR0FBRztRQUNiOztLQUVDLEdBQ0QsSUFBSSxDQUFDM2pCLEdBQUcsR0FBRztRQUNYaEYsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTAxQyxpQkFBaUI1MUMsVUFBVSxDQUFDQyxPQUFPQztJQUNoRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTAxQyxpQkFBaUJsMUMsUUFBUSxDQUFDQyxXQUFXVDtJQUNsRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTAxQyxpQkFBaUIvMEMsY0FBYyxDQUFDQyxZQUFZWjtJQUN6RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDazJDLGdCQUFnQmh6QyxHQUFHQztJQUMvQztBQUNGO0FBQ0EreUMsZUFBZS8xQyxPQUFPLEdBQUcwVztBQUN6QnEvQixlQUFldDNDLFFBQVEsR0FBRztBQUMxQnMzQyxlQUFleHpDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3REaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNMGxDLHdCQUF3QjEwQztJQUM1QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ2daLEdBQUcsR0FBRztRQUNYOztLQUVDLEdBQ0QsSUFBSSxDQUFDdmlCLElBQUksR0FBRztRQUNaOztLQUVDLEdBQ0QsSUFBSSxDQUFDbUgsSUFBSSxHQUFHZ1ksVUFBVXVELEtBQUs7UUFDM0I7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0UsS0FBSyxHQUFHO1FBQ2I7O0tBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNGLEtBQUssR0FBRztRQUNiOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNJLFVBQVUsR0FBRztRQUNsQjs7S0FFQyxHQUNELElBQUksQ0FBQ25JLE1BQU0sR0FBR3dFLFlBQVk0RCxPQUFPO1FBQ2pDOztLQUVDLEdBQ0QsSUFBSSxDQUFDUixNQUFNLEdBQUcsRUFBRTtRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ3E2QixlQUFlLEdBQUcsRUFBRTtRQUN6Qjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDLzhCLEdBQUcsR0FBRztRQUNYOztLQUVDLEdBQ0QsSUFBSSxDQUFDb0QsTUFBTSxHQUFHO1FBQ2Q7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUdoQixnQkFBZ0JpQixJQUFJO1FBQ3RDOzs7OztLQUtDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZC9GLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlpMEMsa0JBQWtCbjBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDakQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlpMEMsa0JBQWtCenpDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlpMEMsa0JBQWtCdHpDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDMUQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3kwQyxpQkFBaUJ2eEMsR0FBR0M7SUFDaEQ7QUFDRjtBQUNBc3hDLGdCQUFnQnQwQyxPQUFPLEdBQUcwVztBQUMxQjQ5QixnQkFBZ0I3MUMsUUFBUSxHQUFHO0FBQzNCNjFDLGdCQUFnQi94QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN2RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQ2lhO1FBQ3hCO1FBQUc7WUFDRHhaLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDa2E7UUFDeEI7UUFBRztZQUNEelosSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHZ047WUFDSHJOLFVBQVU7UUFDWjtRQUFHO1lBQ0R6UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdtbkM7WUFDSHhuQyxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQ2tkO1FBQ3hCO1FBQUc7WUFDRHpjLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNeWxDLHVCQUF1QnowQztJQUMzQnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUN1ekMsYUFBYSxHQUFHO1FBQ3JCOztLQUVDLEdBQ0QsSUFBSSxDQUFDM25DLE1BQU0sR0FBRzBsQyxhQUFha0MsU0FBUztRQUNwQ3gvQixPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJZzBDLGlCQUFpQmwwQyxVQUFVLENBQUNDLE9BQU9DO0lBQ2hEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJZzBDLGlCQUFpQnh6QyxRQUFRLENBQUNDLFdBQVdUO0lBQ2xEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJZzBDLGlCQUFpQnJ6QyxjQUFjLENBQUNDLFlBQVlaO0lBQ3pEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUN3MEMsZ0JBQWdCdHhDLEdBQUdDO0lBQy9DO0FBQ0Y7QUFDQXF4QyxlQUFlcjBDLE9BQU8sR0FBRzBXO0FBQ3pCMjlCLGVBQWU1MUMsUUFBUSxHQUFHO0FBQzFCNDFDLGVBQWU5eEMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDdERoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHOEgsT0FBT3JZLFdBQVcsQ0FBQzIxQztRQUN4QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNTyx5QkFBeUIzMEM7SUFDN0J5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDdVcsR0FBRyxHQUFHO1FBQ1g7O0tBRUMsR0FDRCxJQUFJLENBQUM2QyxLQUFLLEdBQUc7UUFDYnBGLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlrMEMsbUJBQW1CcDBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDbEQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlrMEMsbUJBQW1CMXpDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDcEQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlrMEMsbUJBQW1CdnpDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDM0Q7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQzAwQyxrQkFBa0J4eEMsR0FBR0M7SUFDakQ7QUFDRjtBQUNBdXhDLGlCQUFpQnYwQyxPQUFPLEdBQUcwVztBQUMzQjY5QixpQkFBaUI5MUMsUUFBUSxHQUFHO0FBQzVCODFDLGlCQUFpQmh5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN4RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXNtQyxxQkFBcUJ0MUM7SUFDekJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDeXpDLGlCQUFpQixHQUFHLEVBQUU7UUFDM0I7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCOztLQUVDLEdBQ0QsSUFBSSxDQUFDcGEsVUFBVSxHQUFHLEVBQUU7UUFDcEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ3FhLGlCQUFpQixHQUFHO1FBQ3pCOzs7OztLQUtDLEdBQ0QsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSW51QyxXQUFXO1FBQ2pDbU8sT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTYwQyxlQUFlLzBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDOUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUk2MEMsZUFBZXIwQyxRQUFRLENBQUNDLFdBQVdUO0lBQ2hEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJNjBDLGVBQWVsMEMsY0FBYyxDQUFDQyxZQUFZWjtJQUN2RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDcTFDLGNBQWNueUMsR0FBR0M7SUFDN0M7QUFDRjtBQUNBa3lDLGFBQWFsMUMsT0FBTyxHQUFHMFc7QUFDdkJ3K0IsYUFBYXoyQyxRQUFRLEdBQUc7QUFDeEJ5MkMsYUFBYTN5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNwRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR21LO1FBQ0w7UUFBRztZQUNEamEsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHK0w7UUFDTDtRQUFHO1lBQ0Q3YixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcrTDtZQUNIcE0sVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcrbkM7WUFDSHBvQyxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdrUTtRQUNMO1FBQUc7WUFDRGhnQixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdpUDtRQUNMO1FBQUc7WUFDRC9lLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLG9CQUFvQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNZ25DLDBCQUEwQmgyQztJQUM5QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNzNUIsVUFBVSxHQUFHLEVBQUU7UUFDcEJ0bEIsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXUxQyxvQkFBb0J6MUMsVUFBVSxDQUFDQyxPQUFPQztJQUNuRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXUxQyxvQkFBb0IvMEMsUUFBUSxDQUFDQyxXQUFXVDtJQUNyRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXUxQyxvQkFBb0I1MEMsY0FBYyxDQUFDQyxZQUFZWjtJQUM1RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDKzFDLG1CQUFtQjd5QyxHQUFHQztJQUNsRDtBQUNGO0FBQ0E0eUMsa0JBQWtCNTFDLE9BQU8sR0FBRzBXO0FBQzVCay9CLGtCQUFrQm4zQyxRQUFRLEdBQUc7QUFDN0JtM0Msa0JBQWtCcnpDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHK25DO1lBQ0hwb0MsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2tRO1FBQ0w7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXMyQiwrQkFBK0J4MUM7SUFDbkN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDZ1osR0FBRyxHQUFHO1FBQ1hoRixPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJKzBDLHlCQUF5QmoxQyxVQUFVLENBQUNDLE9BQU9DO0lBQ3hEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJKzBDLHlCQUF5QnYwQyxRQUFRLENBQUNDLFdBQVdUO0lBQzFEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJKzBDLHlCQUF5QnAwQyxjQUFjLENBQUNDLFlBQVlaO0lBQ2pFO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUN1MUMsd0JBQXdCcnlDLEdBQUdDO0lBQ3ZEO0FBQ0Y7QUFDQW95Qyx1QkFBdUJwMUMsT0FBTyxHQUFHMFc7QUFDakMwK0IsdUJBQXVCMzJDLFFBQVEsR0FBRztBQUNsQzIyQyx1QkFBdUI3eUMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDOURoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHeU07UUFDTDtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNczZCLGlDQUFpQy8xQztJQUNyQ3lDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNrMEMsUUFBUSxHQUFHO1FBQ2hCbGdDLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlzMUMsMkJBQTJCeDFDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDMUQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlzMUMsMkJBQTJCOTBDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDNUQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlzMUMsMkJBQTJCMzBDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDbkU7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQzgxQywwQkFBMEI1eUMsR0FBR0M7SUFDekQ7QUFDRjtBQUNBMnlDLHlCQUF5QjMxQyxPQUFPLEdBQUcwVztBQUNuQ2kvQix5QkFBeUJsM0MsUUFBUSxHQUFHO0FBQ3BDazNDLHlCQUF5QnB6QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNoRWhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNd2xDLDJCQUEyQngwQztJQUMvQnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ3BDLElBQUksR0FBRztRQUNaOztLQUVDLEdBQ0QsSUFBSSxDQUFDcTFCLEdBQUcsR0FBRztRQUNYamYsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSSt6QyxxQkFBcUJqMEMsVUFBVSxDQUFDQyxPQUFPQztJQUNwRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSSt6QyxxQkFBcUJ2ekMsUUFBUSxDQUFDQyxXQUFXVDtJQUN0RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSSt6QyxxQkFBcUJwekMsY0FBYyxDQUFDQyxZQUFZWjtJQUM3RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDdTBDLG9CQUFvQnJ4QyxHQUFHQztJQUNuRDtBQUNGO0FBQ0FveEMsbUJBQW1CcDBDLE9BQU8sR0FBRzBXO0FBQzdCMDlCLG1CQUFtQjMxQyxRQUFRLEdBQUc7QUFDOUIyMUMsbUJBQW1CN3hDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzFEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNdW1DLDBCQUEwQnYxQztJQUM5QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNtMEMsWUFBWSxHQUFHLEVBQUU7UUFDdEJuZ0MsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTgwQyxvQkFBb0JoMUMsVUFBVSxDQUFDQyxPQUFPQztJQUNuRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTgwQyxvQkFBb0J0MEMsUUFBUSxDQUFDQyxXQUFXVDtJQUNyRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTgwQyxvQkFBb0JuMEMsY0FBYyxDQUFDQyxZQUFZWjtJQUM1RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDczFDLG1CQUFtQnB5QyxHQUFHQztJQUNsRDtBQUNGO0FBQ0FteUMsa0JBQWtCbjFDLE9BQU8sR0FBRzBXO0FBQzVCeStCLGtCQUFrQjEyQyxRQUFRLEdBQUc7QUFDN0IwMkMsa0JBQWtCNXlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHK0w7WUFDSHBNLFVBQVU7UUFDWjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNaW1DLDJCQUEyQjUwQztJQUMvQnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNrYixTQUFTLEdBQUcsRUFBRTtRQUNuQjs7S0FFQyxHQUNELElBQUksQ0FBQ2s1QixTQUFTLEdBQUc7UUFDakI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7UUFDM0JyZ0MsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSW0wQyxxQkFBcUJyMEMsVUFBVSxDQUFDQyxPQUFPQztJQUNwRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSW0wQyxxQkFBcUIzekMsUUFBUSxDQUFDQyxXQUFXVDtJQUN0RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSW0wQyxxQkFBcUJ4ekMsY0FBYyxDQUFDQyxZQUFZWjtJQUM3RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDMjBDLG9CQUFvQnp4QyxHQUFHQztJQUNuRDtBQUNGO0FBQ0F3eEMsbUJBQW1CeDBDLE9BQU8sR0FBRzBXO0FBQzdCODlCLG1CQUFtQi8xQyxRQUFRLEdBQUc7QUFDOUIrMUMsbUJBQW1CanlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzFEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1lBQzFCTCxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRytPO1lBQ0hwUCxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTWttQyw0QkFBNEI3MEM7SUFDaEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDa2IsU0FBUyxHQUFHLEVBQUU7UUFDbkI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ281QixRQUFRLEdBQUc7UUFDaEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ3Q2QixPQUFPLEdBQUdsRSxhQUFhbUUsR0FBRztRQUMvQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDWixLQUFLLEdBQUc7UUFDYjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7S0FFQyxHQUNELElBQUksQ0FBQ2k3QixHQUFHLEdBQUc7UUFDWDs7Ozs7Ozs7OztLQVVDLEdBQ0QsSUFBSSxDQUFDNVksUUFBUSxHQUFHO1FBQ2hCM25CLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlvMEMsc0JBQXNCdDBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDckQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlvMEMsc0JBQXNCNXpDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDdkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlvMEMsc0JBQXNCenpDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDOUQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQzQwQyxxQkFBcUIxeEMsR0FBR0M7SUFDcEQ7QUFDRjtBQUNBeXhDLG9CQUFvQnowQyxPQUFPLEdBQUcwVztBQUM5Qis5QixvQkFBb0JoMkMsUUFBUSxHQUFHO0FBQy9CZzJDLG9CQUFvQmx5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUMzRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtZQUMxQkwsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDbWE7UUFDeEI7UUFBRztZQUNEMVosSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsR0FBRyxxQkFBcUI7UUFDN0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEdBQUcscUJBQXFCO1FBQzdCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU04bEMscUJBQXFCOTBDO0lBQ3pCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7Ozs7S0FLQyxHQUNELElBQUksQ0FBQ3cwQyxZQUFZLEdBQUc7UUFDcEI7O0tBRUMsR0FDRCxJQUFJLENBQUMvSCxNQUFNLEdBQUd2MkIsaUJBQWlCdStCLGNBQWM7UUFDN0N6Z0MsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXEwQyxlQUFldjBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDOUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlxMEMsZUFBZTd6QyxRQUFRLENBQUNDLFdBQVdUO0lBQ2hEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJcTBDLGVBQWUxekMsY0FBYyxDQUFDQyxZQUFZWjtJQUN2RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDNjBDLGNBQWMzeEMsR0FBR0M7SUFDN0M7QUFDRjtBQUNBMHhDLGFBQWExMEMsT0FBTyxHQUFHMFc7QUFDdkJnK0IsYUFBYWoyQyxRQUFRLEdBQUc7QUFDeEJpMkMsYUFBYW55QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNwRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtRQUMxQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDdWE7UUFDeEI7S0FBRTtBQUNGOzs7O0NBSUMsR0FDRCxNQUFNKzdCLDBCQUEwQi8wQztJQUM5QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNrMEMsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDajdCLE1BQU0sR0FBRyxFQUFFO1FBQ2hCakYsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXMwQyxvQkFBb0J4MEMsVUFBVSxDQUFDQyxPQUFPQztJQUNuRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXMwQyxvQkFBb0I5ekMsUUFBUSxDQUFDQyxXQUFXVDtJQUNyRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXMwQyxvQkFBb0IzekMsY0FBYyxDQUFDQyxZQUFZWjtJQUM1RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDODBDLG1CQUFtQjV4QyxHQUFHQztJQUNsRDtBQUNGO0FBQ0EyeEMsa0JBQWtCMzBDLE9BQU8sR0FBRzBXO0FBQzVCaStCLGtCQUFrQmwyQyxRQUFRLEdBQUc7QUFDN0JrMkMsa0JBQWtCcHlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2dOO1lBQ0hyTixVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXdtQyxrQ0FBa0NuMUM7SUFDdEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDNlcsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDcGdCLElBQUksR0FBRztRQUNadWQsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSTAwQyw0QkFBNEI1MEMsVUFBVSxDQUFDQyxPQUFPQztJQUMzRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSTAwQyw0QkFBNEJsMEMsUUFBUSxDQUFDQyxXQUFXVDtJQUM3RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTAwQyw0QkFBNEIvekMsY0FBYyxDQUFDQyxZQUFZWjtJQUNwRTtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDazFDLDJCQUEyQmh5QyxHQUFHQztJQUMxRDtBQUNGO0FBQ0EreEMsMEJBQTBCLzBDLE9BQU8sR0FBRzBXO0FBQ3BDcStCLDBCQUEwQnQyQyxRQUFRLEdBQUc7QUFDckNzMkMsMEJBQTBCeHlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2pFaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNK25DLGtCQUFrQi8yQztJQUN0QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUN5NUIsSUFBSSxHQUFHLEVBQUU7UUFDZDs7S0FFQyxHQUNELElBQUksQ0FBQzRLLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ3FRLFVBQVUsR0FBRztRQUNsQjFnQyxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJczJDLFlBQVl4MkMsVUFBVSxDQUFDQyxPQUFPQztJQUMzQztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXMyQyxZQUFZOTFDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDN0M7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlzMkMsWUFBWTMxQyxjQUFjLENBQUNDLFlBQVlaO0lBQ3BEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUM4MkMsV0FBVzV6QyxHQUFHQztJQUMxQztBQUNGO0FBQ0EyekMsVUFBVTMyQyxPQUFPLEdBQUcwVztBQUNwQmlnQyxVQUFVbDRDLFFBQVEsR0FBRztBQUNyQms0QyxVQUFVcDBDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1lBQzFCTCxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNeW1DLHdCQUF3QnoxQztJQUM1QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUN5YSxRQUFRLEdBQUcsRUFBRTtRQUNsQnpHLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlnMUMsa0JBQWtCbDFDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDakQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlnMUMsa0JBQWtCeDBDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlnMUMsa0JBQWtCcjBDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDMUQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ3cxQyxpQkFBaUJ0eUMsR0FBR0M7SUFDaEQ7QUFDRjtBQUNBcXlDLGdCQUFnQnIxQyxPQUFPLEdBQUcwVztBQUMxQjIrQixnQkFBZ0I1MkMsUUFBUSxHQUFHO0FBQzNCNDJDLGdCQUFnQjl5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN2RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3dPO1lBQ0g3TyxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTSttQyxtQkFBbUIxMUM7SUFDdkJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMZ1UsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSWkxQyxhQUFhbjFDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDNUM7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlpMUMsYUFBYXowQyxRQUFRLENBQUNDLFdBQVdUO0lBQzlDO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJaTFDLGFBQWF0MEMsY0FBYyxDQUFDQyxZQUFZWjtJQUNyRDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDeTFDLFlBQVl2eUMsR0FBR0M7SUFDM0M7QUFDRjtBQUNBc3lDLFdBQVd0MUMsT0FBTyxHQUFHMFc7QUFDckI0K0IsV0FBVzcyQyxRQUFRLEdBQUc7QUFDdEI2MkMsV0FBVy95QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUNsRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR21LO1FBQ0w7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXMrQiw4QkFBOEJ6M0M7SUFDbEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDNGEsY0FBYyxHQUFHO1FBQ3RCOztLQUVDLEdBQ0QsSUFBSSxDQUFDWixPQUFPLEdBQUdqRSxvQkFBb0I2K0IsSUFBSTtRQUN2Qzs7S0FFQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2I3Z0MsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSWczQyx3QkFBd0JsM0MsVUFBVSxDQUFDQyxPQUFPQztJQUN2RDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSWczQyx3QkFBd0J4MkMsUUFBUSxDQUFDQyxXQUFXVDtJQUN6RDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSWczQyx3QkFBd0JyMkMsY0FBYyxDQUFDQyxZQUFZWjtJQUNoRTtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDdzNDLHVCQUF1QnQwQyxHQUFHQztJQUN0RDtBQUNGO0FBQ0FxMEMsc0JBQXNCcjNDLE9BQU8sR0FBRzBXO0FBQ2hDMmdDLHNCQUFzQjU0QyxRQUFRLEdBQUc7QUFDakM0NEMsc0JBQXNCOTBDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzdEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUNvYTtRQUN4QjtRQUFHO1lBQ0QzWixJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTTJtQyxnQ0FBZ0MzMUM7SUFDcEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDODBDLE9BQU8sR0FBRyxFQUFFO1FBQ2pCOWdDLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUlrMUMsMEJBQTBCcDFDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDekQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUlrMUMsMEJBQTBCMTBDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDM0Q7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUlrMUMsMEJBQTBCdjBDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDbEU7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQzAxQyx5QkFBeUJ4eUMsR0FBR0M7SUFDeEQ7QUFDRjtBQUNBdXlDLHdCQUF3QnYxQyxPQUFPLEdBQUcwVztBQUNsQzYrQix3QkFBd0I5MkMsUUFBUSxHQUFHO0FBQ25DODJDLHdCQUF3Qmh6QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUMvRGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3lvQztZQUNIOW9DLFVBQVU7UUFDWjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNa3BDLHdCQUF3QjczQztJQUM1QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUM0YSxjQUFjLEdBQUc7UUFDdEI7O0tBRUMsR0FDRCxJQUFJLENBQUNzNUIsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDLzdCLEtBQUssR0FBR281QixZQUFZeUQsTUFBTTtRQUMvQmhoQyxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJbzNDLGtCQUFrQnQzQyxVQUFVLENBQUNDLE9BQU9DO0lBQ2pEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJbzNDLGtCQUFrQjUyQyxRQUFRLENBQUNDLFdBQVdUO0lBQ25EO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJbzNDLGtCQUFrQnoyQyxjQUFjLENBQUNDLFlBQVlaO0lBQzFEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUM0M0MsaUJBQWlCMTBDLEdBQUdDO0lBQ2hEO0FBQ0Y7QUFDQXkwQyxnQkFBZ0J6M0MsT0FBTyxHQUFHMFc7QUFDMUIrZ0MsZ0JBQWdCaDVDLFFBQVEsR0FBRztBQUMzQmc1QyxnQkFBZ0JsMUMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDdkRoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUM0MUM7UUFDeEI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXVCLDBCQUEwQjUxQztJQUM5QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNpMUMsWUFBWSxHQUFHLEVBQUU7UUFDdEJqaEMsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSW0xQyxvQkFBb0JyMUMsVUFBVSxDQUFDQyxPQUFPQztJQUNuRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSW0xQyxvQkFBb0IzMEMsUUFBUSxDQUFDQyxXQUFXVDtJQUNyRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSW0xQyxvQkFBb0J4MEMsY0FBYyxDQUFDQyxZQUFZWjtJQUM1RDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDMjFDLG1CQUFtQnp5QyxHQUFHQztJQUNsRDtBQUNGO0FBQ0F3eUMsa0JBQWtCeDFDLE9BQU8sR0FBRzBXO0FBQzVCOCtCLGtCQUFrQi8yQyxRQUFRLEdBQUc7QUFDN0IrMkMsa0JBQWtCanpDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHNm9DO1lBQ0hscEMsVUFBVTtRQUNaO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1xcEMsMEJBQTBCaDRDO0lBQzlCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ2dhLE9BQU8sR0FBR2xFLGFBQWFtRSxHQUFHO1FBQy9COztLQUVDLEdBQ0QsSUFBSSxDQUFDNUMsT0FBTyxHQUFHO1FBQ2ZyRCxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJdTNDLG9CQUFvQnozQyxVQUFVLENBQUNDLE9BQU9DO0lBQ25EO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJdTNDLG9CQUFvQi8yQyxRQUFRLENBQUNDLFdBQVdUO0lBQ3JEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJdTNDLG9CQUFvQjUyQyxjQUFjLENBQUNDLFlBQVlaO0lBQzVEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUMrM0MsbUJBQW1CNzBDLEdBQUdDO0lBQ2xEO0FBQ0Y7QUFDQTQwQyxrQkFBa0I1M0MsT0FBTyxHQUFHMFc7QUFDNUJraEMsa0JBQWtCbjVDLFFBQVEsR0FBRztBQUM3Qm01QyxrQkFBa0JyMUMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDekRoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDbWE7UUFDeEI7UUFBRztZQUNEMVosSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1pcEMsd0JBQXdCajRDO0lBQzVCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQzI4QixLQUFLLEdBQUc7UUFDYjs7S0FFQyxHQUNELElBQUksQ0FBQ3lZLFNBQVMsR0FBRyxFQUFFO1FBQ25CcGhDLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl3M0Msa0JBQWtCMTNDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDakQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl3M0Msa0JBQWtCaDNDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl3M0Msa0JBQWtCNzJDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDMUQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2c0QyxpQkFBaUI5MEMsR0FBR0M7SUFDaEQ7QUFDRjtBQUNBNjBDLGdCQUFnQjczQyxPQUFPLEdBQUcwVztBQUMxQm1oQyxnQkFBZ0JwNUMsUUFBUSxHQUFHO0FBQzNCbzVDLGdCQUFnQnQxQyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN2RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdncEM7WUFDSHJwQyxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTWtuQyxnQ0FBZ0M3MUM7SUFDcEN5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDazBDLFFBQVEsR0FBRztRQUNoQjs7S0FFQyxHQUNELElBQUksQ0FBQ21CLG1CQUFtQixHQUFHLEVBQUU7UUFDN0I7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7UUFDMUJ0aEMsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSW8xQywwQkFBMEJ0MUMsVUFBVSxDQUFDQyxPQUFPQztJQUN6RDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSW8xQywwQkFBMEI1MEMsUUFBUSxDQUFDQyxXQUFXVDtJQUMzRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSW8xQywwQkFBMEJ6MEMsY0FBYyxDQUFDQyxZQUFZWjtJQUNsRTtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDNDFDLHlCQUF5QjF5QyxHQUFHQztJQUN4RDtBQUNGO0FBQ0F5eUMsd0JBQXdCejFDLE9BQU8sR0FBRzBXO0FBQ2xDKytCLHdCQUF3QmgzQyxRQUFRLEdBQUc7QUFDbkNnM0Msd0JBQXdCbHpDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQy9EaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR2dwQztZQUNIcnBDLFVBQVU7UUFDWjtRQUFHO1lBQ0R6UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdpcEM7WUFDSHRwQyxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTTBwQyx3QkFBd0JyNEM7SUFDNUJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOzs7O0tBSUMsR0FDRCxJQUFJLENBQUM0YSxjQUFjLEdBQUc7UUFDdEI7O0tBRUMsR0FDRCxJQUFJLENBQUM0NkIsU0FBUyxHQUFHO1FBQ2pCOztLQUVDLEdBQ0QsSUFBSSxDQUFDdDZCLFNBQVMsR0FBRyxFQUFFO1FBQ25COztLQUVDLEdBQ0QsSUFBSSxDQUFDTCxtQkFBbUIsR0FBRztRQUMzQjdHLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUk0M0Msa0JBQWtCOTNDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDakQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUk0M0Msa0JBQWtCcDNDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDbkQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUk0M0Msa0JBQWtCajNDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDMUQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ280QyxpQkFBaUJsMUMsR0FBR0M7SUFDaEQ7QUFDRjtBQUNBaTFDLGdCQUFnQmo0QyxPQUFPLEdBQUcwVztBQUMxQnVoQyxnQkFBZ0J4NUMsUUFBUSxHQUFHO0FBQzNCdzVDLGdCQUFnQjExQyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN2RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1lBQzFCTCxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1nbUMsK0JBQStCaDFDO0lBQ25DeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ3kxQyxlQUFlLEdBQUc7UUFDdkI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7UUFDMUIxaEMsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXUwQyx5QkFBeUJ6MEMsVUFBVSxDQUFDQyxPQUFPQztJQUN4RDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXUwQyx5QkFBeUIvekMsUUFBUSxDQUFDQyxXQUFXVDtJQUMxRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXUwQyx5QkFBeUI1ekMsY0FBYyxDQUFDQyxZQUFZWjtJQUNqRTtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDKzBDLHdCQUF3Qjd4QyxHQUFHQztJQUN2RDtBQUNGO0FBQ0E0eEMsdUJBQXVCNTBDLE9BQU8sR0FBRzBXO0FBQ2pDaytCLHVCQUF1Qm4yQyxRQUFRLEdBQUc7QUFDbENtMkMsdUJBQXVCcnlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQzlEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsbUJBQW1CO1FBQzFCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3FwQztZQUNIMXBDLFVBQVU7UUFDWjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNbW5DLHFDQUFxQzkxQztJQUN6Q3lDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUM0YSxjQUFjLEdBQUc7UUFDdEI7O0tBRUMsR0FDRCxJQUFJLENBQUNzNUIsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDeUIsT0FBTyxHQUFHO1FBQ2YzaEMsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSXExQywrQkFBK0J2MUMsVUFBVSxDQUFDQyxPQUFPQztJQUM5RDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXExQywrQkFBK0I3MEMsUUFBUSxDQUFDQyxXQUFXVDtJQUNoRTtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXExQywrQkFBK0IxMEMsY0FBYyxDQUFDQyxZQUFZWjtJQUN2RTtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDNjFDLDhCQUE4QjN5QyxHQUFHQztJQUM3RDtBQUNGO0FBQ0EweUMsNkJBQTZCMTFDLE9BQU8sR0FBRzBXO0FBQ3ZDZy9CLDZCQUE2QmozQyxRQUFRLEdBQUc7QUFDeENpM0MsNkJBQTZCbnpDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3BFaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxtQkFBbUI7UUFDMUI7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTWltQyxrQkFBa0JqMUM7SUFDdEJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDNDFDLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCOztLQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUcsRUFBRTtRQUN0QjdoQyxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJdzBDLFlBQVkxMEMsVUFBVSxDQUFDQyxPQUFPQztJQUMzQztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXcwQyxZQUFZaDBDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDN0M7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl3MEMsWUFBWTd6QyxjQUFjLENBQUNDLFlBQVlaO0lBQ3BEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNnMUMsV0FBVzl4QyxHQUFHQztJQUMxQztBQUNGO0FBQ0E2eEMsVUFBVTcwQyxPQUFPLEdBQUcwVztBQUNwQm0rQixVQUFVcDJDLFFBQVEsR0FBRztBQUNyQm8yQyxVQUFVdHlDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ2pEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHd2xDO1FBQ0w7UUFBRztZQUNEdDFDLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzRsQztRQUNMO1FBQUc7WUFDRDExQyxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUd3bUM7WUFDSDdtQyxVQUFVO1FBQ1o7UUFBRztZQUNEelAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHNHBDO1lBQ0hqcUMsVUFBVTtRQUNaO1FBQUc7WUFDRHpQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBR3dsQztRQUNMO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1vRSx3QkFBd0I1NEM7SUFDNUJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDeXJCLEtBQUssR0FBRztRQUNiOztLQUVDLEdBQ0QsSUFBSSxDQUFDeEMsRUFBRSxHQUFHO1FBQ1Y7O0tBRUMsR0FDRCxJQUFJLENBQUNyZCxNQUFNLEdBQUcwbEMsYUFBYWtDLFNBQVM7UUFDcEN4L0IsT0FBT3pXLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJO0lBQ3BDO0lBQ0EsT0FBT3ZDLFdBQVdDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE9BQU8sSUFBSW00QyxrQkFBa0JyNEMsVUFBVSxDQUFDQyxPQUFPQztJQUNqRDtJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSW00QyxrQkFBa0IzM0MsUUFBUSxDQUFDQyxXQUFXVDtJQUNuRDtJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSW00QyxrQkFBa0J4M0MsY0FBYyxDQUFDQyxZQUFZWjtJQUMxRDtJQUNBLE9BQU9SLE9BQU9rRCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNsQixPQUFPMFQsT0FBT3pXLElBQUksQ0FBQ0osTUFBTSxDQUFDMjRDLGlCQUFpQnoxQyxHQUFHQztJQUNoRDtBQUNGO0FBQ0F3MUMsZ0JBQWdCeDRDLE9BQU8sR0FBRzBXO0FBQzFCOGhDLGdCQUFnQi81QyxRQUFRLEdBQUc7QUFDM0IrNUMsZ0JBQWdCajJDLE1BQU0sR0FBR21VLE9BQU96VyxJQUFJLENBQUM2QyxZQUFZLENBQUMsSUFBTTtRQUFDO1lBQ3ZEaEUsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxHQUFHLHFCQUFxQjtRQUM3QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDMjFDO1FBQ3hCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1jLHlCQUF5QmwxQztJQUM3QnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUMrMUMsUUFBUSxHQUFHO1lBQ2RocUMsTUFBTWpXO1FBQ1I7UUFDQWtlLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl5MEMsbUJBQW1CMzBDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDbEQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl5MEMsbUJBQW1CajBDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDcEQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl5MEMsbUJBQW1COXpDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDM0Q7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2kxQyxrQkFBa0IveEMsR0FBR0M7SUFDakQ7QUFDRjtBQUNBOHhDLGlCQUFpQjkwQyxPQUFPLEdBQUcwVztBQUMzQm8rQixpQkFBaUJyMkMsUUFBUSxHQUFHO0FBQzVCcTJDLGlCQUFpQnZ5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUN4RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtZQUN6QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtZQUN4QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtZQUN4QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtZQUN4QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRzhILE9BQU9yWSxXQUFXLENBQUM2MUM7WUFDdEIxbEMsT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtZQUN6QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtZQUN4QkosT0FBTztRQUNUO1FBQUc7WUFDRDFQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG1CQUFtQjtZQUN4QkosT0FBTztRQUNUO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU13bUMsYUFBYXAxQztJQUNqQnlDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNteEIsU0FBUyxHQUFHN3JCLFdBQVdYLElBQUk7UUFDaEM7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ3F4QyxHQUFHLEdBQUcxd0MsV0FBV1gsSUFBSTtRQUMxQnFQLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUkyMEMsT0FBTzcwQyxVQUFVLENBQUNDLE9BQU9DO0lBQ3RDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJMjBDLE9BQU9uMEMsUUFBUSxDQUFDQyxXQUFXVDtJQUN4QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSTIwQyxPQUFPaDBDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDL0M7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ20xQyxNQUFNanlDLEdBQUdDO0lBQ3JDO0FBQ0Y7QUFDQWd5QyxLQUFLaDFDLE9BQU8sR0FBRzBXO0FBQ2ZzK0IsS0FBS3YyQyxRQUFRLEdBQUc7QUFDaEJ1MkMsS0FBS3p5QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUM1Q2hFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTWluQyxhQUFhajJDO0lBQ2pCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDaTJDLGlCQUFpQixHQUFHM3dDLFdBQVdYLElBQUk7UUFDeEM7O0tBRUMsR0FDRCxJQUFJLENBQUN3c0IsU0FBUyxHQUFHN3JCLFdBQVdYLElBQUk7UUFDaENxUCxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJdzFDLE9BQU8xMUMsVUFBVSxDQUFDQyxPQUFPQztJQUN0QztJQUNBLE9BQU9RLFNBQVNDLFNBQVMsRUFBRVQsT0FBTyxFQUFFO1FBQ2xDLE9BQU8sSUFBSXcxQyxPQUFPaDFDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDeEM7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl3MUMsT0FBTzcwQyxjQUFjLENBQUNDLFlBQVlaO0lBQy9DO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUNnMkMsTUFBTTl5QyxHQUFHQztJQUNyQztBQUNGO0FBQ0E2eUMsS0FBSzcxQyxPQUFPLEdBQUcwVztBQUNmbS9CLEtBQUtwM0MsUUFBUSxHQUFHO0FBQ2hCbzNDLEtBQUt0ekMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDNUNoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxvQkFBb0I7UUFDM0I7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUsb0JBQW9CO1FBQzNCO0tBQUU7QUFDRjs7Q0FFQyxHQUNELE1BQU1ncUMsdUJBQXVCaDVDO0lBQzNCeUMsWUFBWUssSUFBSSxDQUFFO1FBQ2hCLEtBQUs7UUFDTDs7S0FFQyxHQUNELElBQUksQ0FBQ20yQyxPQUFPLEdBQUcsRUFBRTtRQUNqQm5pQyxPQUFPelcsSUFBSSxDQUFDMkMsV0FBVyxDQUFDRixNQUFNLElBQUk7SUFDcEM7SUFDQSxPQUFPdkMsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxJQUFJdTRDLGlCQUFpQno0QyxVQUFVLENBQUNDLE9BQU9DO0lBQ2hEO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJdTRDLGlCQUFpQi8zQyxRQUFRLENBQUNDLFdBQVdUO0lBQ2xEO0lBQ0EsT0FBT1csZUFBZUMsVUFBVSxFQUFFWixPQUFPLEVBQUU7UUFDekMsT0FBTyxJQUFJdTRDLGlCQUFpQjUzQyxjQUFjLENBQUNDLFlBQVlaO0lBQ3pEO0lBQ0EsT0FBT1IsT0FBT2tELENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2xCLE9BQU8wVCxPQUFPelcsSUFBSSxDQUFDSixNQUFNLENBQUMrNEMsZ0JBQWdCNzFDLEdBQUdDO0lBQy9DO0FBQ0Y7QUFDQTQxQyxlQUFlNTRDLE9BQU8sR0FBRzBXO0FBQ3pCa2lDLGVBQWVuNkMsUUFBUSxHQUFHO0FBQzFCbTZDLGVBQWVyMkMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDdERoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUdrcUM7WUFDSHZxQyxVQUFVO1FBQ1o7S0FBRTtBQUNGOztDQUVDLEdBQ0QsTUFBTXVxQyxtQkFBbUJsNUM7SUFDdkJ5QyxZQUFZSyxJQUFJLENBQUU7UUFDaEIsS0FBSztRQUNMOztLQUVDLEdBQ0QsSUFBSSxDQUFDeVksTUFBTSxHQUFHO1FBQ2Q7O0tBRUMsR0FDRCxJQUFJLENBQUNpaEIsR0FBRyxHQUFHO1FBQ1g7O0tBRUMsR0FDRCxJQUFJLENBQUMyYyxRQUFRLEdBQUcvd0MsV0FBV1gsSUFBSTtRQUMvQnFQLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl5NEMsYUFBYTM0QyxVQUFVLENBQUNDLE9BQU9DO0lBQzVDO0lBQ0EsT0FBT1EsU0FBU0MsU0FBUyxFQUFFVCxPQUFPLEVBQUU7UUFDbEMsT0FBTyxJQUFJeTRDLGFBQWFqNEMsUUFBUSxDQUFDQyxXQUFXVDtJQUM5QztJQUNBLE9BQU9XLGVBQWVDLFVBQVUsRUFBRVosT0FBTyxFQUFFO1FBQ3pDLE9BQU8sSUFBSXk0QyxhQUFhOTNDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDckQ7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2k1QyxZQUFZLzFDLEdBQUdDO0lBQzNDO0FBQ0Y7QUFDQTgxQyxXQUFXOTRDLE9BQU8sR0FBRzBXO0FBQ3JCb2lDLFdBQVdyNkMsUUFBUSxHQUFHO0FBQ3RCcTZDLFdBQVd2MkMsTUFBTSxHQUFHbVUsT0FBT3pXLElBQUksQ0FBQzZDLFlBQVksQ0FBQyxJQUFNO1FBQUM7WUFDbERoRSxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUcsRUFBRSxxQkFBcUI7UUFDNUI7UUFBRztZQUNEOVAsSUFBSTtZQUNKM0YsTUFBTTtZQUNOdVYsTUFBTTtZQUNORSxHQUFHLEVBQUUscUJBQXFCO1FBQzVCO1FBQUc7WUFDRDlQLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLG9CQUFvQjtRQUMzQjtLQUFFO0FBQ0Y7O0NBRUMsR0FDRCxNQUFNa25DLDZCQUE2QmwyQztJQUNqQ3lDLFlBQVlLLElBQUksQ0FBRTtRQUNoQixLQUFLO1FBQ0w7O0tBRUMsR0FDRCxJQUFJLENBQUNrMEMsUUFBUSxHQUFHO1FBQ2hCOztLQUVDLEdBQ0QsSUFBSSxDQUFDM3dCLEdBQUcsR0FBR25OLGtCQUFrQmtnQyxVQUFVO1FBQ3ZDdGlDLE9BQU96VyxJQUFJLENBQUMyQyxXQUFXLENBQUNGLE1BQU0sSUFBSTtJQUNwQztJQUNBLE9BQU92QyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPLElBQUl5MUMsdUJBQXVCMzFDLFVBQVUsQ0FBQ0MsT0FBT0M7SUFDdEQ7SUFDQSxPQUFPUSxTQUFTQyxTQUFTLEVBQUVULE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUl5MUMsdUJBQXVCajFDLFFBQVEsQ0FBQ0MsV0FBV1Q7SUFDeEQ7SUFDQSxPQUFPVyxlQUFlQyxVQUFVLEVBQUVaLE9BQU8sRUFBRTtRQUN6QyxPQUFPLElBQUl5MUMsdUJBQXVCOTBDLGNBQWMsQ0FBQ0MsWUFBWVo7SUFDL0Q7SUFDQSxPQUFPUixPQUFPa0QsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDbEIsT0FBTzBULE9BQU96VyxJQUFJLENBQUNKLE1BQU0sQ0FBQ2kyQyxzQkFBc0IveUMsR0FBR0M7SUFDckQ7QUFDRjtBQUNBOHlDLHFCQUFxQjkxQyxPQUFPLEdBQUcwVztBQUMvQm8vQixxQkFBcUJyM0MsUUFBUSxHQUFHO0FBQ2hDcTNDLHFCQUFxQnZ6QyxNQUFNLEdBQUdtVSxPQUFPelcsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLElBQU07UUFBQztZQUM1RGhFLElBQUk7WUFDSjNGLE1BQU07WUFDTnVWLE1BQU07WUFDTkUsR0FBRyxFQUFFLHFCQUFxQjtRQUM1QjtRQUFHO1lBQ0Q5UCxJQUFJO1lBQ0ozRixNQUFNO1lBQ051VixNQUFNO1lBQ05FLEdBQUc4SCxPQUFPclksV0FBVyxDQUFDeWE7UUFDeEI7S0FBRTtBQUVGLFNBQVNtZ0MsVUFBVTU1QyxLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxhQUFhO1FBQ2hDO0lBQ0Y7SUFDQSxJQUFJLE9BQU82NUMsb0JBQW9CLFlBQVk7UUFDekMsT0FBT0EsZ0JBQWdCNzVDO0lBQ3pCLE9BQU87UUFDTCxPQUFPNkIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLYyxTQUFTLENBQUMzQztJQUNuQztBQUNGO0FBRUEsTUFBTTg1Qyw0QkFBNEI7QUFDbEMsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxNQUFNQyxtQkFBbUIsRUFBRTtBQUMzQixNQUFNQyxjQUFjdndCLGNBQWM3RCxZQUFZO0lBQzVDNWlCLFlBQVlpM0MsVUFBVSxFQUFFNXFDLElBQUksQ0FBRTtRQUM1QixJQUFJNnFDLGdCQUFnQnBoRCxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3pGLElBQUk0SjtRQUNKLEtBQUs7UUFDTCxJQUFJLENBQUN5M0MsZ0JBQWdCLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsV0FBVyxHQUFHTCxNQUFNcEYsV0FBVyxDQUFDMEYsTUFBTTtRQUMzQyxJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUN6aUQsR0FBRyxHQUFHMkU7UUFDWCxJQUFJLENBQUMrOUMsNEJBQTRCLEdBQUc7WUFDbEMsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixFQUFFO2dCQUMxQnJKLGFBQWEsSUFBSSxDQUFDcUosaUJBQWlCO1lBQ3JDO1lBQ0EsbURBQW1EO1lBQ25ELCtDQUErQztZQUMvQyxJQUFJamdELFNBQVNrZ0QsZUFBZSxLQUFLLFVBQVU7Z0JBQ3pDLElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdwSixXQUFXLElBQU0sSUFBSSxDQUFDc0osMEJBQTBCLElBQUlkO1lBQy9FLE9BQU87Z0JBQ0wsSUFBSSxDQUFDYywwQkFBMEI7WUFDakM7UUFDRjtRQUNBLElBQUksQ0FBQzdpRCxHQUFHLEdBQUdrRSxVQUFVLENBQUN5RyxLQUFLdzNDLGNBQWM1Z0QsVUFBVSxNQUFNLFFBQVFvSixPQUFPLEtBQUssSUFBSUEsS0FBS2pHLFlBQVl1OUMsS0FBSztRQUN2RyxJQUFJLENBQUNhLGVBQWUsR0FBR1gsY0FBY1csZUFBZTtRQUNwRCxJQUFJLENBQUN4MEIsZUFBZSxDQUFDO1FBQ3JCLElBQUksQ0FBQ2hYLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUN5ckMsaUJBQWlCLEdBQUdiO1FBQ3pCLElBQUksQ0FBQ2MsY0FBYyxHQUFHZCxXQUFXM3RCLEVBQUU7UUFDbkMsSUFBSSxDQUFDNVgsTUFBTSxHQUFHc2xDLE1BQU1nQixNQUFNLENBQUNDLE9BQU87SUFDcEM7SUFDQSxJQUFJQyxhQUFhO1FBQ2YsSUFBSXg0QztRQUNKLE9BQU9wTSxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQ29DLEtBQUssSUFBSSxDQUFDbTRDLGVBQWUsTUFBTSxRQUFRbjRDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJLElBQUkwakQsdUJBQXVCLElBQUk7SUFDcko7SUFDQSxvQ0FBb0MsR0FDcEMsSUFBSUMsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDWixlQUFlO0lBQzdCO0lBQ0EsSUFBSWEsbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDUCxpQkFBaUI7SUFDL0I7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSVEsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDUCxjQUFjO0lBQzVCO0lBQ0FRLE9BQU9DLE9BQU8sRUFBRTtRQUNkLElBQUlDLGNBQWM7UUFDbEIsSUFBSSxJQUFJLENBQUNwc0MsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRTtZQUNsQ0YsY0FBYztRQUNoQjtRQUNBLElBQUksSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUMzZ0QsTUFBTSxLQUFLLEtBQUt3Z0QsTUFBTTBCLElBQUksQ0FBQ0MsS0FBSyxFQUFFO1lBQzFELElBQUksQ0FBQ0Msd0JBQXdCO1FBQy9CO1FBQ0EsSUFBSSxDQUFDSixTQUFTO1lBQ1osSUFBSUMsZ0JBQWdCLFNBQVM7Z0JBQzNCMUIsaUJBQWlCN2pELE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQ3ZCLElBQUlBLEVBQUUwbEQsYUFBYSxLQUFLLFFBQVEsQ0FBQ0wsU0FBUzt3QkFDeENBLFVBQVVybEQ7b0JBQ1o7Z0JBQ0Y7Z0JBQ0EsSUFBSXFsRCxTQUFTO29CQUNYLHNCQUFzQjtvQkFDdEJ6QixpQkFBaUIzbUIsTUFBTSxDQUFDMm1CLGlCQUFpQmgvQyxPQUFPLENBQUN5Z0QsVUFBVTtnQkFDN0Q7WUFDRjtZQUNBLElBQUksQ0FBQ0EsU0FBUztnQkFDWkEsVUFBVS9nRCxTQUFTcWhELGFBQWEsQ0FBQ0w7WUFDbkM7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN0QixnQkFBZ0IsQ0FBQ3ByQixRQUFRLENBQUN5c0IsVUFBVTtZQUM1QyxJQUFJLENBQUNyQixnQkFBZ0IsQ0FBQ2o2QyxJQUFJLENBQUNzN0M7UUFDN0I7UUFDQSx5RUFBeUU7UUFDekUsaUVBQWlFO1FBQ2pFLDBDQUEwQztRQUMxQ08sZ0JBQWdCLElBQUksQ0FBQ1YsZ0JBQWdCLEVBQUVHO1FBQ3ZDLGdDQUFnQztRQUNoQyxNQUFNUSx1QkFBdUJSLFFBQVFTLFNBQVMsQ0FBQzFyQixTQUFTO1FBQ3hELE1BQU0yckIsV0FBV0YscUJBQXFCbnRCLElBQUksQ0FBQ3N0QixDQUFBQSxLQUFNQSxHQUFHOXNDLElBQUksS0FBSztRQUM3RCxxREFBcUQ7UUFDckRtc0MsUUFBUVksSUFBSSxHQUFHaDRCLElBQUksQ0FBQztZQUNsQixJQUFJLENBQUNxQyxJQUFJLENBQUN5MUIsV0FBV25MLFdBQVdzTCxvQkFBb0IsR0FBR3RMLFdBQVd1TCxvQkFBb0I7UUFDeEYsR0FBRzloQixLQUFLLENBQUNya0MsQ0FBQUE7WUFDUCxJQUFJQSxFQUFFMkQsSUFBSSxLQUFLLG1CQUFtQjtnQkFDaEMsSUFBSSxDQUFDMnNCLElBQUksQ0FBQ3kxQixXQUFXbkwsV0FBV3dMLG1CQUFtQixHQUFHeEwsV0FBV3lMLG1CQUFtQixFQUFFcm1EO1lBQ3hGLE9BQU8sSUFBSUEsRUFBRTJELElBQUksS0FBSyxjQUFjO2dCQUNsQyxnRkFBZ0Y7Z0JBQ2hGNEMsY0FBY2hELEtBQUssQ0FBQyxHQUFHcUksTUFBTSxDQUFDbTZDLFdBQVcsVUFBVSxTQUFTO1lBQzlELE9BQU87Z0JBQ0x4L0MsY0FBY2dwQixJQUFJLENBQUMsc0JBQXNCM2pCLE1BQU0sQ0FBQ202QyxXQUFXLFVBQVUsVUFBVS9sRDtZQUNqRjtZQUNBLHlFQUF5RTtZQUN6RSxJQUFJK2xELFlBQVlWLFdBQVdRLHFCQUFxQm50QixJQUFJLENBQUNzdEIsQ0FBQUEsS0FBTUEsR0FBRzlzQyxJQUFJLEtBQUssWUFBWWxaLEVBQUUyRCxJQUFJLEtBQUssbUJBQW1CO2dCQUMvRzBoRCxRQUFRLytCLEtBQUssR0FBRztnQkFDaEIrK0IsUUFBUVksSUFBSSxHQUFHNWhCLEtBQUssQ0FBQztnQkFDbkIsMkZBQTJGO2dCQUM3RjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUMvVCxJQUFJLENBQUNzcUIsV0FBVzBMLGVBQWUsRUFBRWpCO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFDQWtCLE9BQU9sQixPQUFPLEVBQUU7UUFDZCxJQUFJO1lBQ0YsK0JBQStCO1lBQy9CLElBQUlBLFNBQVM7Z0JBQ1htQixZQUFZLElBQUksQ0FBQ3RCLGdCQUFnQixFQUFFRztnQkFDbkMsTUFBTXJvQixNQUFNLElBQUksQ0FBQ2duQixnQkFBZ0IsQ0FBQ3AvQyxPQUFPLENBQUN5Z0Q7Z0JBQzFDLElBQUlyb0IsT0FBTyxHQUFHO29CQUNaLElBQUksQ0FBQ2duQixnQkFBZ0IsQ0FBQy9tQixNQUFNLENBQUNELEtBQUs7b0JBQ2xDLElBQUksQ0FBQ3lwQixjQUFjLENBQUNwQjtvQkFDcEIsSUFBSSxDQUFDLzBCLElBQUksQ0FBQ3NxQixXQUFXOEwsZUFBZSxFQUFFckI7Z0JBQ3hDO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQSxNQUFNc0IsV0FBVyxFQUFFO1lBQ25CLElBQUksQ0FBQzNDLGdCQUFnQixDQUFDamtELE9BQU8sQ0FBQzZtRCxDQUFBQTtnQkFDNUJKLFlBQVksSUFBSSxDQUFDdEIsZ0JBQWdCLEVBQUUwQjtnQkFDbkNELFNBQVM1OEMsSUFBSSxDQUFDNjhDO2dCQUNkLElBQUksQ0FBQ0gsY0FBYyxDQUFDRztnQkFDcEIsSUFBSSxDQUFDdDJCLElBQUksQ0FBQ3NxQixXQUFXOEwsZUFBZSxFQUFFRTtZQUN4QztZQUNBLG9CQUFvQjtZQUNwQixJQUFJLENBQUM1QyxnQkFBZ0IsR0FBRyxFQUFFO1lBQzFCLE9BQU8yQztRQUNULFNBQVU7WUFDUixJQUFJLElBQUksQ0FBQzNDLGdCQUFnQixDQUFDM2dELE1BQU0sS0FBSyxHQUFHO2dCQUN0QyxJQUFJLENBQUN3akQsMkJBQTJCO1lBQ2xDO1FBQ0Y7SUFDRjtJQUNBeHNCLE9BQU87UUFDTCxJQUFJLENBQUN5c0IsV0FBVztRQUNoQixJQUFJLENBQUNuQyxpQkFBaUIsQ0FBQ3RxQixJQUFJO0lBQzdCO0lBQ0Ewc0IsU0FBUztRQUNQLElBQUksQ0FBQ3BDLGlCQUFpQixDQUFDcGdDLE9BQU8sR0FBRztJQUNuQztJQUNBeWlDLFVBQVU7UUFDUixJQUFJLENBQUNyQyxpQkFBaUIsQ0FBQ3BnQyxPQUFPLEdBQUc7SUFDbkM7SUFDQSxhQUFhLEdBQ2J1aUMsY0FBYztRQUNaLElBQUksSUFBSSxDQUFDRyxlQUFlLEVBQUU7WUFDeEJoTCxjQUFjLElBQUksQ0FBQ2dMLGVBQWU7UUFDcEM7SUFDRjtJQUNBLGNBQWMsR0FDZEMsb0JBQW9CbkQsYUFBYSxFQUFFO1FBQ2pDLElBQUlBLGNBQWM1Z0QsVUFBVSxFQUFFO1lBQzVCLElBQUksQ0FBQ3ZCLEdBQUcsR0FBR2tFLFVBQVVpK0MsY0FBYzVnRCxVQUFVO1FBQy9DO1FBQ0EsSUFBSTRnRCxjQUFjVyxlQUFlLEVBQUU7WUFDakMsSUFBSSxDQUFDQSxlQUFlLEdBQUdYLGNBQWNXLGVBQWU7UUFDdEQ7SUFDRjtJQUNBK0IsZUFBZXBCLE9BQU8sRUFBRTtRQUN0QixJQUFJQSxtQkFBbUI4QixrQkFBa0I7WUFDdkMsMENBQTBDO1lBQzFDLElBQUlDLGNBQWM7WUFDbEIvQixRQUFRZ0MsS0FBSztZQUNiekQsaUJBQWlCN2pELE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ3ZCLElBQUksQ0FBQ0EsRUFBRTBsRCxhQUFhLEVBQUU7b0JBQ3BCMEIsY0FBYztnQkFDaEI7WUFDRjtZQUNBLElBQUlBLGFBQWE7Z0JBQ2Z4RCxpQkFBaUI3NUMsSUFBSSxDQUFDczdDO1lBQ3hCO1FBQ0Y7SUFDRjtJQUNBWiw2QkFBNkI7UUFDM0IsT0FBT3QzQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQ2kzQixjQUFjLEdBQUc5L0MsU0FBU2tnRCxlQUFlLEtBQUs7UUFDckQ7SUFDRjtJQUNBaUIsMkJBQTJCO1FBQ3pCLElBQUk2QixTQUFTO1lBQ1gsSUFBSSxDQUFDbEQsY0FBYyxHQUFHOS9DLFNBQVNrZ0QsZUFBZSxLQUFLO1lBQ25EbGdELFNBQVM2dUIsZ0JBQWdCLENBQUMsb0JBQW9CLElBQUksQ0FBQ214Qiw0QkFBNEI7UUFDakYsT0FBTztZQUNMLElBQUksQ0FBQ0YsY0FBYyxHQUFHO1FBQ3hCO0lBQ0Y7SUFDQXlDLDhCQUE4QjtRQUM1QixJQUFJUyxTQUFTO1lBQ1hoakQsU0FBUyt1QixtQkFBbUIsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDaXhCLDRCQUE0QjtRQUNwRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTc0IsZ0JBQWdCdHZCLEtBQUssRUFBRSt1QixPQUFPO0lBQ3JDLElBQUlrQztJQUNKLElBQUlsQyxRQUFRUyxTQUFTLFlBQVkxcUIsYUFBYTtRQUM1Q21zQixjQUFjbEMsUUFBUVMsU0FBUztJQUNqQyxPQUFPO1FBQ0x5QixjQUFjLElBQUluc0I7SUFDcEI7SUFDQSx3Q0FBd0M7SUFDeEMsSUFBSW9zQjtJQUNKLElBQUlseEIsTUFBTXBkLElBQUksS0FBSyxTQUFTO1FBQzFCc3VDLGlCQUFpQkQsWUFBWXJ0QixjQUFjO0lBQzdDLE9BQU87UUFDTHN0QixpQkFBaUJELFlBQVlwdEIsY0FBYztJQUM3QztJQUNBLElBQUksQ0FBQ3F0QixlQUFlNXVCLFFBQVEsQ0FBQ3RDLFFBQVE7UUFDbkNreEIsZUFBZXpuRCxPQUFPLENBQUMwbkQsQ0FBQUE7WUFDckJGLFlBQVl4cUIsV0FBVyxDQUFDMHFCO1FBQzFCO1FBQ0FGLFlBQVkzcUIsUUFBUSxDQUFDdEc7SUFDdkI7SUFDQSxJQUFJLENBQUNveEIsY0FBYyxDQUFFckMsQ0FBQUEsbUJBQW1Cc0MsZ0JBQWUsR0FBSTtRQUN6RCxnR0FBZ0c7UUFDaEcsZ0VBQWdFO1FBQ2hFLHNJQUFzSTtRQUN0SXRDLFFBQVF1QyxRQUFRLEdBQUc7SUFDckI7SUFDQSxxSEFBcUg7SUFDckh2QyxRQUFRLytCLEtBQUssR0FBR2loQyxZQUFZcnRCLGNBQWMsR0FBRzcyQixNQUFNLEtBQUs7SUFDeEQsSUFBSWdpRCxtQkFBbUJzQyxrQkFBa0I7UUFDdkN0QyxRQUFRd0MsV0FBVyxHQUFHO0lBQ3hCO0lBQ0EsZ0JBQWdCO0lBQ2hCLElBQUl4QyxRQUFRUyxTQUFTLEtBQUt5QixhQUFhO1FBQ3JDbEMsUUFBUVMsU0FBUyxHQUFHeUI7UUFDcEIsSUFBSSxDQUFDRyxjQUFjSSxXQUFVLEtBQU16QyxtQkFBbUJzQyxrQkFBa0I7WUFDdEUsbUZBQW1GO1lBQ25GLHdCQUF3QjtZQUN4QixzRUFBc0U7WUFDdEUsK0RBQStEO1lBQy9ELDJDQUEyQztZQUMzQyxtREFBbUQ7WUFDbkR4TSxXQUFXO2dCQUNUa0ssUUFBUVMsU0FBUyxHQUFHeUI7Z0JBQ3BCLDZDQUE2QztnQkFDN0Msa0VBQWtFO2dCQUNsRSwrQ0FBK0M7Z0JBQy9DbEMsUUFBUVksSUFBSSxHQUFHNWhCLEtBQUssQ0FBQztnQkFDbkIsZUFBZSxHQUNqQjtZQUNGLEdBQUc7UUFDTDtJQUNGO0FBQ0Y7QUFDQSxjQUFjLEdBQ2QsU0FBU21pQixZQUFZbHdCLEtBQUssRUFBRSt1QixPQUFPO0lBQ2pDLElBQUlBLFFBQVFTLFNBQVMsWUFBWTFxQixhQUFhO1FBQzVDLE1BQU1tc0IsY0FBY2xDLFFBQVFTLFNBQVM7UUFDckN5QixZQUFZeHFCLFdBQVcsQ0FBQ3pHO1FBQ3hCLElBQUlpeEIsWUFBWW50QixTQUFTLEdBQUcvMkIsTUFBTSxHQUFHLEdBQUc7WUFDdENnaUQsUUFBUVMsU0FBUyxHQUFHeUI7UUFDdEIsT0FBTztZQUNMbEMsUUFBUVMsU0FBUyxHQUFHO1FBQ3RCO0lBQ0Y7QUFDRjtBQUNDLFVBQVVqQyxLQUFLO0lBQ2QsSUFBSTBCO0lBQ0gsVUFBVUEsSUFBSTtRQUNiQSxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ2hCQSxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ2hCQSxJQUFJLENBQUMsVUFBVSxHQUFHO0lBQ3BCLEdBQUdBLE9BQU8xQixNQUFNMEIsSUFBSSxJQUFLMUIsQ0FBQUEsTUFBTTBCLElBQUksR0FBRyxDQUFDO0lBQ3ZDLElBQUlWO0lBQ0gsVUFBVUEsTUFBTTtRQUNmQSxNQUFNLENBQUMsU0FBUyxHQUFHO1FBQ25CQSxNQUFNLENBQUMsYUFBYSxHQUFHO1FBQ3ZCQSxNQUFNLENBQUMsY0FBYyxHQUFHO1FBQ3hCQSxNQUFNLENBQUMsbUJBQW1CLEdBQUc7UUFDN0JBLE1BQU0sQ0FBQyxVQUFVLEdBQUc7SUFDdEIsR0FBR0EsU0FBU2hCLE1BQU1nQixNQUFNLElBQUtoQixDQUFBQSxNQUFNZ0IsTUFBTSxHQUFHLENBQUM7SUFDN0MsSUFBSWtEO0lBQ0gsVUFBVXRKLFdBQVc7UUFDcEJBLFdBQVcsQ0FBQyxTQUFTLEdBQUc7UUFDeEJBLFdBQVcsQ0FBQyxTQUFTLEdBQUc7UUFDeEJBLFdBQVcsQ0FBQyxVQUFVLEdBQUc7SUFDM0IsR0FBR3NKLGdCQUFnQmxFLE1BQU1wRixXQUFXLElBQUtvRixDQUFBQSxNQUFNcEYsV0FBVyxHQUFHLENBQUM7SUFDOUQsY0FBYyxHQUNkLFNBQVN1SixZQUFZM25ELENBQUM7UUFDcEIsT0FBUUE7WUFDTixLQUFLa2xELEtBQUswQyxLQUFLO2dCQUNiLE9BQU9ubEMsVUFBVXVELEtBQUs7WUFDeEIsS0FBS2svQixLQUFLQyxLQUFLO2dCQUNiLE9BQU8xaUMsVUFBVW9sQyxLQUFLO1lBQ3hCO2dCQUNFLHFDQUFxQztnQkFDckMsT0FBT3BsQyxVQUFVcWxDLElBQUk7UUFDekI7SUFDRjtJQUNBdEUsTUFBTW1FLFdBQVcsR0FBR0E7SUFDcEIsY0FBYyxHQUNkLFNBQVNJLGNBQWNyL0MsQ0FBQztRQUN0QixPQUFRQTtZQUNOLEtBQUsrWixVQUFVdUQsS0FBSztnQkFDbEIsT0FBT2svQixLQUFLMEMsS0FBSztZQUNuQixLQUFLbmxDLFVBQVVvbEMsS0FBSztnQkFDbEIsT0FBTzNDLEtBQUtDLEtBQUs7WUFDbkI7Z0JBQ0UsT0FBT0QsS0FBS1QsT0FBTztRQUN2QjtJQUNGO0lBQ0FqQixNQUFNdUUsYUFBYSxHQUFHQTtJQUN0QixjQUFjLEdBQ2QsU0FBU0MsY0FBY255QyxDQUFDO1FBQ3RCLE9BQVFBO1lBQ04sS0FBSzJ1QyxPQUFPeUQsTUFBTTtnQkFDaEIsT0FBT3ZsQyxZQUFZd2xDLE1BQU07WUFDM0IsS0FBSzFELE9BQU8yRCxVQUFVO2dCQUNwQixPQUFPemxDLFlBQVkwbEMsVUFBVTtZQUMvQixLQUFLNUQsT0FBTzZELFdBQVc7Z0JBQ3JCLE9BQU8zbEMsWUFBWTRsQyxZQUFZO1lBQ2pDLEtBQUs5RCxPQUFPK0QsZ0JBQWdCO2dCQUMxQixPQUFPN2xDLFlBQVk4bEMsa0JBQWtCO1lBQ3ZDO2dCQUNFLE9BQU85bEMsWUFBWTRELE9BQU87UUFDOUI7SUFDRjtJQUNBazlCLE1BQU13RSxhQUFhLEdBQUdBO0lBQ3RCLGNBQWMsR0FDZCxTQUFTUyxnQkFBZ0I1eUMsQ0FBQztRQUN4QixPQUFRQTtZQUNOLEtBQUs2TSxZQUFZd2xDLE1BQU07Z0JBQ3JCLE9BQU8xRCxPQUFPeUQsTUFBTTtZQUN0QixLQUFLdmxDLFlBQVkwbEMsVUFBVTtnQkFDekIsT0FBTzVELE9BQU8yRCxVQUFVO1lBQzFCLEtBQUt6bEMsWUFBWTRsQyxZQUFZO2dCQUMzQixPQUFPOUQsT0FBTzZELFdBQVc7WUFDM0IsS0FBSzNsQyxZQUFZOGxDLGtCQUFrQjtnQkFDakMsT0FBT2hFLE9BQU8rRCxnQkFBZ0I7WUFDaEM7Z0JBQ0UsT0FBTy9ELE9BQU9DLE9BQU87UUFDekI7SUFDRjtJQUNBakIsTUFBTWlGLGVBQWUsR0FBR0E7SUFDeEIsY0FBYyxHQUNkLFNBQVNDLHFCQUFxQjd5QyxDQUFDO1FBQzdCLE9BQVFBO1lBQ04sS0FBS3VvQyxZQUFZeUQsTUFBTTtnQkFDckIsT0FBTzZGLGNBQWM1RCxNQUFNO1lBQzdCLEtBQUsxRixZQUFZdUssTUFBTTtnQkFDckIsT0FBT2pCLGNBQWNrQixNQUFNO1lBQzdCO2dCQUNFLE9BQU9sQixjQUFjakQsT0FBTztRQUNoQztJQUNGO0lBQ0FqQixNQUFNa0Ysb0JBQW9CLEdBQUdBO0FBQy9CLEdBQUdsRixTQUFVQSxDQUFBQSxRQUFRLENBQUM7QUFFdEIsU0FBU3FGLG9CQUFvQnIrQyxPQUFPLEVBQUVzK0MsYUFBYSxFQUFFQyxhQUFhO0lBQ2hFLElBQUk3OEM7SUFDSixNQUFNK3NDLE9BQU8sQ0FBQy9zQyxLQUFLazNDLFVBQVU1NEMsUUFBTyxNQUFPLFFBQVEwQixPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDO0lBQ3pFLElBQUkrc0MsS0FBS3RoQixLQUFLLEtBQUssTUFBTXNoQixLQUFLdGhCLEtBQUssR0FBRyxDQUFDO0lBQ3ZDLElBQUlzaEIsS0FBS3BoQixLQUFLLEtBQUssTUFBTW9oQixLQUFLcGhCLEtBQUssR0FBRyxDQUFDO0lBQ3ZDLGVBQWU7SUFDZixJQUFJb2hCLEtBQUt0aEIsS0FBSyxFQUFFO1FBQ2RxeEIsOEJBQThCL1AsS0FBS3RoQixLQUFLLEVBQUVteEI7SUFDNUM7SUFDQSxJQUFJN1AsS0FBS3BoQixLQUFLLEVBQUU7UUFDZG14Qiw4QkFBOEIvUCxLQUFLcGhCLEtBQUssRUFBRWt4QjtJQUM1QztJQUNBLE9BQU85UDtBQUNUO0FBQ0EsU0FBUytQLDhCQUE4QkMsVUFBVSxFQUFFQyxhQUFhO0lBQzlEcHBELE9BQU9DLElBQUksQ0FBQ21wRCxlQUFleHBELE9BQU8sQ0FBQ2lhLENBQUFBO1FBQ2pDLElBQUlzdkMsVUFBVSxDQUFDdHZDLElBQUksS0FBS2hYLFdBQVdzbUQsVUFBVSxDQUFDdHZDLElBQUksR0FBR3V2QyxhQUFhLENBQUN2dkMsSUFBSTtJQUN6RTtJQUNBLE9BQU9zdkM7QUFDVDtBQUNBLFNBQVNFLHNCQUFzQjMrQyxPQUFPO0lBQ3BDLE1BQU1pdEIsY0FBYyxDQUFDO0lBQ3JCLElBQUlqdEIsUUFBUXF0QixLQUFLLEVBQUU7UUFDakIsd0JBQXdCO1FBQ3hCLElBQUksT0FBT3J0QixRQUFRcXRCLEtBQUssS0FBSyxVQUFVO1lBQ3JDLE1BQU11eEIsZUFBZSxDQUFDO1lBQ3RCLE1BQU0zd0MsU0FBUzJ3QztZQUNmLE1BQU1sckMsU0FBUzFULFFBQVFxdEIsS0FBSztZQUM1Qi8zQixPQUFPQyxJQUFJLENBQUNtZSxRQUFReGUsT0FBTyxDQUFDaWEsQ0FBQUE7Z0JBQzFCLE9BQVFBO29CQUNOLEtBQUs7d0JBQ0gsaUNBQWlDO3dCQUNqQ3F2Qyw4QkFBOEJ2d0MsUUFBUXlGLE9BQU82OUIsVUFBVTt3QkFDdkQ7b0JBQ0Y7d0JBQ0V0akMsTUFBTSxDQUFDa0IsSUFBSSxHQUFHdUUsTUFBTSxDQUFDdkUsSUFBSTtnQkFDN0I7WUFDRjtZQUNBOGQsWUFBWUksS0FBSyxHQUFHdXhCO1FBQ3RCLE9BQU87WUFDTDN4QixZQUFZSSxLQUFLLEdBQUdydEIsUUFBUXF0QixLQUFLO1FBQ25DO0lBQ0YsT0FBTztRQUNMSixZQUFZSSxLQUFLLEdBQUc7SUFDdEI7SUFDQSxJQUFJcnRCLFFBQVFtdEIsS0FBSyxFQUFFO1FBQ2pCLElBQUksT0FBT250QixRQUFRbXRCLEtBQUssS0FBSyxVQUFVO1lBQ3JDRixZQUFZRSxLQUFLLEdBQUdudEIsUUFBUW10QixLQUFLO1FBQ25DLE9BQU87WUFDTEYsWUFBWUUsS0FBSyxHQUFHO1FBQ3RCO0lBQ0YsT0FBTztRQUNMRixZQUFZRSxLQUFLLEdBQUc7SUFDdEI7SUFDQSxPQUFPRjtBQUNUO0FBQ0E7OztDQUdDLEdBQ0QsU0FBUzR4QixjQUFjcHpCLEtBQUs7SUFDMUIsSUFBSXF6QixhQUFhaG5ELFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3JGLE9BQU93cUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxNQUFNeThCLE1BQU1DO1FBQ1osSUFBSUQsS0FBSztZQUNQLE1BQU1FLFdBQVdGLElBQUlHLGNBQWM7WUFDbkNELFNBQVNFLE9BQU8sR0FBRztZQUNuQixNQUFNQyxlQUFlSCxTQUFTSSxpQkFBaUI7WUFDL0MsTUFBTUMsWUFBWSxJQUFJcDNDLFdBQVdrM0M7WUFDakMsTUFBTTFyQyxTQUFTcXJDLElBQUlRLHVCQUF1QixDQUFDLElBQUlodkIsWUFBWTtnQkFBQzlFLE1BQU00dUIsZ0JBQWdCO2FBQUM7WUFDbkYzbUMsT0FBTzhyQyxPQUFPLENBQUNQO1lBQ2YsTUFBTVEsTUFBTVg7WUFDWkcsU0FBU1MscUJBQXFCLENBQUNKO1lBQy9CLE1BQU1LLFlBQVlMLFVBQVV6eEIsSUFBSSxDQUFDK3hCLENBQUFBLFNBQVVBLFdBQVcsT0FBT0EsV0FBVztZQUN4RWIsSUFBSWMsS0FBSztZQUNULE9BQU8sQ0FBQ0Y7UUFDVjtRQUNBLE9BQU87SUFDVDtBQUNGO0FBQ0E7O0NBRUMsR0FDRCxTQUFTWDtJQUNQLE1BQU1waUIsZ0JBQ04sYUFBYTtJQUNiLE1BQWtCLElBQWdCM21DLENBQUFBLENBQWdEO0lBQ2xGLElBQUkybUMsZUFBYztRQUNoQixPQUFPLElBQUlBLGNBQWE7WUFDdEJrakIsYUFBYTtRQUNmO0lBQ0Y7QUFDRjtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsYUFBYXJzQyxNQUFNO0lBQzFCLElBQUlBLFdBQVdzbEMsTUFBTWdCLE1BQU0sQ0FBQzJELFVBQVUsRUFBRTtRQUN0QyxPQUFPO0lBQ1QsT0FBTyxJQUFJanFDLFdBQVdzbEMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU0sRUFBRTtRQUN6QyxPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU90bEQ7SUFDVDtBQUNGO0FBQ0E7O0NBRUMsR0FDRCxTQUFTNm5ELHlDQUF5Q2hnRCxPQUFPO0lBQ3ZELElBQUkwQixJQUFJOFU7SUFDUixJQUFJeXBDLG1CQUFtQixDQUFDditDLEtBQUsxQixRQUFRcXRCLEtBQUssTUFBTSxRQUFRM3JCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQzdFLHNCQUFzQjtJQUN0QixJQUFJMUIsUUFBUXV4QyxVQUFVLElBQUl2eEMsUUFBUXV4QyxVQUFVLENBQUM3MUIsS0FBSyxHQUFHLEtBQUsxYixRQUFRdXhDLFVBQVUsQ0FBQzUxQixNQUFNLEdBQUcsR0FBRztRQUN2RnNrQyxtQkFBbUIsT0FBT0EscUJBQXFCLFlBQVksQ0FBQyxJQUFJQTtRQUNoRSxJQUFJcEQsWUFBWTtZQUNkb0QsbUJBQW1CM3FELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRzJnRCxtQkFBbUI7Z0JBQ3BFdmtDLE9BQU87b0JBQ0w5QixLQUFLNVosUUFBUXV4QyxVQUFVLENBQUM3MUIsS0FBSztnQkFDL0I7Z0JBQ0FDLFFBQVE7b0JBQ04vQixLQUFLNVosUUFBUXV4QyxVQUFVLENBQUM1MUIsTUFBTTtnQkFDaEM7Z0JBQ0FpRixXQUFXNWdCLFFBQVF1eEMsVUFBVSxDQUFDM3dCLFNBQVM7WUFDekM7UUFDRixPQUFPO1lBQ0xxL0IsbUJBQW1CM3FELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRzJnRCxtQkFBbUI7Z0JBQ3BFdmtDLE9BQU87b0JBQ0wrUSxPQUFPenNCLFFBQVF1eEMsVUFBVSxDQUFDNzFCLEtBQUs7Z0JBQ2pDO2dCQUNBQyxRQUFRO29CQUNOOFEsT0FBT3pzQixRQUFRdXhDLFVBQVUsQ0FBQzUxQixNQUFNO2dCQUNsQztnQkFDQWlGLFdBQVc1Z0IsUUFBUXV4QyxVQUFVLENBQUMzd0IsU0FBUztZQUN6QztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x1TSxPQUFPLENBQUMzVyxLQUFLeFcsUUFBUW10QixLQUFLLE1BQU0sUUFBUTNXLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQzdENlcsT0FBTzR5QjtRQUNQLG1FQUFtRTtRQUNuRUMsWUFBWWxnRCxRQUFRa2dELFVBQVU7UUFDOUJDLG9CQUFvQm5nRCxRQUFRbWdELGtCQUFrQjtRQUM5Q0Msa0JBQWtCcGdELFFBQVFvZ0QsZ0JBQWdCO1FBQzFDQyxhQUFhcmdELFFBQVFxZ0QsV0FBVztJQUNsQztBQUNGO0FBQ0EsU0FBU0MsMkJBQTJCbGxDLFFBQVE7SUFDMUMsTUFBTTRqQixRQUFRNWpCLFNBQVM5SyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ3RELFdBQVc7SUFDaEQsSUFBSSxDQUFDMGtDLFlBQVkzakIsUUFBUSxDQUFDaVIsUUFBUTtRQUNoQyxNQUFNL2hDLE1BQU0sOEJBQThCOEQsTUFBTSxDQUFDaStCO0lBQ25EO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVN1aEIsd0JBQXdCNWxDLE1BQU07SUFDckMsTUFBTTZsQyxRQUFRLEVBQUU7SUFDaEI3bEMsT0FBT3psQixPQUFPLENBQUN1MkIsQ0FBQUE7UUFDYixJQUFJQSxNQUFNQSxLQUFLLEtBQUt0ekIsV0FBVztZQUM3QnFvRCxNQUFNdGhELElBQUksQ0FBQyxJQUFJNjFDLHVCQUF1QjtnQkFDcEMxNUIsS0FBS29RLE1BQU1BLEtBQUssQ0FBQzZ1QixhQUFhO2dCQUM5Qjd1QixPQUFPQSxNQUFNZzFCLFNBQVM7WUFDeEI7UUFDRjtJQUNGO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLFNBQVNyRyx1QkFBdUIxdUIsS0FBSztJQUNuQyxJQUFJQSxpQkFBaUJ1dEIsT0FBTztRQUMxQixPQUFPO1lBQ0x6QyxVQUFVOXFCLE1BQU03UyxHQUFHO1lBQ25COG5DLGFBQWFqMUIsTUFBTS9YLE1BQU07WUFDekJpdEMsWUFBWWwxQixNQUFNMnRCLE9BQU87WUFDekJ3SCxjQUFjbjFCLE1BQU00dUIsZ0JBQWdCLENBQUMzZ0MsT0FBTztZQUM1Q21uQyxXQUFXcDFCLE1BQU1wZCxJQUFJO1FBQ3ZCO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTGtvQyxVQUFVOXFCLE1BQU04cUIsUUFBUTtZQUN4QnVLLFdBQVdyMUIsTUFBTXExQixTQUFTO1lBQzFCcjFCLE9BQU9BLE1BQU1BLEtBQUssR0FBRzB1Qix1QkFBdUIxdUIsTUFBTUEsS0FBSyxJQUFJdHpCO1lBQzNEeW9ELGNBQWNuMUIsTUFBTXMxQixTQUFTO1lBQzdCQyxnQkFBZ0J2MUIsTUFBTXcxQixXQUFXO1lBQ2pDQyxlQUFlejFCLE1BQU1yUSxRQUFRO1FBQy9CO0lBQ0Y7QUFDRjtBQUVBLE1BQU0rbEMsWUFBWTtBQUNsQixNQUFNQyxpQkFBaUI7QUFDdkIsU0FBU0MsZUFBZWx4QyxNQUFNO0lBQzVCLE1BQU1vdEIsUUFBUXB0QixPQUFPRyxLQUFLLENBQUM2d0M7SUFDM0IsSUFBSTVqQixNQUFNL2tDLE1BQU0sR0FBRyxHQUFHO1FBQ3BCLE9BQU87WUFBQytrQyxLQUFLLENBQUMsRUFBRTtZQUFFcHRCLE9BQU80MUIsTUFBTSxDQUFDeEksS0FBSyxDQUFDLEVBQUUsQ0FBQy9rQyxNQUFNLEdBQUc7U0FBRztJQUN2RDtJQUNBLE9BQU87UUFBQzJYO1FBQVE7S0FBRztBQUNyQjtBQUNBLFNBQVNzdkMsTUFBTXZnQyxRQUFRO0lBQ3JCLE9BQU9vRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ3JDLE9BQU8sSUFBSU8sUUFBUUQsQ0FBQUEsVUFBV3N1QixlQUFlWixVQUFVLENBQUMxdEIsU0FBUzFEO0lBQ25FO0FBQ0Y7QUFDQSxjQUFjLEdBQ2QsU0FBU29pQztJQUNQLE9BQU8sb0JBQW9CcDRCLGtCQUFrQjN5QixTQUFTO0FBQ3hEO0FBQ0EsY0FBYyxHQUNkLFNBQVNnckQ7SUFDUCxPQUFPLGNBQWNyNEIsa0JBQWtCM3lCLFNBQVM7QUFDbEQ7QUFDQSxTQUFTaXJEO0lBQ1AsT0FBTyxPQUFPQyxtQkFBbUJ0cEQsYUFBYSxPQUFPdXBELHlCQUF5QnZwRDtBQUNoRjtBQUNBLFNBQVN3cEQ7SUFDUCxPQUFPTDtBQUNUO0FBQ0EsU0FBU007SUFDUCxJQUFJLENBQUUsc0JBQXFCbnZCLFlBQVcsR0FBSTtRQUN4QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJb3FCLFlBQVk7UUFDZCxpRkFBaUY7UUFDakYsT0FBTztJQUNUO0lBQ0EsTUFBTWdGLGVBQWVwdkIsYUFBYXF2QixlQUFlLENBQUM7SUFDbEQsSUFBSUMsU0FBUztJQUNiLElBQUlGLGNBQWM7UUFDaEIsS0FBSyxNQUFNN2lCLFNBQVM2aUIsYUFBYTlsQyxNQUFNLENBQUU7WUFDdkMsSUFBSWlqQixNQUFNNWpCLFFBQVEsS0FBSyxhQUFhO2dCQUNsQzJtQyxTQUFTO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNDO0lBQ1AsSUFBSSxDQUFFLHNCQUFxQnZ2QixZQUFXLEdBQUk7UUFDeEMsT0FBTztJQUNUO0lBQ0EsSUFBSXdxQixhQUFhO1FBQ2YsMEVBQTBFO1FBQzFFLHVEQUF1RDtRQUN2RCxPQUFPO0lBQ1Q7SUFDQSxJQUFJSixZQUFZO1FBQ2QsTUFBTXgrQixVQUFVb3lCO1FBQ2hCLElBQUksQ0FBQ3B5QixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXhELE9BQU8sS0FBS29uQyxnQkFBZ0I1akMsUUFBUXhELE9BQU8sRUFBRSxRQUFRLEdBQUc7WUFDckgsMkNBQTJDO1lBQzNDLE9BQU87UUFDVDtJQUNGO0lBQ0EsTUFBTWduQyxlQUFlcHZCLGFBQWFxdkIsZUFBZSxDQUFDO0lBQ2xELElBQUlJLFNBQVM7SUFDYixJQUFJTCxjQUFjO1FBQ2hCLEtBQUssTUFBTTdpQixTQUFTNmlCLGFBQWE5bEMsTUFBTSxDQUFFO1lBQ3ZDLElBQUlpakIsTUFBTTVqQixRQUFRLEtBQUssYUFBYTtnQkFDbEM4bUMsU0FBUztnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTQyxXQUFXbmpCLEtBQUs7SUFDdkIsT0FBT0EsVUFBVSxTQUFTQSxVQUFVO0FBQ3RDO0FBQ0EsU0FBU29qQixrQkFBa0JyRyxHQUFHO0lBQzVCLElBQUksQ0FBQ3RpRCxVQUFVO1FBQ2IsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDc2lELEtBQUs7UUFDUkEsTUFBTXRpRCxTQUFTcWhELGFBQWEsQ0FBQztJQUMvQjtJQUNBLE9BQU8sZUFBZWlCO0FBQ3hCO0FBQ0EsTUFBTXNHLDhCQUE4QjtJQUNsQ0MsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFNBQVM7QUFDWDtBQUNBLFNBQVNDLDRCQUE0QnZ4QixXQUFXO0lBQzlDLElBQUksQ0FBQ3VyQixTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFFLDBCQUF5QnZyQixXQUFVLEdBQUk7UUFDM0MsT0FBTztJQUNUO0lBQ0EsTUFBTTdTLFVBQVVveUI7SUFDaEIsSUFBSSxDQUFFcHlCLENBQUFBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRdmxCLElBQUksS0FBSyxDQUFDdWxCLFFBQVF4RCxPQUFPLEVBQUU7UUFDekYsc0JBQXNCO1FBQ3RCLE9BQU87SUFDVDtJQUNBLE1BQU1yYyxJQUFJNmpELDJCQUEyQixDQUFDaGtDLFFBQVF2bEIsSUFBSSxDQUFDO0lBQ25ELElBQUkwRixHQUFHO1FBQ0wsT0FBT3lqRCxnQkFBZ0I1akMsUUFBUXhELE9BQU8sRUFBRXJjLE1BQU07SUFDaEQ7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTa2tEO0lBQ1AsT0FBT3BCLHlCQUF5QkM7QUFDbEM7QUFDQSxTQUFTdEU7SUFDUCxJQUFJdjdDO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUsrdUMsWUFBVyxNQUFPLFFBQVEvdUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNUksSUFBSSxNQUFNO0FBQ2hGO0FBQ0EsU0FBUzZwRDtJQUNQLElBQUlqaEQ7SUFDSixPQUFPLENBQUMsQ0FBQ0EsS0FBSyt1QyxZQUFXLE1BQU8sUUFBUS91QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc1SSxJQUFJLE1BQU07QUFDaEY7QUFDQSxTQUFTK2pEO0lBQ1AsSUFBSW43QztJQUNKLE9BQU8sQ0FBQyxDQUFDQSxLQUFLK3VDLFlBQVcsTUFBTyxRQUFRL3VDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzVJLElBQUksTUFBTTtBQUNoRjtBQUNBLFNBQVM4cEQ7SUFDUCxNQUFNamdELElBQUk4dEM7SUFDVixPQUFPLENBQUM5dEMsTUFBTSxRQUFRQSxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUU3SixJQUFJLE1BQU0sWUFBWTZKLEVBQUVrWSxPQUFPLENBQUM1ZSxVQUFVLENBQUM7QUFDN0Y7QUFDQSxTQUFTNG1EO0lBQ1AsSUFBSSxDQUFDcEcsU0FBUyxPQUFPO0lBQ3JCLE9BQU8sd0NBQXdDcmxELElBQUksQ0FBQ0QsVUFBVUUsU0FBUztBQUN6RTtBQUNBLFNBQVNvbEQ7SUFDUCxPQUFPLE9BQU9oakQsYUFBYTtBQUM3QjtBQUNBLFNBQVNxcEQ7SUFDUCwrRkFBK0Y7SUFDL0YsT0FBTzNyRCxVQUFVNHJELE9BQU8sSUFBSTtBQUM5QjtBQUNBLFNBQVNDLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsUUFBUSxDQUFDMzNCLFFBQVEsQ0FBQyxxQkFBcUIwM0IsVUFBVUMsUUFBUSxDQUFDMzNCLFFBQVEsQ0FBQztBQUN0RjtBQUNBLFNBQVM0M0I7SUFDUCx1Q0FBdUM7SUFDdkMsYUFBYTtJQUNiLElBQUlqdEQsVUFBVUEsT0FBT2t0RCx3QkFBd0IsRUFBRTtRQUM3QyxhQUFhO1FBQ2IsT0FBT2x0RCxPQUFPa3RELHdCQUF3QjtJQUN4QztJQUNBLE9BQU9qckQ7QUFDVDtBQUNBLFNBQVNrckQ7SUFDUCxJQUFJLENBQUNQLGlCQUFpQjtRQUNwQixPQUFPM3FEO0lBQ1Q7SUFDQSxJQUFJd0QsT0FBT3duRDtJQUNYLElBQUl4bkQsTUFBTTtRQUNSLE9BQU9BLEtBQUsybkQsUUFBUTtJQUN0QjtJQUNBLE9BQU9uckQ7QUFDVDtBQUNBLFNBQVNvckQ7SUFDUCxJQUFJOUcsU0FBUztRQUNYLE9BQU94bUQsT0FBT3V0RCxnQkFBZ0I7SUFDaEM7SUFDQSxJQUFJVixpQkFBaUI7UUFDbkIsSUFBSW5uRCxPQUFPd25EO1FBQ1gsSUFBSXhuRCxNQUFNO1lBQ1IsT0FBT0EsS0FBSzZuRCxnQkFBZ0I7UUFDOUI7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVN2QixnQkFBZ0J3QixFQUFFLEVBQUVDLEVBQUU7SUFDN0IsTUFBTUMsU0FBU0YsR0FBR256QyxLQUFLLENBQUM7SUFDeEIsTUFBTXN6QyxTQUFTRixHQUFHcHpDLEtBQUssQ0FBQztJQUN4QixNQUFNOWEsSUFBSThQLEtBQUtxVSxHQUFHLENBQUNncUMsT0FBT25yRCxNQUFNLEVBQUVvckQsT0FBT3ByRCxNQUFNO0lBQy9DLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJL0MsR0FBRyxFQUFFK0MsRUFBRztRQUMxQixNQUFNc3JELEtBQUtqMEMsU0FBUyt6QyxNQUFNLENBQUNwckQsRUFBRSxFQUFFO1FBQy9CLE1BQU11ckQsS0FBS2wwQyxTQUFTZzBDLE1BQU0sQ0FBQ3JyRCxFQUFFLEVBQUU7UUFDL0IsSUFBSXNyRCxLQUFLQyxJQUFJLE9BQU87UUFDcEIsSUFBSUQsS0FBS0MsSUFBSSxPQUFPLENBQUM7UUFDckIsSUFBSXZyRCxNQUFNL0MsSUFBSSxLQUFLcXVELE9BQU9DLElBQUksT0FBTztJQUN2QztJQUNBLElBQUlMLE9BQU8sTUFBTUMsT0FBTyxJQUFJO1FBQzFCLE9BQU8sQ0FBQztJQUNWLE9BQU8sSUFBSUEsT0FBTyxJQUFJO1FBQ3BCLE9BQU87SUFDVDtJQUNBLE9BQU9DLE9BQU9uckQsTUFBTSxJQUFJb3JELE9BQU9wckQsTUFBTSxHQUFHLElBQUltckQsT0FBT25yRCxNQUFNLEdBQUdvckQsT0FBT3ByRCxNQUFNLEdBQUcsQ0FBQyxJQUFJO0FBQ25GO0FBQ0EsU0FBU3VyRCxtQkFBbUJsb0QsT0FBTztJQUNqQyxLQUFLLE1BQU1tb0QsU0FBU25vRCxRQUFTO1FBQzNCbW9ELE1BQU0vMUMsTUFBTSxDQUFDZzJDLFlBQVksQ0FBQ0Q7SUFDNUI7QUFDRjtBQUNBLFNBQVNFLG1CQUFtQnJvRCxPQUFPO0lBQ2pDLEtBQUssTUFBTW1vRCxTQUFTbm9ELFFBQVM7UUFDM0Jtb0QsTUFBTS8xQyxNQUFNLENBQUNrMkMsdUJBQXVCLENBQUNIO0lBQ3ZDO0FBQ0Y7QUFDQSxJQUFJSSxpQkFBaUI7QUFDckIsTUFBTUMsb0JBQW9CO0lBQ3hCLElBQUksQ0FBQ0QsZ0JBQWdCQSxpQkFBaUIsSUFBSTNDLGVBQWVzQztJQUN6RCxPQUFPSztBQUNUO0FBQ0EsSUFBSUUsdUJBQXVCO0FBQzNCLE1BQU1DLDBCQUEwQjtJQUM5QixJQUFJLENBQUNELHNCQUFzQjtRQUN6QkEsdUJBQXVCLElBQUk1QyxxQkFBcUJ3QyxvQkFBb0I7WUFDbEVydEQsTUFBTTtZQUNOMnRELFlBQVk7UUFDZDtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNHO0lBQ1AsSUFBSS9pRDtJQUNKLE1BQU0vRixPQUFPLElBQUlvaUIsV0FBVztRQUMxQkMsS0FBS0MsZUFBZXltQyxFQUFFO1FBQ3RCOW1DLFVBQVVxekI7UUFDVnAyQjtJQUNGO0lBQ0EsSUFBSWlvQyxpQkFBaUI7UUFDbkJubkQsS0FBS3VpQixFQUFFLEdBQUcsQ0FBQ3hjLEtBQUsyaEQsa0JBQWlCLE1BQU8sUUFBUTNoRCxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN2RTtJQUNBLE9BQU8vRjtBQUNUO0FBQ0EsSUFBSWdwRDtBQUNKLFNBQVNDO0lBQ1AsSUFBSSxDQUFDRCx1QkFBdUI7UUFDMUJBLHdCQUF3QkU7SUFDMUI7SUFDQSxPQUFPRixzQkFBc0I5a0QsS0FBSztBQUNwQztBQUNBLFNBQVNnbEQ7SUFDUCxJQUFJbnBDLFFBQVE1akIsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDaEYsSUFBSTZqQixTQUFTN2pCLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2pGLElBQUk0aEIsVUFBVTVoQixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNsRixJQUFJZ3RELGVBQWVodEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDdkYsTUFBTWl0RCxTQUFTdHJELFNBQVNxaEQsYUFBYSxDQUFDO0lBQ3RDLGtHQUFrRztJQUNsR2lLLE9BQU9ycEMsS0FBSyxHQUFHQTtJQUNmcXBDLE9BQU9wcEMsTUFBTSxHQUFHQTtJQUNoQixNQUFNb2pDLE1BQU1nRyxPQUFPQyxVQUFVLENBQUM7SUFDOUJqRyxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSWtHLFFBQVEsQ0FBQyxHQUFHLEdBQUdGLE9BQU9ycEMsS0FBSyxFQUFFcXBDLE9BQU9wcEMsTUFBTTtJQUN4RixJQUFJbXBDLGdCQUFnQi9GLEtBQUs7UUFDdkJBLElBQUltRyxTQUFTO1FBQ2JuRyxJQUFJb0csR0FBRyxDQUFDenBDLFFBQVEsR0FBR0MsU0FBUyxHQUFHLElBQUksR0FBR3JXLEtBQUs4L0MsRUFBRSxHQUFHLEdBQUc7UUFDbkRyRyxJQUFJc0csU0FBUztRQUNidEcsSUFBSXVHLFNBQVMsR0FBRztRQUNoQnZHLElBQUl3RyxJQUFJO0lBQ1Y7SUFDQSxhQUFhO0lBQ2IsTUFBTUMsY0FBY1QsT0FBT1UsYUFBYTtJQUN4QyxNQUFNLENBQUNDLFdBQVcsR0FBR0YsWUFBWWoyQixTQUFTO0lBQzFDLElBQUksQ0FBQ20yQixZQUFZO1FBQ2YsTUFBTXpvRCxNQUFNO0lBQ2Q7SUFDQXlvRCxXQUFXaHNDLE9BQU8sR0FBR0E7SUFDckIsT0FBT2dzQztBQUNUO0FBQ0EsSUFBSUM7QUFDSixTQUFTQztJQUNQLElBQUksQ0FBQ0QsdUJBQXVCO1FBQzFCLHlGQUF5RjtRQUN6RixNQUFNNUcsTUFBTSxJQUFJbmlCO1FBQ2hCLE1BQU1pcEIsYUFBYTlHLElBQUkrRyxnQkFBZ0I7UUFDdkMsTUFBTUMsT0FBT2hILElBQUlpSCxVQUFVO1FBQzNCRCxLQUFLQSxJQUFJLENBQUNFLGNBQWMsQ0FBQyxHQUFHO1FBQzVCLE1BQU1DLE1BQU1uSCxJQUFJb0gsNEJBQTRCO1FBQzVDTixXQUFXckcsT0FBTyxDQUFDdUc7UUFDbkJBLEtBQUt2RyxPQUFPLENBQUMwRztRQUNiTCxXQUFXbDdDLEtBQUs7UUFDaEIsQ0FBQ2c3QyxzQkFBc0IsR0FBR08sSUFBSTlwQyxNQUFNLENBQUNpVCxjQUFjO1FBQ25ELElBQUksQ0FBQ3MyQix1QkFBdUI7WUFDMUIsTUFBTTFvRCxNQUFNO1FBQ2Q7UUFDQTBvRCxzQkFBc0Jqc0MsT0FBTyxHQUFHO0lBQ2xDO0lBQ0EsT0FBT2lzQyxzQkFBc0I5bEQsS0FBSztBQUNwQztBQUNBLE1BQU11bUQ7SUFDSnBrRCxZQUFZcWtELFVBQVUsRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNyckIsT0FBTyxHQUFHLElBQUlwWSxRQUFRLENBQUNELFNBQVNFLFNBQVdSLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQzlFLElBQUksQ0FBQ00sT0FBTyxHQUFHQTtnQkFDZixJQUFJLENBQUNFLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSXVqQyxZQUFZO29CQUNkLE1BQU1BLFdBQVd6akMsU0FBU0U7Z0JBQzVCO1lBQ0YsSUFBSWdYLE9BQU8sQ0FBQztZQUNWLElBQUlwNEI7WUFDSixPQUFPLENBQUNBLEtBQUssSUFBSSxDQUFDNGtELFNBQVMsTUFBTSxRQUFRNWtELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJO1FBQ2hGO0lBQ0Y7QUFDRjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTOHZELG9CQUFvQjk2QixLQUFLLEVBQUV6ckIsT0FBTztJQUN6QyxNQUFNeXVDLE9BQU9uNUMsT0FBT2dLLE1BQU0sQ0FBQztRQUN6QmtuRCxZQUFZO1FBQ1pySCxTQUFTO1FBQ1RzSCx1QkFBdUI7UUFDdkJDLGFBQWEsQ0FBQztRQUNkQyxhQUFhLENBQUM7SUFDaEIsR0FBRzNtRDtJQUNILE1BQU00bUQsZUFBZTVIO0lBQ3JCLElBQUksQ0FBQzRILGNBQWM7UUFDakIsTUFBTSxJQUFJM3BELE1BQU07SUFDbEI7SUFDQSxNQUFNNHBELGNBQWNwWSxLQUFLK1gsVUFBVSxHQUFHLzZCLE1BQU00dUIsZ0JBQWdCLENBQUN4NkMsS0FBSyxLQUFLNHJCLE1BQU00dUIsZ0JBQWdCO0lBQzdGLE1BQU15TSxvQkFBb0JGLGFBQWFySCx1QkFBdUIsQ0FBQyxJQUFJaHZCLFlBQVk7UUFBQ3MyQjtLQUFZO0lBQzVGLE1BQU01SCxXQUFXMkgsYUFBYTFILGNBQWM7SUFDNUNELFNBQVN5SCxXQUFXLEdBQUdqWSxLQUFLaVksV0FBVztJQUN2Q3pILFNBQVMwSCxXQUFXLEdBQUdsWSxLQUFLa1ksV0FBVztJQUN2QzFILFNBQVNFLE9BQU8sR0FBRzFRLEtBQUswUSxPQUFPO0lBQy9CRixTQUFTd0gscUJBQXFCLEdBQUdoWSxLQUFLZ1kscUJBQXFCO0lBQzNESyxrQkFBa0J0SCxPQUFPLENBQUNQO0lBQzFCLE1BQU1LLFlBQVksSUFBSXAzQyxXQUFXKzJDLFNBQVNJLGlCQUFpQjtJQUMzRDs7R0FFQyxHQUNELE1BQU0wSCxrQkFBa0I7UUFDdEI5SCxTQUFTK0gsb0JBQW9CLENBQUMxSDtRQUM5QixJQUFJMkgsTUFBTTtRQUNWLEtBQUssTUFBTUMsYUFBYTVILFVBQVc7WUFDakMySCxPQUFPM2hELEtBQUs2aEQsR0FBRyxDQUFDRCxZQUFZLEtBQUs7UUFDbkM7UUFDQSxNQUFNRSxTQUFTOWhELEtBQUsraEQsSUFBSSxDQUFDSixNQUFNM0gsVUFBVTltRCxNQUFNO1FBQy9DLE9BQU80dUQ7SUFDVDtJQUNBLE1BQU1FLFVBQVUsSUFBTWhsQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3BELE1BQU1za0MsYUFBYS9HLEtBQUs7WUFDeEIsSUFBSXBSLEtBQUsrWCxVQUFVLEVBQUU7Z0JBQ25CSyxZQUFZcjNCLElBQUk7WUFDbEI7UUFDRjtJQUNBLE9BQU87UUFDTHUzQjtRQUNBOUg7UUFDQXFJO0lBQ0Y7QUFDRjtBQUNBLE1BQU1DO0lBQ0p2bEQsYUFBYztRQUNaLElBQUksQ0FBQ3dsRCxRQUFRLEdBQUcza0MsUUFBUUQsT0FBTztRQUMvQixJQUFJLENBQUM2a0MsTUFBTSxHQUFHO0lBQ2hCO0lBQ0FDLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ0QsTUFBTSxHQUFHO0lBQ3ZCO0lBQ0FFLE9BQU87UUFDTCxJQUFJLENBQUNGLE1BQU0sSUFBSTtRQUNmLElBQUlHO1FBQ0osTUFBTUMsV0FBVyxJQUFJaGxDLFFBQVFELENBQUFBLFVBQVdnbEMsYUFBYTtnQkFDbkQsSUFBSSxDQUFDSCxNQUFNLElBQUk7Z0JBQ2Y3a0M7WUFDRjtRQUNBLE1BQU1rbEMsYUFBYSxJQUFJLENBQUNOLFFBQVEsQ0FBQ3BrQyxJQUFJLENBQUMsSUFBTXdrQztRQUM1QyxJQUFJLENBQUNKLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVEsQ0FBQ3BrQyxJQUFJLENBQUMsSUFBTXlrQztRQUN6QyxPQUFPQztJQUNUO0FBQ0Y7QUFDQSxTQUFTQyxhQUFhQyxVQUFVO0lBQzlCLE9BQU90VyxZQUFZM2pCLFFBQVEsQ0FBQ2k2QjtBQUM5QjtBQUNBLFNBQVNDLGlCQUFpQnA1QixVQUFVO0lBQ2xDLElBQUksT0FBT0EsZUFBZSxVQUFVO1FBQ2xDLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJejVCLE1BQU1DLE9BQU8sQ0FBQ3c1QixhQUFhO1FBQzdCLE9BQU9BLFVBQVUsQ0FBQyxFQUFFO0lBQ3RCO0lBQ0EsSUFBSUEsV0FBV25DLEtBQUssRUFBRTtRQUNwQixJQUFJdDNCLE1BQU1DLE9BQU8sQ0FBQ3c1QixXQUFXbkMsS0FBSyxHQUFHO1lBQ25DLE9BQU9tQyxXQUFXbkMsS0FBSyxDQUFDLEVBQUU7UUFDNUI7UUFDQSxPQUFPbUMsV0FBV25DLEtBQUs7SUFDekI7SUFDQSxJQUFJbUMsV0FBV3BDLEtBQUssRUFBRTtRQUNwQixJQUFJcjNCLE1BQU1DLE9BQU8sQ0FBQ3c1QixXQUFXcEMsS0FBSyxHQUFHO1lBQ25DLE9BQU9vQyxXQUFXcEMsS0FBSyxDQUFDLEVBQUU7UUFDNUI7UUFDQSxPQUFPb0MsV0FBV3BDLEtBQUs7SUFDekI7SUFDQSxNQUFNeHZCLE1BQU07QUFDZDtBQUNBLFNBQVNpckQsZUFBZW5zQixHQUFHO0lBQ3pCLElBQUlBLElBQUk5L0IsVUFBVSxDQUFDLFNBQVM7UUFDMUIsT0FBTzgvQixJQUFJeGtCLE9BQU8sQ0FBQyxXQUFXO0lBQ2hDO0lBQ0EsT0FBT3drQjtBQUNUO0FBQ0EsU0FBU29zQixVQUFVcHNCLEdBQUc7SUFDcEIsSUFBSUEsSUFBSTkvQixVQUFVLENBQUMsT0FBTztRQUN4QixPQUFPOC9CLElBQUl4a0IsT0FBTyxDQUFDLFNBQVM7SUFDOUI7SUFDQSxPQUFPd2tCO0FBQ1Q7QUFFQSxNQUFNcXNCLFlBQVk7QUFDbEIsTUFBTUM7SUFDSixPQUFPQyxjQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxRQUFRLEtBQUtwd0QsV0FBVztZQUMvQixJQUFJLENBQUNvd0QsUUFBUSxHQUFHLElBQUlGO1FBQ3RCO1FBQ0EsT0FBTyxJQUFJLENBQUNFLFFBQVE7SUFDdEI7SUFDQUMsV0FBV242QyxJQUFJLEVBQUU7UUFDZixJQUFJbzZDLHFCQUFxQjN3RCxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM3RixJQUFJNEo7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLENBQUM1Z0IsS0FBSzJtRCxjQUFjSyxtQkFBbUIsTUFBTSxRQUFRaG5ELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3FvQixJQUFJLElBQUksR0FBRztnQkFDL0ZydUIsY0FBY2hELEtBQUssQ0FBQztnQkFDcEIsSUFBSTtvQkFDRixJQUFJMlYsTUFBTTt3QkFDUixNQUFNZzZDLGNBQWNLLG1CQUFtQixDQUFDOXlELEdBQUcsQ0FBQ3lZO29CQUM5QyxPQUFPO3dCQUNMLE1BQU13VSxRQUFRak8sR0FBRyxDQUFDeXpDLGNBQWNLLG1CQUFtQixDQUFDcnFELE1BQU07b0JBQzVEO2dCQUNGLEVBQUUsT0FBT2xKLEdBQUc7b0JBQ1Z1RyxjQUFjZ3BCLElBQUksQ0FBQztnQkFDckI7WUFDRjtZQUNBLElBQUlpSixVQUFVLE1BQU14MkIsVUFBVWkxQixZQUFZLENBQUNzQixnQkFBZ0I7WUFDM0QsSUFBSSs2QixzQkFDSixtSkFBbUo7WUFDbkosQ0FBRTVMLENBQUFBLGNBQWMsSUFBSSxDQUFDOEwsY0FBYyxDQUFDdDZDLEtBQUksR0FBSTtnQkFDMUMsTUFBTXU2Qyx1QkFBdUJqN0IsUUFBUW4xQixNQUFNLEtBQUssS0FBS20xQixRQUFRRSxJQUFJLENBQUNnN0IsQ0FBQUE7b0JBQ2hFLE1BQU1DLFVBQVVELE9BQU8vNkIsS0FBSyxLQUFLO29CQUNqQyxNQUFNaTdCLGFBQWExNkMsT0FBT3c2QyxPQUFPeDZDLElBQUksS0FBS0EsT0FBTztvQkFDakQsT0FBT3k2QyxXQUFXQztnQkFDcEI7Z0JBQ0EsSUFBSUgsc0JBQXNCO29CQUN4QixNQUFNSSx1QkFBdUI7d0JBQzNCMzdCLE9BQU9oZixTQUFTLGdCQUFnQkEsU0FBUzt3QkFDekM4ZSxPQUFPOWUsU0FBUztvQkFDbEI7b0JBQ0EsTUFBTStOLFNBQVMsTUFBTWpsQixVQUFVaTFCLFlBQVksQ0FBQzhDLFlBQVksQ0FBQzg1QjtvQkFDekRyN0IsVUFBVSxNQUFNeDJCLFVBQVVpMUIsWUFBWSxDQUFDc0IsZ0JBQWdCO29CQUN2RHRSLE9BQU9tVCxTQUFTLEdBQUdyNkIsT0FBTyxDQUFDdTJCLENBQUFBO3dCQUN6QkEsTUFBTStELElBQUk7b0JBQ1o7Z0JBQ0Y7WUFDRjtZQUNBLElBQUluaEIsTUFBTTtnQkFDUnNmLFVBQVVBLFFBQVE3eEIsTUFBTSxDQUFDK3NELENBQUFBLFNBQVVBLE9BQU94NkMsSUFBSSxLQUFLQTtZQUNyRDtZQUNBLE9BQU9zZjtRQUNUO0lBQ0Y7SUFDQXM3QixrQkFBa0I1NkMsSUFBSSxFQUFFMmYsUUFBUSxFQUFFazdCLE9BQU8sRUFBRTtRQUN6QyxPQUFPNW1DLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSTBMLGFBQWFvNkIsV0FBVztnQkFDMUIsT0FBT3A2QjtZQUNUO1lBQ0Esd0VBQXdFO1lBQ3hFLHlCQUF5QjtZQUN6QixNQUFNTCxVQUFVLE1BQU0sSUFBSSxDQUFDNjZCLFVBQVUsQ0FBQ242QztZQUN0QyxNQUFNdzZDLFNBQVNsN0IsUUFBUTNmLElBQUksQ0FBQ3ZZLENBQUFBLElBQUtBLEVBQUV5ekQsT0FBTyxLQUFLQSxXQUFXenpELEVBQUV1NEIsUUFBUSxLQUFLbzZCO1lBQ3pFLE9BQU9TLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPNzZCLFFBQVE7UUFDeEU7SUFDRjtJQUNBMjZCLGVBQWV0NkMsSUFBSSxFQUFFO1FBQ25CLE9BQU9BLE9BQU9nNkMsY0FBY0ssbUJBQW1CLENBQUMxeUMsR0FBRyxDQUFDM0gsUUFBUWc2QyxjQUFjSyxtQkFBbUIsQ0FBQzMrQixJQUFJLEdBQUc7SUFDdkc7QUFDRjtBQUNBcytCLGNBQWNjLGdCQUFnQixHQUFHO0lBQUM7SUFBYztJQUFlO0NBQWE7QUFDNUVkLGNBQWNLLG1CQUFtQixHQUFHLElBQUkvK0I7QUFFeEMsTUFBTXkvQiwyQkFBMkI7QUFDakMsTUFBTUMsbUJBQW1CclE7SUFDdkIsSUFBSS9yQixjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDcThCLFlBQVk7SUFDMUI7SUFDQTs7Ozs7O0dBTUMsR0FDRHRuRCxZQUFZaTNDLFVBQVUsRUFBRTVxQyxJQUFJLEVBQUU0ZSxXQUFXLENBQUU7UUFDekMsSUFBSXM4QixvQkFBb0J6eEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDNUYsSUFBSW9oRCxnQkFBZ0JwaEQsVUFBVVUsTUFBTSxHQUFHLElBQUlWLFNBQVMsQ0FBQyxFQUFFLEdBQUdLO1FBQzFELEtBQUssQ0FBQzhnRCxZQUFZNXFDLE1BQU02cUM7UUFDeEIsSUFBSSxDQUFDc1EsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxJQUFNLElBQUksQ0FBQ0MseUJBQXlCLEdBQUdsd0IsS0FBSyxDQUFDLElBQU0sSUFBSSxDQUFDemlDLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxzREFBc0QsSUFBSSxDQUFDd2hELFVBQVU7UUFDbkssSUFBSSxDQUFDd1AseUJBQXlCLEdBQUdoM0MsRUFBRSxJQUFNNFAsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDdkUsTUFBTSxJQUFJLENBQUNxbkMsYUFBYTtZQUMxQixJQUFJO1FBQ0osSUFBSSxDQUFDQyxzQkFBc0IsR0FBRyxJQUFNdG5DLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ2xFLElBQUksQ0FBQ29uQyx5QkFBeUIsQ0FBQ25aLE1BQU0sQ0FBQztnQkFDdEMsTUFBTSxJQUFJLENBQUNzWixjQUFjO1lBQzNCO1FBQ0EsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFDakIsSUFBSSxJQUFJLENBQUN2USxjQUFjLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQ3dRLGNBQWMsR0FBRztZQUN4QjtZQUNBLElBQUksQ0FBQ2pRLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFFBQVEsSUFBSSxDQUFDaWhDLG9CQUFvQjtZQUM1RSxJQUFJLENBQUMzUCxpQkFBaUIsQ0FBQ3R4QixtQkFBbUIsQ0FBQyxVQUFVLElBQUksQ0FBQ29oQyxzQkFBc0I7WUFDaEYsSUFBSSxDQUFDbmtDLElBQUksQ0FBQ3NxQixXQUFXaWEsS0FBSyxFQUFFLElBQUk7UUFDbEM7UUFDQSxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNFLGNBQWMsR0FBR1Y7UUFDdEIsSUFBSSxDQUFDVyxRQUFRLEdBQUcsSUFBSTNDO1FBQ3BCLElBQUksQ0FBQzRDLGlCQUFpQixHQUFHLElBQUk1QztRQUM3QixJQUFJLENBQUM2QyxhQUFhLEdBQUcsSUFBSTdDO1FBQ3pCLElBQUksQ0FBQzhDLG1CQUFtQixDQUFDcFIsWUFBWTtRQUNyQyw2RUFBNkU7UUFDN0UsSUFBSSxDQUFDcVEsWUFBWSxHQUFHclEsV0FBV3FSLGNBQWM7UUFDN0MsSUFBSXI5QixhQUFhO1lBQ2YsSUFBSSxDQUFDcThCLFlBQVksR0FBR3I4QjtRQUN0QjtJQUNGO0lBQ0EsSUFBSTNCLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQ3d1QixpQkFBaUIsQ0FBQ3h1QixFQUFFO0lBQ2xDO0lBQ0EsSUFBSWkvQixhQUFhO1FBQ2YsSUFBSSxJQUFJLENBQUNsOEMsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRTtZQUNsQyxPQUFPeGlEO1FBQ1Q7UUFDQSxNQUFNLEVBQ0p1akIsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUNtK0IsaUJBQWlCLENBQUMxaUIsV0FBVztRQUN0QyxJQUFJMWIsU0FBU0MsUUFBUTtZQUNuQixPQUFPO2dCQUNMRDtnQkFDQUM7WUFDRjtRQUNGO1FBQ0EsT0FBT3hqQjtJQUNUO0lBQ0EsSUFBSXF5RCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNoQixpQkFBaUI7SUFDL0I7SUFDQSxJQUFJaUIsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDUixjQUFjO0lBQzVCO0lBQ0EsSUFBSTVQLG1CQUFtQjtRQUNyQixJQUFJMzRDLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUNncEQsU0FBUyxNQUFNLFFBQVFocEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaXBELGNBQWMsTUFBTSxRQUFRbjBDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ3NqQyxpQkFBaUI7SUFDcEo7SUFDQXVRLG9CQUFvQk8sUUFBUSxFQUFFbGEsS0FBSyxFQUFFO1FBQ25DLE9BQU9wdUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJc29DLGFBQWEsSUFBSSxDQUFDOVEsaUJBQWlCLElBQUksQ0FBQ3BKLE9BQU87Z0JBQ2pEO1lBQ0Y7WUFDQSxJQUFJLElBQUksQ0FBQ29KLGlCQUFpQixFQUFFO2dCQUMxQixTQUFTO2dCQUNULElBQUksQ0FBQ1gsZ0JBQWdCLENBQUNqa0QsT0FBTyxDQUFDMjFELENBQUFBO29CQUM1QmxQLFlBQVksSUFBSSxDQUFDN0IsaUJBQWlCLEVBQUUrUTtnQkFDdEM7Z0JBQ0EsSUFBSSxDQUFDbkIseUJBQXlCLENBQUNuWixNQUFNLENBQUM7Z0JBQ3RDLElBQUksQ0FBQ3VKLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDc2hDLFdBQVc7Z0JBQ3BFLElBQUksQ0FBQ2hRLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFFBQVEsSUFBSSxDQUFDaWhDLG9CQUFvQjtnQkFDNUUsSUFBSSxDQUFDM1AsaUJBQWlCLENBQUN0eEIsbUJBQW1CLENBQUMsVUFBVSxJQUFJLENBQUNvaEMsc0JBQXNCO1lBQ2xGO1lBQ0EsSUFBSSxDQUFDbE4sV0FBVyxHQUFHLElBQUluc0IsWUFBWTtnQkFBQ3E2QjthQUFTO1lBQzdDLElBQUlBLFVBQVU7Z0JBQ1pBLFNBQVN0aUMsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUN3aEMsV0FBVztnQkFDbkQsMkVBQTJFO2dCQUMzRSx1RUFBdUU7Z0JBQ3ZFLHVCQUF1QjtnQkFDdkIsd0VBQXdFO2dCQUN4RSxpQ0FBaUM7Z0JBQ2pDYyxTQUFTdGlDLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxDQUFDbWhDLG9CQUFvQjtnQkFDM0RtQixTQUFTdGlDLGdCQUFnQixDQUFDLFVBQVUsSUFBSSxDQUFDc2hDLHNCQUFzQjtnQkFDL0QsSUFBSSxDQUFDTixZQUFZLEdBQUdzQixTQUFTTixjQUFjO1lBQzdDO1lBQ0EsSUFBSUs7WUFDSixJQUFJLElBQUksQ0FBQ0QsU0FBUyxJQUFJRSxZQUFZLElBQUksQ0FBQ0UsZ0JBQWdCLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQy96RCxHQUFHLENBQUMyQixLQUFLLENBQUMsd0JBQXdCLElBQUksQ0FBQ3doRCxVQUFVO2dCQUN0RCxJQUFJLElBQUksQ0FBQzdyQyxJQUFJLEtBQUssV0FBVztvQkFDM0IsTUFBTW5ULFVBQVU7Z0JBQ2xCO2dCQUNBNi9DLGdCQUFnQjZQLFVBQVUsSUFBSSxDQUFDRSxnQkFBZ0I7Z0JBQy9DLGlEQUFpRDtnQkFDakQsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ3J2QyxLQUFLLEdBQUc7Z0JBQzlCLE1BQU0sSUFBSSxDQUFDaXZDLFNBQVMsQ0FBQ0ssT0FBTyxDQUFDO29CQUMzQnQvQixPQUFPbS9CO29CQUNQdjhDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO29CQUNmbXNDLFNBQVMsSUFBSSxDQUFDc1EsZ0JBQWdCO2dCQUNoQztnQkFDQUgsaUJBQWlCLElBQUksQ0FBQ0QsU0FBUyxDQUFDQyxjQUFjO1lBQ2hEO1lBQ0EsSUFBSSxJQUFJLENBQUMzNEIsTUFBTSxFQUFFO2dCQUNmLE1BQU0sSUFBSSxDQUFDQSxNQUFNLENBQUNnNUIsWUFBWSxDQUFDTCxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCQztZQUN6RztZQUNBLCtEQUErRDtZQUMvRCx1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsY0FBYyxJQUFJLElBQUksQ0FBQ25RLGlCQUFpQixLQUFLOFEsVUFBVTtnQkFDL0QsSUFBSSxDQUFDOVEsaUJBQWlCLENBQUN0cUIsSUFBSTtZQUM3QjtZQUNBLElBQUksQ0FBQ3NxQixpQkFBaUIsR0FBRzhRO1lBQ3pCLElBQUlBLFVBQVU7Z0JBQ1osc0VBQXNFO2dCQUN0RSxJQUFJLENBQUM5USxpQkFBaUIsQ0FBQ3BnQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMwL0IsT0FBTztnQkFDOUMsOERBQThEO2dCQUM5RCxNQUFNLElBQUksQ0FBQ3lRLGNBQWM7Z0JBQ3pCLElBQUksQ0FBQzFRLGdCQUFnQixDQUFDamtELE9BQU8sQ0FBQzIxRCxDQUFBQTtvQkFDNUI5UCxnQkFBZ0I0UCxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCQyxVQUFVQztnQkFDcEc7WUFDRjtRQUNGO0lBQ0Y7SUFDQUksb0JBQW9CO1FBQ2xCLElBQUlDLFVBQVVwekQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUdzeEQ7UUFDbEYsSUFBSTFuRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLElBQUksQ0FBQ2pVLElBQUksS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDMEMsS0FBSyxFQUFFO2dCQUNsQyxNQUFNLElBQUluZ0QsTUFBTTtZQUNsQjtZQUNBLElBQUksQ0FBQyxDQUFDeUUsS0FBSyt1QyxZQUFXLE1BQU8sUUFBUS91QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3YyxFQUFFLE1BQU0sT0FBTztnQkFDOUUsbURBQW1EO2dCQUNuRCw4RkFBOEY7Z0JBQzlGLE1BQU11aEMsTUFBTTtZQUNkO1lBQ0EsTUFBTTBMLFVBQVVqMEMsS0FBS1EsR0FBRztZQUN4QixNQUFPUixLQUFLUSxHQUFHLEtBQUt5ekMsVUFBVUQsUUFBUztnQkFDckMsTUFBTUUsT0FBTyxJQUFJLENBQUNiLFVBQVU7Z0JBQzVCLElBQUlhLE1BQU07b0JBQ1IsT0FBT0E7Z0JBQ1Q7Z0JBQ0EsTUFBTTNMLE1BQU07WUFDZDtZQUNBLE1BQU0sSUFBSXhRLGtCQUFrQjtRQUM5QjtJQUNGO0lBQ0E7O0dBRUMsR0FDRG9jLGNBQWM7UUFDWixPQUFPL29DLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsK0NBQStDO1lBQy9DLElBQUksSUFBSSxDQUFDNU8sTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUM2RCxXQUFXLEVBQUU7Z0JBQzVDO1lBQ0Y7WUFDQSxNQUFNLEVBQ0o3dkIsUUFBUSxFQUNSazdCLE9BQU8sRUFDUixHQUFHLElBQUksQ0FBQ3BQLGlCQUFpQixDQUFDMWlCLFdBQVc7WUFDdEMsTUFBTS9vQixPQUFPLElBQUksQ0FBQ0EsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUMwQyxLQUFLLEdBQUcsZUFBZTtZQUM3RCxPQUFPaUwsY0FBY0MsV0FBVyxHQUFHVyxpQkFBaUIsQ0FBQzU2QyxNQUFNMmYsVUFBVWs3QjtRQUN2RTtJQUNGO0lBQ0FvQyxPQUFPO1FBQ0wsT0FBT2hwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQ2lwQyxhQUFhLENBQUM7WUFDbkIsT0FBTyxJQUFJO1FBQ2I7SUFDRjtJQUNBQyxTQUFTO1FBQ1AsT0FBT2xwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQ2lwQyxhQUFhLENBQUM7WUFDbkIsT0FBTyxJQUFJO1FBQ2I7SUFDRjtJQUNBUCxhQUFhdi9CLEtBQUssRUFBRTtRQUNsQixJQUFJODlCLG9CQUFvQnp4RCxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM1RixPQUFPd3FCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQzBQLE1BQU0sRUFBRTtnQkFDaEIsTUFBTSxJQUFJaWQsa0JBQWtCO1lBQzlCO1lBQ0EsSUFBSSxDQUFDbDRDLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyw0QkFBNEIsSUFBSSxDQUFDd2hELFVBQVU7WUFDMUQsTUFBTSxJQUFJLENBQUNtUSxtQkFBbUIsQ0FBQzUrQjtZQUMvQiw4RUFBOEU7WUFDOUUsNENBQTRDO1lBQzVDLElBQUksQ0FBQ3crQixjQUFjLEdBQUdWO1lBQ3RCLElBQUksSUFBSSxDQUFDbUIsU0FBUyxFQUFFO2dCQUNsQixNQUFNLElBQUksQ0FBQ2UsYUFBYTtZQUMxQjtZQUNBLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQVYsUUFBUTk5QixXQUFXLEVBQUU7UUFDbkIsT0FBTzNLLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDMkssYUFBYTtnQkFDaEJBLGNBQWMsSUFBSSxDQUFDcThCLFlBQVk7WUFDakM7WUFDQSxJQUFJLENBQUN2eUQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLHFDQUFxQ3BELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUNwR2p0QjtZQUNGO1lBQ0EsTUFBTXkrQixvQkFBb0I7Z0JBQ3hCditCLE9BQU87Z0JBQ1BFLE9BQU87WUFDVDtZQUNBLElBQUksSUFBSSxDQUFDaGYsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRTtnQkFDbEMrUSxrQkFBa0JyK0IsS0FBSyxHQUFHSjtZQUM1QixPQUFPO2dCQUNMeStCLGtCQUFrQnYrQixLQUFLLEdBQUdGO1lBQzVCO1lBQ0EsMkVBQTJFO1lBQzNFLHdEQUF3RDtZQUN4RCxJQUFJLENBQUNrc0IsZ0JBQWdCLENBQUNqa0QsT0FBTyxDQUFDMjFELENBQUFBO2dCQUM1QmxQLFlBQVksSUFBSSxDQUFDdEIsZ0JBQWdCLEVBQUV3UTtZQUNyQztZQUNBLElBQUksQ0FBQy9RLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDc2hDLFdBQVc7WUFDcEUsOEVBQThFO1lBQzlFLHdEQUF3RDtZQUN4RCxzREFBc0Q7WUFDdEQsSUFBSSxDQUFDaFEsaUJBQWlCLENBQUN0cUIsSUFBSTtZQUMzQiw4QkFBOEI7WUFDOUIsTUFBTWt0QixjQUFjLE1BQU12bEQsVUFBVWkxQixZQUFZLENBQUM4QyxZQUFZLENBQUN3OEI7WUFDOUQsTUFBTWQsV0FBV2xPLFlBQVludEIsU0FBUyxFQUFFLENBQUMsRUFBRTtZQUMzQ3E3QixTQUFTdGlDLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDd2hDLFdBQVc7WUFDbkQsSUFBSSxDQUFDL3lELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxnQ0FBZ0MsSUFBSSxDQUFDd2hELFVBQVU7WUFDOUQsTUFBTSxJQUFJLENBQUNtUSxtQkFBbUIsQ0FBQ087WUFDL0IsSUFBSSxDQUFDdEIsWUFBWSxHQUFHcjhCO1lBQ3BCLElBQUksQ0FBQ3hILElBQUksQ0FBQ3NxQixXQUFXNGIsU0FBUyxFQUFFLElBQUk7WUFDcEMsT0FBTyxJQUFJO1FBQ2I7SUFDRjtJQUNBSixjQUFjOXZDLEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUMxa0IsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLFdBQVdxSSxNQUFNLENBQUMsSUFBSSxDQUFDc04sSUFBSSxFQUFFLFdBQVd0TixNQUFNLENBQUMwYSxRQUFRLFVBQVUsWUFBWSxJQUFJLENBQUN5K0IsVUFBVTtRQUMzRyxJQUFJLElBQUksQ0FBQ2QsT0FBTyxLQUFLMzlCLFNBQVMsSUFBSSxDQUFDcStCLGlCQUFpQixDQUFDcGdDLE9BQU8sS0FBSytCLE9BQU87WUFDdEU7UUFDRjtRQUNBLElBQUksQ0FBQzI5QixPQUFPLEdBQUczOUI7UUFDZixJQUFJLENBQUNxK0IsaUJBQWlCLENBQUNwZ0MsT0FBTyxHQUFHLENBQUMrQjtRQUNsQyxJQUFJLENBQUNnSyxJQUFJLENBQUNoSyxRQUFRczBCLFdBQVc2YixLQUFLLEdBQUc3YixXQUFXOGIsT0FBTyxFQUFFLElBQUk7SUFDL0Q7SUFDQSxJQUFJQyxxQkFBcUI7UUFDdkIsT0FBTyxJQUFJLENBQUNoUyxpQkFBaUIsQ0FBQ3BSLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQ29SLGlCQUFpQixDQUFDcitCLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQ3ErQixpQkFBaUIsQ0FBQ3BnQyxPQUFPLElBQUksSUFBSSxDQUFDcXdDLGNBQWM7SUFDL0k7SUFDQW5RLDZCQUE2QjtRQUMzQixNQUFNbVMsU0FBU3oyRCxPQUFPdUosTUFBTSxDQUFDLE1BQU07WUFDakMrNkMsNEJBQTRCO2dCQUMxQmhrRCxLQUFLLElBQU0sS0FBSyxDQUFDZ2tEO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPdDNCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXlwQyxPQUFPblMsMEJBQTBCLENBQUNuakQsSUFBSSxDQUFDLElBQUk7WUFDakQsSUFBSSxDQUFDb3NELFlBQVk7WUFDakIsSUFBSSxDQUFDOXJELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyx5Q0FBeUNxSSxNQUFNLENBQUMsSUFBSSxDQUFDdzRDLGNBQWMsR0FBRyxJQUFJLENBQUNXLFVBQVU7WUFDcEcsSUFBSSxDQUFDLElBQUksQ0FBQ1gsY0FBYyxJQUFJLElBQUksQ0FBQ3VTLGtCQUFrQixJQUFJLENBQUMsSUFBSSxDQUFDckIsY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDclIsT0FBTyxFQUFFO2dCQUM1RixJQUFJLENBQUNyaUQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDRDQUE0Q3FJLE1BQU0sQ0FBQyxJQUFJLENBQUMyUyxNQUFNLEdBQUcsSUFBSSxDQUFDd21DLFVBQVU7Z0JBQy9GLE1BQU0sSUFBSSxDQUFDNlEsT0FBTztnQkFDbEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1lBQ3hCO1FBQ0Y7SUFDRjtJQUNBdjZCLE9BQU87UUFDTCxJQUFJOXRCO1FBQ0osS0FBSyxDQUFDOHRCO1FBQ04sSUFBSSxDQUFDc3FCLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDc2hDLFdBQVc7UUFDcEUsSUFBSSxDQUFDaFEsaUJBQWlCLENBQUN0eEIsbUJBQW1CLENBQUMsUUFBUSxJQUFJLENBQUNpaEMsb0JBQW9CO1FBQzVFLElBQUksQ0FBQzNQLGlCQUFpQixDQUFDdHhCLG1CQUFtQixDQUFDLFVBQVUsSUFBSSxDQUFDb2hDLHNCQUFzQjtRQUMvRWxvRCxDQUFBQSxLQUFLLElBQUksQ0FBQ2dwRCxTQUFTLE1BQU0sUUFBUWhwRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzcUQsT0FBTztRQUNyRSxJQUFJLENBQUN0QixTQUFTLEdBQUd2eUQ7SUFDbkI7SUFDQTs7Ozs7SUFLRSxHQUNGd3hELGdCQUFnQjtRQUNkLE9BQU9ybkMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNMnBDLFNBQVMsTUFBTSxJQUFJLENBQUM5QixpQkFBaUIsQ0FBQ3hDLElBQUk7WUFDaEQsSUFBSTtnQkFDRixJQUFJLElBQUksQ0FBQzZCLGlCQUFpQixLQUFLLE1BQU07b0JBQ25DO2dCQUNGO2dCQUNBLElBQUksQ0FBQyxJQUFJLENBQUN4M0IsTUFBTSxFQUFFO29CQUNoQixJQUFJLENBQUNqN0IsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxxREFBcUQsSUFBSSxDQUFDdzFCLFVBQVU7b0JBQ2xGO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3NQLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUMvakMsSUFBSSxDQUFDc3FCLFdBQVdtYyxjQUFjLEVBQUUsSUFBSTtnQkFDekMsTUFBTTd0QyxVQUFVb3lCO2dCQUNoQixJQUFJLENBQUNweUIsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF2bEIsSUFBSSxNQUFNLFlBQVltcEQsZ0JBQWdCNWpDLFFBQVF4RCxPQUFPLEVBQUUsVUFBVSxHQUFHO29CQUNqSSxpREFBaUQ7b0JBQ2pELE1BQU0sSUFBSW0wQix1QkFBdUI7Z0JBQ25DO2dCQUNBLE1BQU0sSUFBSSxDQUFDaGQsTUFBTSxDQUFDZzVCLFlBQVksQ0FBQztZQUNqQyxTQUFVO2dCQUNSaUI7WUFDRjtRQUNGO0lBQ0Y7SUFDQXBDLGlCQUFpQjtRQUNmLE9BQU92bkMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNMnBDLFNBQVMsTUFBTSxJQUFJLENBQUM5QixpQkFBaUIsQ0FBQ3hDLElBQUk7WUFDaEQsSUFBSTtnQkFDRixJQUFJLElBQUksQ0FBQzZCLGlCQUFpQixLQUFLLE9BQU87b0JBQ3BDO2dCQUNGO2dCQUNBLElBQUksQ0FBQyxJQUFJLENBQUN4M0IsTUFBTSxFQUFFO29CQUNoQixJQUFJLENBQUNqN0IsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxzREFBc0QsSUFBSSxDQUFDdzFCLFVBQVU7b0JBQ25GO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3NQLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUMvakMsSUFBSSxDQUFDc3FCLFdBQVdvYyxlQUFlLEVBQUUsSUFBSTtnQkFDMUMsbUVBQW1FO2dCQUNuRSxNQUFNLElBQUksQ0FBQ242QixNQUFNLENBQUNnNUIsWUFBWSxDQUFDLElBQUksQ0FBQ2xSLGlCQUFpQjtZQUN2RCxTQUFVO2dCQUNSbVM7WUFDRjtRQUNGO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUNERyxvQkFBb0I7UUFDbEIsSUFBSTFxRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUUsRUFBQzVnQixLQUFLLElBQUksQ0FBQ3N3QixNQUFNLE1BQU0sUUFBUXR3QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdveEIsUUFBUSxHQUFHO2dCQUMxRTtZQUNGO1lBQ0EsTUFBTXU1QixjQUFjLE1BQU0sSUFBSSxDQUFDcjZCLE1BQU0sQ0FBQ2MsUUFBUTtZQUM5QyxPQUFPdTVCO1FBQ1Q7SUFDRjtJQUNBOzs7Ozs7Ozs7R0FTQyxHQUNEQyxhQUFhNUIsU0FBUyxFQUFFO1FBQ3RCLElBQUk2Qiw2QkFBNkJ6MEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDckcsSUFBSTRKLElBQUk4VTtRQUNSLE9BQU84TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0ycEMsU0FBUyxNQUFNLElBQUksQ0FBQzdCLGFBQWEsQ0FBQ3pDLElBQUk7WUFDNUMsSUFBSTtnQkFDRixJQUFJLENBQUM1d0QsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLHdCQUF3QixJQUFJLENBQUN3aEQsVUFBVTtnQkFDdEQsSUFBSSxJQUFJLENBQUN3USxTQUFTLEVBQUU7b0JBQ2xCLE1BQU0sSUFBSSxDQUFDZSxhQUFhO2dCQUMxQjtnQkFDQSxJQUFJLElBQUksQ0FBQ3A5QyxJQUFJLEtBQUssV0FBVztvQkFDM0IsTUFBTW5ULFVBQVU7Z0JBQ2xCO2dCQUNBLElBQUksQ0FBQzR2RCxnQkFBZ0IsR0FBRyxDQUFDcHBELEtBQUssSUFBSSxDQUFDb3BELGdCQUFnQixNQUFNLFFBQVFwcEQsT0FBTyxLQUFLLElBQUlBLEtBQUtqSSxTQUFTcWhELGFBQWEsQ0FBQyxJQUFJLENBQUN6c0MsSUFBSTtnQkFDdEgwc0MsZ0JBQWdCLElBQUksQ0FBQ2pCLGlCQUFpQixFQUFFLElBQUksQ0FBQ2dSLGdCQUFnQjtnQkFDN0QsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ3J2QyxLQUFLLEdBQUc7Z0JBQzlCLElBQUksQ0FBQ3F2QyxnQkFBZ0IsQ0FBQzFQLElBQUksR0FBRzVoQixLQUFLLENBQUM1VixDQUFBQSxRQUFTLElBQUksQ0FBQzdzQixHQUFHLENBQUM2c0IsS0FBSyxDQUFDLG9DQUFvQ3R1QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzt3QkFDL0l0MkI7b0JBQ0Y7Z0JBQ0EsTUFBTTRvQyxtQkFBbUI7b0JBQ3ZCbitDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO29CQUNmb2QsT0FBTyxJQUFJLENBQUNxdUIsaUJBQWlCO29CQUM3QlUsU0FBUyxJQUFJLENBQUNzUSxnQkFBZ0I7Z0JBQ2hDO2dCQUNBLE1BQU1KLFVBQVU3bEMsSUFBSSxDQUFDMm5DO2dCQUNyQixJQUFJLENBQUM5QixTQUFTLEdBQUdBO2dCQUNqQixJQUFJLElBQUksQ0FBQ0EsU0FBUyxDQUFDQyxjQUFjLEVBQUU7b0JBQ2pDLEtBQUssTUFBTUUsTUFBTSxJQUFJLENBQUMxUixnQkFBZ0IsQ0FBRTt3QkFDdEMsSUFBSTBSLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsSUFBSXlCLDRCQUE0Qjs0QkFDOUQ1USxZQUFZLElBQUksQ0FBQzdCLGlCQUFpQixFQUFFK1E7NEJBQ3BDOVAsZ0JBQWdCLElBQUksQ0FBQzJQLFNBQVMsQ0FBQ0MsY0FBYyxFQUFFRTt3QkFDakQ7b0JBQ0Y7b0JBQ0EsTUFBTSxDQUFDcjBDLEtBQUssSUFBSSxDQUFDd2IsTUFBTSxNQUFNLFFBQVF4YixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3MEMsWUFBWSxDQUFDLElBQUksQ0FBQ04sU0FBUyxDQUFDQyxjQUFjO2dCQUM3RztZQUNGLFNBQVU7Z0JBQ1JzQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBUSxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUMvQixTQUFTO0lBQ3ZCO0lBQ0E7Ozs7OztHQU1DLEdBQ0RlLGdCQUFnQjtRQUNkLElBQUkvcEQsSUFBSThVO1FBQ1IsT0FBTzhMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ29vQyxTQUFTLEVBQUU7WUFDckIsSUFBSSxDQUFDM3pELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxzQkFBc0IsSUFBSSxDQUFDd2hELFVBQVU7WUFDbkR4NEMsQ0FBQUEsS0FBSyxJQUFJLENBQUNncEQsU0FBUyxDQUFDQyxjQUFjLE1BQU0sUUFBUWpwRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4dEIsSUFBSTtZQUNqRixNQUFNLElBQUksQ0FBQ2s3QixTQUFTLENBQUNzQixPQUFPO1lBQzVCLElBQUksQ0FBQ3RCLFNBQVMsR0FBR3Z5RDtZQUNoQnFlLENBQUFBLEtBQUssSUFBSSxDQUFDczBDLGdCQUFnQixNQUFNLFFBQVF0MEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHazJDLE1BQU07WUFDM0UsSUFBSSxDQUFDNUIsZ0JBQWdCLEdBQUczeUQ7WUFDeEIsTUFBTSxJQUFJLENBQUM0eUQsT0FBTztRQUNwQjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU00QixvQkFBb0Jsa0MsY0FBYzdELFlBQVk7SUFDbEQ1aUIsWUFBWWhDLE9BQU8sQ0FBRTtRQUNuQixLQUFLO1FBQ0wsSUFBSSxDQUFDNHNELGVBQWUsR0FBR0MsQ0FBQUE7WUFDckIsSUFBSW5yRCxJQUFJOFU7WUFDUixNQUFNLEVBQ0puSSxJQUFJLEVBQ0poTSxJQUFJLEVBQ0wsR0FBR3dxRCxHQUFHeHFELElBQUk7WUFDWCxPQUFRZ007Z0JBQ04sS0FBSztvQkFDSDNTLGNBQWNrb0IsS0FBSyxDQUFDdmhCLEtBQUt1aEIsS0FBSyxDQUFDNWlCLE9BQU87b0JBQ3RDLElBQUksQ0FBQ3lrQixJQUFJLENBQUN3bEIsZ0JBQWdCNmhCLGVBQWUsRUFBRXpxRCxLQUFLdWhCLEtBQUs7b0JBQ3JEO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSXZoQixLQUFLcVgsT0FBTyxFQUFFO3dCQUNoQixJQUFJLENBQUNxekMsV0FBVyxDQUFDNWUsT0FBTyxHQUFHajVDLE9BQU8sQ0FBQys0QyxDQUFBQTs0QkFDakMsSUFBSSxDQUFDK2UsT0FBTyxDQUFDL2U7d0JBQ2Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLElBQUksQ0FBQ2dmLGlCQUFpQixLQUFLNXFELEtBQUtxWCxPQUFPLElBQUlyWCxLQUFLNmEsbUJBQW1CLEtBQU0sRUFBQ3hiLEtBQUssSUFBSSxDQUFDd3JELElBQUksTUFBTSxRQUFReHJELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3lyRCxnQkFBZ0IsQ0FBQzV5QyxRQUFRLEdBQUc7d0JBQ2hLLElBQUksQ0FBQ2tMLElBQUksQ0FBQ3dsQixnQkFBZ0JtaUIsa0NBQWtDLEVBQUUvcUQsS0FBS3FYLE9BQU8sRUFBRSxJQUFJLENBQUN3ekMsSUFBSSxDQUFDQyxnQkFBZ0I7d0JBQ3RHLElBQUksQ0FBQ0YsaUJBQWlCLEdBQUc1cUQsS0FBS3FYLE9BQU87b0JBQ3ZDLE9BQU8sSUFBSXJYLEtBQUs2YSxtQkFBbUIsRUFBRTt3QkFDbkMsTUFBTW13QyxjQUFjLENBQUM3MkMsS0FBSyxJQUFJLENBQUMwMkMsSUFBSSxNQUFNLFFBQVExMkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHODJDLHdCQUF3QixDQUFDanJELEtBQUs2YSxtQkFBbUI7d0JBQzlILElBQUksQ0FBQ213QyxhQUFhOzRCQUNoQixNQUFNbnlELFVBQVUsd0RBQXdENkYsTUFBTSxDQUFDc0IsS0FBSzZhLG1CQUFtQjt3QkFDekc7d0JBQ0EsSUFBSSxDQUFDdUksSUFBSSxDQUFDd2xCLGdCQUFnQm1pQixrQ0FBa0MsRUFBRS9xRCxLQUFLcVgsT0FBTyxFQUFFMnpDO29CQUM5RTtvQkFDQSxJQUFJLElBQUksQ0FBQ0osaUJBQWlCLEVBQUU7d0JBQzFCLElBQUksQ0FBQ0YsV0FBVyxDQUFDNWUsT0FBTyxHQUFHajVDLE9BQU8sQ0FBQys0QyxDQUFBQTs0QkFDakMsSUFBSSxDQUFDK2UsT0FBTyxDQUFDL2U7d0JBQ2Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUM4ZSxXQUFXLENBQUN0bkMsSUFBSSxDQUFDc2xCLGlCQUFpQmdELFlBQVksRUFBRTFyQyxLQUFLcXFDLFFBQVEsRUFBRXJxQyxLQUFLd3JDLFFBQVE7b0JBQ2pGO1lBQ0o7UUFDRjtRQUNBLElBQUksQ0FBQzBmLGFBQWEsR0FBR1YsQ0FBQUE7WUFDbkJueEQsY0FBY2tvQixLQUFLLENBQUMscUNBQXFDO2dCQUN2REEsT0FBT2lwQyxHQUFHanBDLEtBQUs7WUFDakI7WUFDQSxJQUFJLENBQUM2QixJQUFJLENBQUN3bEIsZ0JBQWdCNmhCLGVBQWUsRUFBRUQsR0FBR2pwQyxLQUFLO1FBQ3JEO1FBQ0EsSUFBSSxDQUFDbXBDLFdBQVcsR0FBRy9zRCxRQUFRK3NELFdBQVc7UUFDdEMsSUFBSSxDQUFDUyxNQUFNLEdBQUd4dEQsUUFBUXd0RCxNQUFNO1FBQzVCLElBQUksQ0FBQ1AsaUJBQWlCLEdBQUc7SUFDM0I7SUFDQTs7R0FFQyxHQUNEUSxNQUFNUCxJQUFJLEVBQUU7UUFDVixJQUFJLENBQUMvaEIsbUJBQW1CO1lBQ3RCLE1BQU0sSUFBSTZELHVCQUF1QjtRQUNuQztRQUNBdHpDLGNBQWNDLElBQUksQ0FBQztRQUNuQixJQUFJdXhELFNBQVMsSUFBSSxDQUFDQSxJQUFJLEVBQUU7WUFDdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDUSxtQkFBbUIsQ0FBQ1IsTUFBTSxJQUFJLENBQUNILFdBQVc7WUFDL0MsZ0NBQWdDO1lBQ2hDLE1BQU1sd0QsTUFBTTtnQkFDVndSLE1BQU07Z0JBQ05oTSxNQUFNO29CQUNKc3JELG9CQUFvQixJQUFJLENBQUNaLFdBQVcsQ0FBQzFlLFVBQVU7Z0JBQ2pEO1lBQ0Y7WUFDQSxJQUFJLElBQUksQ0FBQ21mLE1BQU0sRUFBRTtnQkFDZjl4RCxjQUFjQyxJQUFJLENBQUMsdUJBQXVCO29CQUN4QzZ4RCxRQUFRLElBQUksQ0FBQ0EsTUFBTTtnQkFDckI7Z0JBQ0EsSUFBSSxDQUFDQSxNQUFNLENBQUNJLFNBQVMsR0FBRyxJQUFJLENBQUNoQixlQUFlO2dCQUM1QyxJQUFJLENBQUNZLE1BQU0sQ0FBQ0ssT0FBTyxHQUFHLElBQUksQ0FBQ04sYUFBYTtnQkFDeEMsSUFBSSxDQUFDQyxNQUFNLENBQUNNLFdBQVcsQ0FBQ2p4RDtZQUMxQjtRQUNGO0lBQ0Y7SUFDQTs7R0FFQyxHQUNEa3hELDZCQUE2QnIwQyxPQUFPLEVBQUV3RCxtQkFBbUIsRUFBRTtRQUN6RHhoQixjQUFjaEQsS0FBSyxDQUFDLGVBQWVxSSxNQUFNLENBQUMyWSxTQUFTLHFCQUFxQjNZLE1BQU0sQ0FBQ21jO1FBQy9FLElBQUksQ0FBQzh3QyxVQUFVLENBQUN0MEMsU0FBU3dEO0lBQzNCO0lBQ0E7O0dBRUMsR0FDRCt3QyxjQUFjQyxPQUFPLEVBQUU7UUFDckIsSUFBSSxDQUFDQSxXQUFXQSxRQUFRMTFELE1BQU0sS0FBSyxHQUFHO1lBQ3BDa0QsY0FBY2dwQixJQUFJLENBQUM7UUFDckIsT0FBTztZQUNMLElBQUksQ0FBQ3lwQyxjQUFjLENBQUNEO1FBQ3RCO0lBQ0Y7SUFDQUUsWUFBWUMsTUFBTSxFQUFFO1FBQ2xCQSxPQUFPM25DLEVBQUUsQ0FBQ29wQixZQUFZd2UsaUJBQWlCLEVBQUVDLENBQUFBO1lBQ3ZDLElBQUksQ0FBQ0MsVUFBVSxDQUFDRDtRQUNsQjtJQUNGO0lBQ0FiLG9CQUFvQlIsSUFBSSxFQUFFSCxXQUFXLEVBQUU7UUFDckNHLEtBQUt4bUMsRUFBRSxDQUFDa3BCLFVBQVU2ZSxjQUFjLEVBQUUsQ0FBQ0MsS0FBS3JCLGNBQWdCLElBQUksQ0FBQ1UsNEJBQTRCLENBQUNXLElBQUlqTyxTQUFTLENBQUN2a0MsVUFBVSxLQUFLaEIsZ0JBQWdCaUIsSUFBSSxFQUFFa3hDLFlBQVk5eUMsUUFBUTtRQUNqSzJ5QyxLQUFLeG1DLEVBQUUsQ0FBQ2twQixVQUFVK2Usc0JBQXNCLEVBQUVuMEMsQ0FBQUE7WUFDeEMsSUFBSUEsVUFBVW8wQyxnQkFBZ0JDLFNBQVMsRUFBRTtnQkFDdkMzQixLQUFLMVcsWUFBWSxDQUFDdGhELE9BQU8sQ0FBQ200RCxDQUFBQTtvQkFDeEJBLFlBQVkxeUMsTUFBTSxDQUFDemxCLE9BQU8sQ0FBQ3c1RCxDQUFBQTt3QkFDekIsSUFBSSxDQUFDWCw0QkFBNEIsQ0FBQ1csSUFBSWpPLFNBQVMsQ0FBQ3ZrQyxVQUFVLEtBQUtoQixnQkFBZ0JpQixJQUFJLEVBQUVreEMsWUFBWTl5QyxRQUFRO29CQUMzRztnQkFDRjtZQUNGO1FBQ0YsR0FBR21NLEVBQUUsQ0FBQ2twQixVQUFVa2YsaUJBQWlCLEVBQUUsQ0FBQ3JqQyxPQUFPc2pDLEdBQUcxQjtZQUM1QyxJQUFJM3JEO1lBQ0osTUFBTTdFLE1BQU07Z0JBQ1Z3UixNQUFNO2dCQUNOaE0sTUFBTTtvQkFDSjZhLHFCQUFxQm13QyxZQUFZOXlDLFFBQVE7b0JBQ3pDeVIsU0FBU1AsTUFBTTZ1QixhQUFhO2dCQUM5QjtZQUNGO1lBQ0M1NEMsQ0FBQUEsS0FBSyxJQUFJLENBQUM4ckQsTUFBTSxNQUFNLFFBQVE5ckQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb3NELFdBQVcsQ0FBQ2p4RDtRQUN6RSxHQUFHNnBCLEVBQUUsQ0FBQ2twQixVQUFVb2YsZUFBZSxFQUFFLENBQUN2akMsT0FBT2lqQyxLQUFLckI7WUFDNUMsSUFBSSxDQUFDNEIsaUJBQWlCLENBQUN4akMsT0FBTzRoQyxZQUFZOXlDLFFBQVEsRUFBRW0wQyxJQUFJak8sU0FBUztRQUNuRSxHQUFHLzVCLEVBQUUsQ0FBQ2twQixVQUFVc2YsZUFBZSxFQUFFO1lBQy9CLElBQUksQ0FBQyxJQUFJLENBQUNoQyxJQUFJLEVBQUU7Z0JBQ2QsTUFBTSxJQUFJaHlELFVBQVU7WUFDdEI7WUFDQSxJQUFJLENBQUM2eUQsNEJBQTRCLENBQUMsSUFBSSxDQUFDYixJQUFJLENBQUNDLGdCQUFnQixDQUFDZ0MsYUFBYSxFQUFFLElBQUksQ0FBQ2pDLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUM1eUMsUUFBUTtZQUMvR3d5QyxZQUFZNWUsT0FBTyxHQUFHajVDLE9BQU8sQ0FBQys0QyxDQUFBQTtnQkFDNUIsSUFBSSxDQUFDK2UsT0FBTyxDQUFDL2U7WUFDZjtRQUNGO1FBQ0FpZixLQUFLQyxnQkFBZ0IsQ0FBQ3ptQyxFQUFFLENBQUNtcEIsaUJBQWlCdWYsbUJBQW1CLEVBQUVDLENBQUFBLGNBQWUvc0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDNUcsSUFBSSxDQUFDZ3RDLGVBQWUsQ0FBQ0QsWUFBWTVqQyxLQUFLLEVBQUU0akMsWUFBWTVqQyxLQUFLLENBQUN1RyxNQUFNO1lBQ2xFO1FBQ0ErNkIsWUFBWXJtQyxFQUFFLENBQUNxa0IsaUJBQWlCbUQsTUFBTSxFQUFFRCxDQUFBQSxVQUFXLElBQUksQ0FBQytlLE9BQU8sQ0FBQy9lLFVBQVV2bkIsRUFBRSxDQUFDcWtCLGlCQUFpQndELGNBQWMsRUFBRSxDQUFDZ2hCLGVBQWUxaEIsV0FBYSxJQUFJLENBQUMyaEIsa0JBQWtCLENBQUNELGVBQWUxaEI7SUFDcEw7SUFDQTJoQixtQkFBbUJ0eUMsbUJBQW1CLEVBQUUyd0IsUUFBUSxFQUFFO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMyZixNQUFNLEVBQUU7WUFDaEIsTUFBTXZ3RCxNQUFNO1FBQ2Q7UUFDQSxNQUFNSixNQUFNO1lBQ1Z3UixNQUFNO1lBQ05oTSxNQUFNO2dCQUNKNmEscUJBQXFCQTtnQkFDckIyd0I7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDMmYsTUFBTSxDQUFDTSxXQUFXLENBQUNqeEQ7SUFDMUI7SUFDQW13RCxRQUFRanhELElBQUksRUFBRTtRQUNaLElBQUksRUFDRm9ULEdBQUcsRUFDSCtOLG1CQUFtQixFQUNuQjJ3QixRQUFRLEVBQ1QsR0FBRzl4QztRQUNKLElBQUkyRjtRQUNKLElBQUksQ0FBQyxJQUFJLENBQUM4ckQsTUFBTSxFQUFFO1lBQ2hCLE1BQU12d0QsTUFBTTtRQUNkO1FBQ0EsTUFBTUosTUFBTTtZQUNWd1IsTUFBTTtZQUNOaE0sTUFBTTtnQkFDSjZhLHFCQUFxQkE7Z0JBQ3JCbkMsYUFBYW1DLHdCQUF5QixFQUFDeGIsS0FBSyxJQUFJLENBQUN3ckQsSUFBSSxNQUFNLFFBQVF4ckQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeXJELGdCQUFnQixDQUFDNXlDLFFBQVE7Z0JBQ3hIcEw7Z0JBQ0EwK0I7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDMmYsTUFBTSxDQUFDTSxXQUFXLENBQUNqeEQ7SUFDMUI7SUFDQW14RCxXQUFXdDBDLE9BQU8sRUFBRXdELG1CQUFtQixFQUFFO1FBQ3ZDLElBQUksSUFBSSxDQUFDc3dDLE1BQU0sRUFBRTtZQUNmLE1BQU1pQyxZQUFZO2dCQUNoQnBoRCxNQUFNO2dCQUNOaE0sTUFBTTtvQkFDSnFYO29CQUNBd0Q7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksQ0FBQ3N3QyxNQUFNLENBQUNNLFdBQVcsQ0FBQzJCO1FBQzFCLE9BQU87WUFDTCxNQUFNLElBQUlDLGVBQWU7UUFDM0I7SUFDRjtJQUNBbEIsV0FBV3R5RCxHQUFHLEVBQUU7UUFDZCxJQUFJd0Y7UUFDSixJQUFJLENBQUMsSUFBSSxDQUFDOHJELE1BQU0sRUFBRTtZQUNoQixNQUFNdHlELFVBQVU7UUFDbEI7UUFDQSxJQUFJLENBQUUsRUFBQ3dHLEtBQUssSUFBSSxDQUFDd3JELElBQUksTUFBTSxRQUFReHJELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3lyRCxnQkFBZ0IsQ0FBQzV5QyxRQUFRLEdBQUc7WUFDekYsTUFBTXJmLFVBQVU7UUFDbEI7UUFDQSxNQUFNMkIsTUFBTTtZQUNWd1IsTUFBTTtZQUNOaE0sTUFBTTtnQkFDSm5HO2dCQUNBZ2hCLHFCQUFxQixJQUFJLENBQUNnd0MsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQzV5QyxRQUFRO1lBQzFEO1FBQ0Y7UUFDQSxJQUFJLENBQUNpekMsTUFBTSxDQUFDTSxXQUFXLENBQUNqeEQ7SUFDMUI7SUFDQXN4RCxlQUFlRCxPQUFPLEVBQUU7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1lBQ2hCLE1BQU12d0QsTUFBTTtRQUNkO1FBQ0EsTUFBTUosTUFBTTtZQUNWd1IsTUFBTTtZQUNOaE0sTUFBTTtnQkFDSjZyRDtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNWLE1BQU0sQ0FBQ00sV0FBVyxDQUFDanhEO0lBQzFCO0lBQ0FveUQsa0JBQWtCeGpDLEtBQUssRUFBRWtrQyxRQUFRLEVBQUVsUCxTQUFTLEVBQUU7UUFDNUMsSUFBSSxDQUFDaDFCLE1BQU12SCxRQUFRLEVBQUU7WUFDbkI7UUFDRjtRQUNBLElBQUksQ0FBRXU4QixDQUFBQSxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVXJsQyxRQUFRLEtBQUtxbEMsVUFBVXJsQyxRQUFRLEtBQUssSUFBSTtZQUM1RyxNQUFNLElBQUlsZ0IsVUFBVTtRQUN0QjtRQUNBLElBQUksQ0FBQzAwRCxjQUFjLENBQUNua0MsTUFBTXZILFFBQVEsRUFBRXVILE1BQU02dUIsYUFBYSxFQUFFcVYsVUFBVWxrQyxNQUFNcGQsSUFBSSxLQUFLLFVBQVVpeUMsMkJBQTJCRyxVQUFVcmxDLFFBQVEsSUFBSWpqQjtJQUMvSTtJQUNBbTNELGdCQUFnQjdqQyxLQUFLLEVBQUV1RyxNQUFNLEVBQUU7UUFDN0IsSUFBSSxDQUFFdkcsQ0FBQUEsaUJBQWlCNDlCLFVBQVMsS0FBTSxDQUFDcjNCLFFBQVE7WUFDN0MsSUFBSSxDQUFDQSxRQUFRdDJCLGNBQWNncEIsSUFBSSxDQUFDO1lBQ2hDO1FBQ0Y7UUFDQSxJQUFJLENBQUNtckMsWUFBWSxDQUFDNzlCLFFBQVF2RyxNQUFNNnVCLGFBQWEsRUFBRW5pRDtJQUNqRDtJQUNBOzs7O0dBSUMsR0FDRHkzRCxlQUFlMXJDLFFBQVEsRUFBRThILE9BQU8sRUFBRTlPLG1CQUFtQixFQUFFOGhCLEtBQUssRUFBRTtRQUM1RCxPQUFPMWMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDa3JDLE1BQU0sRUFBRTtnQkFDaEI7WUFDRjtZQUNBLElBQUluaUIsOEJBQThCO2dCQUNoQyxNQUFNcnJDLFVBQVU7b0JBQ2RxTyxNQUFNO29CQUNONk87b0JBQ0E4TztvQkFDQWdUO2dCQUNGO2dCQUNBLGFBQWE7Z0JBQ2I5YSxTQUFTNHJDLFNBQVMsR0FBRyxJQUFJeGtCLHNCQUFzQixJQUFJLENBQUNraUIsTUFBTSxFQUFFeHREO1lBQzlELE9BQU87Z0JBQ0wsSUFBSXdxQyxhQUFhdG1CLFlBQVk4YSxPQUFPO29CQUNsQyxvQkFBb0I7b0JBQ3BCLE1BQU1uaUMsTUFBTTt3QkFDVndSLE1BQU07d0JBQ05oTSxNQUFNOzRCQUNKMnBCOzRCQUNBZ1Q7NEJBQ0E5aEIscUJBQXFCQTt3QkFDdkI7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDc3dDLE1BQU0sQ0FBQ00sV0FBVyxDQUFDanhEO29CQUN4QjtnQkFDRjtnQkFDQSxhQUFhO2dCQUNiLElBQUl5cUMsV0FBV3BqQixTQUFTNnJDLGNBQWM7Z0JBQ3RDLGFBQWE7Z0JBQ2IsSUFBSUMsV0FBVzlyQyxTQUFTK3JDLGNBQWM7Z0JBQ3RDLElBQUksQ0FBQzNvQixZQUFZLENBQUMwb0IsVUFBVTtvQkFDMUIsYUFBYTtvQkFDYixNQUFNRSxrQkFBa0Joc0MsU0FBU3FuQixvQkFBb0I7b0JBQ3JELGFBQWE7b0JBQ2JybkIsU0FBUzZyQyxjQUFjLEdBQUdHLGdCQUFnQjVvQixRQUFRO29CQUNsREEsV0FBVzRvQixnQkFBZ0I1b0IsUUFBUTtvQkFDbkMsYUFBYTtvQkFDYnBqQixTQUFTK3JDLGNBQWMsR0FBR0MsZ0JBQWdCRixRQUFRO29CQUNsREEsV0FBV0UsZ0JBQWdCRixRQUFRO2dCQUNyQztnQkFDQSxNQUFNbnpELE1BQU07b0JBQ1Z3UixNQUFNO29CQUNOaE0sTUFBTTt3QkFDSjR0RCxnQkFBZ0JEO3dCQUNoQkQsZ0JBQWdCem9CO3dCQUNoQnRiLFNBQVNBO3dCQUNUZ1Q7d0JBQ0E5aEIscUJBQXFCQTtvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDc3dDLE1BQU0sQ0FBQ00sV0FBVyxDQUFDanhELEtBQUs7b0JBQUNtekQ7b0JBQVUxb0I7aUJBQVM7WUFDbkQ7WUFDQSxhQUFhO1lBQ2JwakIsUUFBUSxDQUFDc21CLFVBQVUsR0FBRztRQUN4QjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEcWxCLGFBQWE3OUIsTUFBTSxFQUFFaEcsT0FBTyxFQUFFZ1QsS0FBSyxFQUFFO1FBQ25DLElBQUl0OUI7UUFDSixJQUFJOG9DLGFBQWF4WSxVQUFVLENBQUMsSUFBSSxDQUFDdzdCLE1BQU0sRUFBRTtZQUN2QztRQUNGO1FBQ0EsSUFBSSxDQUFFLEVBQUM5ckQsS0FBSyxJQUFJLENBQUN3ckQsSUFBSSxNQUFNLFFBQVF4ckQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeXJELGdCQUFnQixDQUFDNXlDLFFBQVEsS0FBSyxJQUFJLENBQUMyeUMsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQzV5QyxRQUFRLEtBQUssSUFBSTtZQUN2SSxNQUFNcmYsVUFBVTtRQUNsQjtRQUNBLElBQUltd0MsOEJBQThCO1lBQ2hDM3ZDLGNBQWNDLElBQUksQ0FBQztZQUNuQixNQUFNcUUsVUFBVTtnQkFDZHFPLE1BQU07Z0JBQ042TyxxQkFBcUIsSUFBSSxDQUFDZ3dDLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUM1eUMsUUFBUTtnQkFDeER5UjtnQkFDQWdUO1lBQ0Y7WUFDQSxhQUFhO1lBQ2JoTixPQUFPODlCLFNBQVMsR0FBRyxJQUFJeGtCLHNCQUFzQixJQUFJLENBQUNraUIsTUFBTSxFQUFFeHREO1FBQzVELE9BQU87WUFDTHRFLGNBQWNDLElBQUksQ0FBQztZQUNuQixhQUFhO1lBQ2IsTUFBTXcwRCxnQkFBZ0JuK0IsT0FBT3VaLG9CQUFvQjtZQUNqRCxNQUFNMXVDLE1BQU07Z0JBQ1Z3UixNQUFNO2dCQUNOaE0sTUFBTTtvQkFDSjR0RCxnQkFBZ0JFLGNBQWNILFFBQVE7b0JBQ3RDRCxnQkFBZ0JJLGNBQWM3b0IsUUFBUTtvQkFDdEN0STtvQkFDQWhUO29CQUNBOU8scUJBQXFCLElBQUksQ0FBQ2d3QyxJQUFJLENBQUNDLGdCQUFnQixDQUFDNXlDLFFBQVE7Z0JBQzFEO1lBQ0Y7WUFDQSxJQUFJLENBQUNpekMsTUFBTSxDQUFDTSxXQUFXLENBQUNqeEQsS0FBSztnQkFBQ3N6RCxjQUFjSCxRQUFRO2dCQUFFRyxjQUFjN29CLFFBQVE7YUFBQztRQUMvRTtRQUNBLGFBQWE7UUFDYnRWLE1BQU0sQ0FBQ3dZLFVBQVUsR0FBRztJQUN0QjtBQUNGO0FBRUEsSUFBSTRsQjtBQUNILFVBQVVBLGVBQWU7SUFDeEJBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbERBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbERBLGVBQWUsQ0FBQ0EsZUFBZSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDdEQsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQyxNQUFNQztJQUNKcnVELGFBQWM7UUFDWixJQUFJLENBQUNzdUQsWUFBWSxHQUFHLElBQUkzbUM7UUFDeEIsSUFBSSxDQUFDNG1DLFNBQVMsR0FBRyxJQUFJaEo7UUFDckIsSUFBSSxDQUFDaUosYUFBYSxHQUFHO0lBQ3ZCO0lBQ0FDLElBQUlDLElBQUksRUFBRTtRQUNSLE9BQU9wdUMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNcXVDLFdBQVc7Z0JBQ2ZybEMsSUFBSSxJQUFJLENBQUNrbEMsYUFBYTtnQkFDdEJJLFlBQVkxNUMsS0FBS1EsR0FBRztnQkFDcEJxM0IsUUFBUXFoQixnQkFBZ0JTLE9BQU87WUFDakM7WUFDQSxJQUFJLENBQUNQLFlBQVksQ0FBQ2pvRCxHQUFHLENBQUNzb0QsU0FBU3JsQyxFQUFFLEVBQUVxbEM7WUFDbkMsTUFBTTFFLFNBQVMsTUFBTSxJQUFJLENBQUNzRSxTQUFTLENBQUM1SSxJQUFJO1lBQ3hDLElBQUk7Z0JBQ0ZnSixTQUFTRyxVQUFVLEdBQUc1NUMsS0FBS1EsR0FBRztnQkFDOUJpNUMsU0FBUzVoQixNQUFNLEdBQUdxaEIsZ0JBQWdCVyxPQUFPO2dCQUN6QyxPQUFPLE1BQU1MO1lBQ2YsU0FBVTtnQkFDUkMsU0FBUzVoQixNQUFNLEdBQUdxaEIsZ0JBQWdCWSxTQUFTO2dCQUMzQyxJQUFJLENBQUNWLFlBQVksQ0FBQ3htQyxNQUFNLENBQUM2bUMsU0FBU3JsQyxFQUFFO2dCQUNwQzJnQztZQUNGO1FBQ0Y7SUFDRjtJQUNBZ0YsUUFBUTtRQUNOLE9BQU8zdUMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxPQUFPLElBQUksQ0FBQ211QyxHQUFHLENBQUMsSUFBTW51QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHLGFBQWM7UUFDdEU7SUFDRjtJQUNBNHVDLFdBQVc7UUFDVCxPQUFPOTdELE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQ2tpQixZQUFZLENBQUNqeUQsTUFBTTtJQUM1QztBQUNGO0FBRUEsTUFBTTh5RCwwQkFBMEI7SUFBQztJQUFhO0lBQVc7SUFBUztJQUFVO0lBQVk7Q0FBUTtBQUNoRyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDOUIsTUFBTUMsVUFBVUgsd0JBQXdCcDNELE9BQU8sQ0FBQ3MzRCxJQUFJampELElBQUksS0FBSztJQUM3RDFTLGNBQWN6RCxLQUFLLENBQUMsb0NBQW9DO1FBQ3REcTVEO1FBQ0FEO0lBQ0Y7SUFDQSxPQUFPQztBQUNUO0FBQ0EsSUFBSUM7QUFDSCxVQUFVQSxxQkFBcUI7SUFDOUJBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQ2pFQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRztJQUNoRUEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDbkVBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUc7SUFDcEVBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0FBQ3JFLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDdEQsY0FBYyxHQUNkLE1BQU1DO0lBQ0osSUFBSUMsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ2ozQyxLQUFLO0lBQ25CO0lBQ0EsSUFBSWszQyxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUNsM0MsS0FBSyxLQUFLKzJDLHNCQUFzQkksYUFBYSxJQUFJLElBQUksQ0FBQ24zQyxLQUFLLEtBQUsrMkMsc0JBQXNCSyxZQUFZO0lBQ2hIO0lBQ0EsSUFBSUMsMkJBQTJCO1FBQzdCLE9BQU8sSUFBSSxDQUFDcjNDLEtBQUssS0FBSysyQyxzQkFBc0JPLFVBQVUsSUFBSSxJQUFJLENBQUN0M0MsS0FBSyxLQUFLKzJDLHNCQUFzQlEsWUFBWTtJQUM3RztJQUNBL3ZELGFBQWM7UUFDWixJQUFJZ3dELFVBQVVsNkQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDbEYsSUFBSW9oRCxnQkFBZ0JwaEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RixJQUFJNEo7UUFDSiwrQkFBK0IsR0FDL0IsSUFBSSxDQUFDMjJDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQzc5QixLQUFLLEdBQUcrMkMsc0JBQXNCSyxZQUFZO1FBQy9DLElBQUksQ0FBQzc2RCxHQUFHLEdBQUcyRTtRQUNYLGNBQWMsR0FDZCxJQUFJLENBQUN1MkQsY0FBYyxHQUFHO1lBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLzVEO1lBQ2hCLElBQUksQ0FBQ2c2RCxPQUFPLEdBQUdoNkQ7WUFDZixJQUFJLENBQUNpNkQscUJBQXFCLEdBQUdqNkQ7WUFDN0IsSUFBSSxDQUFDazZELHVCQUF1QixHQUFHbDZEO1lBQy9CLElBQUksQ0FBQ202RCxvQkFBb0IsR0FBR242RDtZQUM1QixJQUFJLENBQUNvNkQsT0FBTyxHQUFHcDZEO1lBQ2YsSUFBSSxDQUFDcTZELG1CQUFtQixHQUFHcjZEO1lBQzNCLElBQUksQ0FBQ3M2RCx5QkFBeUIsR0FBR3Q2RDtZQUNqQyxJQUFJLENBQUN1NkQsY0FBYyxHQUFHdjZEO1lBQ3RCLElBQUksQ0FBQ3c2RCxTQUFTLEdBQUd4NkQ7WUFDakIsSUFBSSxDQUFDeTZELE9BQU8sR0FBR3o2RDtRQUNqQjtRQUNBLElBQUksQ0FBQ3BCLEdBQUcsR0FBR2tFLFVBQVUsQ0FBQ3lHLEtBQUt3M0MsY0FBYzVnRCxVQUFVLE1BQU0sUUFBUW9KLE9BQU8sS0FBSyxJQUFJQSxLQUFLakcsWUFBWW8zRCxNQUFNO1FBQ3hHLElBQUksQ0FBQ2haLGVBQWUsR0FBR1gsY0FBY1csZUFBZTtRQUNwRCxJQUFJLENBQUNtWSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDYyxZQUFZLEdBQUcsSUFBSXpDO1FBQ3hCLElBQUksQ0FBQzBDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUl6TDtRQUN2QixJQUFJLENBQUMwTCxjQUFjLEdBQUcsSUFBSTFMO1FBQzFCLElBQUksQ0FBQy9zQyxLQUFLLEdBQUcrMkMsc0JBQXNCSyxZQUFZO0lBQ2pEO0lBQ0EsSUFBSTFYLGFBQWE7UUFDZixJQUFJeDRDLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUNtNEMsZUFBZSxNQUFNLFFBQVFuNEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksT0FBTyxRQUFRK2YsT0FBTyxLQUFLLElBQUlBLEtBQUssQ0FBQztJQUNqSTtJQUNBak8sS0FBS3d6QixHQUFHLEVBQUVtM0IsS0FBSyxFQUFFemtCLElBQUksRUFBRTBrQixXQUFXLEVBQUU7UUFDbEMsT0FBTzd3QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLDZFQUE2RTtZQUM3RSxZQUFZO1lBQ1osSUFBSSxDQUFDOUgsS0FBSyxHQUFHKzJDLHNCQUFzQk8sVUFBVTtZQUM3QyxJQUFJLENBQUM5eEQsT0FBTyxHQUFHeXVDO1lBQ2YsTUFBTTJrQixNQUFNLE1BQU0sSUFBSSxDQUFDNVQsT0FBTyxDQUFDempCLEtBQUttM0IsT0FBT3prQixNQUFNMGtCO1lBQ2pELE9BQU9DO1FBQ1Q7SUFDRjtJQUNBQyxVQUFVdDNCLEdBQUcsRUFBRW0zQixLQUFLLEVBQUV0NkMsR0FBRyxFQUFFazJCLE1BQU0sRUFBRTtRQUNqQyxPQUFPeHNCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ3RpQixPQUFPLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQ2pKLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMscUVBQXFFLElBQUksQ0FBQ3cxQixVQUFVO2dCQUNsRztZQUNGO1lBQ0EsSUFBSSxDQUFDMS9CLEtBQUssR0FBRysyQyxzQkFBc0JRLFlBQVk7WUFDL0Msc0RBQXNEO1lBQ3RELElBQUksQ0FBQ3VCLGlCQUFpQjtZQUN0QixNQUFNRixNQUFNLE1BQU0sSUFBSSxDQUFDNVQsT0FBTyxDQUFDempCLEtBQUttM0IsT0FBTzU5RCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDVSxPQUFPLEdBQUc7Z0JBQ3hGcXpELFdBQVc7Z0JBQ1h6NkM7Z0JBQ0EyNkMsaUJBQWlCemtCO1lBQ25CO1lBQ0EsT0FBT3NrQjtRQUNUO0lBQ0Y7SUFDQTVULFFBQVF6akIsR0FBRyxFQUFFbTNCLEtBQUssRUFBRXprQixJQUFJLEVBQUUwa0IsV0FBVyxFQUFFO1FBQ3JDLElBQUksQ0FBQ0ssY0FBYyxHQUFHL2tCO1FBQ3RCMVMsTUFBTW1zQixlQUFlbnNCO1FBQ3JCLHVCQUF1QjtRQUN2QkEsTUFBTUEsSUFBSXhrQixPQUFPLENBQUMsT0FBTztRQUN6QndrQixPQUFPO1FBQ1AsTUFBTTAzQixhQUFhaFA7UUFDbkIsTUFBTXJyQixTQUFTczZCLHVCQUF1QlIsT0FBT08sWUFBWWhsQjtRQUN6RCxPQUFPLElBQUk1ckIsUUFBUSxDQUFDRCxTQUFTRSxTQUFXUixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUN0RSxNQUFNMnBDLFNBQVMsTUFBTSxJQUFJLENBQUNnSCxjQUFjLENBQUN0TCxJQUFJO2dCQUM3QyxJQUFJO29CQUNGLE1BQU1nTSxlQUFlLElBQU1yeEMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDekQsSUFBSSxDQUFDdTlCLEtBQUs7NEJBQ1Z4UCxhQUFhdWpCOzRCQUNiOXdDLE9BQU8sSUFBSStyQixnQkFBZ0I7d0JBQzdCO29CQUNBLE1BQU0ra0IsWUFBWXRqQixXQUFXO3dCQUMzQixJQUFJLENBQUN1UCxLQUFLO3dCQUNWLzhCLE9BQU8sSUFBSStyQixnQkFBZ0I7b0JBQzdCLEdBQUdKLEtBQUtvbEIsZ0JBQWdCO29CQUN4QixJQUFJVixnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSSxLQUFLLElBQUlBLFlBQVlXLE9BQU8sRUFBRTt3QkFDakZIO29CQUNGO29CQUNBUixnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSSxLQUFLLElBQUlBLFlBQVk3cUMsZ0JBQWdCLENBQUMsU0FBU3FyQztvQkFDaEcsSUFBSSxDQUFDNThELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxpQkFBaUJxSSxNQUFNLENBQUNnN0IsTUFBTTNDLFNBQVMsSUFBSSxDQUFDOGdCLFVBQVU7b0JBQ3JFLElBQUksSUFBSSxDQUFDNlosRUFBRSxFQUFFO3dCQUNYLE1BQU0sSUFBSSxDQUFDbFUsS0FBSztvQkFDbEI7b0JBQ0EsSUFBSSxDQUFDa1UsRUFBRSxHQUFHLElBQUlDLFVBQVVqNEIsTUFBTTNDO29CQUM5QixJQUFJLENBQUMyNkIsRUFBRSxDQUFDRSxVQUFVLEdBQUc7b0JBQ3JCLElBQUksQ0FBQ0YsRUFBRSxDQUFDRyxNQUFNLEdBQUc7d0JBQ2Y3akIsYUFBYXVqQjtvQkFDZjtvQkFDQSxJQUFJLENBQUNHLEVBQUUsQ0FBQ2xHLE9BQU8sR0FBR2hCLENBQUFBLEtBQU12cUMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDdEQsSUFBSSxJQUFJLENBQUM5SCxLQUFLLEtBQUsrMkMsc0JBQXNCNEMsU0FBUyxFQUFFO2dDQUNsRDlqQixhQUFhdWpCO2dDQUNiLElBQUk7b0NBQ0YsTUFBTVEsT0FBTyxNQUFNQyxNQUFNLE9BQU90ekQsTUFBTSxDQUFDZzdCLElBQUk1NUIsU0FBUyxDQUFDLElBQUksYUFBYXBCLE1BQU0sQ0FBQ3E0QjtvQ0FDN0UsSUFBSWc3QixLQUFLcmxCLE1BQU0sQ0FBQ3VsQixPQUFPLENBQUMsR0FBR3I0RCxVQUFVLENBQUMsTUFBTTt3Q0FDMUMsTUFBTVksTUFBTSxNQUFNdTNELEtBQUtHLElBQUk7d0NBQzNCenhDLE9BQU8sSUFBSStyQixnQkFBZ0JoeUMsS0FBSyxFQUFFLG9DQUFvQyxLQUFJdTNELEtBQUtybEIsTUFBTTtvQ0FDdkYsT0FBTzt3Q0FDTGpzQixPQUFPLElBQUkrckIsZ0JBQWdCLGtCQUFrQixFQUFFLHVDQUF1QyxLQUFJdWxCLEtBQUtybEIsTUFBTTtvQ0FDdkc7Z0NBQ0YsRUFBRSxPQUFPNTVDLEdBQUc7b0NBQ1YydEIsT0FBTyxJQUFJK3JCLGdCQUFnQiw0QkFBNEIsRUFBRSwyQ0FBMkM7Z0NBQ3RHO2dDQUNBOzRCQUNGOzRCQUNBLHVCQUF1Qjs0QkFDdkIsSUFBSSxDQUFDMmxCLGFBQWEsQ0FBQzNIO3dCQUNyQjtvQkFDQSxJQUFJLENBQUNrSCxFQUFFLENBQUNuRyxTQUFTLEdBQUdmLENBQUFBLEtBQU12cUMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDeEQsSUFBSTVnQixJQUFJOFUsSUFBSUMsSUFBSUM7NEJBQ2hCLDBEQUEwRDs0QkFDMUQsSUFBSTA5Qzs0QkFDSixJQUFJLE9BQU92SCxHQUFHeHFELElBQUksS0FBSyxVQUFVO2dDQUMvQixNQUFNM0IsT0FBT0csS0FBS0MsS0FBSyxDQUFDK3JELEdBQUd4cUQsSUFBSTtnQ0FDL0IreEQsT0FBT3hmLGVBQWVwMEMsUUFBUSxDQUFDRTs0QkFDakMsT0FBTyxJQUFJbXNELEdBQUd4cUQsSUFBSSxZQUFZNkQsYUFBYTtnQ0FDekNrdUQsT0FBT3hmLGVBQWU5MEMsVUFBVSxDQUFDLElBQUlvSSxXQUFXMmtELEdBQUd4cUQsSUFBSTs0QkFDekQsT0FBTztnQ0FDTCxJQUFJLENBQUN0TCxHQUFHLENBQUM2c0IsS0FBSyxDQUFDLHVDQUF1QzdpQixNQUFNLENBQUMsT0FBTzhyRCxHQUFHeHFELElBQUksR0FBRyxJQUFJLENBQUM2M0MsVUFBVTtnQ0FDN0Y7NEJBQ0Y7NEJBQ0EsSUFBSSxJQUFJLENBQUMxL0IsS0FBSyxLQUFLKzJDLHNCQUFzQjRDLFNBQVMsRUFBRTtnQ0FDbEQsSUFBSU0sdUJBQXVCO2dDQUMzQiwyQkFBMkI7Z0NBQzNCLElBQUksQ0FBQyxDQUFDL3lELEtBQUsweUQsS0FBS3B6RCxPQUFPLE1BQU0sUUFBUVUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHME0sSUFBSSxNQUFNLFFBQVE7b0NBQ2pGLElBQUksQ0FBQ29NLEtBQUssR0FBRysyQyxzQkFBc0I0QyxTQUFTO29DQUM1Q2hCLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWTNxQyxtQkFBbUIsQ0FBQyxTQUFTbXJDO29DQUNuRyxJQUFJLENBQUNlLG1CQUFtQixHQUFHTixLQUFLcHpELE9BQU8sQ0FBQ2hDLEtBQUssQ0FBQ20zQyxXQUFXO29DQUN6RCxJQUFJLENBQUN3ZSxvQkFBb0IsR0FBR1AsS0FBS3B6RCxPQUFPLENBQUNoQyxLQUFLLENBQUNvM0MsWUFBWTtvQ0FDM0QsSUFBSSxJQUFJLENBQUNzZSxtQkFBbUIsSUFBSSxJQUFJLENBQUNBLG1CQUFtQixHQUFHLEdBQUc7d0NBQzVELElBQUksQ0FBQzM5RCxHQUFHLENBQUMyQixLQUFLLENBQUMsZUFBZXBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHOzRDQUM5RWdSLFNBQVMsSUFBSSxDQUFDd0osbUJBQW1COzRDQUNqQ0UsVUFBVSxJQUFJLENBQUNELG9CQUFvQjt3Q0FDckM7d0NBQ0EsSUFBSSxDQUFDRSxpQkFBaUI7b0NBQ3hCO29DQUNBanlDLFFBQVF3eEMsS0FBS3B6RCxPQUFPLENBQUNoQyxLQUFLO2dDQUM1QixPQUFPLElBQUksSUFBSSxDQUFDd2IsS0FBSyxLQUFLKzJDLHNCQUFzQlEsWUFBWSxJQUFJcUMsS0FBS3B6RCxPQUFPLENBQUNvTixJQUFJLEtBQUssU0FBUztvQ0FDN0YsaUVBQWlFO29DQUNqRSxJQUFJLENBQUNvTSxLQUFLLEdBQUcrMkMsc0JBQXNCNEMsU0FBUztvQ0FDNUNoQixnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSSxLQUFLLElBQUlBLFlBQVkzcUMsbUJBQW1CLENBQUMsU0FBU21yQztvQ0FDbkcsSUFBSSxDQUFDa0IsaUJBQWlCO29DQUN0QixJQUFJLENBQUMsQ0FBQ3IrQyxLQUFLNDlDLEtBQUtwekQsT0FBTyxNQUFNLFFBQVF3VixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdwSSxJQUFJLE1BQU0sYUFBYTt3Q0FDdEZ3VSxRQUFRLENBQUNuTSxLQUFLMjlDLEtBQUtwekQsT0FBTyxNQUFNLFFBQVF5VixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd6WCxLQUFLO29DQUMzRSxPQUFPO3dDQUNMNGpCO3dDQUNBNnhDLHVCQUF1QjtvQ0FDekI7Z0NBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQzVDLHdCQUF3QixJQUFJdUMsS0FBS3B6RCxPQUFPLENBQUNvTixJQUFJLEtBQUssU0FBUztvQ0FDekUwVSxPQUFPLElBQUkrckIsZ0JBQWdCLHNEQUFzRCxFQUFFLHNDQUFzQztnQ0FDM0gsT0FBTyxJQUFJLENBQUNKLEtBQUs0a0IsU0FBUyxFQUFFO29DQUMxQix5REFBeUQ7b0NBQ3pEdndDLE9BQU8sSUFBSStyQixnQkFBZ0Isc0NBQXNDOXRDLE1BQU0sQ0FBQyxDQUFDMlYsS0FBSzA5QyxLQUFLcHpELE9BQU8sTUFBTSxRQUFRMFYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdEksSUFBSSxFQUFFO2dDQUM1STtnQ0FDQSxJQUFJLENBQUNxbUQsc0JBQXNCO29DQUN6QjtnQ0FDRjs0QkFDRjs0QkFDQSxJQUFJLElBQUksQ0FBQ0ssYUFBYSxFQUFFO2dDQUN0QixNQUFNclYsTUFBTSxJQUFJLENBQUNxVixhQUFhOzRCQUNoQzs0QkFDQSxJQUFJLENBQUNDLG9CQUFvQixDQUFDWDt3QkFDNUI7b0JBQ0EsSUFBSSxDQUFDTCxFQUFFLENBQUNpQixPQUFPLEdBQUduSSxDQUFBQTt3QkFDaEIsSUFBSSxJQUFJLENBQUNnRix3QkFBd0IsRUFBRTs0QkFDakMvdUMsT0FBTyxJQUFJK3JCLGdCQUFnQjt3QkFDN0I7d0JBQ0EsSUFBSSxDQUFDOTNDLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsb0JBQW9CcHZCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHOzRCQUNsRnBMLFFBQVErZCxHQUFHL2QsTUFBTTs0QkFDakJ0MEIsT0FBTyxJQUFJLENBQUNBLEtBQUs7d0JBQ25CO3dCQUNBLElBQUksQ0FBQ3k2QyxhQUFhLENBQUNwSSxHQUFHL2QsTUFBTTtvQkFDOUI7Z0JBQ0YsU0FBVTtvQkFDUm1kO2dCQUNGO1lBQ0Y7SUFDRjtJQUNBcE0sUUFBUTtRQUNOLE9BQU92OUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNMnBDLFNBQVMsTUFBTSxJQUFJLENBQUMrRyxXQUFXLENBQUNyTCxJQUFJO1lBQzFDLElBQUk7Z0JBQ0YsSUFBSSxDQUFDbnRDLEtBQUssR0FBRysyQyxzQkFBc0JJLGFBQWE7Z0JBQ2hELElBQUksSUFBSSxDQUFDb0MsRUFBRSxFQUFFO29CQUNYLElBQUksQ0FBQ0EsRUFBRSxDQUFDbkcsU0FBUyxHQUFHO29CQUNwQixJQUFJLENBQUNtRyxFQUFFLENBQUNHLE1BQU0sR0FBRztvQkFDakIsSUFBSSxDQUFDSCxFQUFFLENBQUNpQixPQUFPLEdBQUc7b0JBQ2xCLHdIQUF3SDtvQkFDeEgsTUFBTUUsZUFBZSxJQUFJcnlDLFFBQVFELENBQUFBO3dCQUMvQixJQUFJLElBQUksQ0FBQ214QyxFQUFFLEVBQUU7NEJBQ1gsSUFBSSxDQUFDQSxFQUFFLENBQUNpQixPQUFPLEdBQUc7Z0NBQ2hCcHlDOzRCQUNGO3dCQUNGLE9BQU87NEJBQ0xBO3dCQUNGO29CQUNGO29CQUNBLElBQUksSUFBSSxDQUFDbXhDLEVBQUUsQ0FBQ3JyQixVQUFVLEdBQUcsSUFBSSxDQUFDcXJCLEVBQUUsQ0FBQ29CLE9BQU8sRUFBRTt3QkFDeEMsSUFBSSxDQUFDcEIsRUFBRSxDQUFDbFUsS0FBSzt3QkFDYixnREFBZ0Q7d0JBQ2hELE1BQU1oOUIsUUFBUXV5QyxJQUFJLENBQUM7NEJBQUNGOzRCQUFjelYsTUFBTTt5QkFBSztvQkFDL0M7b0JBQ0EsSUFBSSxDQUFDc1UsRUFBRSxHQUFHNTdEO2dCQUNaO1lBQ0YsU0FBVTtnQkFDUixJQUFJLENBQUNxaUIsS0FBSyxHQUFHKzJDLHNCQUFzQkssWUFBWTtnQkFDL0MsSUFBSSxDQUFDMEIsaUJBQWlCO2dCQUN0QnJIO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsOEJBQThCO0lBQzlCb0osVUFBVUMsS0FBSyxFQUFFO1FBQ2YsSUFBSSxDQUFDditELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxpQkFBaUJwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztZQUNoRnFiLFVBQVVELE1BQU1oZ0MsR0FBRztRQUNyQjtRQUNBLElBQUksQ0FBQ2tnQyxXQUFXLENBQUM7WUFDZnBuRCxNQUFNO1lBQ05wUCxPQUFPeTJELDBCQUEwQkg7UUFDbkM7SUFDRjtJQUNBLGtDQUFrQztJQUNsQ0ksV0FBV0MsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQzUrRCxHQUFHLENBQUMyQixLQUFLLENBQUMsa0JBQWtCcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7WUFDakYwYixXQUFXRCxPQUFPcmdDLEdBQUc7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ2tnQyxXQUFXLENBQUM7WUFDdEJwbkQsTUFBTTtZQUNOcFAsT0FBT3kyRCwwQkFBMEJFO1FBQ25DO0lBQ0Y7SUFDQUUsaUJBQWlCMTZCLFNBQVMsRUFBRWx0QixNQUFNLEVBQUU7UUFDbEMsSUFBSSxDQUFDbFgsR0FBRyxDQUFDa0IsS0FBSyxDQUFDLHlCQUF5QjNDLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO1lBQ3hGL2U7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDcTZCLFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPLElBQUlnMUMsZUFBZTtnQkFDeEI0QixlQUFlLzBDLEtBQUtjLFNBQVMsQ0FBQ3c1QjtnQkFDOUJsdEI7WUFDRjtRQUNGO0lBQ0Y7SUFDQTZuRCxjQUFjdmYsUUFBUSxFQUFFOTZCLEtBQUssRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQys1QyxXQUFXLENBQUM7WUFDdEJwbkQsTUFBTTtZQUNOcFAsT0FBTyxJQUFJazFDLGlCQUFpQjtnQkFDMUJ0N0IsS0FBSzI5QjtnQkFDTDk2QjtZQUNGO1FBQ0Y7SUFDRjtJQUNBczZDLGFBQWExRSxHQUFHLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNtRSxXQUFXLENBQUM7WUFDdEJwbkQsTUFBTTtZQUNOcFAsT0FBT3F5RDtRQUNUO0lBQ0Y7SUFDQTJFLHdCQUF3Qjk4QyxRQUFRLEVBQUVwZ0IsSUFBSSxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxDQUFDMDhELFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPLElBQUkwMUMsMEJBQTBCO2dCQUNuQ3g3QjtnQkFDQXBnQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBbTlELHdCQUF3QkMsUUFBUSxFQUFFO1FBQ2hDLElBQUksQ0FBQ1YsV0FBVyxDQUFDO1lBQ2ZwbkQsTUFBTTtZQUNOcFAsT0FBT2szRDtRQUNUO0lBQ0Y7SUFDQUMsdUJBQXVCQyxHQUFHLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNaLFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPbzNEO1FBQ1Q7SUFDRjtJQUNBQyxjQUFjQyxJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNkLFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPczNEO1FBQ1Q7SUFDRjtJQUNBQyxzQkFBc0JoZ0IsUUFBUSxFQUFFajdCLE1BQU0sRUFBRTtRQUN0QyxPQUFPLElBQUksQ0FBQ2s2QyxXQUFXLENBQUM7WUFDdEJwbkQsTUFBTTtZQUNOcFAsT0FBTyxJQUFJczFDLGtCQUFrQjtnQkFDM0JpQztnQkFDQWo3QjtZQUNGO1FBQ0Y7SUFDRjtJQUNBazdDLGtDQUFrQzFlLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUU7UUFDbkUsT0FBTyxJQUFJLENBQUN5ZCxXQUFXLENBQUM7WUFDdEJwbkQsTUFBTTtZQUNOcFAsT0FBTyxJQUFJdTFDLHVCQUF1QjtnQkFDaEN1RDtnQkFDQUM7WUFDRjtRQUNGO0lBQ0Y7SUFDQTBlLHFCQUFxQnJlLFFBQVEsRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ29kLFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPbzVDO1FBQ1Q7SUFDRjtJQUNBc2UsV0FBVztRQUNULDBFQUEwRSxHQUMxRSxPQUFPN3pDLFFBQVFqTyxHQUFHLENBQUM7WUFBQyxJQUFJLENBQUM0Z0QsV0FBVyxDQUFDO2dCQUNuQ3BuRCxNQUFNO2dCQUNOcFAsT0FBTzJJLFdBQVc3RyxLQUFLLENBQUNvVyxLQUFLUSxHQUFHO1lBQ2xDO1lBQUksSUFBSSxDQUFDODlDLFdBQVcsQ0FBQztnQkFDbkJwbkQsTUFBTTtnQkFDTnBQLE9BQU8sSUFBSTIxQyxLQUFLO29CQUNkbmhCLFdBQVc3ckIsV0FBVzdHLEtBQUssQ0FBQ29XLEtBQUtRLEdBQUc7b0JBQ3BDMmdDLEtBQUsxd0MsV0FBVzdHLEtBQUssQ0FBQyxJQUFJLENBQUN1M0MsR0FBRztnQkFDaEM7WUFDRjtTQUFHO0lBQ0w7SUFDQXNlLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ25CLFdBQVcsQ0FBQztZQUN0QnBuRCxNQUFNO1lBQ05wUCxPQUFPLElBQUlxMUMsYUFBYTtnQkFDdEJ3QyxjQUFjO2dCQUNkL0gsUUFBUXYyQixpQkFBaUJxK0MsZ0JBQWdCO1lBQzNDO1FBQ0Y7SUFDRjtJQUNBcEIsWUFBWXgwRCxPQUFPLEVBQUU7UUFDbkIsSUFBSTYxRCxZQUFZLytELFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3BGLE9BQU93cUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxrRUFBa0U7WUFDbEUseUVBQXlFO1lBQ3pFLE1BQU13MEMsV0FBVyxDQUFDRCxhQUFhLENBQUN6RixvQkFBb0Jwd0Q7WUFDcEQsSUFBSTgxRCxZQUFZLElBQUksQ0FBQ3Q4QyxLQUFLLEtBQUsrMkMsc0JBQXNCUSxZQUFZLEVBQUU7Z0JBQ2pFLElBQUksQ0FBQ2dCLGNBQWMsQ0FBQzd6RCxJQUFJLENBQUMsSUFBTW9qQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO3dCQUM3RCxNQUFNLElBQUksQ0FBQ2t6QyxXQUFXLENBQUN4MEQsU0FBUztvQkFDbEM7Z0JBQ0E7WUFDRjtZQUNBLDREQUE0RDtZQUM1RCxJQUFJLENBQUM2MUQsV0FBVztnQkFDZCxNQUFNLElBQUksQ0FBQy9ELFlBQVksQ0FBQzdCLEtBQUs7WUFDL0I7WUFDQSxJQUFJLElBQUksQ0FBQzZELGFBQWEsRUFBRTtnQkFDdEIsTUFBTXJWLE1BQU0sSUFBSSxDQUFDcVYsYUFBYTtZQUNoQztZQUNBLElBQUksQ0FBQyxJQUFJLENBQUNmLEVBQUUsSUFBSSxJQUFJLENBQUNBLEVBQUUsQ0FBQ3JyQixVQUFVLEtBQUssSUFBSSxDQUFDcXJCLEVBQUUsQ0FBQ2dELElBQUksRUFBRTtnQkFDbkQsSUFBSSxDQUFDaGdFLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsc0RBQXNEN2lCLE1BQU0sQ0FBQ0MsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFvTixJQUFJLEdBQUcsSUFBSSxDQUFDOHJDLFVBQVU7Z0JBQzVKO1lBQ0Y7WUFDQSxNQUFNbVgsTUFBTSxJQUFJdmQsY0FBYztnQkFDNUI5eUM7WUFDRjtZQUNBLElBQUk7Z0JBQ0YsSUFBSSxJQUFJLENBQUNneEQsT0FBTyxFQUFFO29CQUNoQixJQUFJLENBQUMrQixFQUFFLENBQUN0ckIsSUFBSSxDQUFDNG9CLElBQUk1dkQsWUFBWTtnQkFDL0IsT0FBTztvQkFDTCxJQUFJLENBQUNzeUQsRUFBRSxDQUFDdHJCLElBQUksQ0FBQzRvQixJQUFJbndELFFBQVE7Z0JBQzNCO1lBQ0YsRUFBRSxPQUFPL0wsR0FBRztnQkFDVixJQUFJLENBQUM0QixHQUFHLENBQUM2c0IsS0FBSyxDQUFDLGdDQUFnQ3R1QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztvQkFDL0Z0MkIsT0FBT3p1QjtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUNBNC9ELHFCQUFxQjNCLEdBQUcsRUFBRTtRQUN4QixJQUFJMXhELElBQUk4VTtRQUNSLE1BQU0zWixNQUFNdTJELElBQUlweUQsT0FBTztRQUN2QixJQUFJbkUsT0FBTzFFLFdBQVc7WUFDcEIsSUFBSSxDQUFDcEIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLGdDQUFnQyxJQUFJLENBQUN3aEQsVUFBVTtZQUM5RDtRQUNGO1FBQ0EsSUFBSThjLGNBQWM7UUFDbEIsSUFBSW42RCxJQUFJdVIsSUFBSSxLQUFLLFVBQVU7WUFDekIsTUFBTTZvRCxLQUFLQyw0QkFBNEJyNkQsSUFBSW1DLEtBQUs7WUFDaEQsSUFBSSxJQUFJLENBQUNrekQsUUFBUSxFQUFFO2dCQUNqQixJQUFJLENBQUNBLFFBQVEsQ0FBQytFO1lBQ2hCO1FBQ0YsT0FBTyxJQUFJcDZELElBQUl1UixJQUFJLEtBQUssU0FBUztZQUMvQixNQUFNNm9ELEtBQUtDLDRCQUE0QnI2RCxJQUFJbUMsS0FBSztZQUNoRCxJQUFJLElBQUksQ0FBQ3V6RCxPQUFPLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQ0EsT0FBTyxDQUFDMEU7WUFDZjtRQUNGLE9BQU8sSUFBSXA2RCxJQUFJdVIsSUFBSSxLQUFLLFdBQVc7WUFDakMsTUFBTStzQixZQUFZdDZCLEtBQUtDLEtBQUssQ0FBQ2pFLElBQUltQyxLQUFLLENBQUM0MkMsYUFBYTtZQUNwRCxJQUFJLElBQUksQ0FBQytjLFNBQVMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUN4M0IsV0FBV3QrQixJQUFJbUMsS0FBSyxDQUFDaVAsTUFBTTtZQUM1QztRQUNGLE9BQU8sSUFBSXBSLElBQUl1UixJQUFJLEtBQUssVUFBVTtZQUNoQyxJQUFJLElBQUksQ0FBQytvRCxtQkFBbUIsRUFBRTtnQkFDNUIsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQyxDQUFDejFELEtBQUs3RSxJQUFJbUMsS0FBSyxDQUFDdzNDLFlBQVksTUFBTSxRQUFROTBDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDNUY7UUFDRixPQUFPLElBQUk3RSxJQUFJdVIsSUFBSSxLQUFLLGtCQUFrQjtZQUN4QyxJQUFJLElBQUksQ0FBQ2drRCxxQkFBcUIsRUFBRTtnQkFDOUIsSUFBSSxDQUFDQSxxQkFBcUIsQ0FBQ3YxRCxJQUFJbUMsS0FBSztZQUN0QztRQUNGLE9BQU8sSUFBSW5DLElBQUl1UixJQUFJLEtBQUssbUJBQW1CO1lBQ3pDLElBQUksSUFBSSxDQUFDZ3BELGlCQUFpQixFQUFFO2dCQUMxQixJQUFJLENBQUNBLGlCQUFpQixDQUFDLENBQUM1Z0QsS0FBSzNaLElBQUltQyxLQUFLLENBQUM4ZCxRQUFRLE1BQU0sUUFBUXRHLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDdEY7UUFDRixPQUFPLElBQUkzWixJQUFJdVIsSUFBSSxLQUFLLFNBQVM7WUFDL0IsSUFBSSxJQUFJLENBQUMrakQsT0FBTyxFQUFFO2dCQUNoQixJQUFJLENBQUNBLE9BQU8sQ0FBQ3QxRCxJQUFJbUMsS0FBSztZQUN4QjtRQUNGLE9BQU8sSUFBSW5DLElBQUl1UixJQUFJLEtBQUssUUFBUTtZQUM5QixJQUFJLElBQUksQ0FBQ29rRCxtQkFBbUIsRUFBRTtnQkFDNUIsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQzMxRCxJQUFJbUMsS0FBSyxDQUFDNFosR0FBRyxFQUFFL2IsSUFBSW1DLEtBQUssQ0FBQ3ljLEtBQUs7WUFDekQ7UUFDRixPQUFPLElBQUk1ZSxJQUFJdVIsSUFBSSxLQUFLLGNBQWM7WUFDcEMsSUFBSSxJQUFJLENBQUNpcEQsWUFBWSxJQUFJeDZELElBQUltQyxLQUFLLENBQUNrdUQsSUFBSSxFQUFFO2dCQUN2QyxJQUFJLENBQUNtSyxZQUFZLENBQUN4NkQsSUFBSW1DLEtBQUssQ0FBQ2t1RCxJQUFJO1lBQ2xDO1FBQ0YsT0FBTyxJQUFJcndELElBQUl1UixJQUFJLEtBQUsscUJBQXFCO1lBQzNDLElBQUksSUFBSSxDQUFDa3BELG1CQUFtQixFQUFFO2dCQUM1QixJQUFJLENBQUNBLG1CQUFtQixDQUFDejZELElBQUltQyxLQUFLO1lBQ3BDO1FBQ0YsT0FBTyxJQUFJbkMsSUFBSXVSLElBQUksS0FBSyxxQkFBcUI7WUFDM0MsSUFBSSxJQUFJLENBQUNtcEQsbUJBQW1CLEVBQUU7Z0JBQzVCLElBQUksQ0FBQ0EsbUJBQW1CLENBQUMxNkQsSUFBSW1DLEtBQUs7WUFDcEM7UUFDRixPQUFPLElBQUluQyxJQUFJdVIsSUFBSSxLQUFLLDJCQUEyQjtZQUNqRCxJQUFJLElBQUksQ0FBQ3FrRCx5QkFBeUIsRUFBRTtnQkFDbEMsSUFBSSxDQUFDQSx5QkFBeUIsQ0FBQzUxRCxJQUFJbUMsS0FBSztZQUMxQztRQUNGLE9BQU8sSUFBSW5DLElBQUl1UixJQUFJLEtBQUssZ0NBQWdDO1lBQ3RELElBQUksSUFBSSxDQUFDb3BELDhCQUE4QixFQUFFO2dCQUN2QyxJQUFJLENBQUNBLDhCQUE4QixDQUFDMzZELElBQUltQyxLQUFLO1lBQy9DO1FBQ0YsT0FBTyxJQUFJbkMsSUFBSXVSLElBQUksS0FBSyxnQkFBZ0I7WUFDdEMsSUFBSSxJQUFJLENBQUNza0QsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQzcxRCxJQUFJbUMsS0FBSztZQUMvQjtRQUNGLE9BQU8sSUFBSW5DLElBQUl1UixJQUFJLEtBQUssb0JBQW9CO1lBQzFDLElBQUksSUFBSSxDQUFDaWtELHVCQUF1QixFQUFFO2dCQUNoQyxJQUFJLENBQUNBLHVCQUF1QixDQUFDeDFELElBQUltQyxLQUFLO1lBQ3hDO1FBQ0YsT0FBTyxJQUFJbkMsSUFBSXVSLElBQUksS0FBSyx3QkFBd0I7WUFDOUMsSUFBSSxJQUFJLENBQUNxcEQsbUJBQW1CLEVBQUU7Z0JBQzVCLElBQUksQ0FBQ0EsbUJBQW1CLENBQUM1NkQsSUFBSW1DLEtBQUs7WUFDcEM7UUFDRixPQUFPLElBQUluQyxJQUFJdVIsSUFBSSxLQUFLO2FBQWUsSUFBSXZSLElBQUl1UixJQUFJLEtBQUssWUFBWTtZQUNsRSxJQUFJLENBQUNpcUMsR0FBRyxHQUFHbmhDLEtBQUtRLEdBQUcsS0FBS2phLE9BQU9tUyxRQUFRLENBQUMvUyxJQUFJbUMsS0FBSyxDQUFDczVDLGlCQUFpQixDQUFDOXlDLFFBQVE7WUFDNUUsSUFBSSxDQUFDa3lELGdCQUFnQjtZQUNyQlYsY0FBYztRQUNoQixPQUFPO1lBQ0wsSUFBSSxDQUFDamdFLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyx1QkFBdUJwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDdEZ5ZCxTQUFTOTZELElBQUl1UixJQUFJO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJLENBQUM0b0QsYUFBYTtZQUNoQixJQUFJLENBQUNVLGdCQUFnQjtRQUN2QjtJQUNGO0lBQ0FFLGlCQUFpQjtRQUNmLE1BQU8sSUFBSSxDQUFDN0UsY0FBYyxDQUFDdjZELE1BQU0sR0FBRyxFQUFHO1lBQ3JDLE1BQU02NEQsTUFBTSxJQUFJLENBQUMwQixjQUFjLENBQUM1dkQsS0FBSztZQUNyQyxJQUFJa3VELEtBQUs7Z0JBQ1AsSUFBSSxDQUFDeUIsWUFBWSxDQUFDckMsR0FBRyxDQUFDWTtZQUN4QjtRQUNGO0lBQ0Y7SUFDQTRELGNBQWNubUIsTUFBTSxFQUFFO1FBQ3BCLE9BQU94c0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLElBQUksQ0FBQzlILEtBQUssS0FBSysyQyxzQkFBc0JLLFlBQVksRUFBRTtZQUN2RCxNQUFNaUcsa0JBQWtCLElBQUksQ0FBQ2pGLE9BQU87WUFDcEMsTUFBTSxJQUFJLENBQUMvUyxLQUFLO1lBQ2hCLElBQUksQ0FBQzlvRCxHQUFHLENBQUMyQixLQUFLLENBQUMsZ0NBQWdDcUksTUFBTSxDQUFDK3RDLFNBQVN4NUMsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7Z0JBQy9HcEw7WUFDRjtZQUNBLElBQUkrb0IsaUJBQWlCO2dCQUNuQkEsZ0JBQWdCL29CO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBMGxCLGNBQWMzSCxFQUFFLEVBQUU7UUFDaEIsSUFBSSxDQUFDOTFELEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsbUJBQW1CdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO1lBQ2xGdDJCLE9BQU9pcEM7UUFDVDtJQUNGO0lBQ0E7OztHQUdDLEdBQ0Q2SyxtQkFBbUI7UUFDakIsSUFBSSxDQUFDSSxnQkFBZ0I7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQ3BELG1CQUFtQixFQUFFO1lBQzdCLElBQUksQ0FBQzM5RCxHQUFHLENBQUMydEIsSUFBSSxDQUFDLGlDQUFpQyxJQUFJLENBQUN3MUIsVUFBVTtZQUM5RDtRQUNGO1FBQ0EsSUFBSSxDQUFDL0QsV0FBVyxHQUFHakYsZUFBZVosVUFBVSxDQUFDO1lBQzNDLElBQUksQ0FBQ3Y1QyxHQUFHLENBQUMydEIsSUFBSSxDQUFDLGtEQUFrRDNqQixNQUFNLENBQUMsSUFBSW1XLEtBQUtBLEtBQUtRLEdBQUcsS0FBSyxJQUFJLENBQUNnOUMsbUJBQW1CLEdBQUcsTUFBTXFELFdBQVcsS0FBSyxJQUFJLENBQUM3ZCxVQUFVO1lBQzdKLElBQUksQ0FBQythLGFBQWEsQ0FBQztRQUNyQixHQUFHLElBQUksQ0FBQ1AsbUJBQW1CLEdBQUc7SUFDaEM7SUFDQTs7R0FFQyxHQUNEb0QsbUJBQW1CO1FBQ2pCLElBQUksSUFBSSxDQUFDM2hCLFdBQVcsRUFBRTtZQUNwQmpGLGVBQWViLFlBQVksQ0FBQyxJQUFJLENBQUM4RixXQUFXO1FBQzlDO0lBQ0Y7SUFDQTBlLG9CQUFvQjtRQUNsQixJQUFJLENBQUN2QixpQkFBaUI7UUFDdEIsSUFBSSxDQUFDb0UsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMvQyxvQkFBb0IsRUFBRTtZQUM5QixJQUFJLENBQUM1OUQsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxrQ0FBa0MsSUFBSSxDQUFDdzFCLFVBQVU7WUFDL0Q7UUFDRjtRQUNBLElBQUksQ0FBQ25qRCxHQUFHLENBQUMyQixLQUFLLENBQUMsdUJBQXVCLElBQUksQ0FBQ3doRCxVQUFVO1FBQ3JELElBQUksQ0FBQzlELFlBQVksR0FBR2xGLGVBQWVDLFdBQVcsQ0FBQztZQUM3QyxJQUFJLENBQUN1bEIsUUFBUTtRQUNmLEdBQUcsSUFBSSxDQUFDL0Isb0JBQW9CLEdBQUc7SUFDakM7SUFDQXJCLG9CQUFvQjtRQUNsQixJQUFJLENBQUN2OEQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDBCQUEwQixJQUFJLENBQUN3aEQsVUFBVTtRQUN4RCxJQUFJLENBQUM0ZCxnQkFBZ0I7UUFDckIsSUFBSSxJQUFJLENBQUMxaEIsWUFBWSxFQUFFO1lBQ3JCbEYsZUFBZUUsYUFBYSxDQUFDLElBQUksQ0FBQ2dGLFlBQVk7UUFDaEQ7SUFDRjtBQUNGO0FBQ0EsU0FBUzhnQiw0QkFBNEJELEVBQUU7SUFDckMsTUFBTWUsTUFBTTtRQUNWLzNELE1BQU07UUFDTnExQixLQUFLMmhDLEdBQUczaEMsR0FBRztJQUNiO0lBQ0EsT0FBUTJoQyxHQUFHaDNELElBQUk7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0grM0QsSUFBSS8zRCxJQUFJLEdBQUdnM0QsR0FBR2gzRCxJQUFJO1lBQ2xCO0lBQ0o7SUFDQSxPQUFPKzNEO0FBQ1Q7QUFDQSxTQUFTdkMsMEJBQTBCdUMsR0FBRztJQUNwQyxNQUFNZixLQUFLLElBQUlsakIsbUJBQW1CO1FBQ2hDemUsS0FBSzBpQyxJQUFJMWlDLEdBQUc7UUFDWnIxQixNQUFNKzNELElBQUkvM0QsSUFBSTtJQUNoQjtJQUNBLE9BQU9nM0Q7QUFDVDtBQUNBLFNBQVN2RCx1QkFBdUJSLEtBQUssRUFBRXYzRCxJQUFJLEVBQUU4eUMsSUFBSTtJQUMvQyxJQUFJL3NDO0lBQ0osTUFBTTAzQixTQUFTLElBQUk2K0I7SUFDbkI3K0IsT0FBTy93QixHQUFHLENBQUMsZ0JBQWdCNnFEO0lBQzNCLE9BQU87SUFDUCxJQUFJemtCLEtBQUs0a0IsU0FBUyxFQUFFO1FBQ2xCajZCLE9BQU8vd0IsR0FBRyxDQUFDLGFBQWE7UUFDeEIsSUFBSW9tQyxLQUFLNzFCLEdBQUcsRUFBRTtZQUNad2dCLE9BQU8vd0IsR0FBRyxDQUFDLE9BQU9vbUMsS0FBSzcxQixHQUFHO1FBQzVCO0lBQ0Y7SUFDQXdnQixPQUFPL3dCLEdBQUcsQ0FBQyxrQkFBa0JvbUMsS0FBS3lwQixhQUFhLEdBQUcsTUFBTTtJQUN4RCxhQUFhO0lBQ2I5K0IsT0FBTy93QixHQUFHLENBQUMsT0FBT3k2QyxrQkFBa0IsZ0JBQWdCO0lBQ3BEMXBCLE9BQU8vd0IsR0FBRyxDQUFDLFdBQVcxTSxLQUFLa2YsT0FBTztJQUNsQ3VlLE9BQU8vd0IsR0FBRyxDQUFDLFlBQVkxTSxLQUFLaWlCLFFBQVEsQ0FBQ3BZLFFBQVE7SUFDN0MsSUFBSTdKLEtBQUt5aUIsV0FBVyxFQUFFO1FBQ3BCZ2IsT0FBTy93QixHQUFHLENBQUMsZ0JBQWdCMU0sS0FBS3lpQixXQUFXO0lBQzdDO0lBQ0EsSUFBSXppQixLQUFLdWlCLEVBQUUsRUFBRTtRQUNYa2IsT0FBTy93QixHQUFHLENBQUMsTUFBTTFNLEtBQUt1aUIsRUFBRTtJQUMxQjtJQUNBLElBQUl2aUIsS0FBS3dpQixTQUFTLEVBQUU7UUFDbEJpYixPQUFPL3dCLEdBQUcsQ0FBQyxjQUFjMU0sS0FBS3dpQixTQUFTO0lBQ3pDO0lBQ0EsSUFBSXhpQixLQUFLMGlCLE9BQU8sRUFBRTtRQUNoQithLE9BQU8vd0IsR0FBRyxDQUFDLFdBQVcxTSxLQUFLMGlCLE9BQU87SUFDcEM7SUFDQSxJQUFJMWlCLEtBQUsyaUIsY0FBYyxFQUFFO1FBQ3ZCOGEsT0FBTy93QixHQUFHLENBQUMsbUJBQW1CMU0sS0FBSzJpQixjQUFjO0lBQ25EO0lBQ0EsSUFBSW13QixLQUFLMHBCLFdBQVcsS0FBS2hnRSxXQUFXO1FBQ2xDaWhDLE9BQU8vd0IsR0FBRyxDQUFDLFdBQVdvbUMsS0FBSzBwQixXQUFXO0lBQ3hDO0lBQ0EsSUFBSTFwQixLQUFLMnBCLGNBQWMsRUFBRTtRQUN2QmgvQixPQUFPL3dCLEdBQUcsQ0FBQyxtQkFBbUI7SUFDaEM7SUFDQSxJQUFJb21DLEtBQUs4a0IsZUFBZSxFQUFFO1FBQ3hCbjZCLE9BQU8vd0IsR0FBRyxDQUFDLG9CQUFvQm9tQyxLQUFLOGtCLGVBQWUsQ0FBQy90RCxRQUFRO0lBQzlEO0lBQ0EsYUFBYTtJQUNiLElBQUksQ0FBQzlELEtBQUt2SyxVQUFVa2hFLFVBQVUsTUFBTSxRQUFRMzJELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3pCLElBQUksRUFBRTtRQUM1RSxhQUFhO1FBQ2JtNUIsT0FBTy93QixHQUFHLENBQUMsV0FBV2xSLFVBQVVraEUsVUFBVSxDQUFDcDRELElBQUk7SUFDakQ7SUFDQSxPQUFPLElBQUljLE1BQU0sQ0FBQ3E0QixPQUFPNXpCLFFBQVE7QUFDbkM7QUFFQSxJQUFJOHlELFdBQVcsQ0FBQztBQUVoQixJQUFJQyxZQUFZO0lBQUM1aEUsU0FBUyxDQUFDO0FBQUM7QUFFNUIsSUFBSTZoRSxZQUFZRCxVQUFVNWhFLE9BQU8sR0FBRztJQUNsQzZILEdBQUc7UUFBQztZQUNGMUYsTUFBTTtZQUNOMi9ELEtBQUs7UUFDUDtLQUFFO0lBQ0Z6akQsR0FBRztRQUFDO1lBQ0YsaUNBQWlDO1lBQ2pDLGtFQUFrRTtZQUNsRWxjLE1BQU07WUFDTjIvRCxLQUFLO1lBQ0w3NUQsT0FBTztnQkFBQztnQkFBWTtnQkFBYTtnQkFBa0I7Z0JBQVc7Z0JBQVM7YUFBVTtZQUNqRnNCLFFBQVE7UUFDVjtLQUFFO0lBQ0YscUVBQXFFO0lBQ3JFbUwsR0FBRztRQUFDO1lBQ0Z2UyxNQUFNO1FBQ1I7S0FBRTtJQUNGUCxHQUFHO1FBQUM7WUFDRk8sTUFBTTtRQUNSO0tBQUU7SUFDRm0zQyxHQUFHO1FBQUM7WUFDRm4zQyxNQUFNO1FBQ1I7S0FBRTtJQUNGM0QsR0FBRztRQUFDO1lBQ0YyRCxNQUFNO1FBQ1I7S0FBRTtJQUNGZ1ksR0FBRztRQUFDO1lBQ0ZoWSxNQUFNO1FBQ1I7S0FBRTtJQUNGc2UsR0FBRztRQUFDO1lBQ0Z0ZSxNQUFNO1FBQ1I7S0FBRTtJQUNGLG9EQUFvRDtJQUNwRDRaLEdBQUc7UUFBQztZQUNGNVosTUFBTTtRQUNSO0tBQUU7SUFDRiw2Q0FBNkM7SUFDN0MscUNBQXFDO0lBQ3JDb0YsR0FBRztRQUFDO1lBQ0YsUUFBUTtZQUNScEYsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFTO2FBQU87WUFDeEJzQixRQUFRO1FBQ1Y7S0FBRTtJQUNGeU4sR0FBRztRQUFDO1lBQ0Ysd0JBQXdCO1lBQ3hCN1UsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFXO2FBQUs7WUFDeEJzQixRQUFRO1FBQ1Y7S0FBRTtJQUNGeUMsR0FBRztRQUFDO1lBQ0YsWUFBWTtZQUNaekQsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFRO2FBQVE7WUFDeEJzQixRQUFRO1FBQ1Y7S0FBRTtJQUNGakwsR0FBRztRQUFDO1lBQ0Ysd0NBQXdDO1lBQ3hDLGtDQUFrQztZQUNsQyxnRUFBZ0U7WUFDaEV3akUsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVE7Z0JBQVE7Z0JBQVk7YUFBVztZQUMvQ3NCLFFBQVE7UUFDVjtLQUFFO0lBQ0Z3QyxHQUFHO1FBQUM7WUFDRiw0QkFBNEI7WUFDNUJ4RCxNQUFNO1lBQ051NUQsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVc7Z0JBQVM7Z0JBQVE7YUFBVztZQUMvQ3NCLFFBQVEsU0FBVThVLENBQUM7Z0JBQ2pCLE9BQU9BLEVBQUVzOEIsUUFBUSxHQUFHLHVCQUF1QnQ4QixFQUFFMGpELElBQUksR0FBRyxvQkFBb0I7WUFDMUU7UUFDRjtRQUFHO1lBQ0QseURBQXlEO1lBQ3pELHlDQUF5QztZQUN6Q3g1RCxNQUFNO1lBQ051NUQsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVc7YUFBUztZQUM1QnNCLFFBQVE7UUFDVjtRQUFHO1lBQ0QsdUJBQXVCO1lBQ3ZCcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELG9DQUFvQztZQUNwQ3BILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0w3NUQsT0FBTztnQkFBQztnQkFBUTtnQkFBVztnQkFBUzthQUFVO1lBQzlDc0IsUUFBUSxTQUFVOFUsQ0FBQztnQkFDakIsT0FBT0EsRUFBRXVKLE9BQU8sSUFBSSxPQUFPLHVCQUF1QjtZQUNwRDtRQUNGO1FBQUc7WUFDRCwyQkFBMkI7WUFDM0JyZixNQUFNO1lBQ051NUQsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVc7YUFBUTtZQUMzQnNCLFFBQVE7UUFDVjtRQUFHO1lBQ0QseUJBQXlCO1lBQ3pCaEIsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFXO2dCQUFRO2FBQVU7WUFDckNzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixPQUFPQSxFQUFFMmpELE9BQU8sSUFBSSxPQUFPLHFCQUFxQjtZQUNsRDtRQUNGO1FBQUc7WUFDRCxnREFBZ0Q7WUFDaEQscUNBQXFDO1lBQ3JDLDhGQUE4RjtZQUM5Rno1RCxNQUFNO1lBQ051NUQsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQWE7Z0JBQWU7Z0JBQU87YUFBUztZQUM3RHNCLFFBQVEsU0FBVThVLENBQUM7Z0JBQ2pCLE9BQU8sY0FBZUEsQ0FBQUEsRUFBRXVuQixTQUFTLEdBQUcsUUFBUSxJQUFHLElBQU12bkIsQ0FBQUEsQ0FBQyxDQUFDLGNBQWMsR0FBRyxRQUFRLElBQUcsSUFBSyxRQUFTQSxDQUFBQSxFQUFFNGpELE1BQU0sR0FBRyxRQUFRLEVBQUM7WUFDdkg7UUFDRjtRQUFHO1lBQ0QsdUJBQXVCO1lBQ3ZCOS9ELE1BQU07WUFDTjIvRCxLQUFLO1FBQ1A7UUFBRztZQUNELCtGQUErRjtZQUMvRnY1RCxNQUFNO1lBQ051NUQsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQU07Z0JBQVM7Z0JBQVU7YUFBZ0I7WUFDakRzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixPQUFPQSxFQUFFNmpELGFBQWEsSUFBSSxPQUFPLHVCQUF1QjtZQUMxRDtRQUNGO1FBQUc7WUFDRCxrQkFBa0I7WUFDbEIvL0QsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELG1CQUFtQjtZQUNuQnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQUc7WUFDRCxVQUFVO1lBQ1ZwSCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsbUZBQW1GO1lBQ25GcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELGFBQWE7WUFDYnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQUc7WUFDRCxnQkFBZ0I7WUFDaEJwSCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsYUFBYTtZQUNicEgsTUFBTTtZQUNOMi9ELEtBQUs7UUFDUDtRQUFHO1lBQ0QsYUFBYTtZQUNiMy9ELE1BQU07WUFDTjIvRCxLQUFLO1FBQ1A7UUFBRztZQUNELG1CQUFtQjtZQUNuQjMvRCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsbUNBQW1DO1lBQ25DcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELGtGQUFrRjtZQUNsRnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0w3NUQsT0FBTztnQkFBQztnQkFBUTthQUFPO1lBQ3ZCc0IsUUFBUTtRQUNWO1FBQUc7WUFDRCw0REFBNEQ7WUFDNUQsaUhBQWlIO1lBQ2pILGtKQUFrSjtZQUNsSixnSUFBZ0k7WUFDaEksa0tBQWtLO1lBQ2xLaEIsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFjO2dCQUFhO2dCQUFhO2dCQUFZO2dCQUFNO2dCQUFRO2dCQUFRO2dCQUFTO2dCQUFTO2dCQUFXO2dCQUFjO2dCQUFjO2FBQWU7WUFDMUpzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixJQUFJOGpELE1BQU07Z0JBQ1ZBLE9BQU85akQsRUFBRStqRCxLQUFLLElBQUksT0FBTyx1QkFBdUI7Z0JBRWhELGdGQUFnRjtnQkFDaEZELE9BQU85akQsRUFBRWdrRCxPQUFPLElBQUksT0FBTyxnQkFBZ0I7Z0JBQzNDLElBQUloa0QsRUFBRWlrRCxVQUFVLElBQUksTUFBTTtvQkFDeEJILE9BQU87Z0JBQ1Q7Z0JBQ0FBLE9BQU85akQsQ0FBQyxDQUFDLGFBQWEsSUFBSSxPQUFPLG1CQUFtQjtnQkFDcEQ4akQsT0FBTzlqRCxDQUFDLENBQUMsZUFBZSxJQUFJLE9BQU8scUJBQXFCO2dCQUN4RCxPQUFPOGpEO1lBQ1Q7UUFDRjtRQUFHO1lBQ0QsdUVBQXVFO1lBQ3ZFaGdFLE1BQU07WUFDTjIvRCxLQUFLO1FBQ1A7UUFBRztZQUNELGtFQUFrRTtZQUNsRTMvRCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsMkJBQTJCO1lBQzNCcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELDJDQUEyQztZQUMzQ2hCLE1BQU07WUFDTnU1RCxLQUFLO1lBQ0w3NUQsT0FBTztnQkFBQztnQkFBTTtnQkFBYTthQUFRO1lBQ25Dc0IsUUFBUSxTQUFVOFUsQ0FBQztnQkFDakIsSUFBSThqRCxNQUFNO2dCQUNWLElBQUk5akQsRUFBRXdyQixTQUFTLElBQUksTUFBTTtvQkFDdkJzNEIsT0FBTztvQkFDUCxJQUFJOWpELEVBQUVoVyxLQUFLLElBQUksTUFBTTt3QkFDbkI4NUQsT0FBTztvQkFDVDtnQkFDRjtnQkFDQSxPQUFPQTtZQUNUO1FBQ0Y7UUFBRztZQUNELHVCQUF1QjtZQUN2Qiw0Q0FBNEM7WUFDNUM1NUQsTUFBTTtZQUNOLGdGQUFnRjtZQUNoRnU1RCxLQUFLO1lBQ0w3NUQsT0FBTztnQkFBQztnQkFBYTthQUFRO1lBQzdCc0IsUUFBUTtRQUNWO1FBQUc7WUFDRCw0REFBNEQ7WUFDNURwSCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQVk7YUFBUTtZQUM1QnNCLFFBQVEsdUJBQXVCLG9DQUFvQztRQUNyRTtRQUFHO1lBQ0QsNkJBQTZCO1lBQzdCaEIsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFRO2FBQU87WUFDdkJzQixRQUFRO1FBQ1Y7UUFBRztZQUNELGFBQWE7WUFDYnBILE1BQU07WUFDTjIvRCxLQUFLO1FBQ1A7UUFBRztZQUNELGVBQWU7WUFDZjMvRCxNQUFNO1lBQ04yL0QsS0FBSztRQUNQO1FBQUc7WUFDRCx5Q0FBeUM7WUFDekMzL0QsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFpQjtnQkFBTzthQUFpQjtZQUNqRHNCLFFBQVEsU0FBVThVLENBQUM7Z0JBQ2pCLE9BQU9BLEVBQUVzd0IsY0FBYyxJQUFJLE9BQU8scUJBQXFCO1lBQ3pEO1FBQ0Y7UUFBRztZQUNELDZCQUE2QjtZQUM3QnhzQyxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsaUVBQWlFO1lBQ2pFaEIsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFNO2dCQUFhO2FBQVM7WUFDcENzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixPQUFPQSxFQUFFb2tCLE1BQU0sR0FBRyxpQkFBaUI7WUFDckM7UUFDRjtRQUFHO1lBQ0QsbUZBQW1GO1lBQ25GLDBDQUEwQztZQUMxQyxxQ0FBcUM7WUFDckNsNkIsTUFBTTtZQUNOdTVELEtBQUssSUFBSS9pQyxPQUNULGlCQUFpQjtZQUNqQiwwQkFDQSxpREFBaUQ7WUFDakQsMEVBQ0EscUJBQXFCO1lBQ3JCO1lBQ0E5MkIsT0FBTztnQkFBQztnQkFBTTtnQkFBUTtnQkFBVTtnQkFBUTthQUFTO1lBQ2pEc0IsUUFBUSxTQUFVOFUsQ0FBQztnQkFDakIsT0FBTyx1QkFBd0JBLENBQUFBLEVBQUVra0QsSUFBSSxHQUFHLFdBQVcsRUFBQztZQUN0RDtRQUNGO1FBQUc7WUFDRCw0Q0FBNEM7WUFDNUMsa0NBQWtDO1lBQ2xDcGdFLE1BQU07WUFDTjIvRCxLQUFLLElBQUkvaUMsT0FDVCxlQUFlO1lBQ2YsZ0JBQ0EsbUJBQW1CO1lBQ25CLHNDQUNBLHVCQUF1QjtZQUN2QiwrQ0FDQSxNQUFNO1lBQ047WUFDQTkyQixPQUFPO2dCQUFDO2dCQUFRO2dCQUFTO2dCQUFRO2FBQVE7WUFDekNzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixPQUFPLG9CQUFxQkEsQ0FBQUEsRUFBRWtrRCxJQUFJLEdBQUcsV0FBVyxFQUFDO1lBQ25EO1FBQ0Y7UUFBRztZQUNELGtEQUFrRDtZQUNsRCxtRUFBbUU7WUFDbkUsd0NBQXdDO1lBQ3hDLHlDQUF5QztZQUN6Q3BnRSxNQUFNO1lBQ04yL0QsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7YUFBUTtZQUNoQnNCLFFBQVE7UUFDVjtRQUFHO1lBQ0QsaUJBQWlCO1lBQ2pCLG9CQUFvQjtZQUNwQnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQUc7WUFDRCxVQUFVO1lBQ1Ysb0RBQW9EO1lBQ3BEcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFjO2dCQUFXO2dCQUFnQjtnQkFBZTthQUFVO1lBQzFFc0IsUUFBUTtRQUNWO1FBQUc7WUFDRCxnQkFBZ0I7WUFDaEJwSCxNQUFNO1lBQ04yL0QsS0FBSztRQUNQO1FBQUc7WUFDRCxZQUFZO1lBQ1ozL0QsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELG9DQUFvQztZQUNwQyxzRUFBc0U7WUFDdEVwSCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0Qsb0NBQW9DO1lBQ3BDLHNFQUFzRTtZQUN0RXBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQUc7WUFDRCxVQUFVO1lBQ1YsMkRBQTJEO1lBQzNEaEIsTUFBTTtZQUNOdTVELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFVO2FBQVk7WUFDOUJzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixPQUFPLGlCQUFrQkEsQ0FBQUEsRUFBRW1rRCxTQUFTLElBQUksT0FBTyxRQUFRLEVBQUM7WUFDMUQ7UUFDRjtRQUFHO1lBQ0QsVUFBVTtZQUNWLDhCQUE4QjtZQUM5QnJnRSxNQUFNO1lBQ04yL0QsS0FBSztZQUNMNzVELE9BQU87Z0JBQUM7Z0JBQU07Z0JBQWtCO2dCQUFtQjtnQkFBaUI7YUFBa0I7WUFDdEZzQixRQUFRLFNBQVU4VSxDQUFDO2dCQUNqQixJQUFJOGpELE1BQU07Z0JBQ1ZBLE9BQU85akQsRUFBRXNXLEVBQUUsSUFBSSxPQUFPLGFBQWE7Z0JBQ25Dd3RDLE9BQU85akQsRUFBRW9rRCxlQUFlLElBQUksT0FBTyxRQUFRO2dCQUMzQ04sT0FBTzlqRCxFQUFFcWtELGFBQWEsSUFBSSxPQUFPLGFBQWE7Z0JBQzlDUCxPQUFPOWpELEVBQUVza0QsZUFBZSxJQUFJLE9BQU8sUUFBUTtnQkFDM0MsT0FBT1I7WUFDVDtRQUNGO1FBQUc7WUFDRCxvQkFBb0I7WUFDcEJoZ0UsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELGlCQUFpQjtZQUNqQnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQ0EsMkNBQTJDO1FBQzNDO1lBQ0Usa0JBQWtCO1lBQ2xCcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTHY0RCxRQUFRO1FBQ1Y7UUFBRztZQUNELGFBQWE7WUFDYnBILE1BQU07WUFDTjIvRCxLQUFLO1lBQ0x2NEQsUUFBUTtRQUNWO1FBQUc7WUFDRCxhQUFhO1lBQ2JwSCxNQUFNO1lBQ04yL0QsS0FBSztZQUNMdjRELFFBQVE7UUFDVjtRQUFHO1lBQ0QsY0FBYztZQUNkcEgsTUFBTTtZQUNOMi9ELEtBQUs7WUFDTDc1RCxPQUFPO2dCQUFDO2dCQUFNO2FBQVU7WUFDeEJzQixRQUFRO1FBQ1Y7UUFBRztZQUNELG9FQUFvRTtZQUNwRWhCLE1BQU07WUFDTk4sT0FBTztnQkFBQzthQUFRO1FBQ2xCO0tBQUU7QUFDSjtBQUVBLDJFQUEyRTtBQUMzRXRKLE9BQU9DLElBQUksQ0FBQ2lqRSxXQUFXdGpFLE9BQU8sQ0FBQyxTQUFVaWEsR0FBRztJQUMxQyxJQUFJb3FELE9BQU9mLFNBQVMsQ0FBQ3JwRCxJQUFJO0lBQ3pCb3FELEtBQUtya0UsT0FBTyxDQUFDLFNBQVVzQyxHQUFHO1FBQ3hCLElBQUksQ0FBQ0EsSUFBSWloRSxHQUFHLEVBQUU7WUFDWmpoRSxJQUFJaWhFLEdBQUcsR0FBRztRQUNaO1FBQ0EsSUFBSSxDQUFDamhFLElBQUkwSSxNQUFNLEVBQUU7WUFDZjFJLElBQUkwSSxNQUFNLEdBQUc7UUFDZjtJQUNGO0FBQ0Y7QUFDQSxJQUFJczVELGlCQUFpQmpCLFVBQVU1aEUsT0FBTztBQUVyQyxVQUFVQSxPQUFPO0lBQ2hCLElBQUk4aUUsYUFBYSxTQUFVajdELENBQUM7UUFDMUIsT0FBT3lDLE9BQU94RCxPQUFPZSxRQUFRQSxJQUFJZixPQUFPZSxLQUFLQTtJQUMvQztJQUNBLElBQUlrN0QsbUJBQW1CLFNBQVUxaUQsS0FBSyxFQUFFbGQsUUFBUSxFQUFFOEUsS0FBSyxFQUFFKzZELE9BQU87UUFDOUQsSUFBSUEsV0FBVyxDQUFDLzZELE9BQU87WUFDckI5RSxRQUFRLENBQUM2L0QsUUFBUSxHQUFHRixXQUFXemlELEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE9BQU87WUFDTCxJQUFLLElBQUl6ZSxJQUFJLEdBQUdBLElBQUlxRyxNQUFNcEcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7Z0JBQ3hDLElBQUl5ZSxLQUFLLENBQUN6ZSxJQUFJLEVBQUUsSUFBSSxNQUFNO29CQUN4QnVCLFFBQVEsQ0FBQzhFLEtBQUssQ0FBQ3JHLEVBQUUsQ0FBQyxHQUFHa2hFLFdBQVd6aUQsS0FBSyxDQUFDemUsSUFBSSxFQUFFO2dCQUM5QztZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUlxaEUsV0FBVyxTQUFVcGlFLEdBQUcsRUFBRXNDLFFBQVEsRUFBRSsvRCxPQUFPO1FBQzdDLElBQUlDLGFBQWF0aUUsSUFBSXNCLElBQUksSUFBSXRCLElBQUlvSCxLQUFLO1FBQ3RDLElBQUlwSCxJQUFJMEgsSUFBSSxJQUFJLENBQUNwRixRQUFRLENBQUN0QyxJQUFJMEgsSUFBSSxDQUFDLEVBQUU7WUFDbkNwRixRQUFRLENBQUN0QyxJQUFJMEgsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUN6QixPQUFPLElBQUk0NkQsY0FBYyxDQUFDaGdFLFFBQVEsQ0FBQ3RDLElBQUlzQixJQUFJLENBQUMsRUFBRTtZQUM1Q2dCLFFBQVEsQ0FBQ3RDLElBQUlzQixJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3hCO1FBQ0EsSUFBSWloRSxjQUFjdmlFLElBQUkwSCxJQUFJLEdBQUcsQ0FBQyxJQUM5QixtQ0FBbUM7UUFDbkM0NkQsYUFBYWhnRSxRQUFRLENBQUN0QyxJQUFJc0IsSUFBSSxDQUFDLEdBQUdnQixVQUFVLG9DQUFvQztRQUVoRjQvRCxpQkFBaUJHLFFBQVE3aUQsS0FBSyxDQUFDeGYsSUFBSWloRSxHQUFHLEdBQUdzQixhQUFhdmlFLElBQUlvSCxLQUFLLEVBQUVwSCxJQUFJc0IsSUFBSTtRQUN6RSxJQUFJdEIsSUFBSTBILElBQUksRUFBRTtZQUNacEYsUUFBUSxDQUFDdEMsSUFBSTBILElBQUksQ0FBQyxDQUFDQSxJQUFJLENBQUM2NkQ7UUFDMUI7SUFDRjtJQUNBLElBQUlDLFVBQVVSO0lBQ2QsSUFBSVMsWUFBWXZrQyxPQUFPbi9CLFNBQVMsQ0FBQ2EsSUFBSSxDQUFDTyxJQUFJLENBQUM7SUFDM0NoQixRQUFRbUssS0FBSyxHQUFHLFNBQVV3MEIsR0FBRztRQUMzQixJQUFJNGtDLFVBQVUsQ0FBQyxHQUNidjBCLFFBQVEsRUFBRSxFQUNWN3JDLFdBQVdvZ0UsU0FBUyx5REFBeUQ7UUFFL0UsNEJBQTRCO1FBQzVCNWtDLElBQUlobEIsS0FBSyxDQUFDLGdCQUFnQnhVLE1BQU0sQ0FBQ20rRCxXQUFXL2tFLE9BQU8sQ0FBQyxTQUFVazdDLENBQUM7WUFDN0QsSUFBSW53QyxPQUFPbXdDLENBQUMsQ0FBQyxFQUFFO1lBQ2YsSUFBSXlwQixVQUFVenBCLEVBQUVuMkMsS0FBSyxDQUFDO1lBQ3RCLElBQUlnRyxTQUFTLEtBQUs7Z0JBQ2hCMGxDLE1BQU16bUMsSUFBSSxDQUFDO29CQUNUaTdELEtBQUssRUFBRTtvQkFDUEMsTUFBTSxFQUFFO2dCQUNWO2dCQUNBdGdFLFdBQVc2ckMsS0FBSyxDQUFDQSxNQUFNbnRDLE1BQU0sR0FBRyxFQUFFLEVBQUUsNkJBQTZCO1lBQ25FO1lBQ0EsSUFBSyxJQUFJbW5DLElBQUksR0FBR0EsSUFBSSxDQUFDcTZCLE9BQU8sQ0FBQy81RCxLQUFLLElBQUksRUFBRSxFQUFFekgsTUFBTSxFQUFFbW5DLEtBQUssRUFBRztnQkFDeEQsSUFBSW5vQyxNQUFNd2lFLE9BQU8sQ0FBQy81RCxLQUFLLENBQUMwL0IsRUFBRTtnQkFDMUIsSUFBSW5vQyxJQUFJaWhFLEdBQUcsQ0FBQ3JoRSxJQUFJLENBQUN5aUUsVUFBVTtvQkFDekIsT0FBT0QsU0FBU3BpRSxLQUFLc0MsVUFBVSsvRDtnQkFDakM7WUFDRjtRQUNGO1FBQ0FLLFFBQVF2MEIsS0FBSyxHQUFHQSxPQUFPLGFBQWE7UUFDcEMsT0FBT3UwQjtJQUNUO0lBQ0EsSUFBSUcsZUFBZSxTQUFVQyxHQUFHLEVBQUV4eEMsSUFBSTtRQUNwQyxJQUFJemQsSUFBSXlkLEtBQUt4WSxLQUFLLENBQUMsU0FBUztRQUM1QixJQUFJakYsRUFBRTdTLE1BQU0sS0FBSyxHQUFHO1lBQ2xCOGhFLEdBQUcsQ0FBQ2p2RCxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUdvdUQsV0FBV3B1RCxDQUFDLENBQUMsRUFBRTtRQUM3QixPQUFPLElBQUlBLEVBQUU3UyxNQUFNLEtBQUssS0FBS3N3QixLQUFLdHdCLE1BQU0sR0FBRyxHQUFHO1lBQzVDOGhFLEdBQUcsQ0FBQ2p2RCxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUdsVDtRQUNkO1FBQ0EsT0FBT21pRTtJQUNUO0lBQ0EzakUsUUFBUTRqRSxXQUFXLEdBQUcsU0FBVXpCLEdBQUc7UUFDakMsT0FBT0EsSUFBSXhvRCxLQUFLLENBQUMsUUFBUXlhLE1BQU0sQ0FBQ3N2QyxjQUFjLENBQUM7SUFDakQ7SUFFQSw4REFBOEQ7SUFDOUQxakUsUUFBUTZqRSxlQUFlLEdBQUc3akUsUUFBUTRqRSxXQUFXO0lBQzdDNWpFLFFBQVE4akUsYUFBYSxHQUFHLFNBQVUzQixHQUFHO1FBQ25DLE9BQU9BLElBQUl0ekQsUUFBUSxHQUFHOEssS0FBSyxDQUFDLEtBQUtwVSxHQUFHLENBQUN1QjtJQUN2QztJQUNBOUcsUUFBUStqRSxxQkFBcUIsR0FBRyxTQUFVNUIsR0FBRztRQUMzQyxJQUFJNkIsYUFBYSxFQUFFO1FBQ25CLElBQUlwOUIsUUFBUXU3QixJQUFJeG9ELEtBQUssQ0FBQyxLQUFLcFUsR0FBRyxDQUFDdTlEO1FBQy9CLElBQUssSUFBSWxoRSxJQUFJLEdBQUdBLElBQUlnbEMsTUFBTS9rQyxNQUFNLEVBQUVELEtBQUssRUFBRztZQUN4Q29pRSxXQUFXejdELElBQUksQ0FBQztnQkFDZDYrQixXQUFXUixLQUFLLENBQUNobEMsRUFBRTtnQkFDbkIwbEMsSUFBSVYsS0FBSyxDQUFDaGxDLElBQUksRUFBRTtnQkFDaEIybEMsTUFBTVgsS0FBSyxDQUFDaGxDLElBQUksRUFBRTtZQUNwQjtRQUNGO1FBQ0EsT0FBT29pRTtJQUNUO0lBQ0Foa0UsUUFBUWlrRSxvQkFBb0IsR0FBRyxTQUFVOUIsR0FBRztRQUMxQyxPQUFPQSxJQUFJeG9ELEtBQUssQ0FBQyxLQUFLcFUsR0FBRyxDQUFDLFNBQVVrVSxJQUFJO1lBQ3RDLE9BQU9BLEtBQUtqTyxTQUFTLENBQUMsR0FBR2lPLEtBQUs1WCxNQUFNLEdBQUcsR0FBRzhYLEtBQUssQ0FBQyxLQUFLeWEsTUFBTSxDQUFDc3ZDLGNBQWMsQ0FBQztRQUM3RTtJQUNGO0lBQ0ExakUsUUFBUWtrRSx3QkFBd0IsR0FBRyxTQUFVL0IsR0FBRztRQUM5QyxPQUFPQSxJQUFJeG9ELEtBQUssQ0FBQyxLQUFLcFUsR0FBRyxDQUFDLFNBQVVrZ0IsTUFBTTtZQUN4QyxPQUFPQSxPQUFPOUwsS0FBSyxDQUFDLEtBQUtwVSxHQUFHLENBQUMsU0FBVWdFLE1BQU07Z0JBQzNDLElBQUk0NkQsTUFDRkMsU0FBUztnQkFDWCxJQUFJNzZELE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBSztvQkFDckI0NkQsT0FBT3JCLFdBQVd2NUQ7Z0JBQ3BCLE9BQU87b0JBQ0w0NkQsT0FBT3JCLFdBQVd2NUQsT0FBT2lDLFNBQVMsQ0FBQyxHQUFHakMsT0FBTzFILE1BQU07b0JBQ25EdWlFLFNBQVM7Z0JBQ1g7Z0JBQ0EsT0FBTztvQkFDTEQsTUFBTUE7b0JBQ05DLFFBQVFBO2dCQUNWO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YsR0FBR3pDO0FBRUgsSUFBSTBCLFVBQVVSO0FBRWQsOEVBQThFO0FBQzlFLElBQUl3QixlQUFlO0FBQ25CLElBQUk5NkQsU0FBUyxTQUFVKzZELFNBQVM7SUFDOUIsSUFBSTFpRSxJQUFJO0lBQ1IsSUFBSTRyQixPQUFPcnNCO0lBQ1gsSUFBSXFRLE1BQU1nYyxLQUFLM3JCLE1BQU07SUFDckIsT0FBT3lpRSxVQUFVMWpELE9BQU8sQ0FBQ3lqRCxjQUFjLFNBQVUza0UsQ0FBQztRQUNoRCxJQUFJa0MsS0FBSzRQLEtBQUs7WUFDWixPQUFPOVIsR0FBRyxtQkFBbUI7UUFDL0I7UUFDQSxJQUFJbUgsTUFBTTJtQixJQUFJLENBQUM1ckIsRUFBRTtRQUNqQkEsS0FBSztRQUNMLE9BQVFsQztZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTzRLLE9BQU96RDtZQUNoQixLQUFLO2dCQUNILE9BQU9DLE9BQU9EO1lBQ2hCLEtBQUs7Z0JBQ0gsT0FBTztRQUNYO0lBQ0Y7QUFDQSwrRUFBK0U7QUFDakY7QUFDQSxJQUFJMDlELFdBQVcsU0FBVWo3RCxJQUFJLEVBQUV6SSxHQUFHLEVBQUVzQyxRQUFRO0lBQzFDLElBQUlnL0QsTUFBTXRoRSxJQUFJMEksTUFBTSxZQUFZdEksV0FBV0osSUFBSTBJLE1BQU0sQ0FBQzFJLElBQUkwSCxJQUFJLEdBQUdwRixXQUFXQSxRQUFRLENBQUN0QyxJQUFJc0IsSUFBSSxDQUFDLElBQUl0QixJQUFJMEksTUFBTTtJQUM1RyxJQUFJaWtCLE9BQU87UUFBQ2xrQixPQUFPLE1BQU02NEQ7S0FBSTtJQUM3QixJQUFJdGhFLElBQUlvSCxLQUFLLEVBQUU7UUFDYixJQUFLLElBQUlyRyxJQUFJLEdBQUdBLElBQUlmLElBQUlvSCxLQUFLLENBQUNwRyxNQUFNLEVBQUVELEtBQUssRUFBRztZQUM1QyxJQUFJdkQsSUFBSXdDLElBQUlvSCxLQUFLLENBQUNyRyxFQUFFO1lBQ3BCLElBQUlmLElBQUlzQixJQUFJLEVBQUU7Z0JBQ1pxckIsS0FBS2psQixJQUFJLENBQUNwRixRQUFRLENBQUN0QyxJQUFJc0IsSUFBSSxDQUFDLENBQUM5RCxFQUFFO1lBQ2pDLE9BQU87Z0JBQ0wsZ0NBQWdDO2dCQUNoQ212QixLQUFLamxCLElBQUksQ0FBQ3BGLFFBQVEsQ0FBQ3RDLElBQUlvSCxLQUFLLENBQUNyRyxFQUFFLENBQUM7WUFDbEM7UUFDRjtJQUNGLE9BQU87UUFDTDRyQixLQUFLamxCLElBQUksQ0FBQ3BGLFFBQVEsQ0FBQ3RDLElBQUlzQixJQUFJLENBQUM7SUFDOUI7SUFDQSxPQUFPb0gsT0FBT3JJLEtBQUssQ0FBQyxNQUFNc3NCO0FBQzVCO0FBRUEsc0JBQXNCO0FBQ3RCLHNDQUFzQztBQUN0QyxJQUFJZzNDLG9CQUFvQjtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDekYsSUFBSUMsb0JBQW9CO0lBQUM7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUM1QyxJQUFJQyxXQUFXLFNBQVVuQixPQUFPLEVBQUV6ckIsSUFBSTtJQUNwQ0EsT0FBT0EsUUFBUSxDQUFDO0lBQ2hCLGtDQUFrQztJQUNsQyxJQUFJeXJCLFFBQVFyL0MsT0FBTyxJQUFJLE1BQU07UUFDM0JxL0MsUUFBUXIvQyxPQUFPLEdBQUcsR0FBRyxpREFBaUQ7SUFDeEU7SUFDQSxJQUFJcS9DLFFBQVFwaEUsSUFBSSxJQUFJLE1BQU07UUFDeEJvaEUsUUFBUXBoRSxJQUFJLEdBQUcsS0FBSyxnREFBZ0Q7SUFDdEU7SUFDQW9oRSxRQUFRdjBCLEtBQUssQ0FBQ3p3QyxPQUFPLENBQUMsU0FBVTB5QyxLQUFLO1FBQ25DLElBQUlBLE1BQU0wekIsUUFBUSxJQUFJLE1BQU07WUFDMUIxekIsTUFBTTB6QixRQUFRLEdBQUc7UUFDbkI7SUFDRjtJQUNBLElBQUlDLGFBQWE5c0IsS0FBSzhzQixVQUFVLElBQUlKO0lBQ3BDLElBQUlLLGFBQWEvc0IsS0FBSytzQixVQUFVLElBQUlKO0lBQ3BDLElBQUk5bEMsTUFBTSxFQUFFO0lBRVosNkRBQTZEO0lBQzdEaW1DLFdBQVdybUUsT0FBTyxDQUFDLFNBQVUrSyxJQUFJO1FBQy9CKzVELE9BQU8sQ0FBQy81RCxLQUFLLENBQUMvSyxPQUFPLENBQUMsU0FBVXNDLEdBQUc7WUFDakMsSUFBSUEsSUFBSXNCLElBQUksSUFBSW9oRSxXQUFXQSxPQUFPLENBQUMxaUUsSUFBSXNCLElBQUksQ0FBQyxJQUFJLE1BQU07Z0JBQ3BEdzhCLElBQUlwMkIsSUFBSSxDQUFDZzhELFNBQVNqN0QsTUFBTXpJLEtBQUswaUU7WUFDL0IsT0FBTyxJQUFJMWlFLElBQUkwSCxJQUFJLElBQUlnN0QsV0FBV0EsT0FBTyxDQUFDMWlFLElBQUkwSCxJQUFJLENBQUMsSUFBSSxNQUFNO2dCQUMzRGc3RCxPQUFPLENBQUMxaUUsSUFBSTBILElBQUksQ0FBQyxDQUFDaEssT0FBTyxDQUFDLFNBQVUyMUQsRUFBRTtvQkFDcEN2MUIsSUFBSXAyQixJQUFJLENBQUNnOEQsU0FBU2o3RCxNQUFNekksS0FBS3F6RDtnQkFDL0I7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxrREFBa0Q7SUFDbERxUCxRQUFRdjBCLEtBQUssQ0FBQ3p3QyxPQUFPLENBQUMsU0FBVTB5QyxLQUFLO1FBQ25DdFMsSUFBSXAyQixJQUFJLENBQUNnOEQsU0FBUyxLQUFLbEIsUUFBUS9rRSxDQUFDLENBQUMsRUFBRSxFQUFFMnlDO1FBQ3JDNHpCLFdBQVd0bUUsT0FBTyxDQUFDLFNBQVUrSyxJQUFJO1lBQy9CKzVELE9BQU8sQ0FBQy81RCxLQUFLLENBQUMvSyxPQUFPLENBQUMsU0FBVXNDLEdBQUc7Z0JBQ2pDLElBQUlBLElBQUlzQixJQUFJLElBQUk4dUMsU0FBU0EsS0FBSyxDQUFDcHdDLElBQUlzQixJQUFJLENBQUMsSUFBSSxNQUFNO29CQUNoRHc4QixJQUFJcDJCLElBQUksQ0FBQ2c4RCxTQUFTajdELE1BQU16SSxLQUFLb3dDO2dCQUMvQixPQUFPLElBQUlwd0MsSUFBSTBILElBQUksSUFBSTBvQyxTQUFTQSxLQUFLLENBQUNwd0MsSUFBSTBILElBQUksQ0FBQyxJQUFJLE1BQU07b0JBQ3ZEMG9DLEtBQUssQ0FBQ3B3QyxJQUFJMEgsSUFBSSxDQUFDLENBQUNoSyxPQUFPLENBQUMsU0FBVTIxRCxFQUFFO3dCQUNsQ3YxQixJQUFJcDJCLElBQUksQ0FBQ2c4RCxTQUFTajdELE1BQU16SSxLQUFLcXpEO29CQUMvQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU92MUIsSUFBSS9zQixJQUFJLENBQUMsVUFBVTtBQUM1QjtBQUVBLElBQUlrekQsU0FBU25EO0FBQ2IsSUFBSWwzRCxTQUFTaTZEO0FBQ2IsSUFBSUssUUFBUXQ2RDtBQUNaLElBQUlOLFFBQVEyNkQsT0FBTzM2RCxLQUFLO0FBQ3hCMjZELE9BQU9sQixXQUFXO0FBQ2xCa0IsT0FBT2pCLGVBQWUsRUFBRSwwQkFBMEI7QUFDbERpQixPQUFPaEIsYUFBYTtBQUNwQmdCLE9BQU9mLHFCQUFxQjtBQUM1QmUsT0FBT2Isb0JBQW9CO0FBQzNCYSxPQUFPWix3QkFBd0I7QUFFL0I7Ozs7O0FBS0EsR0FDQSxNQUFNYyxxQkFBcUI7QUFDM0IsTUFBTUMsV0FBVztJQUNmQyxvQkFBb0I7SUFDcEJDLHFCQUFxQjtJQUNyQkMsc0JBQXNCO0FBQ3hCO0FBQ0EsY0FBYyxHQUNkLE1BQU1DLG9CQUFvQnZ6QyxjQUFjN0QsWUFBWTtJQUNsRCxJQUFJMk0sS0FBSztRQUNQLElBQUksQ0FBQyxJQUFJLENBQUNJLEdBQUcsRUFBRTtZQUNiLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUksQ0FBQ3NxQyxRQUFRO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUN0cUMsR0FBRztJQUNqQjtJQUNBM3ZCLFlBQVk0MkQsTUFBTSxDQUFFO1FBQ2xCLElBQUlzRCxtQkFBbUJwa0UsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUM1RixJQUFJb2hELGdCQUFnQnBoRCxVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3pGLElBQUk0SjtRQUNKLEtBQUs7UUFDTCxJQUFJLENBQUMzSyxHQUFHLEdBQUcyRTtRQUNYLElBQUksQ0FBQ3lnRSxpQkFBaUIsR0FBRyxFQUFFO1FBQzNCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7UUFDeEIsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ0MsU0FBUyxHQUFHL3BELEVBQUV1YyxDQUFBQSxVQUFXM00sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDNUQsSUFBSSxDQUFDbUQsSUFBSSxDQUFDbTJDLFNBQVNDLGtCQUFrQjtnQkFDckMsSUFBSTtvQkFDRixNQUFNLElBQUksQ0FBQ2Esa0JBQWtCO2dCQUMvQixFQUFFLE9BQU92bkUsR0FBRztvQkFDVixJQUFJODVCLFNBQVM7d0JBQ1hBLFFBQVE5NUI7b0JBQ1YsT0FBTzt3QkFDTCxNQUFNQTtvQkFDUjtnQkFDRjtZQUNGLElBQUk7UUFDSixJQUFJLENBQUMwcUQsS0FBSyxHQUFHO1lBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ2x1QixHQUFHLEVBQUU7Z0JBQ2I7WUFDRjtZQUNBLElBQUksQ0FBQ0EsR0FBRyxDQUFDa3VCLEtBQUs7WUFDZCxJQUFJLENBQUNsdUIsR0FBRyxDQUFDZ3JDLHVCQUF1QixHQUFHO1lBQ25DLElBQUksQ0FBQ2hyQyxHQUFHLENBQUNpckMsMEJBQTBCLEdBQUc7WUFDdEMsSUFBSSxDQUFDanJDLEdBQUcsQ0FBQ2tyQyx5QkFBeUIsR0FBRztZQUNyQyxJQUFJLENBQUNsckMsR0FBRyxDQUFDbXJDLGFBQWEsR0FBRztZQUN6QixJQUFJLENBQUNuckMsR0FBRyxDQUFDb3JDLG1CQUFtQixHQUFHO1lBQy9CLElBQUksQ0FBQ3ByQyxHQUFHLENBQUNxckMsc0JBQXNCLEdBQUc7WUFDbEMsSUFBSSxDQUFDcnJDLEdBQUcsQ0FBQ3NyQyxjQUFjLEdBQUc7WUFDMUIsSUFBSSxDQUFDdHJDLEdBQUcsQ0FBQ21yQyxhQUFhLEdBQUc7WUFDekIsSUFBSSxDQUFDbnJDLEdBQUcsQ0FBQ3VyQyxPQUFPLEdBQUc7WUFDbkIsSUFBSSxDQUFDdnJDLEdBQUcsQ0FBQ2dyQyx1QkFBdUIsR0FBRztZQUNuQyxJQUFJLENBQUNockMsR0FBRyxDQUFDaXJDLDBCQUEwQixHQUFHO1lBQ3RDLElBQUksQ0FBQ2pyQyxHQUFHLEdBQUc7UUFDYjtRQUNBLElBQUksQ0FBQzU2QixHQUFHLEdBQUdrRSxVQUFVLENBQUN5RyxLQUFLdzNDLGNBQWM1Z0QsVUFBVSxNQUFNLFFBQVFvSixPQUFPLEtBQUssSUFBSUEsS0FBS2pHLFlBQVl1Z0UsV0FBVztRQUM3RyxJQUFJLENBQUM5aUIsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUMwZixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDc0QsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ3ZxQyxHQUFHLEdBQUcsSUFBSSxDQUFDc3FDLFFBQVE7SUFDMUI7SUFDQUEsV0FBVztRQUNULE1BQU0xcUMsS0FBS294QixvQkFDWCxrSEFBa0g7UUFDbEgsSUFBSXo1QixrQkFBa0IsSUFBSSxDQUFDMHZDLE1BQU0sRUFBRSxJQUFJLENBQUNzRCxnQkFBZ0IsSUFBSSxJQUFJaHpDLGtCQUFrQixJQUFJLENBQUMwdkMsTUFBTTtRQUM3RnJuQyxHQUFHMHJDLGNBQWMsR0FBR3BRLENBQUFBO1lBQ2xCLElBQUluckQ7WUFDSixJQUFJLENBQUNtckQsR0FBRzF4QixTQUFTLEVBQUU7WUFDbEJ6NUIsQ0FBQUEsS0FBSyxJQUFJLENBQUN5N0QsY0FBYyxNQUFNLFFBQVF6N0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksRUFBRW8yRCxHQUFHMXhCLFNBQVM7UUFDNUY7UUFDQTVKLEdBQUc2ckMsbUJBQW1CLEdBQUd2USxDQUFBQTtZQUN2QixJQUFJbnJEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDMjdELG1CQUFtQixNQUFNLFFBQVEzN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksRUFBRW8yRDtRQUNyRjtRQUNBdDdCLEdBQUdxckMsMEJBQTBCLEdBQUc7WUFDOUIsSUFBSWw3RDtZQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQzQ3RCwwQkFBMEIsTUFBTSxRQUFRNTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJLEVBQUU4NkIsR0FBRzJYLGtCQUFrQjtRQUNqSDtRQUNBM1gsR0FBR3lyQyxzQkFBc0IsR0FBRztZQUMxQixJQUFJdDdEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDNjdELHNCQUFzQixNQUFNLFFBQVE3N0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksRUFBRTg2QixHQUFHMkQsY0FBYztRQUN6RztRQUNBM0QsR0FBR29yQyx1QkFBdUIsR0FBRztZQUMzQixJQUFJajdEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDODdELHVCQUF1QixNQUFNLFFBQVE5N0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksRUFBRTg2QixHQUFHZ1ksZUFBZTtRQUMzRztRQUNBaFksR0FBR3VyQyxhQUFhLEdBQUdqUSxDQUFBQTtZQUNqQixJQUFJbnJEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDKzdELGFBQWEsTUFBTSxRQUFRLzdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJLEVBQUVvMkQ7UUFDL0U7UUFDQXQ3QixHQUFHMnJDLE9BQU8sR0FBR3JRLENBQUFBO1lBQ1gsSUFBSW5yRDtZQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQ2c4RCxPQUFPLE1BQU0sUUFBUWg4RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTCxJQUFJLENBQUMsSUFBSSxFQUFFbzJEO1FBQ3pFO1FBQ0EsT0FBT3Q3QjtJQUNUO0lBQ0EsSUFBSTJvQixhQUFhO1FBQ2YsSUFBSXg0QyxJQUFJOFU7UUFDUixPQUFPbGhCLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUNrWCxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ3czQyxhQUFhLEVBQUVXLGVBQWUsTUFBTSxRQUFRcmpDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRy9mLElBQUksQ0FBQ2lMO0lBQ3pIO0lBQ0EsSUFBSWk4RCxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUNoc0MsR0FBRyxLQUFLLFFBQVMsS0FBSSxDQUFDSixFQUFFLENBQUMyWCxrQkFBa0IsS0FBSyxlQUFlLElBQUksQ0FBQzNYLEVBQUUsQ0FBQzJYLGtCQUFrQixLQUFLLFdBQVU7SUFDdEg7SUFDQXBPLGdCQUFnQkssU0FBUyxFQUFFO1FBQ3pCLE9BQU83WSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDaVAsRUFBRSxDQUFDcXNDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDeEIsYUFBYSxFQUFFO2dCQUNwRCxPQUFPLElBQUksQ0FBQzdxQyxFQUFFLENBQUN1SixlQUFlLENBQUNLO1lBQ2pDO1lBQ0EsSUFBSSxDQUFDZ2hDLGlCQUFpQixDQUFDajlELElBQUksQ0FBQ2k4QjtRQUM5QjtJQUNGO0lBQ0F2SyxxQkFBcUJxbUMsRUFBRSxFQUFFO1FBQ3ZCLElBQUl2MUQ7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSXU3QyxZQUFZMWxFO1lBQ2hCLElBQUk4K0QsR0FBR2gzRCxJQUFJLEtBQUssU0FBUztnQkFDdkIsSUFBSSxFQUNGNjlELFVBQVUsRUFDVkMsUUFBUSxFQUNULEdBQUdDLG1DQUFtQy9HO2dCQUN2QyxJQUFJLENBQUNzRixnQkFBZ0IsR0FBR3VCO2dCQUN4QixJQUFJLENBQUN0QixjQUFjLEdBQUd1QjtZQUN4QixPQUFPLElBQUk5RyxHQUFHaDNELElBQUksS0FBSyxVQUFVO2dCQUMvQixNQUFNZytELFlBQVluOUQsTUFBTSxDQUFDWSxLQUFLdTFELEdBQUczaEMsR0FBRyxNQUFNLFFBQVE1ekIsT0FBTyxLQUFLLElBQUlBLEtBQUs7Z0JBQ3ZFdThELFVBQVV0NEIsS0FBSyxDQUFDendDLE9BQU8sQ0FBQ3l3QyxDQUFBQTtvQkFDdEIsSUFBSUEsTUFBTTFsQyxJQUFJLEtBQUssU0FBUzt3QkFDMUIscUNBQXFDO3dCQUNyQyxJQUFJLENBQUNxOEQsYUFBYSxDQUFDenVDLElBQUksQ0FBQ3F3QyxDQUFBQTs0QkFDdEIsSUFBSSxDQUFDQSxRQUFRaHRDLFdBQVcsSUFBSXlVLE1BQU0xZ0MsR0FBRyxJQUFJaTVELFFBQVFodEMsV0FBVyxDQUFDanNCLEdBQUcsRUFBRTtnQ0FDaEUsT0FBTzs0QkFDVDs0QkFDQSxJQUFJazVELGVBQWU7NEJBQ25CeDRCLE1BQU13MEIsR0FBRyxDQUFDdHNDLElBQUksQ0FBQ3NzQyxDQUFBQTtnQ0FDYixJQUFJQSxJQUFJbjdCLEtBQUssQ0FBQzFsQyxXQUFXLE9BQU80a0UsUUFBUWwvQixLQUFLLENBQUMxbEMsV0FBVyxJQUFJO29DQUMzRDZrRSxlQUFlaEUsSUFBSWg5QyxPQUFPO29DQUMxQixPQUFPO2dDQUNUO2dDQUNBLE9BQU87NEJBQ1Q7NEJBQ0EsSUFBSWdoRCxpQkFBaUIsR0FBRztnQ0FDdEIsT0FBTzs0QkFDVDs0QkFDQSxJQUFJQyxZQUFZOzRCQUNoQixLQUFLLE1BQU1oRSxRQUFRejBCLE1BQU15MEIsSUFBSSxDQUFFO2dDQUM3QixJQUFJQSxLQUFLajlDLE9BQU8sS0FBS2doRCxjQUFjO29DQUNqQy9ELEtBQUt4QixNQUFNLEdBQUd3QixLQUFLeEIsTUFBTSxDQUFDdG9ELEtBQUssQ0FBQyxLQUFLeFUsTUFBTSxDQUFDdWlFLENBQUFBLE9BQVEsQ0FBQ0EsS0FBS3R3QyxRQUFRLENBQUMsc0JBQXNCeGxCLElBQUksQ0FBQztvQ0FDOUYsSUFBSTIxRCxRQUFRSSxLQUFLLEdBQUcsR0FBRzt3Q0FDckJsRSxLQUFLeEIsTUFBTSxJQUFJLHNCQUFzQjczRCxNQUFNLENBQUNtOUQsUUFBUUksS0FBSyxHQUFHO29DQUM5RDtvQ0FDQUYsWUFBWTtvQ0FDWjtnQ0FDRjs0QkFDRjs0QkFDQSxJQUFJLENBQUNBLFdBQVc7Z0NBQ2QsSUFBSUYsUUFBUUksS0FBSyxHQUFHLEdBQUc7b0NBQ3JCMzRCLE1BQU15MEIsSUFBSSxDQUFDbDdELElBQUksQ0FBQzt3Q0FDZGllLFNBQVNnaEQ7d0NBQ1R2RixRQUFRLHFCQUFxQjczRCxNQUFNLENBQUNtOUQsUUFBUUksS0FBSyxHQUFHO29DQUN0RDtnQ0FDRjs0QkFDRjs0QkFDQSxPQUFPO3dCQUNUO29CQUNGO2dCQUNGO2dCQUNBVCxZQUFZbkMsTUFBTXVDO1lBQ3BCO1lBQ0EsTUFBTSxJQUFJLENBQUNNLFlBQVksQ0FBQ3RILElBQUk0RyxXQUFXO1lBQ3ZDLElBQUksQ0FBQzFCLGlCQUFpQixDQUFDam5FLE9BQU8sQ0FBQ2ltQyxDQUFBQTtnQkFDN0IsSUFBSSxDQUFDNUosRUFBRSxDQUFDdUosZUFBZSxDQUFDSztZQUMxQjtZQUNBLElBQUksQ0FBQ2doQyxpQkFBaUIsR0FBRyxFQUFFO1lBQzNCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1lBQ3JCLElBQUksSUFBSSxDQUFDQyxXQUFXLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ0EsV0FBVyxHQUFHO2dCQUNuQixNQUFNLElBQUksQ0FBQ0ssa0JBQWtCO1lBQy9CLE9BQU8sSUFBSXpGLEdBQUdoM0QsSUFBSSxLQUFLLFVBQVU7Z0JBQy9CLElBQUksQ0FBQ3dsQixJQUFJLENBQUNtMkMsU0FBU0UsbUJBQW1CO2dCQUN0QyxJQUFJN0UsR0FBRzNoQyxHQUFHLEVBQUU7b0JBQ1YsTUFBTTJvQyxZQUFZbjlELE1BQU1tMkQsR0FBRzNoQyxHQUFHO29CQUM5QjJvQyxVQUFVdDRCLEtBQUssQ0FBQ3p3QyxPQUFPLENBQUN5d0MsQ0FBQUE7d0JBQ3RCLElBQUlBLE1BQU0xbEMsSUFBSSxLQUFLLFNBQVM7NEJBQzFCLElBQUksQ0FBQ3dsQixJQUFJLENBQUNtMkMsU0FBU0csb0JBQW9CLEVBQUVwMkIsTUFBTXcwQixHQUFHO3dCQUNwRDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBdUMsbUJBQW1CMThELE9BQU8sRUFBRTtRQUMxQixJQUFJMEI7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxJQUFJLENBQUNpd0MsT0FBTyxLQUFLcDZELFdBQVc7Z0JBQzlCO1lBQ0Y7WUFDQSxJQUFJNkgsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF3K0QsVUFBVSxFQUFFO2dCQUN4RSxJQUFJLENBQUN6bkUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLGtCQUFrQixJQUFJLENBQUN3aEQsVUFBVTtnQkFDaEQsSUFBSSxDQUFDa2lCLGFBQWEsR0FBRztZQUN2QjtZQUNBLElBQUksSUFBSSxDQUFDenFDLEdBQUcsSUFBSSxJQUFJLENBQUNBLEdBQUcsQ0FBQ3VELGNBQWMsS0FBSyxvQkFBb0I7Z0JBQzlELHFFQUFxRTtnQkFDckUsMkRBQTJEO2dCQUMzRCxNQUFNdXBDLFlBQVksSUFBSSxDQUFDOXNDLEdBQUcsQ0FBQ2lzQyxpQkFBaUI7Z0JBQzVDLElBQUksQ0FBQzU5RCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXcrRCxVQUFVLEtBQUtDLFdBQVc7b0JBQ3ZGLGlGQUFpRjtvQkFDakYseURBQXlEO29CQUN6RCxNQUFNLElBQUksQ0FBQzlzQyxHQUFHLENBQUNmLG9CQUFvQixDQUFDNnRDO2dCQUN0QyxPQUFPO29CQUNMLElBQUksQ0FBQ3BDLFdBQVcsR0FBRztvQkFDbkI7Z0JBQ0Y7WUFDRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMxcUMsR0FBRyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxDQUFDdUQsY0FBYyxLQUFLLFVBQVU7Z0JBQzVELElBQUksQ0FBQ24rQixHQUFHLENBQUMydEIsSUFBSSxDQUFDLHFEQUFxRCxJQUFJLENBQUN3MUIsVUFBVTtnQkFDbEY7WUFDRjtZQUNBLHFCQUFxQjtZQUNyQixJQUFJLENBQUNuakQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLHlCQUF5QixJQUFJLENBQUN3aEQsVUFBVTtZQUN2RCxNQUFNb2IsUUFBUSxNQUFNLElBQUksQ0FBQy9qQyxFQUFFLENBQUNzSSxXQUFXLENBQUM3NUI7WUFDeEMsTUFBTWkrRCxZQUFZbjlELE1BQU0sQ0FBQ1ksS0FBSzR6RCxNQUFNaGdDLEdBQUcsTUFBTSxRQUFRNXpCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQzFFdThELFVBQVV0NEIsS0FBSyxDQUFDendDLE9BQU8sQ0FBQ3l3QyxDQUFBQTtnQkFDdEIsSUFBSUEsTUFBTTFsQyxJQUFJLEtBQUssU0FBUztvQkFDMUJ5K0QseUJBQXlCLzRCLE9BQU8sRUFBRSxFQUFFLEVBQUU7Z0JBQ3hDLE9BQU8sSUFBSUEsTUFBTTFsQyxJQUFJLEtBQUssU0FBUztvQkFDakMwK0QsNkJBQTZCaDVCO29CQUM3QixzRUFBc0U7b0JBQ3RFLElBQUksQ0FBQzIyQixhQUFhLENBQUN6dUMsSUFBSSxDQUFDcXdDLENBQUFBO3dCQUN0QixJQUFJLENBQUN2NEIsTUFBTWk1QixJQUFJLElBQUksQ0FBQ1YsUUFBUTdpRCxHQUFHLElBQUksQ0FBQ3NxQixNQUFNaTVCLElBQUksQ0FBQzd3QyxRQUFRLENBQUNtd0MsUUFBUTdpRCxHQUFHLEdBQUc7NEJBQ3BFLE9BQU87d0JBQ1Q7d0JBQ0EsSUFBSThpRCxlQUFlO3dCQUNuQng0QixNQUFNdzBCLEdBQUcsQ0FBQ3RzQyxJQUFJLENBQUNzc0MsQ0FBQUE7NEJBQ2IsSUFBSUEsSUFBSW43QixLQUFLLENBQUMxbEMsV0FBVyxPQUFPNGtFLFFBQVFsL0IsS0FBSyxDQUFDMWxDLFdBQVcsSUFBSTtnQ0FDM0Q2a0UsZUFBZWhFLElBQUloOUMsT0FBTztnQ0FDMUIsT0FBTzs0QkFDVDs0QkFDQSxPQUFPO3dCQUNUO3dCQUNBLElBQUlnaEQsaUJBQWlCLEdBQUc7NEJBQ3RCLE9BQU87d0JBQ1Q7d0JBQ0EsSUFBSUMsWUFBWTt3QkFDaEIsS0FBSyxNQUFNaEUsUUFBUXowQixNQUFNeTBCLElBQUksQ0FBRTs0QkFDN0IsSUFBSUEsS0FBS2o5QyxPQUFPLEtBQUtnaEQsY0FBYztnQ0FDakMsSUFBSSxDQUFDL0QsS0FBS3hCLE1BQU0sQ0FBQzdxQyxRQUFRLENBQUMsMkJBQTJCO29DQUNuRHFzQyxLQUFLeEIsTUFBTSxJQUFJLDJCQUEyQjczRCxNQUFNLENBQUN1RSxLQUFLdTVELEtBQUssQ0FBQ1gsUUFBUUksS0FBSyxHQUFHM0M7Z0NBQzlFO2dDQUNBLElBQUksQ0FBQ3ZCLEtBQUt4QixNQUFNLENBQUM3cUMsUUFBUSxDQUFDLHlCQUF5QjtvQ0FDakRxc0MsS0FBS3hCLE1BQU0sSUFBSSx5QkFBeUI3M0QsTUFBTSxDQUFDbTlELFFBQVFJLEtBQUs7Z0NBQzlEO2dDQUNBRixZQUFZO2dDQUNaOzRCQUNGO3dCQUNGO3dCQUNBLElBQUksQ0FBQ0EsV0FBVzs0QkFDZHo0QixNQUFNeTBCLElBQUksQ0FBQ2w3RCxJQUFJLENBQUM7Z0NBQ2RpZSxTQUFTZ2hEO2dDQUNUdkYsUUFBUSwwQkFBMEI3M0QsTUFBTSxDQUFDdUUsS0FBS3U1RCxLQUFLLENBQUNYLFFBQVFJLEtBQUssR0FBRzNDLHFCQUFxQiwwQkFBMEI1NkQsTUFBTSxDQUFDbTlELFFBQVFJLEtBQUs7NEJBQ3pJO3dCQUNGO3dCQUNBLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNqSixPQUFPb0csTUFBTXVDO1lBQ3JDLElBQUksQ0FBQzFMLE9BQU8sQ0FBQytDO1FBQ2Y7SUFDRjtJQUNBd0oscUJBQXFCO1FBQ25CLElBQUlwOUQ7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXF6QyxTQUFTLE1BQU0sSUFBSSxDQUFDcGtDLEVBQUUsQ0FBQzBJLFlBQVk7WUFDekMsTUFBTWdrQyxZQUFZbjlELE1BQU0sQ0FBQ1ksS0FBS2kwRCxPQUFPcmdDLEdBQUcsTUFBTSxRQUFRNXpCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQzNFdThELFVBQVV0NEIsS0FBSyxDQUFDendDLE9BQU8sQ0FBQ3l3QyxDQUFBQTtnQkFDdEIsSUFBSUEsTUFBTTFsQyxJQUFJLEtBQUssU0FBUztvQkFDMUJ5K0QseUJBQXlCLzRCLE9BQU8sSUFBSSxDQUFDNDJCLGdCQUFnQixFQUFFLElBQUksQ0FBQ0MsY0FBYztnQkFDNUU7WUFDRjtZQUNBLE1BQU0sSUFBSSxDQUFDK0IsWUFBWSxDQUFDNUksUUFBUStGLE1BQU11QztZQUN0QyxPQUFPdEk7UUFDVDtJQUNGO0lBQ0Evc0Isa0JBQWtCOWEsS0FBSyxFQUFFaXhDLGVBQWUsRUFBRTtRQUN4QyxPQUFPLElBQUksQ0FBQ3h0QyxFQUFFLENBQUNxWCxpQkFBaUIsQ0FBQzlhLE9BQU9peEM7SUFDMUM7SUFDQXJtQyxlQUFlMmhCLGdCQUFnQixFQUFFMmtCLGVBQWUsRUFBRTtRQUNoRCxPQUFPLElBQUksQ0FBQ3p0QyxFQUFFLENBQUNtSCxjQUFjLENBQUMyaEIsa0JBQWtCMmtCO0lBQ2xEO0lBQ0FqdEMsU0FBU3RHLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNrRyxHQUFHLEVBQUU7WUFDYixNQUFNLElBQUl3ZCwwQkFBMEI7UUFDdEM7UUFDQSxPQUFPLElBQUksQ0FBQ3hkLEdBQUcsQ0FBQ0ksUUFBUSxDQUFDdEc7SUFDM0I7SUFDQXd6QyxxQkFBcUJ0akUsSUFBSSxFQUFFO1FBQ3pCLElBQUksQ0FBQzJnRSxhQUFhLENBQUNwOUQsSUFBSSxDQUFDdkQ7SUFDMUI7SUFDQXVqRSxpQkFBaUJDLFNBQVMsRUFBRTtRQUMxQixJQUFJejlEO1FBQ0osSUFBSSxDQUFDLElBQUksQ0FBQ2l3QixHQUFHLEVBQUU7WUFDYixNQUFNLElBQUl3ZCwwQkFBMEI7UUFDdEM7UUFDQSxPQUFPLENBQUN6dEMsS0FBSyxJQUFJLENBQUNpd0IsR0FBRyxNQUFNLFFBQVFqd0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdzlELGdCQUFnQixDQUFDQztJQUNsRjtJQUNBQyxpQkFBaUI7UUFDZixJQUFJMTlEO1FBQ0osT0FBTyxDQUFDLENBQUUsRUFBQ0EsS0FBSyxJQUFJLENBQUNpd0IsR0FBRyxNQUFNLFFBQVFqd0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd3dCLFdBQVc7SUFDL0U7SUFDQUEsWUFBWUYsTUFBTSxFQUFFO1FBQ2xCLElBQUl0d0I7UUFDSixPQUFPLENBQUNBLEtBQUssSUFBSSxDQUFDaXdCLEdBQUcsTUFBTSxRQUFRandCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3d3QixXQUFXLENBQUNGO0lBQzdFO0lBQ0FxdEMscUJBQXFCO1FBQ25CLElBQUkzOUQsSUFBSThVO1FBQ1IsT0FBTyxDQUFDQSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ2l3QixHQUFHLE1BQU0sUUFBUWp3QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc2bkMsZUFBZSxNQUFNLFFBQVEveUIsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDekg7SUFDQThvRCx3QkFBd0I7UUFDdEIsSUFBSTU5RCxJQUFJOFU7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDaXdCLEdBQUcsTUFBTSxRQUFRandCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3duQyxrQkFBa0IsTUFBTSxRQUFRMXlCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQzVIO0lBQ0Erb0QscUJBQXFCO1FBQ25CLElBQUk3OUQsSUFBSThVO1FBQ1IsT0FBTyxDQUFDQSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ2l3QixHQUFHLE1BQU0sUUFBUWp3QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3ekIsY0FBYyxNQUFNLFFBQVExZSxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN4SDtJQUNBOGxCLGtCQUFrQjtRQUNoQixJQUFJNTZCLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUNpd0IsR0FBRyxNQUFNLFFBQVFqd0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNDZCLGVBQWUsRUFBQyxNQUFPLFFBQVE5bEIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtJQUM3SDtJQUNBb2IsYUFBYTtRQUNYLElBQUlsd0IsSUFBSThVO1FBQ1IsT0FBTyxDQUFDQSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ2l3QixHQUFHLE1BQU0sUUFBUWp3QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrd0IsVUFBVSxFQUFDLE1BQU8sUUFBUXBiLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7SUFDeEg7SUFDQWdwRCxzQkFBc0I7UUFDcEIsSUFBSTk5RDtRQUNKLE9BQU8sQ0FBQ0EsS0FBSyxJQUFJLENBQUNpd0IsR0FBRyxNQUFNLFFBQVFqd0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHKzlELGdCQUFnQjtJQUNqRjtJQUNBQyx1QkFBdUI7UUFDckIsSUFBSWgrRDtRQUNKLE9BQU8sQ0FBQ0EsS0FBSyxJQUFJLENBQUM2dkIsRUFBRSxNQUFNLFFBQVE3dkIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHazhELGlCQUFpQjtJQUNqRjtJQUNBOXFDLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ3ZCLEVBQUUsQ0FBQ3VCLFFBQVE7SUFDekI7SUFDQTZzQyxzQkFBc0I7UUFDcEIsSUFBSWorRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDcVAsR0FBRyxFQUFFO2dCQUNiO1lBQ0Y7WUFDQSxJQUFJaXVDLDBCQUEwQjtZQUM5QixNQUFNQyxpQkFBaUIsSUFBSWwyQztZQUMzQixxQkFBcUI7WUFDckIsTUFBTWd4QyxhQUFhLElBQUloeEM7WUFDdkIsTUFBTXlCLFFBQVEsTUFBTSxJQUFJLENBQUN1RyxHQUFHLENBQUNtQixRQUFRO1lBQ3JDMUgsTUFBTWwyQixPQUFPLENBQUNzSixDQUFBQTtnQkFDWixPQUFRQSxFQUFFeUIsSUFBSTtvQkFDWixLQUFLO3dCQUNIMi9ELDBCQUEwQnBoRSxFQUFFb2hFLHVCQUF1Qjt3QkFDbkQ7b0JBQ0YsS0FBSzt3QkFDSCxJQUFJQSw0QkFBNEIsTUFBTXBoRSxFQUFFc2hFLFFBQVEsRUFBRTs0QkFDaERGLDBCQUEwQnBoRSxFQUFFOHNCLEVBQUU7d0JBQ2hDO3dCQUNBdTBDLGVBQWV4M0QsR0FBRyxDQUFDN0osRUFBRThzQixFQUFFLEVBQUU5c0I7d0JBQ3pCO29CQUNGLEtBQUs7d0JBQ0htOEQsV0FBV3R5RCxHQUFHLENBQUM3SixFQUFFOHNCLEVBQUUsRUFBRSxHQUFHdnFCLE1BQU0sQ0FBQ3ZDLEVBQUUrZixPQUFPLEVBQUUsS0FBS3hkLE1BQU0sQ0FBQ3ZDLEVBQUUwL0IsSUFBSTt3QkFDNUQ7Z0JBQ0o7WUFDRjtZQUNBLElBQUkwaEMsNEJBQTRCLElBQUk7Z0JBQ2xDLE9BQU96bkU7WUFDVDtZQUNBLE1BQU00bkUsYUFBYSxDQUFDcitELEtBQUttK0QsZUFBZWpxRSxHQUFHLENBQUNncUUsd0JBQXVCLE1BQU8sUUFBUWwrRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzK0QsaUJBQWlCO1lBQy9ILElBQUlELGVBQWU1bkUsV0FBVztnQkFDNUIsT0FBT0E7WUFDVDtZQUNBLE9BQU93aUUsV0FBVy9rRSxHQUFHLENBQUNtcUU7UUFDeEI7SUFDRjtJQUNBeEIsYUFBYXRILEVBQUUsRUFBRWdKLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQy9CLE9BQU81OUMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJMjlDLFFBQVE7Z0JBQ1YsTUFBTUUsY0FBY2xKLEdBQUczaEMsR0FBRztnQkFDMUIyaEMsR0FBRzNoQyxHQUFHLEdBQUcycUM7Z0JBQ1QsSUFBSTtvQkFDRixJQUFJLENBQUNscEUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLGtCQUFrQnFJLE1BQU0sQ0FBQ20vRCxTQUFTLFdBQVcsU0FBUyxpQkFBaUIsSUFBSSxDQUFDaG1CLFVBQVU7b0JBQ3JHLElBQUlnbUIsUUFBUTt3QkFDVixNQUFNLElBQUksQ0FBQzN1QyxFQUFFLENBQUNYLG9CQUFvQixDQUFDcW1DO29CQUNyQyxPQUFPO3dCQUNMLE1BQU0sSUFBSSxDQUFDMWxDLEVBQUUsQ0FBQzJFLG1CQUFtQixDQUFDK2dDO29CQUNwQztvQkFDQTtnQkFDRixFQUFFLE9BQU85aEUsR0FBRztvQkFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLG1CQUFtQjNqQixNQUFNLENBQUNrMkQsR0FBR2gzRCxJQUFJLEVBQUUscUNBQXFDM0ssT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7d0JBQ3RJdDJCLE9BQU96dUI7d0JBQ1BtZ0MsS0FBSzJxQztvQkFDUDtvQkFDQWhKLEdBQUczaEMsR0FBRyxHQUFHNnFDO2dCQUNYO1lBQ0Y7WUFDQSxJQUFJO2dCQUNGLElBQUlELFFBQVE7b0JBQ1YsTUFBTSxJQUFJLENBQUMzdUMsRUFBRSxDQUFDWCxvQkFBb0IsQ0FBQ3FtQztnQkFDckMsT0FBTztvQkFDTCxNQUFNLElBQUksQ0FBQzFsQyxFQUFFLENBQUMyRSxtQkFBbUIsQ0FBQytnQztnQkFDcEM7WUFDRixFQUFFLE9BQU85aEUsR0FBRztnQkFDVixzQ0FBc0M7Z0JBQ3RDLHdGQUF3RjtnQkFDeEYsSUFBSTBILE1BQU07Z0JBQ1YsSUFBSTFILGFBQWE4SCxPQUFPO29CQUN0QkosTUFBTTFILEVBQUU2TCxPQUFPO2dCQUNqQixPQUFPLElBQUksT0FBTzdMLE1BQU0sVUFBVTtvQkFDaEMwSCxNQUFNMUg7Z0JBQ1I7Z0JBQ0EsTUFBTStNLFNBQVM7b0JBQ2IwaEIsT0FBTy9tQjtvQkFDUHk0QixLQUFLMmhDLEdBQUczaEMsR0FBRztnQkFDYjtnQkFDQSxJQUFJLENBQUM0cUMsVUFBVSxJQUFJLENBQUMzdUMsRUFBRSxDQUFDcXNDLGlCQUFpQixFQUFFO29CQUN4QzE3RCxPQUFPaytELFNBQVMsR0FBRyxJQUFJLENBQUM3dUMsRUFBRSxDQUFDcXNDLGlCQUFpQjtnQkFDOUM7Z0JBQ0EsSUFBSSxDQUFDN21FLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsaUJBQWlCN2lCLE1BQU0sQ0FBQ2syRCxHQUFHaDNELElBQUksR0FBRzNLLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUNqR2g0QztnQkFDRjtnQkFDQSxNQUFNLElBQUlrdEMsaUJBQWlCdnlDO1lBQzdCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBUzZoRSx5QkFBeUIvNEIsS0FBSyxFQUFFbTRCLFVBQVUsRUFBRUMsUUFBUTtJQUMzRCxrQ0FBa0M7SUFDbEMsSUFBSXNDLGNBQWM7SUFDbEIxNkIsTUFBTXcwQixHQUFHLENBQUN0c0MsSUFBSSxDQUFDc3NDLENBQUFBO1FBQ2IsSUFBSUEsSUFBSW43QixLQUFLLEtBQUssUUFBUTtZQUN4QnFoQyxjQUFjbEcsSUFBSWg5QyxPQUFPO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBLCtCQUErQjtJQUMvQixJQUFJa2pELGNBQWMsR0FBRztRQUNuQixJQUFJLENBQUMxNkIsTUFBTTI2QixNQUFNLEVBQUU7WUFDakIzNkIsTUFBTTI2QixNQUFNLEdBQUcsRUFBRTtRQUNuQjtRQUNBLElBQUl2QyxTQUFTaHdDLFFBQVEsQ0FBQzRYLE1BQU0xZ0MsR0FBRyxLQUFLLENBQUMwZ0MsTUFBTTI2QixNQUFNLENBQUN6eUMsSUFBSSxDQUFDdVMsQ0FBQUEsS0FBTUEsR0FBR2pqQixPQUFPLEtBQUtrakQsZUFBZWpnQyxHQUFHbmdDLElBQUksS0FBSyxTQUFTO1lBQzlHMGxDLE1BQU0yNkIsTUFBTSxDQUFDcGhFLElBQUksQ0FBQztnQkFDaEJpZSxTQUFTa2pEO2dCQUNUcGdFLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSTY5RCxXQUFXL3ZDLFFBQVEsQ0FBQzRYLE1BQU0xZ0MsR0FBRyxHQUFHO1lBQ2xDMGdDLE1BQU15MEIsSUFBSSxDQUFDdnNDLElBQUksQ0FBQ3VzQyxDQUFBQTtnQkFDZCxJQUFJQSxLQUFLajlDLE9BQU8sS0FBS2tqRCxhQUFhO29CQUNoQyxJQUFJLENBQUNqRyxLQUFLeEIsTUFBTSxDQUFDN3FDLFFBQVEsQ0FBQyxhQUFhO3dCQUNyQ3FzQyxLQUFLeEIsTUFBTSxJQUFJO29CQUNqQjtvQkFDQSxPQUFPO2dCQUNUO2dCQUNBLE9BQU87WUFDVDtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrRiw2QkFBNkJoNUIsS0FBSztJQUN6QyxJQUFJamtDLElBQUk4VSxJQUFJQyxJQUFJQztJQUNoQixNQUFNc29CLFFBQVEsQ0FBQ3hvQixLQUFLLENBQUM5VSxLQUFLaWtDLE1BQU13MEIsR0FBRyxDQUFDLEVBQUUsTUFBTSxRQUFRejRELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3M5QixLQUFLLE1BQU0sUUFBUXhvQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4SixXQUFXO0lBQzFJLElBQUksQ0FBQ20xQyxXQUFXbmpCLFFBQVE7UUFDdEI7SUFDRjtJQUNBLElBQUl1aEMsUUFBUTtJQUNaLE1BQU1DLFVBQVUsQ0FBQy9wRCxLQUFLa3ZCLE1BQU04NkIsR0FBRyxNQUFNLFFBQVFocUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb1gsSUFBSSxDQUFDNHlDLENBQUFBO1FBQzVFLElBQUlBLElBQUlyaEMsR0FBRyxLQUFLZ2lCLGdCQUFnQjtZQUM5QixPQUFPO1FBQ1Q7UUFDQSxJQUFJcWYsSUFBSXpoRSxLQUFLLEdBQUd1aEUsT0FBTztZQUNyQkEsUUFBUUUsSUFBSXpoRSxLQUFLO1FBQ25CO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDd2hFLFNBQVM7UUFDWDlwRCxDQUFBQSxLQUFLaXZCLE1BQU04NkIsR0FBRyxNQUFNLFFBQVEvcEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeFgsSUFBSSxDQUFDO1lBQzVERixPQUFPdWhFLFFBQVE7WUFDZm5oQyxLQUFLZ2lCO1FBQ1A7SUFDRjtBQUNGO0FBQ0EsU0FBUzRjLG1DQUFtQzFJLEtBQUs7SUFDL0MsSUFBSTV6RDtJQUNKLE1BQU1vOEQsYUFBYSxFQUFFO0lBQ3JCLE1BQU1DLFdBQVcsRUFBRTtJQUNuQixNQUFNRSxZQUFZbjlELE1BQU0sQ0FBQ1ksS0FBSzR6RCxNQUFNaGdDLEdBQUcsTUFBTSxRQUFRNXpCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQzFFLElBQUkyK0QsY0FBYztJQUNsQnBDLFVBQVV0NEIsS0FBSyxDQUFDendDLE9BQU8sQ0FBQ3l3QyxDQUFBQTtRQUN0QixJQUFJamtDO1FBQ0osSUFBSWlrQyxNQUFNMWxDLElBQUksS0FBSyxTQUFTO1lBQzFCMGxDLE1BQU13MEIsR0FBRyxDQUFDdHNDLElBQUksQ0FBQ3NzQyxDQUFBQTtnQkFDYixJQUFJQSxJQUFJbjdCLEtBQUssS0FBSyxRQUFRO29CQUN4QnFoQyxjQUFjbEcsSUFBSWg5QyxPQUFPO29CQUN6QixPQUFPO2dCQUNUO2dCQUNBLE9BQU87WUFDVDtZQUNBLElBQUksQ0FBQ3piLEtBQUtpa0MsTUFBTTI2QixNQUFNLE1BQU0sUUFBUTUrRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtc0IsSUFBSSxDQUFDdVMsQ0FBQUEsS0FBTUEsR0FBR2pqQixPQUFPLEtBQUtrakQsZUFBZWpnQyxHQUFHbmdDLElBQUksS0FBSyxTQUFTO2dCQUM1SDg5RCxTQUFTNytELElBQUksQ0FBQ3ltQyxNQUFNMWdDLEdBQUc7WUFDekI7WUFDQTBnQyxNQUFNeTBCLElBQUksQ0FBQ3ZzQyxJQUFJLENBQUN1c0MsQ0FBQUE7Z0JBQ2QsSUFBSUEsS0FBS2o5QyxPQUFPLEtBQUtrakQsYUFBYTtvQkFDaEMsSUFBSWpHLEtBQUt4QixNQUFNLENBQUM3cUMsUUFBUSxDQUFDLG1CQUFtQjt3QkFDMUMrdkMsV0FBVzUrRCxJQUFJLENBQUN5bUMsTUFBTTFnQyxHQUFHO29CQUMzQjtvQkFDQSxPQUFPO2dCQUNUO2dCQUNBLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0w2NEQ7UUFDQUM7SUFDRjtBQUNGO0FBRUEsTUFBTTJDLG9CQUFvQjtBQUMxQixNQUFNQyxrQkFBa0I7SUFDdEI7O0dBRUMsR0FDREMsY0FBYy91QixhQUFhRyxLQUFLLENBQUMzTixVQUFVO0lBQzNDdzhCLGFBQWFodkIsYUFBYUcsS0FBSztJQUMvQjh1QixLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsYUFBYTtJQUNicGxELFdBQVc7SUFDWHFsRCxxQkFBcUIvdEIsbUJBQW1CTSxVQUFVLENBQUNsQyxRQUFRO0lBQzNENHZCLG9CQUFvQjtJQUNwQkMsWUFBWVQ7SUFDWlUsYUFBYTtBQUNmO0FBQ0EsTUFBTTlpQixnQkFBZ0I7SUFDcEIraUIsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLGtCQUFrQjtBQUNwQjtBQUNBLE1BQU1oakIsZ0JBQWdCO0lBQ3BCaE4sWUFBWWEsYUFBYU0sSUFBSSxDQUFDbkIsVUFBVTtBQUMxQztBQUNBLE1BQU1pd0IscUJBQXFCO0lBQ3pCcEosZ0JBQWdCO0lBQ2hCcUosVUFBVTtJQUNWQywyQkFBMkI7SUFDM0JDLGlCQUFpQixJQUFJNS9DO0lBQ3JCNi9DLHVCQUF1QjtJQUN2QkMsZ0JBQWdCO0FBQ2xCO0FBQ0EsTUFBTUMsNEJBQTRCO0lBQ2hDNUosZUFBZTtJQUNmNkosWUFBWTtJQUNaQyx1QkFBdUI7SUFDdkJuTyxrQkFBa0I7QUFDcEI7QUFFQSxJQUFJb087QUFDSCxVQUFVQSxnQkFBZ0I7SUFDekJBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUN2REEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDdERBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ25EQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDckQsR0FBR0Esb0JBQXFCQSxDQUFBQSxtQkFBbUIsQ0FBQztBQUM1QyxNQUFNQztJQUNKLElBQUlDLGlCQUFpQjtRQUNuQixPQUFPLElBQUksQ0FBQ0MsNkJBQTZCO0lBQzNDO0lBQ0EsSUFBSUMsa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyw4QkFBOEI7SUFDNUM7SUFDQSxJQUFJN1EsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ2ozQyxLQUFLO0lBQ25CO0lBQ0F4WSxZQUFZbTlELFNBQVMsRUFBRW5wQixpQkFBaUIsRUFBRWtELGFBQWEsQ0FBRTtRQUN2RCxJQUFJeDNDO1FBQ0osSUFBSSxDQUFDc2dFLHFCQUFxQixHQUFHRiwwQkFBMEJFLHFCQUFxQjtRQUM1RSxJQUFJLENBQUNqckUsR0FBRyxHQUFHMkU7UUFDWCxJQUFJLENBQUM2bUUsV0FBVyxHQUFHO1lBQ2pCLElBQUk3Z0U7WUFDSixNQUFNOGdFLGdCQUFnQixJQUFJLENBQUNob0QsS0FBSztZQUNoQyxNQUFNaW9ELG1CQUFtQixJQUFJLENBQUNDLGtCQUFrQixDQUFDeG1FLEdBQUcsQ0FBQ2kvQyxDQUFBQSxLQUFNQSxHQUFHa2tCLGtCQUFrQjtZQUNoRixJQUFJb0QsaUJBQWlCenVELEtBQUssQ0FBQzJ1RCxDQUFBQSxLQUFNQSxPQUFPLGNBQWM7Z0JBQ3BELElBQUksQ0FBQ25vRCxLQUFLLEdBQUd5bkQsaUJBQWlCOU4sU0FBUztZQUN6QyxPQUFPLElBQUlzTyxpQkFBaUI1MEMsSUFBSSxDQUFDODBDLENBQUFBLEtBQU1BLE9BQU8sV0FBVztnQkFDdkQsSUFBSSxDQUFDbm9ELEtBQUssR0FBR3luRCxpQkFBaUJXLE1BQU07WUFDdEMsT0FBTyxJQUFJSCxpQkFBaUI1MEMsSUFBSSxDQUFDODBDLENBQUFBLEtBQU1BLE9BQU8sZUFBZTtnQkFDM0QsSUFBSSxDQUFDbm9ELEtBQUssR0FBR3luRCxpQkFBaUJuUSxVQUFVO1lBQzFDLE9BQU8sSUFBSTJRLGlCQUFpQnp1RCxLQUFLLENBQUMydUQsQ0FBQUEsS0FBTUEsT0FBTyxXQUFXO2dCQUN4RCxJQUFJLENBQUNub0QsS0FBSyxHQUFHeW5ELGlCQUFpQlksTUFBTTtZQUN0QyxPQUFPLElBQUlKLGlCQUFpQjUwQyxJQUFJLENBQUM4MEMsQ0FBQUEsS0FBTUEsT0FBTyxXQUFXO2dCQUN2RCxJQUFJLENBQUNub0QsS0FBSyxHQUFHeW5ELGlCQUFpQjlNLE9BQU87WUFDdkMsT0FBTyxJQUFJc04saUJBQWlCenVELEtBQUssQ0FBQzJ1RCxDQUFBQSxLQUFNQSxPQUFPLFFBQVE7Z0JBQ3JELElBQUksQ0FBQ25vRCxLQUFLLEdBQUd5bkQsaUJBQWlCYSxHQUFHO1lBQ25DO1lBQ0EsSUFBSU4sa0JBQWtCLElBQUksQ0FBQ2hvRCxLQUFLLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQ3pqQixHQUFHLENBQUMyQixLQUFLLENBQUMseUJBQXlCcUksTUFBTSxDQUFDa2hFLGdCQUFnQixDQUFDTyxjQUFjLEVBQUUsUUFBUXpoRSxNQUFNLENBQUNraEUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDem5ELEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQzAvQixVQUFVO2dCQUM1SXg0QyxDQUFBQSxLQUFLLElBQUksQ0FBQ3FoRSxhQUFhLE1BQU0sUUFBUXJoRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTCxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQytqQixLQUFLLEVBQUUsSUFBSSxDQUFDd29ELFNBQVMsQ0FBQzNELGtCQUFrQixJQUFJLElBQUksQ0FBQzRELFVBQVUsQ0FBQzVELGtCQUFrQjtZQUNsSztRQUNGO1FBQ0EsSUFBSSxDQUFDdG9FLEdBQUcsR0FBR2tFLFVBQVUsQ0FBQ3lHLEtBQUt3M0MsY0FBYzVnRCxVQUFVLE1BQU0sUUFBUW9KLE9BQU8sS0FBSyxJQUFJQSxLQUFLakcsWUFBWXluRSxTQUFTO1FBQzNHLElBQUksQ0FBQ2hxQixhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ2twQiw2QkFBNkIsR0FBRyxDQUFDcHNCO1FBQ3RDLElBQUksQ0FBQ3NzQiw4QkFBOEIsR0FBR3RzQjtRQUN0QyxNQUFNbXRCLGtCQUFrQjtZQUN0QjUyQyxVQUFVO2dCQUFDO29CQUNUNjJDLFVBQVU7Z0JBQ1o7YUFBRTtRQUNKO1FBQ0EsSUFBSSxDQUFDSixTQUFTLEdBQUcsSUFBSWhILFlBQVltRCxXQUFXZ0UsaUJBQWlCanFCO1FBQzdELElBQUksQ0FBQytwQixVQUFVLEdBQUcsSUFBSWpILFlBQVltRCxXQUFXam1CO1FBQzdDLElBQUksQ0FBQzhwQixTQUFTLENBQUN4Rix1QkFBdUIsR0FBRyxJQUFJLENBQUMrRSxXQUFXO1FBQ3pELElBQUksQ0FBQ1UsVUFBVSxDQUFDekYsdUJBQXVCLEdBQUcsSUFBSSxDQUFDK0UsV0FBVztRQUMxRCxJQUFJLENBQUNTLFNBQVMsQ0FBQzFGLDBCQUEwQixHQUFHLElBQUksQ0FBQ2lGLFdBQVc7UUFDNUQsSUFBSSxDQUFDVSxVQUFVLENBQUMzRiwwQkFBMEIsR0FBRyxJQUFJLENBQUNpRixXQUFXO1FBQzdELElBQUksQ0FBQ1MsU0FBUyxDQUFDekYsc0JBQXNCLEdBQUcsSUFBSSxDQUFDZ0YsV0FBVztRQUN4RCxJQUFJLENBQUNVLFVBQVUsQ0FBQzFGLHNCQUFzQixHQUFHLElBQUksQ0FBQ2dGLFdBQVc7UUFDekQsSUFBSSxDQUFDUyxTQUFTLENBQUM3RixjQUFjLEdBQUdoaUMsQ0FBQUE7WUFDOUIsSUFBSXo1QjtZQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQ3k3RCxjQUFjLE1BQU0sUUFBUXo3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTCxJQUFJLENBQUMsSUFBSSxFQUFFMGtDLFdBQVd3WSxhQUFha0MsU0FBUztRQUNqSDtRQUNBLElBQUksQ0FBQ290QixVQUFVLENBQUM5RixjQUFjLEdBQUdoaUMsQ0FBQUE7WUFDL0IsSUFBSXo1QjtZQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQ3k3RCxjQUFjLE1BQU0sUUFBUXo3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTCxJQUFJLENBQUMsSUFBSSxFQUFFMGtDLFdBQVd3WSxhQUFhMHZCLFVBQVU7UUFDbEg7UUFDQSxtRUFBbUU7UUFDbkUsSUFBSSxDQUFDSixVQUFVLENBQUN4RixhQUFhLEdBQUc1USxDQUFBQTtZQUM5QixJQUFJbnJEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDKzdELGFBQWEsTUFBTSxRQUFRLzdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJLEVBQUVvMkQ7UUFDL0U7UUFDQSxJQUFJLENBQUNvVyxVQUFVLENBQUN2RixPQUFPLEdBQUc3USxDQUFBQTtZQUN4QixJQUFJbnJEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDZzhELE9BQU8sTUFBTSxRQUFRaDhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJLEVBQUVvMkQ7UUFDekU7UUFDQSxJQUFJLENBQUNtVyxTQUFTLENBQUN6USxPQUFPLEdBQUcrQyxDQUFBQTtZQUN2QixJQUFJNXpEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDNGhFLGdCQUFnQixNQUFNLFFBQVE1aEUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksRUFBRTYrRDtRQUNsRjtRQUNBLElBQUksQ0FBQzk2QyxLQUFLLEdBQUd5bkQsaUJBQWlCYSxHQUFHO1FBQ2pDLElBQUksQ0FBQzdQLGNBQWMsR0FBRyxJQUFJMUw7SUFDNUI7SUFDQSxJQUFJck4sYUFBYTtRQUNmLElBQUl4NEMsSUFBSThVO1FBQ1IsT0FBT2xoQixPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDa1gsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUN3M0MsYUFBYSxFQUFFVyxlQUFlLE1BQU0sUUFBUXJqQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcvZixJQUFJLENBQUNpTDtJQUN6SDtJQUNBNmhFLG1CQUFtQjtRQUNqQixJQUFJQyxVQUFVMXJFLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ2xGLElBQUksQ0FBQ3NxRSw2QkFBNkIsR0FBR29CO1FBQ3JDLElBQUksQ0FBQ2pCLFdBQVc7SUFDbEI7SUFDQWtCLG9CQUFvQjtRQUNsQixJQUFJRCxVQUFVMXJFLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ2xGLElBQUksQ0FBQ3dxRSw4QkFBOEIsR0FBR2tCO1FBQ3RDLElBQUksQ0FBQ2pCLFdBQVc7SUFDbEI7SUFDQW1CLDRCQUE0QjFqRSxPQUFPLEVBQUU7UUFDbkMsT0FBTyxJQUFJLENBQUNnakUsU0FBUyxDQUFDdEcsa0JBQWtCLENBQUMxOEQ7SUFDM0M7SUFDQTJqRSxtQkFBbUIxTSxFQUFFLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUMrTCxTQUFTLENBQUNweUMsb0JBQW9CLENBQUNxbUM7SUFDN0M7SUFDQS9rQyxZQUFZRixNQUFNLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNneEMsU0FBUyxDQUFDOXdDLFdBQVcsQ0FBQ0Y7SUFDcEM7SUFDQTZ0QixRQUFRO1FBQ04sT0FBT3Y5QixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDMGdELFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQ3pELGtCQUFrQixPQUFPLFVBQVU7Z0JBQ3RFLE1BQU15RCxZQUFZLElBQUksQ0FBQ0EsU0FBUztnQkFDaEMsS0FBSyxNQUFNaHhDLFVBQVVneEMsVUFBVXB4QyxVQUFVLEdBQUk7b0JBQzNDLElBQUk7d0JBQ0YsMERBQTBEO3dCQUMxRCxJQUFJb3hDLFVBQVU1RCxjQUFjLElBQUk7NEJBQzlCNEQsVUFBVTl3QyxXQUFXLENBQUNGO3dCQUN4QjtvQkFDRixFQUFFLE9BQU83OEIsR0FBRzt3QkFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLHlCQUF5QnB2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzs0QkFDdkZ0MkIsT0FBT3p1Qjt3QkFDVDtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsTUFBTTB0QixRQUFRak8sR0FBRyxDQUFDO2dCQUFDLElBQUksQ0FBQ291RCxTQUFTLENBQUNuakIsS0FBSztnQkFBSSxJQUFJLENBQUNvakIsVUFBVSxDQUFDcGpCLEtBQUs7YUFBRztZQUNuRSxJQUFJLENBQUMwaUIsV0FBVztRQUNsQjtJQUNGO0lBQ0FxQixvQkFBb0I7UUFDbEIsT0FBT3RoRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQzJnRCxVQUFVLENBQUM3RyxhQUFhLEdBQUc7WUFDaEMsd0NBQXdDO1lBQ3hDLElBQUksSUFBSSxDQUFDK0YsY0FBYyxFQUFFO2dCQUN2QixNQUFNLElBQUksQ0FBQ3VCLDJCQUEyQixDQUFDO29CQUNyQ2xGLFlBQVk7Z0JBQ2Q7WUFDRjtRQUNGO0lBQ0Y7SUFDQTFqQyxnQkFBZ0JLLFNBQVMsRUFBRWx0QixNQUFNLEVBQUU7UUFDakMsT0FBT3FVLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSXJVLFdBQVcwbEMsYUFBYWtDLFNBQVMsRUFBRTtnQkFDckMsTUFBTSxJQUFJLENBQUNtdEIsU0FBUyxDQUFDbG9DLGVBQWUsQ0FBQ0s7WUFDdkMsT0FBTztnQkFDTCxNQUFNLElBQUksQ0FBQzhuQyxVQUFVLENBQUNub0MsZUFBZSxDQUFDSztZQUN4QztRQUNGO0lBQ0Y7SUFDQTBvQyxnQ0FBZ0M1TSxFQUFFLEVBQUU7UUFDbEMsT0FBTzMwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQ3ZyQixHQUFHLENBQUMyQixLQUFLLENBQUMseUJBQXlCcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7Z0JBQ3hGNHBCLFlBQVk3TSxHQUFHaDNELElBQUk7Z0JBQ25CcTFCLEtBQUsyaEMsR0FBRzNoQyxHQUFHO2dCQUNYSixnQkFBZ0IsSUFBSSxDQUFDK3RDLFVBQVUsQ0FBQzFELGtCQUFrQixHQUFHLzVELFFBQVE7WUFDL0Q7WUFDQSxNQUFNLElBQUksQ0FBQ3k5RCxVQUFVLENBQUNyeUMsb0JBQW9CLENBQUNxbUM7WUFDM0MsbUJBQW1CO1lBQ25CLE1BQU10QixTQUFTLE1BQU0sSUFBSSxDQUFDc04sVUFBVSxDQUFDbkUsa0JBQWtCO1lBQ3ZELE9BQU9uSjtRQUNUO0lBQ0Y7SUFDQW9PLG9CQUFvQm5MLE1BQU0sRUFBRTRGLFVBQVUsRUFBRTtRQUN0QyxJQUFJLENBQUN3RSxTQUFTLENBQUM5RCxnQkFBZ0IsQ0FBQ3RHO1FBQ2hDLElBQUksQ0FBQ3FLLFVBQVUsQ0FBQy9ELGdCQUFnQixDQUFDdEc7UUFDakMsSUFBSTRGLFlBQVk7WUFDZCxJQUFJLENBQUNvRixpQkFBaUI7UUFDeEI7SUFDRjtJQUNBSSw0QkFBNEJDLGVBQWUsRUFBRS9ZLE9BQU8sRUFBRTtRQUNwRCxJQUFJeHBEO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0ycEMsU0FBUyxNQUFNLElBQUksQ0FBQ2dILGNBQWMsQ0FBQ3RMLElBQUk7WUFDN0MsSUFBSTtnQkFDRixJQUFJLElBQUksQ0FBQ3lhLDZCQUE2QixJQUFJLElBQUksQ0FBQ1ksU0FBUyxDQUFDM0Qsa0JBQWtCLE9BQU8sZUFBZSxJQUFJLENBQUMyRCxTQUFTLENBQUMzRCxrQkFBa0IsT0FBTyxjQUFjO29CQUNySixJQUFJLENBQUN0b0UsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDJDQUEyQyxJQUFJLENBQUN3aEQsVUFBVTtvQkFDekUsSUFBSSxDQUFDOG9CLFNBQVMsQ0FBQ3ZHLFNBQVM7Z0JBQzFCO2dCQUNBLE1BQU01NUMsUUFBUWpPLEdBQUcsQ0FBQyxDQUFDbFQsS0FBSyxJQUFJLENBQUNnaEUsa0JBQWtCLE1BQU0sUUFBUWhoRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4RixHQUFHLENBQUNnb0UsQ0FBQUEsWUFBYSxJQUFJLENBQUNDLHdCQUF3QixDQUFDRCxXQUFXRCxpQkFBaUIvWTtZQUN0SyxTQUFVO2dCQUNSZTtZQUNGO1FBQ0Y7SUFDRjtJQUNBd1EsVUFBVXdILGVBQWUsRUFBRTtRQUN6QixPQUFPM2hELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsT0FBTyxJQUFJTyxRQUFRLENBQUNELFNBQVNFLFNBQVdSLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQ3RFLE1BQU04aEQscUJBQXFCOXpCLFdBQVc7d0JBQ3BDeHRCLE9BQU87b0JBQ1QsR0FBRyxJQUFJLENBQUNrL0MscUJBQXFCO29CQUM3QixNQUFNck8sZUFBZTt3QkFDbkJ0akIsYUFBYSt6Qjt3QkFDYnRoRCxPQUFPO29CQUNUO29CQUNBbWhELGdCQUFnQkksTUFBTSxDQUFDLzdDLGdCQUFnQixDQUFDLFNBQVNxckM7b0JBQ2pELElBQUksQ0FBQ3FQLFNBQVMsQ0FBQ2wrQyxJQUFJLENBQUM4MkMsU0FBU0Msa0JBQWtCLEVBQUU7d0JBQy9DLElBQUlvSSxnQkFBZ0JJLE1BQU0sQ0FBQ3ZRLE9BQU8sRUFBRTs0QkFDbEM7d0JBQ0Y7d0JBQ0EsSUFBSSxDQUFDa1AsU0FBUyxDQUFDbCtDLElBQUksQ0FBQzgyQyxTQUFTRSxtQkFBbUIsRUFBRTs0QkFDaER6ckIsYUFBYSt6Qjs0QkFDYnhoRDt3QkFDRjtvQkFDRjtvQkFDQSxNQUFNLElBQUksQ0FBQ29nRCxTQUFTLENBQUN2RyxTQUFTLENBQUN0bkUsQ0FBQUE7d0JBQzdCazdDLGFBQWErekI7d0JBQ2J0aEQsT0FBTzN0QjtvQkFDVDtnQkFDRjtRQUNGO0lBQ0Y7SUFDQW12RSx3QkFBd0I3NEMsS0FBSyxFQUFFdXpDLGVBQWUsRUFBRTtRQUM5QyxPQUFPLElBQUksQ0FBQ2dFLFNBQVMsQ0FBQ3RxQyxjQUFjLENBQUNqTixPQUFPdXpDO0lBQzlDO0lBQ0F1RixrQkFBa0I5NEMsS0FBSyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDdTNDLFNBQVMsQ0FBQ2p4QyxRQUFRLENBQUN0RztJQUNqQztJQUNBKzRDLDJCQUEyQjEyQyxLQUFLLEVBQUVpeEMsZUFBZSxFQUFFO1FBQ2pELE9BQU8sSUFBSSxDQUFDaUUsU0FBUyxDQUFDcDZCLGlCQUFpQixDQUFDOWEsT0FBT2l4QztJQUNqRDtJQUNBOztHQUVDLEdBQ0RZLG9CQUFvQjF4RCxNQUFNLEVBQUU7UUFDMUIsSUFBSUEsV0FBVzBsQyxhQUFha0MsU0FBUyxFQUFFO1lBQ3JDLE9BQU8sSUFBSSxDQUFDbXRCLFNBQVMsQ0FBQ3JELG1CQUFtQjtRQUMzQyxPQUFPLElBQUkxeEQsV0FBVzBsQyxhQUFhMHZCLFVBQVUsRUFBRTtZQUM3QyxPQUFPLElBQUksQ0FBQ0wsU0FBUyxDQUFDckQsbUJBQW1CO1FBQzNDO1FBQ0EsT0FBTyxJQUFJLENBQUMrQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMvQyxtQkFBbUI7SUFDdkQ7SUFDQSxJQUFJK0MscUJBQXFCO1FBQ3ZCLE1BQU0rQixhQUFhLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNyQyw2QkFBNkIsRUFBRTtZQUN0Q3FDLFdBQVd2bEUsSUFBSSxDQUFDLElBQUksQ0FBQzhqRSxTQUFTO1FBQ2hDO1FBQ0EsSUFBSSxJQUFJLENBQUNWLDhCQUE4QixFQUFFO1lBQ3ZDbUMsV0FBV3ZsRSxJQUFJLENBQUMsSUFBSSxDQUFDK2pFLFVBQVU7UUFDakM7UUFDQSxPQUFPd0I7SUFDVDtJQUNBTix5QkFBeUJPLFdBQVcsRUFBRVQsZUFBZSxFQUFFO1FBQ3JELElBQUkvWSxVQUFVcHpELFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ2txRSxxQkFBcUI7UUFDNUcsT0FBTzEvQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU1pbkIsa0JBQWtCbTdCLFlBQVlyRixrQkFBa0I7WUFDdEQsSUFBSTkxQixvQkFBb0IsYUFBYTtnQkFDbkM7WUFDRjtZQUNBLE9BQU8sSUFBSTFtQixRQUFRLENBQUNELFNBQVNFLFNBQVdSLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQ3RFLE1BQU1xeEMsZUFBZTt3QkFDbkIsSUFBSSxDQUFDNThELEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsOEJBQThCLElBQUksQ0FBQ3cxQixVQUFVO3dCQUMzRGhKLGVBQWViLFlBQVksQ0FBQ3MwQjt3QkFDNUI3aEQsT0FBTyxJQUFJK3JCLGdCQUFnQixzQ0FBc0MsRUFBRSxtQ0FBbUM7b0JBQ3hHO29CQUNBLElBQUlvMUIsb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0JJLE1BQU0sQ0FBQ3ZRLE9BQU8sRUFBRTt3QkFDcEdIO29CQUNGO29CQUNBc1Esb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0JJLE1BQU0sQ0FBQy83QyxnQkFBZ0IsQ0FBQyxTQUFTcXJDO29CQUNuSCxNQUFNZ1IsaUJBQWlCenpCLGVBQWVaLFVBQVUsQ0FBQzt3QkFDL0MyekIsb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0JJLE1BQU0sQ0FBQzc3QyxtQkFBbUIsQ0FBQyxTQUFTbXJDO3dCQUN0SDd3QyxPQUFPLElBQUkrckIsZ0JBQWdCO29CQUM3QixHQUFHcWM7b0JBQ0gsTUFBTyxJQUFJLENBQUMxd0MsS0FBSyxLQUFLeW5ELGlCQUFpQjlOLFNBQVMsQ0FBRTt3QkFDaEQsTUFBTTFVLE1BQU0sS0FBSyx1SkFBdUo7d0JBQ3hLLElBQUl3a0Isb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0JJLE1BQU0sQ0FBQ3ZRLE9BQU8sRUFBRTs0QkFDcEdoeEMsT0FBTyxJQUFJK3JCLGdCQUFnQixzQ0FBc0MsRUFBRSxtQ0FBbUM7NEJBQ3RHO3dCQUNGO29CQUNGO29CQUNBcUMsZUFBZWIsWUFBWSxDQUFDczBCO29CQUM1QlYsb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0JJLE1BQU0sQ0FBQzc3QyxtQkFBbUIsQ0FBQyxTQUFTbXJDO29CQUN0SC93QztnQkFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1naUQsbUJBQW1CO0FBQ3pCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxtQkFBbUIsSUFBSTtBQUM3QixNQUFNQyxpQkFBaUI7QUFDdkIsSUFBSUM7QUFDSCxVQUFVQSxPQUFPO0lBQ2hCQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQzlCQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ25DLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQixjQUFjLEdBQ2QsTUFBTUMsa0JBQWtCeDhDLGNBQWM3RCxZQUFZO0lBQ2hELElBQUlzZ0QsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDQyxTQUFTO0lBQ3ZCO0lBQ0FuakUsWUFBWWhDLE9BQU8sQ0FBRTtRQUNuQixJQUFJMEI7UUFDSixLQUFLO1FBQ0wsSUFBSSxDQUFDMUIsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ20vRCxTQUFTLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUM2QyxxQkFBcUIsR0FBR0YsMEJBQTBCRSxxQkFBcUI7UUFDNUUsSUFBSSxDQUFDb0QsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDcHZCLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ3F2QixPQUFPLEdBQUdMLFFBQVFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDSCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDSSxxQkFBcUIsR0FBRyxDQUFDO1FBQzlCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQix1RUFBdUUsR0FDdkUsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsdUVBQXVFLEdBQ3ZFLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQzl1RSxHQUFHLEdBQUcyRTtRQUNYLElBQUksQ0FBQ29xRSxpQkFBaUIsR0FBRy9wRSxDQUFBQTtZQUN2QixJQUFJLEVBQ0Yrc0MsT0FBTyxFQUNSLEdBQUcvc0M7WUFDSixPQUFPdW1CLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ3JDLElBQUksQ0FBQ3dtQixTQUFTO29CQUNaO2dCQUNGO2dCQUNBLElBQUlBLFFBQVFoYixLQUFLLEtBQUsrMkMscUJBQXFCO29CQUN6QyxJQUFJLENBQUNrQixhQUFhLEdBQUdqOUI7Z0JBQ3ZCLE9BQU8sSUFBSUEsUUFBUWhiLEtBQUssS0FBSzgyQyxrQkFBa0I7b0JBQzdDLElBQUksQ0FBQ29CLFVBQVUsR0FBR2w5QjtnQkFDcEIsT0FBTztvQkFDTDtnQkFDRjtnQkFDQSxJQUFJLENBQUMveEMsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLG1CQUFtQnFJLE1BQU0sQ0FBQytuQyxRQUFReGQsRUFBRSxFQUFFLE1BQU12cUIsTUFBTSxDQUFDK25DLFFBQVFoYixLQUFLLEdBQUcsSUFBSSxDQUFDb3NCLFVBQVU7Z0JBQ2pHcFIsUUFBUThrQixTQUFTLEdBQUcsSUFBSSxDQUFDcVksaUJBQWlCO1lBQzVDO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLGlCQUFpQixHQUFHamxFLENBQUFBLFVBQVdzaEIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDbEUsSUFBSTlMLElBQUlDO2dCQUNSLG9HQUFvRztnQkFDcEcsTUFBTXcxQyxTQUFTLE1BQU0sSUFBSSxDQUFDaWEsZUFBZSxDQUFDdmUsSUFBSTtnQkFDOUMsSUFBSTtvQkFDRixTQUFTO29CQUNULElBQUl2K0M7b0JBQ0osSUFBSXBJLFFBQVFxQixJQUFJLFlBQVk2RCxhQUFhO3dCQUN2Q2tELFNBQVNwSSxRQUFRcUIsSUFBSTtvQkFDdkIsT0FBTyxJQUFJckIsUUFBUXFCLElBQUksWUFBWThqRSxNQUFNO3dCQUN2Qy84RCxTQUFTLE1BQU1wSSxRQUFRcUIsSUFBSSxDQUFDK2pFLFdBQVc7b0JBQ3pDLE9BQU87d0JBQ0wsSUFBSSxDQUFDcnZFLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMseUJBQXlCdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHOzRCQUN4RjczQyxNQUFNckIsUUFBUXFCLElBQUk7d0JBQ3BCO3dCQUNBO29CQUNGO29CQUNBLE1BQU1na0UsS0FBSzVwRCxXQUFXM2MsVUFBVSxDQUFDLElBQUlvSSxXQUFXa0I7b0JBQ2hELElBQUksQ0FBQyxDQUFDb04sS0FBSzZ2RCxHQUFHcm5FLEtBQUssTUFBTSxRQUFRd1gsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcEksSUFBSSxNQUFNLFdBQVc7d0JBQ2hGLDJCQUEyQjt3QkFDM0IsSUFBSSxDQUFDcVgsSUFBSSxDQUFDcXFCLFlBQVl3MkIsb0JBQW9CLEVBQUVELEdBQUdybkUsS0FBSyxDQUFDQSxLQUFLLENBQUM4ZCxRQUFRO29CQUNyRSxPQUFPLElBQUksQ0FBQyxDQUFDckcsS0FBSzR2RCxHQUFHcm5FLEtBQUssTUFBTSxRQUFReVgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHckksSUFBSSxNQUFNLFFBQVE7d0JBQ3BGLElBQUksQ0FBQ3FYLElBQUksQ0FBQ3FxQixZQUFZeTJCLGtCQUFrQixFQUFFRixHQUFHcm5FLEtBQUssQ0FBQ0EsS0FBSyxFQUFFcW5FLEdBQUdoNEQsSUFBSTtvQkFDbkU7Z0JBQ0YsU0FBVTtvQkFDUjQ5QztnQkFDRjtZQUNGO1FBQ0EsSUFBSSxDQUFDdWEsZUFBZSxHQUFHeDFDLENBQUFBO1lBQ3JCLE1BQU04WCxVQUFVOVgsTUFBTXkxQyxhQUFhO1lBQ25DLE1BQU1DLGNBQWM1OUIsUUFBUTY5QixjQUFjLEtBQUssSUFBSSxVQUFVO1lBQzdELElBQUkzMUMsaUJBQWlCNDFDLGNBQWM1MUMsTUFBTXBOLEtBQUssRUFBRTtnQkFDOUMsTUFBTSxFQUNKQSxLQUFLLEVBQ04sR0FBR29OLE1BQU1wTixLQUFLO2dCQUNmLElBQUksQ0FBQzdzQixHQUFHLENBQUM2c0IsS0FBSyxDQUFDLHdCQUF3QjdpQixNQUFNLENBQUMybEUsYUFBYSxNQUFNM2xFLE1BQU0sQ0FBQ2l3QixNQUFNaHdCLE9BQU8sR0FBRzFMLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUN4SXQyQjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsSUFBSSxDQUFDN3NCLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsZ0NBQWdDN2lCLE1BQU0sQ0FBQzJsRSxjQUFjcHhFLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUNwSGxwQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUM2MUMsdUJBQXVCLEdBQUc3MUMsQ0FBQUE7WUFDN0IsTUFBTThYLFVBQVU5WCxNQUFNeTFDLGFBQWE7WUFDbkMsTUFBTUMsY0FBYzU5QixRQUFRNjlCLGNBQWMsS0FBSyxJQUFJanFELGdCQUFnQm9xRCxLQUFLLEdBQUdwcUQsZ0JBQWdCQyxRQUFRO1lBQ25HLElBQUksQ0FBQ29xRCwyQkFBMkIsQ0FBQ0w7UUFDbkM7UUFDQSxvRkFBb0Y7UUFDcEYsMkVBQTJFO1FBQzNFLGlFQUFpRTtRQUNqRSxJQUFJLENBQUNNLGdCQUFnQixHQUFHLENBQUMzTyxZQUFZNE87WUFDbkMsSUFBSSxJQUFJLENBQUM5QixTQUFTLEVBQUU7Z0JBQ2xCO1lBQ0Y7WUFDQSxJQUFJLENBQUNwdUUsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxHQUFHM2pCLE1BQU0sQ0FBQ3MzRCxZQUFZLGtCQUFrQixJQUFJLENBQUNuZSxVQUFVO1lBQ3JFLElBQUksSUFBSSxDQUFDc3JCLGlCQUFpQixLQUFLLEdBQUc7Z0JBQ2hDLHlDQUF5QztnQkFDekMsSUFBSSxDQUFDQyxjQUFjLEdBQUd2dUQsS0FBS1EsR0FBRztZQUNoQztZQUNBLE1BQU13dkQsYUFBYWhvRCxDQUFBQTtnQkFDakIsSUFBSSxDQUFDbm9CLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsc0NBQXNDM2pCLE1BQU0sQ0FBQyxJQUFJLENBQUN5a0UsaUJBQWlCLEVBQUUsZUFBZXprRSxNQUFNLENBQUNtZSxVQUFVLGtCQUFrQixJQUFJLENBQUNnN0IsVUFBVTtnQkFDcEosSUFBSSxDQUFDejBCLElBQUksQ0FBQ3FxQixZQUFZcTNCLFlBQVk7Z0JBQ2xDLElBQUksQ0FBQ3RuQixLQUFLO1lBQ1o7WUFDQSxNQUFNM2dDLFdBQVdoSSxLQUFLUSxHQUFHLEtBQUssSUFBSSxDQUFDK3RELGNBQWM7WUFDakQsSUFBSTJCLFFBQVEsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQztnQkFDakNDLFdBQVdwb0Q7Z0JBQ1hpRCxZQUFZLElBQUksQ0FBQ3FqRCxpQkFBaUI7WUFDcEM7WUFDQSxJQUFJNEIsVUFBVSxNQUFNO2dCQUNsQkYsV0FBV2hvRDtnQkFDWDtZQUNGO1lBQ0EsSUFBSW01QyxlQUFlME0sZ0JBQWdCO2dCQUNqQ3FDLFFBQVE7WUFDVjtZQUNBLElBQUksQ0FBQ3J3RSxHQUFHLENBQUMyQixLQUFLLENBQUMsbUJBQW1CcUksTUFBTSxDQUFDcW1FLE9BQU8sT0FBTyxJQUFJLENBQUNsdEIsVUFBVTtZQUN0RSxJQUFJLENBQUNxdEIscUJBQXFCO1lBQzFCLElBQUksSUFBSSxDQUFDclUsS0FBSyxJQUFJLElBQUksQ0FBQ3NVLGlCQUFpQixFQUFFO2dCQUN4QyxrRkFBa0Y7Z0JBQ2xGLDZEQUE2RDtnQkFDN0QsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQ0MsV0FBVyxDQUFDLElBQUksQ0FBQ3ZVLEtBQUs7WUFDL0M7WUFDQSxJQUFJLENBQUN3VSxnQkFBZ0IsR0FBR3gyQixlQUFlWixVQUFVLENBQUMsSUFBTSxJQUFJLENBQUNxM0IsZ0JBQWdCLENBQUNWLG1CQUFtQkc7UUFDbkc7UUFDQSxJQUFJLENBQUNRLGdCQUFnQixHQUFHO1lBQ3RCLE9BQU8sSUFBSS9rRCxRQUFRLENBQUNELFNBQVNFO2dCQUMzQixJQUFJLElBQUksQ0FBQ3VpRCxPQUFPLEtBQUtMLFFBQVFuVyxTQUFTLEVBQUU7b0JBQ3RDanNDO2dCQUNGO2dCQUNBLE1BQU1pbEQsY0FBYztvQkFDbEIsSUFBSSxDQUFDdmdELEdBQUcsQ0FBQ3dvQixZQUFZcTNCLFlBQVksRUFBRVc7b0JBQ25DbGxEO2dCQUNGO2dCQUNBLE1BQU1rbEQsaUJBQWlCO29CQUNyQixJQUFJLENBQUN4Z0QsR0FBRyxDQUFDd29CLFlBQVk2YixTQUFTLEVBQUVrYztvQkFDaEMva0Q7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDZ0MsSUFBSSxDQUFDZ3JCLFlBQVk2YixTQUFTLEVBQUVrYztnQkFDakMsSUFBSSxDQUFDL2lELElBQUksQ0FBQ2dyQixZQUFZcTNCLFlBQVksRUFBRVc7WUFDdEM7UUFDRjtRQUNBLElBQUksQ0FBQ2YsMkJBQTJCLEdBQUcxNEQsQ0FBQUE7WUFDakMsTUFBTTBnQyxTQUFTLElBQUksQ0FBQ2c1QixpQkFBaUIsQ0FBQzE1RDtZQUN0QyxJQUFJLE9BQU8wZ0MsV0FBVyxlQUFlQSxXQUFXLElBQUksQ0FBQ2k1QixjQUFjLENBQUNweUUsR0FBRyxDQUFDeVksT0FBTztnQkFDN0UsSUFBSSxDQUFDMjVELGNBQWMsQ0FBQzMvRCxHQUFHLENBQUNnRyxNQUFNMGdDO2dCQUM5QixJQUFJLENBQUN0cEIsSUFBSSxDQUFDcXFCLFlBQVltNEIscUJBQXFCLEVBQUVsNUIsUUFBUTFnQztZQUN2RDtRQUNGO1FBQ0EsSUFBSSxDQUFDMDVELGlCQUFpQixHQUFHMTVELENBQUFBO1lBQ3ZCLE1BQU1rNkIsS0FBSyxJQUFJLENBQUMyL0Isa0JBQWtCLENBQUM3NUQ7WUFDbkMsSUFBSWs2QixJQUFJO2dCQUNOLE9BQU9BLEdBQUc0L0IsY0FBYyxJQUFJNS9CLEdBQUc2L0IsMEJBQTBCO1lBQzNEO1FBQ0Y7UUFDQSxJQUFJLENBQUNDLG1CQUFtQixHQUFHO1lBQ3pCLGdJQUFnSTtZQUNoSSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDN1csWUFBWSxLQUFLRixzQkFBc0JRLFlBQVksRUFBRTtnQkFDbkUsSUFBSSxDQUFDd1YscUJBQXFCO2dCQUMxQixJQUFJLENBQUNJLGdCQUFnQixDQUFDbnZELGdCQUFnQit2RCxzQkFBc0I7WUFDOUQ7UUFDRjtRQUNBLElBQUksQ0FBQ3h4RSxHQUFHLEdBQUdrRSxVQUFVLENBQUN5RyxLQUFLMUIsUUFBUTFILFVBQVUsTUFBTSxRQUFRb0osT0FBTyxLQUFLLElBQUlBLEtBQUtqRyxZQUFZK3NFLE1BQU07UUFDbEcsSUFBSSxDQUFDdHZCLGFBQWEsR0FBRztZQUNuQjVnRCxZQUFZMEgsUUFBUTFILFVBQVU7WUFDOUJ1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDb3VCLE1BQU0sR0FBRyxJQUFJOVcsYUFBYXI1RCxXQUFXLElBQUksQ0FBQytnRCxhQUFhO1FBQzVELElBQUksQ0FBQ292QixNQUFNLENBQUN4VCxhQUFhLEdBQUcsSUFBSSxDQUFDOTBELE9BQU8sQ0FBQ3lvRSxnQkFBZ0I7UUFDekQsSUFBSSxDQUFDOUcsZUFBZSxHQUFHLElBQUksQ0FBQzNoRSxPQUFPLENBQUMyaEUsZUFBZTtRQUNuRCxJQUFJLENBQUMrRyxzQkFBc0I7UUFDM0IsSUFBSSxDQUFDMVYsV0FBVyxHQUFHLElBQUl6TDtRQUN2QixJQUFJLENBQUMyZSxlQUFlLEdBQUcsSUFBSTNlO1FBQzNCLElBQUksQ0FBQ3lnQixjQUFjLEdBQUcsSUFBSXIrQyxJQUFJO1lBQUM7Z0JBQUNqTixnQkFBZ0JvcUQsS0FBSztnQkFBRTthQUFLO1lBQUU7Z0JBQUNwcUQsZ0JBQWdCQyxRQUFRO2dCQUFFO2FBQUs7U0FBQztRQUMvRixJQUFJLENBQUMyckQsTUFBTSxDQUFDblIsbUJBQW1CLEdBQUdoZ0IsQ0FBQUEsVUFBVyxJQUFJLENBQUMxeEIsSUFBSSxDQUFDcXFCLFlBQVlnRixpQkFBaUIsRUFBRXFDO1FBQ3RGLElBQUksQ0FBQ214QixNQUFNLENBQUNoUixtQkFBbUIsR0FBR3FSLENBQUFBLFNBQVUsSUFBSSxDQUFDbGpELElBQUksQ0FBQ3FxQixZQUFZb0YsdUJBQXVCLEVBQUV5ekI7UUFDM0YsSUFBSSxDQUFDTCxNQUFNLENBQUNqUixZQUFZLEdBQUdzUixDQUFBQSxTQUFVLElBQUksQ0FBQ2xqRCxJQUFJLENBQUNxcUIsWUFBWW1GLFVBQVUsRUFBRTB6QjtRQUN2RSxJQUFJLENBQUNMLE1BQU0sQ0FBQzdRLG1CQUFtQixHQUFHckQsQ0FBQUEsT0FBUSxJQUFJLENBQUMzdUMsSUFBSSxDQUFDcXFCLFlBQVlyM0IsaUJBQWlCLEVBQUUyN0M7UUFDbkYsSUFBSSxDQUFDa1UsTUFBTSxDQUFDOVEsOEJBQThCLEdBQUdtUixDQUFBQSxTQUFVLElBQUksQ0FBQ2xqRCxJQUFJLENBQUNxcUIsWUFBWXVGLDRCQUE0QixFQUFFc3pCO1FBQzNHLElBQUksQ0FBQ0wsTUFBTSxDQUFDbFIsaUJBQWlCLEdBQUd1UixDQUFBQSxTQUFVLElBQUksQ0FBQ2xqRCxJQUFJLENBQUNxcUIsWUFBWWtGLGVBQWUsRUFBRTJ6QjtRQUNqRixJQUFJLENBQUNMLE1BQU0sQ0FBQy9RLG1CQUFtQixHQUFHb1IsQ0FBQUEsU0FBVSxJQUFJLENBQUNsakQsSUFBSSxDQUFDcXFCLFlBQVk4NEIsa0JBQWtCLEVBQUVEO0lBQ3hGO0lBQ0EsY0FBYyxHQUNkLElBQUl6dUIsYUFBYTtRQUNmLElBQUl4NEMsSUFBSThVLElBQUlDLElBQUlDLElBQUlteUQsSUFBSUM7UUFDeEIsT0FBTztZQUNMNWIsTUFBTSxDQUFDMTJDLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDcW5FLGtCQUFrQixNQUFNLFFBQVFybkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd3JELElBQUksTUFBTSxRQUFRMTJDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFkLElBQUk7WUFDcklrd0UsU0FBUyxDQUFDdHlELEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNzeUQsa0JBQWtCLE1BQU0sUUFBUXR5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd5MkMsSUFBSSxNQUFNLFFBQVF4MkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa0MsR0FBRztZQUN2STJCLFVBQVUsQ0FBQ3V1RCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDRSxrQkFBa0IsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4YixXQUFXLE1BQU0sUUFBUXliLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3Z1RCxRQUFRO1FBQ3RKO0lBQ0Y7SUFDQWhTLEtBQUt3ekIsR0FBRyxFQUFFbTNCLEtBQUssRUFBRXprQixJQUFJLEVBQUUwa0IsV0FBVyxFQUFFO1FBQ2xDLE9BQU83d0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUN5WixHQUFHLEdBQUdBO1lBQ1gsSUFBSSxDQUFDbTNCLEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUMrVixVQUFVLEdBQUd4NkI7WUFDbEIsSUFBSSxDQUFDbTNCLGVBQWUsR0FBR24zQixLQUFLc3pCLFVBQVU7WUFDdEMsSUFBSTtnQkFDRixJQUFJLENBQUM0RCxZQUFZLElBQUk7Z0JBQ3JCLElBQUksQ0FBQ3VELDBCQUEwQjtnQkFDL0IsTUFBTUMsZUFBZSxNQUFNLElBQUksQ0FBQ2IsTUFBTSxDQUFDLy9ELElBQUksQ0FBQ3d6QixLQUFLbTNCLE9BQU96a0IsTUFBTTBrQjtnQkFDOUQsSUFBSSxDQUFDZ1MsU0FBUyxHQUFHO2dCQUNqQixJQUFJLENBQUM0RCxrQkFBa0IsR0FBR0k7Z0JBQzFCLElBQUksQ0FBQ256QixpQkFBaUIsR0FBR216QixhQUFhbnpCLGlCQUFpQjtnQkFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQ296QixTQUFTLEVBQUU7b0JBQ25CLE1BQU0sSUFBSSxDQUFDQyxTQUFTLENBQUNGO2dCQUN2QjtnQkFDQSxlQUFlO2dCQUNmLElBQUksQ0FBQyxJQUFJLENBQUNuekIsaUJBQWlCLEVBQUU7b0JBQzNCLElBQUksQ0FBQ3ltQixTQUFTO2dCQUNoQjtnQkFDQSxJQUFJLENBQUM2TSxtQkFBbUIsR0FBR0gsYUFBYUcsbUJBQW1CO2dCQUMzRCxPQUFPSDtZQUNULEVBQUUsT0FBT2gwRSxHQUFHO2dCQUNWLElBQUlBLGFBQWEwNUMsaUJBQWlCO29CQUNoQyxJQUFJMTVDLEVBQUUyNUMsTUFBTSxLQUFLLEVBQUUsMkNBQTJDLEtBQUk7d0JBQ2hFLElBQUksQ0FBQy8zQyxHQUFHLENBQUMydEIsSUFBSSxDQUFDLHVDQUF1QzNqQixNQUFNLENBQUMsSUFBSSxDQUFDNGtFLFlBQVksRUFBRSxRQUFRNWtFLE1BQU0sQ0FBQyxJQUFJLENBQUM2a0UsZUFBZSxHQUFHLElBQUksQ0FBQzFyQixVQUFVO3dCQUNwSSxJQUFJLElBQUksQ0FBQ3lyQixZQUFZLEdBQUcsSUFBSSxDQUFDQyxlQUFlLEVBQUU7NEJBQzVDLE9BQU8sSUFBSSxDQUFDcjlELElBQUksQ0FBQ3d6QixLQUFLbTNCLE9BQU96a0IsTUFBTTBrQjt3QkFDckM7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsTUFBTWgrRDtZQUNSO1FBQ0Y7SUFDRjtJQUNBMHFELFFBQVE7UUFDTixPQUFPdjlCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTTJwQyxTQUFTLE1BQU0sSUFBSSxDQUFDK0csV0FBVyxDQUFDckwsSUFBSTtZQUMxQyxJQUFJLElBQUksQ0FBQ3VkLFFBQVEsRUFBRTtnQkFDakJqWjtnQkFDQTtZQUNGO1lBQ0EsSUFBSTtnQkFDRixJQUFJLENBQUNrWixTQUFTLEdBQUc7Z0JBQ2pCLElBQUksQ0FBQzEvQyxJQUFJLENBQUNxcUIsWUFBWXk1QixPQUFPO2dCQUM3QixJQUFJLENBQUNoaUQsa0JBQWtCO2dCQUN2QixJQUFJLENBQUNpaUQsd0JBQXdCO2dCQUM3QixJQUFJLENBQUNDLHFCQUFxQjtnQkFDMUIsTUFBTSxJQUFJLENBQUNDLHNCQUFzQjtnQkFDakMsTUFBTSxJQUFJLENBQUNDLGFBQWE7WUFDMUIsU0FBVTtnQkFDUjFkO1lBQ0Y7UUFDRjtJQUNGO0lBQ0F5ZCx5QkFBeUI7UUFDdkIsSUFBSWhvRTtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNLENBQUM1Z0IsS0FBSyxJQUFJLENBQUMwbkUsU0FBUyxNQUFNLFFBQVExbkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbStDLEtBQUs7WUFDekUsSUFBSSxDQUFDdXBCLFNBQVMsR0FBR2p4RTtZQUNqQixNQUFNeXhFLFlBQVlyaEMsQ0FBQUE7Z0JBQ2hCLElBQUksQ0FBQ0EsSUFBSTtnQkFDVEEsR0FBR3NYLEtBQUs7Z0JBQ1J0WCxHQUFHc2hDLG1CQUFtQixHQUFHO2dCQUN6QnRoQyxHQUFHeXNCLE9BQU8sR0FBRztnQkFDYnpzQixHQUFHdWhDLFNBQVMsR0FBRztnQkFDZnZoQyxHQUFHc2xCLE9BQU8sR0FBRztnQkFDYnRsQixHQUFHcWxCLFNBQVMsR0FBRztnQkFDZnJsQixHQUFHMnJCLE1BQU0sR0FBRztZQUNkO1lBQ0EwVixVQUFVLElBQUksQ0FBQ0csT0FBTztZQUN0QkgsVUFBVSxJQUFJLENBQUM1RCxVQUFVO1lBQ3pCNEQsVUFBVSxJQUFJLENBQUNJLFVBQVU7WUFDekJKLFVBQVUsSUFBSSxDQUFDN0QsYUFBYTtZQUM1QixJQUFJLENBQUNnRSxPQUFPLEdBQUc1eEU7WUFDZixJQUFJLENBQUM2dEUsVUFBVSxHQUFHN3RFO1lBQ2xCLElBQUksQ0FBQzZ4RSxVQUFVLEdBQUc3eEU7WUFDbEIsSUFBSSxDQUFDNHRFLGFBQWEsR0FBRzV0RTtRQUN2QjtJQUNGO0lBQ0F3eEUsZ0JBQWdCO1FBQ2QsT0FBT3JuRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0sSUFBSSxDQUFDZ21ELE1BQU0sQ0FBQ3pvQixLQUFLO1lBQ3ZCLElBQUksQ0FBQ3lvQixNQUFNLENBQUNyVyxjQUFjO1FBQzVCO0lBQ0Y7SUFDQWxnQyxTQUFTcy9CLEdBQUcsRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDa1UscUJBQXFCLENBQUNsVSxJQUFJaDJDLEdBQUcsQ0FBQyxFQUFFO1lBQ3ZDLE1BQU0sSUFBSTR6QixrQkFBa0I7UUFDOUI7UUFDQSxPQUFPLElBQUlwc0IsUUFBUSxDQUFDRCxTQUFTRTtZQUMzQixNQUFNbW5ELHFCQUFxQjM1QixXQUFXO2dCQUNwQyxPQUFPLElBQUksQ0FBQ2kxQixxQkFBcUIsQ0FBQ2xVLElBQUloMkMsR0FBRyxDQUFDO2dCQUMxQ3lILE9BQU8sSUFBSStyQixnQkFBZ0I7WUFDN0IsR0FBRztZQUNILElBQUksQ0FBQzAyQixxQkFBcUIsQ0FBQ2xVLElBQUloMkMsR0FBRyxDQUFDLEdBQUc7Z0JBQ3BDdUgsU0FBU2puQixDQUFBQTtvQkFDUDAwQyxhQUFhNDVCO29CQUNicm5ELFFBQVFqbkI7Z0JBQ1Y7Z0JBQ0FtbkIsUUFBUTtvQkFDTnV0QixhQUFhNDVCO29CQUNibm5ELE9BQU8sSUFBSTdsQixNQUFNO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSSxDQUFDcXJFLE1BQU0sQ0FBQ3ZTLFlBQVksQ0FBQzFFO1FBQzNCO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUNEbi9CLFlBQVlGLE1BQU0sRUFBRTtRQUNsQixJQUFJQSxPQUFPdkcsS0FBSyxJQUFJLElBQUksQ0FBQzg1QyxxQkFBcUIsQ0FBQ3Z6QyxPQUFPdkcsS0FBSyxDQUFDSCxFQUFFLENBQUMsRUFBRTtZQUMvRCxNQUFNLEVBQ0p4SSxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUN5aUQscUJBQXFCLENBQUN2ekMsT0FBT3ZHLEtBQUssQ0FBQ0gsRUFBRSxDQUFDO1lBQy9DLElBQUl4SSxRQUFRO2dCQUNWQTtZQUNGO1lBQ0EsT0FBTyxJQUFJLENBQUN5aUQscUJBQXFCLENBQUN2ekMsT0FBT3ZHLEtBQUssQ0FBQ0gsRUFBRSxDQUFDO1FBQ3BEO1FBQ0EsSUFBSTtZQUNGLElBQUksQ0FBQzg5QyxTQUFTLENBQUNsM0MsV0FBVyxDQUFDRjtZQUMzQixPQUFPO1FBQ1QsRUFBRSxPQUFPNzhCLEdBQUc7WUFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLDBCQUEwQnB2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDeEZ0MkIsT0FBT3p1QjtZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQSswRSxpQkFBaUIzekIsUUFBUSxFQUFFOTZCLEtBQUssRUFBRTtRQUNoQyxJQUFJLENBQUM2c0QsTUFBTSxDQUFDeFMsYUFBYSxDQUFDdmYsVUFBVTk2QjtJQUN0QztJQUNBLElBQUkwdUQsMkJBQTJCO1FBQzdCLElBQUl6b0U7UUFDSixPQUFPLENBQUNBLEtBQUssSUFBSSxDQUFDcWtFLGFBQWEsTUFBTSxRQUFRcmtFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2duQyxVQUFVO0lBQ3JGO0lBQ0EwaEMsNEJBQTRCO1FBQzFCLElBQUkxb0U7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsT0FBTyxDQUFDNWdCLEtBQUssSUFBSSxDQUFDMG5FLFNBQVMsTUFBTSxRQUFRMW5FLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2krRCxtQkFBbUI7UUFDMUY7SUFDRjtJQUNBLGFBQWEsR0FDYjBLLHFCQUFxQkMsUUFBUSxFQUFFO1FBQzdCLElBQUksQ0FBQzlDLGlCQUFpQixHQUFHOEM7SUFDM0I7SUFDQWpCLFVBQVVGLFlBQVksRUFBRTtRQUN0QixJQUFJem5FO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLHFCQUFxQjtZQUNyQixJQUFJLElBQUksQ0FBQzhtRCxTQUFTLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUMzWCxZQUFZLEtBQUt3USxpQkFBaUJhLEdBQUcsRUFBRTtnQkFDMUU7WUFDRjtZQUNBLElBQUksQ0FBQzdsRCxjQUFjLEdBQUcsQ0FBQ3ZiLEtBQUt5bkUsYUFBYTliLFdBQVcsTUFBTSxRQUFRM3JELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tYLEdBQUc7WUFDakcsTUFBTXVtRCxZQUFZLElBQUksQ0FBQ29MLG9CQUFvQixDQUFDcEI7WUFDNUMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSWxILG1CQUFtQi9DLFdBQVdnSyxhQUFhbnpCLGlCQUFpQixFQUFFLElBQUksQ0FBQ2tELGFBQWE7WUFDckcsSUFBSSxDQUFDenpCLElBQUksQ0FBQ3FxQixZQUFZMDZCLGlCQUFpQixFQUFFLElBQUksQ0FBQ3BCLFNBQVMsQ0FBQ3BHLFNBQVMsRUFBRSxJQUFJLENBQUNvRyxTQUFTLENBQUNuRyxVQUFVO1lBQzVGLElBQUksQ0FBQ21HLFNBQVMsQ0FBQ2pNLGNBQWMsR0FBRyxDQUFDaGlDLFdBQVdsdEI7Z0JBQzFDLElBQUksQ0FBQ3E2RCxNQUFNLENBQUN6UyxnQkFBZ0IsQ0FBQzE2QixXQUFXbHRCO1lBQzFDO1lBQ0EsSUFBSSxDQUFDbTdELFNBQVMsQ0FBQzlGLGdCQUFnQixHQUFHaE8sQ0FBQUE7Z0JBQ2hDLElBQUksQ0FBQ2dULE1BQU0sQ0FBQ2pULFNBQVMsQ0FBQ0M7WUFDeEI7WUFDQSxJQUFJLENBQUM4VCxTQUFTLENBQUMzTCxhQUFhLEdBQUcsSUFBSSxDQUFDcUksaUJBQWlCO1lBQ3JELElBQUksQ0FBQ3NELFNBQVMsQ0FBQ3JHLGFBQWEsR0FBRyxDQUFDeDVCLGlCQUFpQmtoQyxnQkFBZ0JDLGtCQUFvQnBvRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO29CQUNuSCxJQUFJLENBQUN2ckIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDRCQUE0QnFJLE1BQU0sQ0FBQ3dvQyxrQkFBa0IsSUFBSSxDQUFDMlEsVUFBVTtvQkFDbkYsSUFBSTNRLG9CQUFvQjA0QixpQkFBaUI5TixTQUFTLEVBQUU7d0JBQ2xELE1BQU13VyxhQUFhLElBQUksQ0FBQ3RGLE9BQU8sS0FBS0wsUUFBUU0sR0FBRzt3QkFDL0MsSUFBSSxDQUFDRCxPQUFPLEdBQUdMLFFBQVFuVyxTQUFTO3dCQUNoQyxJQUFJOGIsWUFBWTs0QkFDZCxJQUFJLENBQUNsbEQsSUFBSSxDQUFDcXFCLFlBQVkrZSxTQUFTLEVBQUVzYTt3QkFDbkM7b0JBQ0YsT0FBTyxJQUFJNS9CLG9CQUFvQjA0QixpQkFBaUJXLE1BQU0sRUFBRTt3QkFDdEQsK0VBQStFO3dCQUMvRSxJQUFJLElBQUksQ0FBQ3lDLE9BQU8sS0FBS0wsUUFBUW5XLFNBQVMsRUFBRTs0QkFDdEMsSUFBSSxDQUFDd1csT0FBTyxHQUFHTCxRQUFRbUMsWUFBWTs0QkFDbkMsSUFBSSxDQUFDSCxnQkFBZ0IsQ0FBQyx5QkFBeUIwRCxvQkFBb0IsV0FBV2x5RCxnQkFBZ0JveUQsb0JBQW9CLEdBQUdweUQsZ0JBQWdCcXlELG1CQUFtQjt3QkFDMUo7b0JBQ0Y7Z0JBQ0Y7WUFDQSxJQUFJLENBQUN6QixTQUFTLENBQUMxTCxPQUFPLEdBQUc3USxDQUFBQTtnQkFDdkIsSUFBSSxDQUFDcG5DLElBQUksQ0FBQ3FxQixZQUFZZzdCLGVBQWUsRUFBRWplLEdBQUdwaEMsS0FBSyxFQUFFb2hDLEdBQUcxN0IsT0FBTyxDQUFDLEVBQUUsRUFBRTA3QixHQUFHM29DLFFBQVE7WUFDN0U7WUFDQSxJQUFJLENBQUM2bUQsa0JBQWtCO1FBQ3pCO0lBQ0Y7SUFDQTdCLDZCQUE2QjtRQUMzQiw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDWixNQUFNLENBQUNwVyxRQUFRLEdBQUcrRSxDQUFBQSxLQUFNMzBDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQzNELElBQUksQ0FBQyxJQUFJLENBQUM4bUQsU0FBUyxFQUFFO29CQUNuQjtnQkFDRjtnQkFDQSxJQUFJLENBQUNyeUUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDBCQUEwQnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUN6RjRwQixZQUFZN00sR0FBR2gzRCxJQUFJO2dCQUNyQjtnQkFDQSxNQUFNLElBQUksQ0FBQ21wRSxTQUFTLENBQUN6RixrQkFBa0IsQ0FBQzFNO1lBQzFDO1FBQ0EsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ3FSLE1BQU0sQ0FBQzNWLFNBQVMsR0FBRyxDQUFDeDNCLFdBQVdsdEI7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQ203RCxTQUFTLEVBQUU7Z0JBQ25CO1lBQ0Y7WUFDQSxJQUFJLENBQUNyeUUsR0FBRyxDQUFDa0IsS0FBSyxDQUFDLCtCQUErQjNDLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUM5Ri9lO2dCQUNBbHRCO1lBQ0Y7WUFDQSxJQUFJLENBQUNtN0QsU0FBUyxDQUFDdHVDLGVBQWUsQ0FBQ0ssV0FBV2x0QjtRQUM1QztRQUNBLDhDQUE4QztRQUM5QyxJQUFJLENBQUNxNkQsTUFBTSxDQUFDL1YsT0FBTyxHQUFHMEUsQ0FBQUEsS0FBTTMwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUMxRCxJQUFJLENBQUMsSUFBSSxDQUFDOG1ELFNBQVMsRUFBRTtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EsTUFBTXpULFNBQVMsTUFBTSxJQUFJLENBQUN5VCxTQUFTLENBQUN2RiwrQkFBK0IsQ0FBQzVNO2dCQUNwRSxJQUFJLENBQUNxUixNQUFNLENBQUM1UyxVQUFVLENBQUNDO1lBQ3pCO1FBQ0EsSUFBSSxDQUFDMlMsTUFBTSxDQUFDbFcscUJBQXFCLEdBQUdnQixDQUFBQTtZQUNsQyxJQUFJMXhEO1lBQ0osSUFBSSxDQUFDM0ssR0FBRyxDQUFDMkIsS0FBSyxDQUFDLG1DQUFtQ3BELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUNsRzcrQixLQUFLKzNDLElBQUkvM0MsR0FBRztnQkFDWm9RLE9BQU8sQ0FBQy9wQixLQUFLMHhELElBQUkzbkMsS0FBSyxNQUFNLFFBQVEvcEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa1gsR0FBRztZQUNyRTtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUMyc0QscUJBQXFCLENBQUNuUyxJQUFJLzNDLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QyxJQUFJLENBQUN0a0IsR0FBRyxDQUFDNnNCLEtBQUssQ0FBQyw4QkFBOEI3aUIsTUFBTSxDQUFDcXlELElBQUkvM0MsR0FBRyxHQUFHL2xCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUM5RzcrQixLQUFLKzNDLElBQUkvM0MsR0FBRztnQkFDZDtnQkFDQTtZQUNGO1lBQ0EsTUFBTSxFQUNKdUgsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDMmlELHFCQUFxQixDQUFDblMsSUFBSS8zQyxHQUFHLENBQUM7WUFDdkMsT0FBTyxJQUFJLENBQUNrcUQscUJBQXFCLENBQUNuUyxJQUFJLzNDLEdBQUcsQ0FBQztZQUMxQ3VILFFBQVF3d0MsSUFBSTNuQyxLQUFLO1FBQ25CO1FBQ0EsSUFBSSxDQUFDNjhDLE1BQU0sQ0FBQ2pXLHVCQUF1QixHQUFHbC9CLENBQUFBO1lBQ3BDLElBQUksQ0FBQzFOLElBQUksQ0FBQ3FxQixZQUFZazdCLHFCQUFxQixFQUFFNzNDO1FBQy9DO1FBQ0EsSUFBSSxDQUFDbTFDLE1BQU0sQ0FBQzVWLGNBQWMsR0FBR1EsQ0FBQUE7WUFDM0IsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2Y7UUFDQSxJQUFJLENBQUNvVixNQUFNLENBQUM5VixtQkFBbUIsR0FBRyxDQUFDamMsVUFBVTk2QjtZQUMzQyxJQUFJLENBQUNnSyxJQUFJLENBQUNxcUIsWUFBWW03QixVQUFVLEVBQUUxMEIsVUFBVTk2QjtRQUM5QztRQUNBLElBQUksQ0FBQzZzRCxNQUFNLENBQUM3Vix5QkFBeUIsR0FBR2tXLENBQUFBO1lBQ3RDLElBQUksQ0FBQ2xqRCxJQUFJLENBQUNxcUIsWUFBWXNGLHVCQUF1QixFQUFFdXpCO1FBQ2pEO1FBQ0EsSUFBSSxDQUFDTCxNQUFNLENBQUMxVixPQUFPLEdBQUc7WUFDcEIsSUFBSSxDQUFDb1UsZ0JBQWdCLENBQUMsVUFBVXh1RCxnQkFBZ0IrdkQsc0JBQXNCO1FBQ3hFO1FBQ0EsSUFBSSxDQUFDRCxNQUFNLENBQUNuVyxPQUFPLEdBQUcrWSxDQUFBQTtZQUNwQixJQUFJQSxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTXIwQixZQUFZLEVBQUU7Z0JBQ3BFLElBQUksQ0FBQ3V1QixtQkFBbUIsR0FBRztnQkFDM0IsNERBQTREO2dCQUM1RCxJQUFJLENBQUM0QixnQkFBZ0IsQ0FBQ2pDO1lBQ3hCLE9BQU87Z0JBQ0wsSUFBSSxDQUFDdC9DLElBQUksQ0FBQ3FxQixZQUFZcTNCLFlBQVksRUFBRStELFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNcDhCLE1BQU07Z0JBQzlGLElBQUksQ0FBQytRLEtBQUs7WUFDWjtZQUNBLElBQUksQ0FBQzlvRCxHQUFHLENBQUMyQixLQUFLLENBQUMsd0JBQXdCcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7Z0JBQ3ZGcEwsUUFBUW84QixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTXA4QixNQUFNO1lBQ3BFO1FBQ0Y7SUFDRjtJQUNBeTdCLHFCQUFxQlksY0FBYyxFQUFFO1FBQ25DLElBQUl6cEU7UUFDSixNQUFNeTlELFlBQVk3cEUsT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNi9ELFNBQVM7UUFDbEQsSUFBSSxDQUFDejlELEtBQUssSUFBSSxDQUFDdW5FLFVBQVUsTUFBTSxRQUFRdm5FLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBwRSxXQUFXLEVBQUU7WUFDOUUsSUFBSSxDQUFDcjBFLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyx3REFBd0QsSUFBSSxDQUFDd2hELFVBQVU7WUFDdEYsd0VBQXdFO1lBQ3hFLGFBQWE7WUFDYmlsQixVQUFVa00sd0JBQXdCLEdBQUc7UUFDdkM7UUFDQSxvREFBb0Q7UUFDcEQsSUFBSUYsZUFBZXh2QyxVQUFVLElBQUksQ0FBQ3dqQyxVQUFVeGpDLFVBQVUsRUFBRTtZQUN0RCxNQUFNMnZDLGdCQUFnQixFQUFFO1lBQ3hCSCxlQUFleHZDLFVBQVUsQ0FBQ3ptQyxPQUFPLENBQUNxMkUsQ0FBQUE7Z0JBQ2hDLE1BQU1DLGVBQWU7b0JBQ25CMXZDLE1BQU15dkMsVUFBVXp2QyxJQUFJO2dCQUN0QjtnQkFDQSxJQUFJeXZDLFVBQVU3a0MsUUFBUSxFQUFFOGtDLGFBQWE5a0MsUUFBUSxHQUFHNmtDLFVBQVU3a0MsUUFBUTtnQkFDbEUsSUFBSTZrQyxVQUFVeDBCLFVBQVUsRUFBRTtvQkFDeEJ5MEIsYUFBYXowQixVQUFVLEdBQUd3MEIsVUFBVXgwQixVQUFVO2dCQUNoRDtnQkFDQXUwQixjQUFjcHNFLElBQUksQ0FBQ3NzRTtZQUNyQjtZQUNBck0sVUFBVXhqQyxVQUFVLEdBQUcydkM7UUFDekI7UUFDQSxJQUFJSCxlQUFlN0IsbUJBQW1CLElBQUk2QixlQUFlN0IsbUJBQW1CLENBQUMxcUQsVUFBVSxLQUFLdEcsb0JBQW9CbXpELE9BQU8sRUFBRTtZQUN2SHRNLFVBQVV1TSxrQkFBa0IsR0FBRztRQUNqQztRQUNBLGFBQWE7UUFDYnZNLFVBQVV4b0MsWUFBWSxHQUFHO1FBQ3pCLGFBQWE7UUFDYndvQyxVQUFVd00sd0JBQXdCLEdBQUc7UUFDckMsT0FBT3hNO0lBQ1Q7SUFDQTRMLHFCQUFxQjtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDM0IsU0FBUyxFQUFFO1lBQ25CO1FBQ0Y7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSSxJQUFJLENBQUNXLE9BQU8sRUFBRTtZQUNoQixJQUFJLENBQUNBLE9BQU8sQ0FBQ25jLFNBQVMsR0FBRztZQUN6QixJQUFJLENBQUNtYyxPQUFPLENBQUNsYyxPQUFPLEdBQUc7UUFDekI7UUFDQSxJQUFJLElBQUksQ0FBQ21jLFVBQVUsRUFBRTtZQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQ3BjLFNBQVMsR0FBRztZQUM1QixJQUFJLENBQUNvYyxVQUFVLENBQUNuYyxPQUFPLEdBQUc7UUFDNUI7UUFDQSx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDa2MsT0FBTyxHQUFHLElBQUksQ0FBQ1gsU0FBUyxDQUFDNUUsMEJBQTBCLENBQUNJLGtCQUFrQjtZQUN6RSxzQ0FBc0M7WUFDdENnSCxTQUFTO1lBQ1RqRixnQkFBZ0I7UUFDbEI7UUFDQSxJQUFJLENBQUNxRCxVQUFVLEdBQUcsSUFBSSxDQUFDWixTQUFTLENBQUM1RSwwQkFBMEIsQ0FBQ0sscUJBQXFCO1lBQy9FK0csU0FBUztRQUNYO1FBQ0EseUVBQXlFO1FBQ3pFLElBQUksQ0FBQzdCLE9BQU8sQ0FBQ25jLFNBQVMsR0FBRyxJQUFJLENBQUNxWSxpQkFBaUI7UUFDL0MsSUFBSSxDQUFDK0QsVUFBVSxDQUFDcGMsU0FBUyxHQUFHLElBQUksQ0FBQ3FZLGlCQUFpQjtRQUNsRCw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDOEQsT0FBTyxDQUFDbGMsT0FBTyxHQUFHLElBQUksQ0FBQzJZLGVBQWU7UUFDM0MsSUFBSSxDQUFDd0QsVUFBVSxDQUFDbmMsT0FBTyxHQUFHLElBQUksQ0FBQzJZLGVBQWU7UUFDOUMsbUVBQW1FO1FBQ25FLElBQUksQ0FBQ3VELE9BQU8sQ0FBQzNCLDBCQUEwQixHQUFHO1FBQzFDLElBQUksQ0FBQzRCLFVBQVUsQ0FBQzVCLDBCQUEwQixHQUFHO1FBQzdDLGtDQUFrQztRQUNsQyxJQUFJLENBQUMyQixPQUFPLENBQUNGLG1CQUFtQixHQUFHLElBQUksQ0FBQ2hELHVCQUF1QjtRQUMvRCxJQUFJLENBQUNtRCxVQUFVLENBQUNILG1CQUFtQixHQUFHLElBQUksQ0FBQ2hELHVCQUF1QjtJQUNwRTtJQUNBZ0Ysa0JBQWtCMzZDLFdBQVcsRUFBRTdpQixJQUFJLEVBQUU4eUQsVUFBVSxFQUFFO1FBQy9DLElBQUksQ0FBRSxzQkFBcUIxdUMsWUFBVyxHQUFJO1lBQ3hDO1FBQ0Y7UUFDQSxNQUFNcTVDLE1BQU1yNUMsYUFBYXF2QixlQUFlLENBQUN6ekM7UUFDekMsSUFBSSxDQUFDeTlELEtBQUs7UUFDVixJQUFJLENBQUMvMEUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDJCQUEyQnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO1lBQzFGNHhCO1FBQ0Y7UUFDQSxNQUFNQyxVQUFVLEVBQUU7UUFDbEIsTUFBTUMsaUJBQWlCLEVBQUU7UUFDekIsTUFBTUMsWUFBWSxFQUFFO1FBQ3BCSCxJQUFJL3ZELE1BQU0sQ0FBQzdtQixPQUFPLENBQUN5WSxDQUFBQTtZQUNqQixNQUFNcXhCLFFBQVFyeEIsRUFBRXlOLFFBQVEsQ0FBQ3BPLFdBQVc7WUFDcEMsSUFBSWd5QixVQUFVLGNBQWM7Z0JBQzFCK3NDLFFBQVE3c0UsSUFBSSxDQUFDeU87Z0JBQ2I7WUFDRjtZQUNBLE1BQU11K0Qsb0JBQW9CbHRDLFVBQVUsU0FBU2orQixNQUFNLENBQUNvZ0U7WUFDcEQsSUFBSSxDQUFDK0ssbUJBQW1CO2dCQUN0QkQsVUFBVS9zRSxJQUFJLENBQUN5TztnQkFDZjtZQUNGO1lBQ0EsbUVBQW1FO1lBQ25FLDZEQUE2RDtZQUM3RCxJQUFJd3pELGVBQWUsUUFBUTtnQkFDekIsSUFBSXh6RCxFQUFFdytELFdBQVcsSUFBSXgrRCxFQUFFdytELFdBQVcsQ0FBQ3ArQyxRQUFRLENBQUMsNEJBQTRCO29CQUN0RWcrQyxRQUFRN3NFLElBQUksQ0FBQ3lPO2dCQUNmLE9BQU87b0JBQ0xxK0QsZUFBZTlzRSxJQUFJLENBQUN5TztnQkFDdEI7Z0JBQ0E7WUFDRjtZQUNBbytELFFBQVE3c0UsSUFBSSxDQUFDeU87UUFDZjtRQUNBLElBQUk4MEMsNEJBQTRCdnhCLGNBQWM7WUFDNUNBLFlBQVlrN0MsbUJBQW1CLENBQUNMLFFBQVFockUsTUFBTSxDQUFDaXJFLGdCQUFnQkM7UUFDakU7SUFDRjtJQUNBSSxhQUFhNWdELEtBQUssRUFBRWdqQixJQUFJLEVBQUVuVixTQUFTLEVBQUU7UUFDbkMsT0FBT2hYLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSWcvQix1QkFBdUI7Z0JBQ3pCLE1BQU10dkIsU0FBUyxNQUFNLElBQUksQ0FBQ3M2Qyw2QkFBNkIsQ0FBQzdnRCxPQUFPZ2pCLE1BQU1uVjtnQkFDckUsT0FBT3RIO1lBQ1Q7WUFDQSxJQUFJdXZCLG9CQUFvQjtnQkFDdEIsSUFBSSxDQUFDeHFELEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsNEJBQTRCLElBQUksQ0FBQ3cxQixVQUFVO2dCQUN6RCxNQUFNbG9CLFNBQVMsTUFBTSxJQUFJLENBQUN1NkMsa0JBQWtCLENBQUM5Z0QsTUFBTTR1QixnQkFBZ0I7Z0JBQ25FLE9BQU9yb0I7WUFDVDtZQUNBLE1BQU0sSUFBSW1kLDBCQUEwQjtRQUN0QztJQUNGO0lBQ0FxOUIsc0JBQXNCL2dELEtBQUssRUFBRWdoRCxjQUFjLEVBQUVoK0IsSUFBSSxFQUFFblYsU0FBUyxFQUFFO1FBQzVELE9BQU9oWCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLHFCQUFxQjtZQUNyQixJQUFJZy9CLHVCQUF1QjtnQkFDekIsT0FBTyxJQUFJLENBQUNvckIsZ0NBQWdDLENBQUNqaEQsT0FBT2doRCxnQkFBZ0JoK0IsTUFBTW5WO1lBQzVFO1lBQ0EsSUFBSWlvQixvQkFBb0I7Z0JBQ3RCLElBQUksQ0FBQ3hxRCxHQUFHLENBQUMyQixLQUFLLENBQUMsNEJBQTRCLElBQUksQ0FBQ3doRCxVQUFVO2dCQUMxRCxPQUFPLElBQUksQ0FBQ3F5QixrQkFBa0IsQ0FBQzlnRCxNQUFNNHVCLGdCQUFnQjtZQUN2RDtZQUNBLE1BQU0sSUFBSWxMLDBCQUEwQjtRQUN0QztJQUNGO0lBQ0FtOUIsOEJBQThCN2dELEtBQUssRUFBRWdqQixJQUFJLEVBQUVuVixTQUFTLEVBQUU7UUFDcEQsT0FBT2hYLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQzhtRCxTQUFTLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSWo2QiwwQkFBMEI7WUFDdEM7WUFDQSxNQUFNaGUsVUFBVSxFQUFFO1lBQ2xCLElBQUkxRixNQUFNaXhCLFdBQVcsRUFBRTtnQkFDckJ2ckIsUUFBUWp5QixJQUFJLENBQUN1c0IsTUFBTWl4QixXQUFXO1lBQ2hDO1lBQ0EsTUFBTXNpQixrQkFBa0I7Z0JBQ3RCemlDLFdBQVc7Z0JBQ1hwTDtZQUNGO1lBQ0EsSUFBSW1JLFdBQVc7Z0JBQ2IwbEMsZ0JBQWdCcG1DLGFBQWEsR0FBR1U7WUFDbEM7WUFDQSwyRkFBMkY7WUFDM0YsTUFBTXBJLGNBQWMsTUFBTSxJQUFJLENBQUNrNEMsU0FBUyxDQUFDOUUsdUJBQXVCLENBQUM3NEMsTUFBTTR1QixnQkFBZ0IsRUFBRTJrQjtZQUN6RixJQUFJdnpDLE1BQU1wZCxJQUFJLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQ0MsS0FBSyxJQUFJbE0sS0FBSzB5QixVQUFVLEVBQUU7Z0JBQ3RELElBQUksQ0FBQzBLLGlCQUFpQixDQUFDMzZDLGFBQWF6RixNQUFNcGQsSUFBSSxFQUFFb2dDLEtBQUsweUIsVUFBVTtnQkFDL0QxMUMsTUFBTXVULEtBQUssR0FBR3lQLEtBQUsweUIsVUFBVTtZQUMvQjtZQUNBLE9BQU9qd0MsWUFBWWMsTUFBTTtRQUMzQjtJQUNGO0lBQ0EwNkMsaUNBQWlDamhELEtBQUssRUFBRWdoRCxjQUFjLEVBQUVoK0IsSUFBSSxFQUFFblYsU0FBUyxFQUFFO1FBQ3ZFLE9BQU9oWCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUM4bUQsU0FBUyxFQUFFO2dCQUNuQixNQUFNLElBQUlqNkIsMEJBQTBCO1lBQ3RDO1lBQ0EsTUFBTTZ2QixrQkFBa0I7Z0JBQ3RCemlDLFdBQVc7WUFDYjtZQUNBLElBQUlqRCxXQUFXO2dCQUNiMGxDLGdCQUFnQnBtQyxhQUFhLEdBQUdVO1lBQ2xDO1lBQ0EsMkZBQTJGO1lBQzNGLE1BQU1wSSxjQUFjLE1BQU0sSUFBSSxDQUFDazRDLFNBQVMsQ0FBQzlFLHVCQUF1QixDQUFDbUksZUFBZXB5QixnQkFBZ0IsRUFBRTJrQjtZQUNsRyxJQUFJLENBQUN2d0IsS0FBSzB5QixVQUFVLEVBQUU7Z0JBQ3BCO1lBQ0Y7WUFDQSxJQUFJLENBQUMwSyxpQkFBaUIsQ0FBQzM2QyxhQUFhekYsTUFBTXBkLElBQUksRUFBRW9nQyxLQUFLMHlCLFVBQVU7WUFDL0QxMUMsTUFBTWtoRCx1QkFBdUIsQ0FBQ2wrQixLQUFLMHlCLFVBQVUsRUFBRWp3QyxZQUFZYyxNQUFNO1lBQ2pFLE9BQU9kLFlBQVljLE1BQU07UUFDM0I7SUFDRjtJQUNBdTZDLG1CQUFtQjlnRCxLQUFLLEVBQUU7UUFDeEIsT0FBT25KLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQzhtRCxTQUFTLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSWo2QiwwQkFBMEI7WUFDdEM7WUFDQSxPQUFPLElBQUksQ0FBQ2k2QixTQUFTLENBQUM3RSxpQkFBaUIsQ0FBQzk0QztRQUMxQztJQUNGO0lBQ0FrOEMsaUJBQWlCNzRCLE1BQU0sRUFBRTtRQUN2QixJQUFJcHRDLElBQUk4VSxJQUFJQztRQUNaLE9BQU82TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDNmlELFNBQVMsRUFBRTtnQkFDbEI7WUFDRjtZQUNBLDJGQUEyRjtZQUMzRixJQUFJLElBQUksQ0FBQ08sbUJBQW1CLEVBQUU7Z0JBQzVCaHFFLGNBQWNncEIsSUFBSSxDQUFDLGlEQUFpRCxJQUFJLENBQUN3MUIsVUFBVTtnQkFDbkY7WUFDRjtZQUNBLElBQUksQ0FBQyxDQUFDeDRDLEtBQUssSUFBSSxDQUFDNG5FLG1CQUFtQixNQUFNLFFBQVE1bkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZ2QsZ0JBQWdCLE1BQU1wRyxvQkFBb0JzMEQsUUFBUSxJQUcvSCwrREFGK0Q7WUFDL0Qsc0NBQXNDO1lBQ3JDLEVBQUNuMkQsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzR5RCxTQUFTLE1BQU0sUUFBUTV5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpN0MsWUFBWSxNQUFNLFFBQVFoN0MsT0FBTyxLQUFLLElBQUlBLEtBQUt3ckQsaUJBQWlCYSxHQUFHLE1BQU1iLGlCQUFpQmEsR0FBRyxFQUFFO2dCQUNsSyxJQUFJLENBQUNzQyxtQkFBbUIsR0FBRztZQUM3QjtZQUNBLElBQUk7Z0JBQ0YsSUFBSSxDQUFDTSxtQkFBbUIsR0FBRztnQkFDM0IsSUFBSSxJQUFJLENBQUNOLG1CQUFtQixFQUFFO29CQUM1QixNQUFNLElBQUksQ0FBQ3lILGlCQUFpQjtnQkFDOUIsT0FBTztvQkFDTCxNQUFNLElBQUksQ0FBQ251RCxnQkFBZ0IsQ0FBQ293QjtnQkFDOUI7Z0JBQ0EsSUFBSSxDQUFDMjZCLHFCQUFxQjtnQkFDMUIsSUFBSSxDQUFDckUsbUJBQW1CLEdBQUc7WUFDN0IsRUFBRSxPQUFPandFLEdBQUc7Z0JBQ1YsSUFBSSxDQUFDcXdFLGlCQUFpQixJQUFJO2dCQUMxQixJQUFJc0gsY0FBYztnQkFDbEIsSUFBSTMzRSxhQUFhZzZDLDJCQUEyQjtvQkFDMUMsSUFBSSxDQUFDcDRDLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxnQ0FBZ0NwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzt3QkFDL0Z0MkIsT0FBT3p1QjtvQkFDVDtvQkFDQSxnQkFBZ0I7b0JBQ2hCMjNFLGNBQWM7Z0JBQ2hCLE9BQU8sSUFBSSxDQUFFMzNFLENBQUFBLGFBQWE0M0Usb0JBQW1CLEdBQUk7b0JBQy9DLGdCQUFnQjtvQkFDaEIsSUFBSSxDQUFDM0gsbUJBQW1CLEdBQUc7Z0JBQzdCO2dCQUNBLElBQUkwSCxhQUFhO29CQUNmLElBQUksQ0FBQzlGLGdCQUFnQixDQUFDLGFBQWF4dUQsZ0JBQWdCdzBELFVBQVU7Z0JBQy9ELE9BQU87b0JBQ0wsSUFBSSxDQUFDajJFLEdBQUcsQ0FBQzRFLElBQUksQ0FBQyxzQ0FBc0NvRixNQUFNLENBQUMsSUFBSSxDQUFDeWtFLGlCQUFpQixFQUFFLGVBQWV6a0UsTUFBTSxDQUFDbVcsS0FBS1EsR0FBRyxLQUFLLElBQUksQ0FBQyt0RCxjQUFjLEVBQUUsa0JBQWtCLElBQUksQ0FBQ3ZyQixVQUFVO29CQUM1SyxJQUFJLENBQUN6MEIsSUFBSSxDQUFDcXFCLFlBQVlxM0IsWUFBWTtvQkFDbEMsTUFBTSxJQUFJLENBQUN0bkIsS0FBSztnQkFDbEI7WUFDRixTQUFVO2dCQUNSLElBQUksQ0FBQzZsQixtQkFBbUIsR0FBRztZQUM3QjtRQUNGO0lBQ0Y7SUFDQTJCLGtCQUFrQnZxRSxPQUFPLEVBQUU7UUFDekIsSUFBSTtZQUNGLE9BQU8sSUFBSSxDQUFDNmtFLGVBQWUsQ0FBQ3ovQyxrQkFBa0IsQ0FBQ3BsQjtRQUNqRCxFQUFFLE9BQU8zSCxHQUFHO1lBQ1YsSUFBSSxDQUFDNEIsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyx5Q0FBeUNwdkIsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7Z0JBQ3ZHdDJCLE9BQU96dUI7WUFDVDtRQUNGO1FBQ0EsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBMDNFLGtCQUFrQkksU0FBUyxFQUFFO1FBQzNCLElBQUl2ckUsSUFBSThVLElBQUlDO1FBQ1osT0FBTzZMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSTtnQkFDRixJQUFJLENBQUMsSUFBSSxDQUFDeVosR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDbTNCLEtBQUssRUFBRTtvQkFDNUIsZ0RBQWdEO29CQUNoRCxNQUFNLElBQUkvakIsMEJBQTBCO2dCQUN0QztnQkFDQSxJQUFJLENBQUNwNEMsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLDBCQUEwQm9GLE1BQU0sQ0FBQyxJQUFJLENBQUN5a0UsaUJBQWlCLEdBQUcsSUFBSSxDQUFDdHJCLFVBQVU7Z0JBQ3ZGLElBQUksQ0FBQ3owQixJQUFJLENBQUNxcUIsWUFBWW85QixVQUFVO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDNUUsTUFBTSxDQUFDNVcsY0FBYyxFQUFFO29CQUMvQixNQUFNLElBQUksQ0FBQzRXLE1BQU0sQ0FBQzNSLFNBQVM7Z0JBQzdCO2dCQUNBLE1BQU0sSUFBSSxDQUFDK1Msc0JBQXNCO2dCQUNqQyxNQUFNLElBQUksQ0FBQ0MsYUFBYTtnQkFDeEIsSUFBSVI7Z0JBQ0osSUFBSTtvQkFDRixJQUFJLENBQUMsSUFBSSxDQUFDRixVQUFVLEVBQUU7d0JBQ3BCLElBQUksQ0FBQ2x5RSxHQUFHLENBQUMydEIsSUFBSSxDQUFDLGdFQUFnRSxJQUFJLENBQUN3MUIsVUFBVTt3QkFDN0YsTUFBTSxJQUFJNnlCO29CQUNaO29CQUNBLGlFQUFpRTtvQkFDakU1RCxlQUFlLE1BQU0sSUFBSSxDQUFDNWdFLElBQUksQ0FBQzBrRSxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJQSxZQUFZLElBQUksQ0FBQ2x4QyxHQUFHLEVBQUUsSUFBSSxDQUFDbTNCLEtBQUssRUFBRSxJQUFJLENBQUMrVixVQUFVO2dCQUMvSCxFQUFFLE9BQU85ekUsR0FBRztvQkFDVixJQUFJQSxhQUFhMDVDLG1CQUFtQjE1QyxFQUFFMjVDLE1BQU0sS0FBSyxFQUFFLG9DQUFvQyxLQUFJO3dCQUN6RixNQUFNLElBQUlLLDBCQUEwQjtvQkFDdEM7b0JBQ0EsTUFBTSxJQUFJNDlCO2dCQUNaO2dCQUNBLElBQUksSUFBSSxDQUFDbEgsY0FBYyxFQUFFO29CQUN2QixJQUFJLENBQUNBLGNBQWMsR0FBRztvQkFDdEIsTUFBTSxJQUFJNW9FLE1BQU07Z0JBQ2xCO2dCQUNBLElBQUksQ0FBQ3FyRSxNQUFNLENBQUMxUSxjQUFjO2dCQUMxQixJQUFJLENBQUNueUMsSUFBSSxDQUFDcXFCLFlBQVlxOUIsZUFBZSxFQUFFaEU7Z0JBQ3ZDLE1BQU0sSUFBSSxDQUFDaUUsb0JBQW9CO2dCQUMvQixvRUFBb0U7Z0JBQ3BFLElBQUksSUFBSSxDQUFDOUUsTUFBTSxDQUFDN1csWUFBWSxLQUFLRixzQkFBc0I0QyxTQUFTLEVBQUU7b0JBQ2hFLE1BQU0sSUFBSTRZLHFCQUFxQjtnQkFDakM7Z0JBQ0NyckUsQ0FBQUEsS0FBSyxJQUFJLENBQUM4bEUsaUJBQWlCLE1BQU0sUUFBUTlsRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcyckUsYUFBYTtnQkFDbkYsb0JBQW9CO2dCQUNwQixJQUFJLENBQUM1bkQsSUFBSSxDQUFDcXFCLFlBQVk2YixTQUFTO1lBQ2pDLEVBQUUsT0FBTy9uQyxPQUFPO2dCQUNkLE1BQU0wcEQsZ0JBQWdCLE1BQU0sQ0FBQzkyRCxLQUFLLElBQUksQ0FBQ2d4RCxpQkFBaUIsTUFBTSxRQUFRaHhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRysyRCxvQkFBb0I7Z0JBQ3RILElBQUlELGVBQWU7b0JBQ2pCLE1BQU0sSUFBSSxDQUFDVCxpQkFBaUIsQ0FBQ1M7b0JBQzdCO2dCQUNGLE9BQU87b0JBQ0wsaURBQWlEO29CQUNoRDcyRCxDQUFBQSxLQUFLLElBQUksQ0FBQyt3RCxpQkFBaUIsTUFBTSxRQUFRL3dELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzQyRCxhQUFhO29CQUNuRixNQUFNenBEO2dCQUNSO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FsRixpQkFBaUJvd0IsTUFBTSxFQUFFO1FBQ3ZCLElBQUlwdEM7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ3laLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQ20zQixLQUFLLEVBQUU7Z0JBQzVCLGdEQUFnRDtnQkFDaEQsTUFBTSxJQUFJL2pCLDBCQUEwQjtZQUN0QztZQUNBLDhCQUE4QjtZQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDaTZCLFNBQVMsRUFBRTtnQkFDbkIsTUFBTSxJQUFJajZCLDBCQUEwQjtZQUN0QztZQUNBLElBQUksQ0FBQ3A0QyxHQUFHLENBQUM0RSxJQUFJLENBQUMsdUNBQXVDb0YsTUFBTSxDQUFDLElBQUksQ0FBQ3lrRSxpQkFBaUIsR0FBRyxJQUFJLENBQUN0ckIsVUFBVTtZQUNwRyxJQUFJLENBQUN6MEIsSUFBSSxDQUFDcXFCLFlBQVkwOUIsUUFBUTtZQUM5QixJQUFJO2dCQUNGLElBQUksQ0FBQ3RFLDBCQUEwQjtnQkFDL0IsTUFBTTlWLE1BQU0sTUFBTSxJQUFJLENBQUNrVixNQUFNLENBQUNqVixTQUFTLENBQUMsSUFBSSxDQUFDdDNCLEdBQUcsRUFBRSxJQUFJLENBQUNtM0IsS0FBSyxFQUFFLElBQUksQ0FBQ2oyQyxjQUFjLEVBQUU2eEI7Z0JBQ25GLElBQUlza0IsS0FBSztvQkFDUCxNQUFNK0wsWUFBWSxJQUFJLENBQUNvTCxvQkFBb0IsQ0FBQ25YO29CQUM1QyxJQUFJLENBQUNnVyxTQUFTLENBQUNyRixtQkFBbUIsQ0FBQzVFO2dCQUNyQztZQUNGLEVBQUUsT0FBT3Y3QyxPQUFPO2dCQUNkLElBQUk1aUIsVUFBVTtnQkFDZCxJQUFJNGlCLGlCQUFpQjNtQixPQUFPO29CQUMxQitELFVBQVU0aUIsTUFBTTVpQixPQUFPO29CQUN2QixJQUFJLENBQUNqSyxHQUFHLENBQUM2c0IsS0FBSyxDQUFDQSxNQUFNNWlCLE9BQU8sRUFBRTFMLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO3dCQUM5RXQyQjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJQSxpQkFBaUJpckIsbUJBQW1CanJCLE1BQU1rckIsTUFBTSxLQUFLLEVBQUUsb0NBQW9DLEtBQUk7b0JBQ2pHLE1BQU0sSUFBSUssMEJBQTBCO2dCQUN0QztnQkFDQSxJQUFJdnJCLGlCQUFpQmlyQixtQkFBbUJqckIsTUFBTWtyQixNQUFNLEtBQUssRUFBRSxzQ0FBc0MsS0FBSTtvQkFDbkcsTUFBTWxyQjtnQkFDUjtnQkFDQSxNQUFNLElBQUltcEQscUJBQXFCL3JFO1lBQ2pDO1lBQ0EsSUFBSSxDQUFDeWtCLElBQUksQ0FBQ3FxQixZQUFZMjlCLGFBQWE7WUFDbkMsSUFBSSxJQUFJLENBQUM1SCxjQUFjLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxHQUFHO2dCQUN0QixNQUFNLElBQUk1b0UsTUFBTTtZQUNsQjtZQUNBLE1BQU0sSUFBSSxDQUFDbXNFLFNBQVMsQ0FBQ3hGLGlCQUFpQjtZQUN0QyxNQUFNLElBQUksQ0FBQ3dKLG9CQUFvQjtZQUMvQixvRUFBb0U7WUFDcEUsSUFBSSxJQUFJLENBQUM5RSxNQUFNLENBQUM3VyxZQUFZLEtBQUtGLHNCQUFzQjRDLFNBQVMsRUFBRTtnQkFDaEUsTUFBTSxJQUFJNFkscUJBQXFCO1lBQ2pDO1lBQ0EsSUFBSSxDQUFDekUsTUFBTSxDQUFDMVEsY0FBYztZQUMxQixrREFBa0Q7WUFDbEQsOERBQThEO1lBQzlELElBQUksQ0FBQyxDQUFDbDJELEtBQUssSUFBSSxDQUFDc29FLFVBQVUsTUFBTSxRQUFRdG9FLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2duQyxVQUFVLE1BQU0sVUFBVSxJQUFJLENBQUNzaEMsVUFBVSxDQUFDMStDLEVBQUUsS0FBSyxNQUFNO2dCQUN6SCxJQUFJLENBQUN5L0Msa0JBQWtCO1lBQ3pCO1lBQ0EsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQ3RsRCxJQUFJLENBQUNxcUIsWUFBWTQ5QixPQUFPO1FBQy9CO0lBQ0Y7SUFDQUMsMkJBQTJCemlCLE9BQU8sRUFBRStZLGVBQWUsRUFBRTtRQUNuRCxPQUFPM2hELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQzhtRCxTQUFTLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSWo2QiwwQkFBMEI7WUFDdEM7WUFDQSxNQUFNLElBQUksQ0FBQ2k2QixTQUFTLENBQUNwRiwyQkFBMkIsQ0FBQ0MsaUJBQWlCL1k7UUFDcEU7SUFDRjtJQUNBa2lCLHVCQUF1QjtRQUNyQixPQUFPOXFELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDK2lELE9BQU8sR0FBR0wsUUFBUTRJLFlBQVk7WUFDbkMsSUFBSSxDQUFDNzJFLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyw0Q0FBNEMsSUFBSSxDQUFDd2hELFVBQVU7WUFDMUUsSUFBSTtnQkFDRixNQUFNdUYsTUFBTXFsQixtQkFBbUIsa0VBQWtFO2dCQUNqRyxJQUFJLENBQUMsSUFBSSxDQUFDc0UsU0FBUyxFQUFFO29CQUNuQixNQUFNLElBQUlqNkIsMEJBQTBCO2dCQUN0QztnQkFDQSxNQUFNLElBQUksQ0FBQ2k2QixTQUFTLENBQUNwRiwyQkFBMkIsQ0FBQzdyRSxXQUFXLElBQUksQ0FBQzZwRSxxQkFBcUI7Z0JBQ3RGLElBQUksQ0FBQ3FELE9BQU8sR0FBR0wsUUFBUW5XLFNBQVM7WUFDbEMsRUFBRSxPQUFPMTVELEdBQUc7Z0JBQ1Ysb0RBQW9EO2dCQUNwRCxJQUFJLENBQUNrd0UsT0FBTyxHQUFHTCxRQUFRbUMsWUFBWTtnQkFDbkMsTUFBTSxJQUFJdDRCLGdCQUFnQixzQ0FBc0M5dEMsTUFBTSxDQUFDNUwsRUFBRTZMLE9BQU87WUFDbEY7UUFDRjtJQUNGO0lBQ0EsYUFBYSxHQUNiNnNFLGVBQWVDLE1BQU0sRUFBRXovRCxJQUFJLEVBQUU7UUFDM0IsT0FBT2lVLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXpsQixNQUFNaXhFLE9BQU81c0UsUUFBUTtZQUMzQix5Q0FBeUM7WUFDekMsTUFBTSxJQUFJLENBQUM2c0Usd0JBQXdCLENBQUMxL0Q7WUFDcEMsTUFBTWs2QixLQUFLLElBQUksQ0FBQzIvQixrQkFBa0IsQ0FBQzc1RDtZQUNuQyxJQUFJazZCLElBQUk7Z0JBQ05BLEdBQUdFLElBQUksQ0FBQzVyQztZQUNWO1lBQ0EsSUFBSSxDQUFDa3FFLDJCQUEyQixDQUFDMTREO1FBQ25DO0lBQ0Y7SUFDQTs7R0FFQyxHQUNEMi9ELDZCQUE2QjMvRCxJQUFJLEVBQUU7UUFDakMsSUFBSTQwRCxhQUFhbnJFLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ2srQyxpQkFBaUI7UUFDM0csSUFBSXQwQztRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDOG1ELFNBQVMsRUFBRTtnQkFDbkIsTUFBTSxJQUFJajZCLDBCQUEwQjtZQUN0QztZQUNBLE1BQU0rMEIsWUFBWWpCLGFBQWEsSUFBSSxDQUFDbUcsU0FBUyxDQUFDbkcsVUFBVSxHQUFHLElBQUksQ0FBQ21HLFNBQVMsQ0FBQ3BHLFNBQVM7WUFDbkYsTUFBTWlMLGdCQUFnQmhMLGFBQWEsZUFBZTtZQUNsRCxJQUFJLENBQUNpQixXQUFXO2dCQUNkLE1BQU0sSUFBSXIxQixnQkFBZ0IsR0FBRzl0QyxNQUFNLENBQUNrdEUsZUFBZTtZQUNyRDtZQUNBLElBQUksQ0FBQ2hMLGNBQWMsQ0FBQyxJQUFJLENBQUNtRyxTQUFTLENBQUNwRyxTQUFTLENBQUNyRixjQUFjLElBQUksSUFBSSxDQUFDeUwsU0FBUyxDQUFDcEcsU0FBUyxDQUFDMUQscUJBQXFCLE9BQU8sWUFBWTtnQkFDOUgsb0JBQW9CO2dCQUNwQixJQUFJLENBQUM3QyxTQUFTO1lBQ2hCO1lBQ0EsTUFBTXlSLGdCQUFnQixJQUFJLENBQUNoRyxrQkFBa0IsQ0FBQzc1RCxNQUFNNDBEO1lBQ3BELElBQUksQ0FBQ2lMLGtCQUFrQixRQUFRQSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY3hsQyxVQUFVLE1BQU0sUUFBUTtnQkFDdkc7WUFDRjtZQUNBLDJCQUEyQjtZQUMzQixNQUFNeWxDLFVBQVUsSUFBSWozRCxPQUFPVyxPQUFPLEtBQUssSUFBSSxDQUFDbXFELHFCQUFxQjtZQUNqRSxNQUFPLElBQUk5cUQsT0FBT1csT0FBTyxLQUFLczJELFFBQVM7Z0JBQ3JDLElBQUlqSyxVQUFVdkcsY0FBYyxJQUFJLENBQUMsQ0FBQ2o4RCxLQUFLLElBQUksQ0FBQ3dtRSxrQkFBa0IsQ0FBQzc1RCxNQUFNNDBELFdBQVUsTUFBTyxRQUFRdmhFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2duQyxVQUFVLE1BQU0sUUFBUTtvQkFDaEo7Z0JBQ0Y7Z0JBQ0EsTUFBTStXLE1BQU07WUFDZDtZQUNBLE1BQU0sSUFBSTVRLGdCQUFnQix1QkFBdUI5dEMsTUFBTSxDQUFDa3RFLGVBQWUsd0JBQXdCbHRFLE1BQU0sQ0FBQ21qRSxVQUFVNUUscUJBQXFCO1FBQ3ZJO0lBQ0Y7SUFDQXlPLHlCQUF5QjEvRCxJQUFJLEVBQUU7UUFDN0IsT0FBT2lVLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTSxJQUFJLENBQUMwckQsNEJBQTRCLENBQUMzL0QsTUFBTTtRQUNoRDtJQUNGO0lBQ0EsYUFBYSxHQUNiKy9ELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDaEYsU0FBUyxFQUFFO1lBQ25CLE9BQU87UUFDVDtRQUNBLHFCQUFxQjtRQUNyQixJQUFJLElBQUksQ0FBQ0EsU0FBUyxDQUFDM1gsWUFBWSxLQUFLd1EsaUJBQWlCOU4sU0FBUyxFQUFFO1lBQzlELE9BQU87UUFDVDtRQUNBLDZCQUE2QjtRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDbVUsTUFBTSxDQUFDdlUsRUFBRSxJQUFJLElBQUksQ0FBQ3VVLE1BQU0sQ0FBQ3ZVLEVBQUUsQ0FBQ3JyQixVQUFVLEtBQUtzckIsVUFBVTZPLE1BQU0sRUFBRTtZQUNyRSxPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxjQUFjLEdBQ2RwRyxZQUFZO1FBQ1YsT0FBT242QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLHVCQUF1QjtZQUN2QixPQUFPLElBQUlPLFFBQVEsQ0FBQ0QsU0FBU0UsU0FBV1IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDdEUsSUFBSSxDQUFDLElBQUksQ0FBQzhtRCxTQUFTLEVBQUU7d0JBQ25CdG1ELE9BQU8sSUFBSXNzQixpQkFBaUI7d0JBQzVCO29CQUNGO29CQUNBLElBQUksQ0FBQ2c2QixTQUFTLENBQUM3RixnQkFBZ0I7b0JBQy9CLE1BQU1VLGtCQUFrQixJQUFJb0s7b0JBQzVCLE1BQU1DLGVBQWU7d0JBQ25CckssZ0JBQWdCc0ssS0FBSzt3QkFDckIsSUFBSSxDQUFDeDNFLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxxREFBcUQsSUFBSSxDQUFDd2hELFVBQVU7d0JBQ25GdDNCO3dCQUNBO29CQUNGO29CQUNBLElBQUksSUFBSSxDQUFDc2lELFFBQVEsRUFBRTt3QkFDakJwaUQsT0FBTztvQkFDVDtvQkFDQSxJQUFJLENBQUM0RCxFQUFFLENBQUNvcEIsWUFBWXk1QixPQUFPLEVBQUUrRTtvQkFDN0IsSUFBSSxDQUFDbEYsU0FBUyxDQUFDcEcsU0FBUyxDQUFDbCtDLElBQUksQ0FBQzgyQyxTQUFTRyxvQkFBb0IsRUFBRXlTLENBQUFBO3dCQUMzRCxNQUFNamdCLFNBQVMsSUFBSTVrQzt3QkFDbkI2a0QsU0FBU3Q1RSxPQUFPLENBQUNpbEUsQ0FBQUE7NEJBQ2YsTUFBTW43QixRQUFRbTdCLElBQUluN0IsS0FBSyxDQUFDaHlCLFdBQVc7NEJBQ25DLElBQUkrNkMsYUFBYS9vQixRQUFRO2dDQUN2QnV2QixPQUFPbG1ELEdBQUcsQ0FBQzh4RCxJQUFJaDlDLE9BQU8sRUFBRTZoQjs0QkFDMUI7d0JBQ0Y7d0JBQ0EsSUFBSSxDQUFDdlosSUFBSSxDQUFDcXFCLFlBQVl3ZSxpQkFBaUIsRUFBRUM7b0JBQzNDO29CQUNBLElBQUk7d0JBQ0YsTUFBTSxJQUFJLENBQUM2YSxTQUFTLENBQUMzTSxTQUFTLENBQUN3SDt3QkFDL0JyaEQ7b0JBQ0YsRUFBRSxPQUFPenRCLEdBQUc7d0JBQ1YsSUFBSUEsYUFBYWk2QyxrQkFBa0I7NEJBQ2pDLElBQUksQ0FBQ2cyQixtQkFBbUIsR0FBRzt3QkFDN0I7d0JBQ0EsSUFBSSxDQUFDNEIsZ0JBQWdCLENBQUMsZUFBZXh1RCxnQkFBZ0J3MEQsVUFBVTt3QkFDL0RscUQsT0FBTzN0QjtvQkFDVCxTQUFVO3dCQUNSLElBQUksQ0FBQ215QixHQUFHLENBQUN3b0IsWUFBWXk1QixPQUFPLEVBQUUrRTtvQkFDaEM7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0FwRyxtQkFBbUI3NUQsSUFBSSxFQUFFK25ELEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUNBLEtBQUs7WUFDUixJQUFJL25ELFNBQVNxTyxnQkFBZ0JvcUQsS0FBSyxFQUFFO2dCQUNsQyxPQUFPLElBQUksQ0FBQ2lELE9BQU87WUFDckI7WUFDQSxJQUFJMTdELFNBQVNxTyxnQkFBZ0JDLFFBQVEsRUFBRTtnQkFDckMsT0FBTyxJQUFJLENBQUNxdEQsVUFBVTtZQUN4QjtRQUNGLE9BQU87WUFDTCxJQUFJMzdELFNBQVNxTyxnQkFBZ0JvcUQsS0FBSyxFQUFFO2dCQUNsQyxPQUFPLElBQUksQ0FBQ2QsVUFBVTtZQUN4QjtZQUNBLElBQUkzM0QsU0FBU3FPLGdCQUFnQkMsUUFBUSxFQUFFO2dCQUNyQyxPQUFPLElBQUksQ0FBQ29wRCxhQUFhO1lBQzNCO1FBQ0Y7SUFDRjtJQUNBLGNBQWMsR0FDZDFQLGNBQWNvWSxZQUFZLEVBQUVDLFdBQVcsRUFBRTtRQUN2QyxJQUFJaHRFLElBQUk4VTtRQUNSLElBQUksQ0FBQyxJQUFJLENBQUM0eUQsU0FBUyxFQUFFO1lBQ25CLElBQUksQ0FBQ3J5RSxHQUFHLENBQUMydEIsSUFBSSxDQUFDLDJEQUEyRCxJQUFJLENBQUN3MUIsVUFBVTtZQUN4RjtRQUNGO1FBQ0EsTUFBTXkwQixpQkFBaUIsSUFBSSxDQUFDdkYsU0FBUyxDQUFDbkcsVUFBVSxDQUFDekQsbUJBQW1CO1FBQ3BFLE1BQU1vUCxnQkFBZ0IsSUFBSSxDQUFDeEYsU0FBUyxDQUFDbkcsVUFBVSxDQUFDdkQsb0JBQW9CO1FBQ3BFOzs7O0lBSUEsR0FDQSxNQUFNeEgsZ0JBQWdCLENBQUMxaEQsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUN1bkUsVUFBVSxNQUFNLFFBQVF2bkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdzJELGFBQWEsTUFBTSxRQUFRMWhELE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQzNJLE1BQU0rRyxZQUFZLElBQUlub0I7UUFDdEJxNUUsYUFBYXY1RSxPQUFPLENBQUN1MkIsQ0FBQUE7WUFDbkIsSUFBSUEsTUFBTW9qRCxTQUFTLEtBQUszVyxlQUFlO2dCQUNyQzM2QyxVQUFVcmUsSUFBSSxDQUFDdXNCLE1BQU04cUIsUUFBUTtZQUMvQjtRQUNGO1FBQ0EsSUFBSSxDQUFDK3hCLE1BQU0sQ0FBQ2pTLGFBQWEsQ0FBQyxJQUFJN2hCLFVBQVU7WUFDdENtaEIsUUFBUWdaLGlCQUFpQmxaLDBCQUEwQjtnQkFDakRuZ0MsS0FBS3E1QyxlQUFlcjVDLEdBQUc7Z0JBQ3ZCcjFCLE1BQU0wdUUsZUFBZTF1RSxJQUFJO1lBQzNCLEtBQUs5SDtZQUNMbTlELE9BQU9zWixnQkFBZ0JuWiwwQkFBMEI7Z0JBQy9DbmdDLEtBQUtzNUMsY0FBY3Q1QyxHQUFHO2dCQUN0QnIxQixNQUFNMnVFLGNBQWMzdUUsSUFBSTtZQUMxQixLQUFLOUg7WUFDTDIyRSxjQUFjLElBQUkzNkIsbUJBQW1CO2dCQUNuQzUyQjtnQkFDQWs1QixXQUFXLENBQUN5aEI7Z0JBQ1p4aEIsbUJBQW1CLEVBQUU7WUFDdkI7WUFDQXVCLGVBQWVzSSx3QkFBd0JtdUI7WUFDdkN4MkIsY0FBYyxJQUFJLENBQUM2MkIsZ0JBQWdCO1FBQ3JDO0lBQ0Y7SUFDQSxhQUFhLEdBQ2JDLFdBQVc7UUFDVCw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDbkosY0FBYyxHQUFHO0lBQ3hCO0lBQ0FrSixtQkFBbUI7UUFDakIsTUFBTXZ1QixRQUFRLEVBQUU7UUFDaEIsTUFBTXl1QixVQUFVLENBQUMxbUMsSUFBSXQ2QjtZQUNuQixJQUFJLENBQUNzNkIsT0FBTyxRQUFRQSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqZCxFQUFFLE1BQU1uekIsYUFBYW93QyxHQUFHamQsRUFBRSxLQUFLLE1BQU07Z0JBQ25GazFCLE1BQU10aEQsSUFBSSxDQUFDLElBQUlpNUMsZ0JBQWdCO29CQUM3QnJxQixPQUFPeWEsR0FBR3phLEtBQUs7b0JBQ2Z4QyxJQUFJaWQsR0FBR2pkLEVBQUU7b0JBQ1RyZDtnQkFDRjtZQUNGO1FBQ0Y7UUFDQWdoRSxRQUFRLElBQUksQ0FBQy9HLGtCQUFrQixDQUFDeHJELGdCQUFnQm9xRCxLQUFLLEdBQUduekIsYUFBYWtDLFNBQVM7UUFDOUVvNUIsUUFBUSxJQUFJLENBQUMvRyxrQkFBa0IsQ0FBQ3hyRCxnQkFBZ0JDLFFBQVEsR0FBR2czQixhQUFha0MsU0FBUztRQUNqRm81QixRQUFRLElBQUksQ0FBQy9HLGtCQUFrQixDQUFDeHJELGdCQUFnQm9xRCxLQUFLLEVBQUUsT0FBT256QixhQUFhMHZCLFVBQVU7UUFDckY0TCxRQUFRLElBQUksQ0FBQy9HLGtCQUFrQixDQUFDeHJELGdCQUFnQkMsUUFBUSxFQUFFLE9BQU9nM0IsYUFBYTB2QixVQUFVO1FBQ3hGLE9BQU83aUI7SUFDVDtJQUNBK21CLHdCQUF3QjtRQUN0QixJQUFJLElBQUksQ0FBQ0csZ0JBQWdCLEVBQUU7WUFDekJ4MkIsZUFBZWIsWUFBWSxDQUFDLElBQUksQ0FBQ3EzQixnQkFBZ0I7UUFDbkQ7SUFDRjtJQUNBK0Isd0JBQXdCO1FBQ3RCLElBQUksQ0FBQ2xDLHFCQUFxQjtRQUMxQixJQUFJLENBQUMvQixpQkFBaUIsR0FBRztJQUMzQjtJQUNBa0QseUJBQXlCO1FBQ3ZCLElBQUlqc0IsU0FBUztZQUNYeG1ELE9BQU9xeUIsZ0JBQWdCLENBQUMsVUFBVSxJQUFJLENBQUMrL0MsbUJBQW1CO1FBQzVEO0lBQ0Y7SUFDQW1CLDJCQUEyQjtRQUN6QixJQUFJL3NCLFNBQVM7WUFDWHhtRCxPQUFPdXlCLG1CQUFtQixDQUFDLFVBQVUsSUFBSSxDQUFDNi9DLG1CQUFtQjtRQUMvRDtJQUNGO0FBQ0Y7QUFDQSxNQUFNMEUsNkJBQTZCOXZFO0FBQU87QUFFMUMsTUFBTWl5RTtJQUNKbHRFLFlBQVkrNUIsR0FBRyxFQUFFbTNCLEtBQUssQ0FBRTtRQUN0QixJQUFJLENBQUNpYyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7UUFDMUIsSUFBSSxDQUFDcHNCLFNBQVMsR0FBRyxJQUFJcXNCLElBQUl2ekM7UUFDekIsSUFBSSxDQUFDbTNCLEtBQUssR0FBR0E7SUFDZjtJQUNBdVUsWUFBWXZVLEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDZjtJQUNBbFEsVUFBVTtRQUNSLE9BQU9BLFFBQVEsSUFBSSxDQUFDQyxTQUFTO0lBQy9CO0lBQ0Fzc0IsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDdHNCLFNBQVM7SUFDdkI7SUFDQXNxQixxQkFBcUJwYSxXQUFXLEVBQUU7UUFDaEMsT0FBTzd3QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMwZ0MsT0FBTyxJQUFJO2dCQUNuQixNQUFNL2xELE1BQU07WUFDZDtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUN1eUUsY0FBYyxJQUFJdDRELEtBQUtRLEdBQUcsS0FBSyxJQUFJLENBQUN5M0QsWUFBWSxHQUFHLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUU7Z0JBQ25GLElBQUksQ0FBQ0ksY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ3RjO1lBQ3ZEO1lBQ0EsTUFBTXVjLGNBQWMsSUFBSSxDQUFDRixjQUFjLENBQUNoM0IsT0FBTyxDQUFDMThDLE1BQU0sQ0FBQ2dmLENBQUFBLFNBQVUsQ0FBQyxJQUFJLENBQUN1MEQsZ0JBQWdCLENBQUNyaEUsSUFBSSxDQUFDMmhFLENBQUFBLFlBQWFBLFVBQVU1ekMsR0FBRyxLQUFLamhCLE9BQU9paEIsR0FBRztZQUN0SSxJQUFJMnpDLFlBQVlsM0UsTUFBTSxHQUFHLEdBQUc7Z0JBQzFCLE1BQU1vM0UsYUFBYUYsV0FBVyxDQUFDLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQ0wsZ0JBQWdCLENBQUNud0UsSUFBSSxDQUFDMHdFO2dCQUMzQmwwRSxjQUFjaEQsS0FBSyxDQUFDLGdCQUFnQnFJLE1BQU0sQ0FBQzZ1RSxXQUFXOTBELE1BQU07Z0JBQzVELE9BQU84MEQsV0FBVzd6QyxHQUFHO1lBQ3ZCLE9BQU87Z0JBQ0wsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBc3hDLGdCQUFnQjtRQUNkLElBQUksQ0FBQ2dDLGdCQUFnQixHQUFHLEVBQUU7SUFDNUI7SUFDQSxhQUFhLEdBQ2JJLG9CQUFvQnBMLE1BQU0sRUFBRTtRQUMxQixPQUFPL2hELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXV0RCx5QkFBeUIsTUFBTXhiLE1BQU0sR0FBR3R6RCxNQUFNLENBQUMrdUUsa0JBQWtCLElBQUksQ0FBQzdzQixTQUFTLEdBQUcsYUFBYTtnQkFDbkc4c0IsU0FBUztvQkFDUEMsZUFBZSxVQUFVanZFLE1BQU0sQ0FBQyxJQUFJLENBQUNteUQsS0FBSztnQkFDNUM7Z0JBQ0FtUjtZQUNGO1lBQ0EsSUFBSXdMLHVCQUF1QjFwRSxFQUFFLEVBQUU7Z0JBQzdCLE1BQU1xcEUsaUJBQWlCLE1BQU1LLHVCQUF1Qm52RSxJQUFJO2dCQUN4RCxJQUFJLENBQUN5dUUsWUFBWSxHQUFHajRELEtBQUtRLEdBQUc7Z0JBQzVCLE9BQU84M0Q7WUFDVCxPQUFPO2dCQUNMLE1BQU0sSUFBSTNnQyxnQkFBZ0Isb0NBQW9DOXRDLE1BQU0sQ0FBQzh1RSx1QkFBdUJJLFVBQVUsR0FBR0osdUJBQXVCOWdDLE1BQU0sS0FBSyxNQUFNLEVBQUUsb0NBQW9DLE1BQUs1MkMsV0FBVzAzRSx1QkFBdUI5Z0MsTUFBTTtZQUN0TztRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrZ0Msa0JBQWtCN3NCLFNBQVM7SUFDbEMsT0FBTyxHQUFHbGlELE1BQU0sQ0FBQ2tpRCxVQUFVcmxDLFFBQVEsQ0FBQ3JHLE9BQU8sQ0FBQyxNQUFNLFNBQVMsTUFBTXhXLE1BQU0sQ0FBQ2tpRCxVQUFVaXRCLElBQUksRUFBRTtBQUMxRjtBQUVBLE1BQU1DLG1CQUFtQjtBQUN6QixTQUFTQyxlQUFlQyxZQUFZLEVBQUVDLFNBQVM7SUFDN0MsSUFBSSxDQUFDQSxXQUFXO1FBQ2QsT0FBTztJQUNUO0lBQ0EsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUksbUJBQW1CSCxjQUFjO1FBQ25DRSxXQUFXRixhQUFhSSxhQUFhO1FBQ3JDRCxZQUFZRixVQUFVRyxhQUFhO0lBQ3JDLE9BQU8sSUFBSSxlQUFlSixjQUFjO1FBQ3RDRSxXQUFXRixhQUFhSyxTQUFTO1FBQ2pDRixZQUFZRixVQUFVSSxTQUFTO0lBQ2pDO0lBQ0EsSUFBSUgsYUFBYXA0RSxhQUFhcTRFLGNBQWNyNEUsYUFBYWs0RSxhQUFhNzhDLFNBQVMsS0FBS3I3QixhQUFhbTRFLFVBQVU5OEMsU0FBUyxLQUFLcjdCLFdBQVc7UUFDbEksT0FBTztJQUNUO0lBQ0EsT0FBTyxDQUFDbzRFLFdBQVdDLFNBQVEsSUFBSyxJQUFJLE9BQVFILENBQUFBLGFBQWE3OEMsU0FBUyxHQUFHODhDLFVBQVU5OEMsU0FBUztBQUMxRjtBQUVBLE1BQU1tOUMsd0JBQXdCdG5CO0lBQzVCOzs7OztHQUtDLEdBQ0RybkQsWUFBWWkzQyxVQUFVLEVBQUVoc0IsV0FBVyxDQUFFO1FBQ25DLElBQUlzOEIsb0JBQW9CenhELFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzVGLElBQUk4dUQsZUFBZTl1RCxVQUFVVSxNQUFNLEdBQUcsSUFBSVYsU0FBUyxDQUFDLEVBQUUsR0FBR0s7UUFDekQsSUFBSStnRCxnQkFBZ0JwaEQsVUFBVVUsTUFBTSxHQUFHLElBQUlWLFNBQVMsQ0FBQyxFQUFFLEdBQUdLO1FBQzFELEtBQUssQ0FBQzhnRCxZQUFZRCxNQUFNMEIsSUFBSSxDQUFDMEMsS0FBSyxFQUFFbndCLGFBQWFzOEIsbUJBQW1CclE7UUFDcEUsY0FBYyxHQUNkLElBQUksQ0FBQzAzQixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBTXZ1RCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDMFAsTUFBTSxFQUFFO29CQUNoQixJQUFJLENBQUN3bkIsZUFBZSxHQUFHO29CQUN2QjtnQkFDRjtnQkFDQSxJQUFJcHVCO2dCQUNKLElBQUk7b0JBQ0ZBLFFBQVEsTUFBTSxJQUFJLENBQUMwbEQsY0FBYztnQkFDbkMsRUFBRSxPQUFPMzdFLEdBQUc7b0JBQ1YsSUFBSSxDQUFDNEIsR0FBRyxDQUFDNnNCLEtBQUssQ0FBQyxvQ0FBb0N0dUIsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7d0JBQ25HdDJCLE9BQU96dUI7b0JBQ1Q7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsSUFBSWkyQixTQUFTLElBQUksQ0FBQ2tsRCxTQUFTLEVBQUU7b0JBQzNCLElBQUksQ0FBQzkyQixlQUFlLEdBQUc0MkIsZUFBZWhsRCxPQUFPLElBQUksQ0FBQ2tsRCxTQUFTO2dCQUM3RDtnQkFDQSxJQUFJLENBQUNBLFNBQVMsR0FBR2xsRDtZQUNuQjtRQUNBLElBQUksQ0FBQ3c3QixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ21xQixlQUFlO0lBQ3RCO0lBQ0FDLFlBQVloakQsUUFBUSxFQUFFO1FBQ3BCLE9BQU8xTCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDZ25DLFlBQVksQ0FBQ3Q3QixRQUFRLEtBQUtBLFVBQVU7Z0JBQzNDLE9BQU87WUFDVDtZQUNBLElBQUksQ0FBQ3M3QixZQUFZLENBQUN0N0IsUUFBUSxHQUFHQTtZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDb3JCLE9BQU8sRUFBRTtnQkFDakIsTUFBTSxJQUFJLENBQUM2M0IsWUFBWTtZQUN6QjtZQUNBLE9BQU8sSUFBSSxDQUFDNzNCLE9BQU8sSUFBSTZPLGlCQUFpQmo2QixjQUFjLElBQUksQ0FBQ3FzQixnQkFBZ0IsQ0FBQ2pqQixXQUFXLEdBQUdwSixRQUFRO1FBQ3BHO0lBQ0Y7SUFDQXM5QixPQUFPO1FBQ0wsTUFBTVMsU0FBU3oyRCxPQUFPdUosTUFBTSxDQUFDLE1BQU07WUFDakN5c0QsTUFBTTtnQkFDSjExRCxLQUFLLElBQU0sS0FBSyxDQUFDMDFEO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPaHBDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTTJwQyxTQUFTLE1BQU0sSUFBSSxDQUFDL0IsUUFBUSxDQUFDdkMsSUFBSTtZQUN2QyxJQUFJO2dCQUNGLHVGQUF1RjtnQkFDdkYsSUFBSSxJQUFJLENBQUNqMEMsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUMyRCxVQUFVLElBQUksSUFBSSxDQUFDaXpCLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQ25tQixjQUFjLEVBQUU7b0JBQ3RGLElBQUksQ0FBQzF6RCxHQUFHLENBQUMyQixLQUFLLENBQUMsc0JBQXNCLElBQUksQ0FBQ3doRCxVQUFVO29CQUNwRCxrRUFBa0U7b0JBQ2xFLElBQUksQ0FBQ0osaUJBQWlCLENBQUN0cUIsSUFBSTtnQkFDN0I7Z0JBQ0EsTUFBTXU4QixPQUFPVCxJQUFJLENBQUM3MEQsSUFBSSxDQUFDLElBQUk7Z0JBQzNCLE9BQU8sSUFBSTtZQUNiLFNBQVU7Z0JBQ1J3MUQ7WUFDRjtRQUNGO0lBQ0Y7SUFDQVQsU0FBUztRQUNQLE1BQU1PLFNBQVN6MkQsT0FBT3VKLE1BQU0sQ0FBQyxNQUFNO1lBQ2pDMnNELFFBQVE7Z0JBQ041MUQsS0FBSyxJQUFNLEtBQUssQ0FBQzQxRDtZQUNuQjtRQUNGO1FBQ0EsT0FBT2xwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0ycEMsU0FBUyxNQUFNLElBQUksQ0FBQy9CLFFBQVEsQ0FBQ3ZDLElBQUk7WUFDdkMsSUFBSTtnQkFDRixNQUFNdXBCLG1CQUFtQixJQUFJLENBQUM1bkIsWUFBWSxDQUFDdDdCLFFBQVEsSUFBSSxJQUFJLENBQUM4ckIsaUJBQWlCLENBQUMxaUIsV0FBVyxHQUFHcEosUUFBUSxLQUFLaTZCLGlCQUFpQixJQUFJLENBQUNxQixZQUFZLENBQUN0N0IsUUFBUTtnQkFDcEosSUFBSSxJQUFJLENBQUN0YSxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQzJELFVBQVUsSUFBSyxLQUFJLENBQUNpekIsVUFBVSxJQUFJLElBQUksQ0FBQzkyQixpQkFBaUIsQ0FBQ3BSLFVBQVUsS0FBSyxXQUFXd29DLGdCQUFlLEtBQU0sQ0FBQyxJQUFJLENBQUN6bUIsY0FBYyxFQUFFO29CQUM3SixJQUFJLENBQUMxekQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLHlCQUF5QixJQUFJLENBQUN3aEQsVUFBVTtvQkFDdkQsTUFBTSxJQUFJLENBQUMrMkIsWUFBWTtnQkFDekI7Z0JBQ0EsTUFBTWxsQixPQUFPUCxNQUFNLENBQUMvMEQsSUFBSSxDQUFDLElBQUk7Z0JBQzdCLE9BQU8sSUFBSTtZQUNiLFNBQVU7Z0JBQ1J3MUQ7WUFDRjtRQUNGO0lBQ0Y7SUFDQWdsQixhQUFhanhFLE9BQU8sRUFBRTtRQUNwQixPQUFPc2lCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSTJLO1lBQ0osSUFBSWp0QixTQUFTO2dCQUNYLE1BQU0wckQsb0JBQW9CL00sc0JBQXNCO29CQUM5Q3h4QixPQUFPbnRCO2dCQUNUO2dCQUNBLElBQUksT0FBTzByRCxrQkFBa0J2K0IsS0FBSyxLQUFLLFdBQVc7b0JBQ2hERixjQUFjeStCLGtCQUFrQnYrQixLQUFLO2dCQUN2QztZQUNGO1lBQ0EsTUFBTSxJQUFJLENBQUM0OUIsT0FBTyxDQUFDOTlCO1FBQ3JCO0lBQ0Y7SUFDQTg5QixRQUFROTlCLFdBQVcsRUFBRTtRQUNuQixNQUFNOCtCLFNBQVN6MkQsT0FBT3VKLE1BQU0sQ0FBQyxNQUFNO1lBQ2pDa3NELFNBQVM7Z0JBQ1BuMUQsS0FBSyxJQUFNLEtBQUssQ0FBQ20xRDtZQUNuQjtRQUNGO1FBQ0EsT0FBT3pvQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU1tSixRQUFRLE1BQU1zZ0MsT0FBT2hCLE9BQU8sQ0FBQ3QwRCxJQUFJLENBQUMsSUFBSSxFQUFFdzJCO1lBQzlDLElBQUksQ0FBQzhqRCxlQUFlO1lBQ3BCLE9BQU90bEQ7UUFDVDtJQUNGO0lBQ0EsYUFBYSxHQUNiMGxELGVBQWU7UUFDYixJQUFJLENBQUMxMEIsU0FBUztZQUNaO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ0wsZUFBZSxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLGVBQWUsR0FBR2pMLFlBQVk7WUFDakMsSUFBSSxDQUFDMC9CLGFBQWE7UUFDcEIsR0FBR1Y7SUFDTDtJQUNBN2pCLGFBQWE1QixTQUFTLEVBQUU7UUFDdEIsSUFBSWhwRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNMnBDLFNBQVMsTUFBTSxJQUFJLENBQUM3QixhQUFhLENBQUN6QyxJQUFJO1lBQzVDLElBQUk7Z0JBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ2YsWUFBWSxFQUFFO29CQUN0QixNQUFNM3BELE1BQU07Z0JBQ2Q7Z0JBQ0EsSUFBSSxJQUFJLENBQUN5dEQsU0FBUyxFQUFFO29CQUNsQixNQUFNLElBQUksQ0FBQ2UsYUFBYTtnQkFDMUI7Z0JBQ0EsSUFBSSxJQUFJLENBQUNwOUMsSUFBSSxLQUFLLFdBQVc7b0JBQzNCLE1BQU1uVCxVQUFVO2dCQUNsQjtnQkFDQSxNQUFNc3hELG1CQUFtQjtvQkFDdkJuK0MsTUFBTSxJQUFJLENBQUNBLElBQUk7b0JBQ2ZvZCxPQUFPLElBQUksQ0FBQ3F1QixpQkFBaUI7b0JBQzdCOE0sY0FBYyxJQUFJLENBQUNBLFlBQVk7Z0JBQ2pDO2dCQUNBLElBQUksQ0FBQzd2RCxHQUFHLENBQUMyQixLQUFLLENBQUMsOEJBQThCcUksTUFBTSxDQUFDMnBELFVBQVU1eEQsSUFBSSxHQUFHLElBQUksQ0FBQ29oRCxVQUFVO2dCQUNwRixNQUFNd1EsVUFBVTdsQyxJQUFJLENBQUMybkM7Z0JBQ3JCLElBQUksQ0FBQzlCLFNBQVMsR0FBR0E7Z0JBQ2pCLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUNDLGNBQWMsRUFBRTtvQkFDakMsTUFBTSxDQUFDanBELEtBQUssSUFBSSxDQUFDc3dCLE1BQU0sTUFBTSxRQUFRdHdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NwRCxZQUFZLENBQUMsSUFBSSxDQUFDTixTQUFTLENBQUNDLGNBQWM7Z0JBQzdHO1lBQ0YsU0FBVTtnQkFDUnNCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E7OztHQUdDLEdBQ0RtbEIsZ0JBQWdCeHFCLFlBQVksRUFBRTtRQUM1QixJQUFJLENBQUNBLFlBQVksR0FBR0E7SUFDdEI7SUFDQWtxQixpQkFBaUI7UUFDZixJQUFJcHZFO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBRSxFQUFDNWdCLEtBQUssSUFBSSxDQUFDc3dCLE1BQU0sTUFBTSxRQUFRdHdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR294QixRQUFRLEdBQUc7Z0JBQzFFLE9BQU8zNkI7WUFDVDtZQUNBLE1BQU1pekIsUUFBUSxNQUFNLElBQUksQ0FBQzRHLE1BQU0sQ0FBQ2MsUUFBUTtZQUN4QyxJQUFJdStDO1lBQ0pqbUQsTUFBTWwyQixPQUFPLENBQUNzSixDQUFBQTtnQkFDWixJQUFJQSxFQUFFeUIsSUFBSSxLQUFLLGdCQUFnQjtvQkFDN0JveEUsYUFBYTt3QkFDWHB4RSxNQUFNO3dCQUNOczBCLFVBQVUvMUIsRUFBRThzQixFQUFFO3dCQUNkZ21ELGFBQWE5eUUsRUFBRTh5RSxXQUFXO3dCQUMxQnp4RCxhQUFhcmhCLEVBQUVxaEIsV0FBVzt3QkFDMUI2d0QsV0FBV2x5RSxFQUFFa3lFLFNBQVM7d0JBQ3RCbDlDLFdBQVdoMUIsRUFBRWcxQixTQUFTO3dCQUN0Qis5QyxlQUFlL3lFLEVBQUUreUUsYUFBYTt3QkFDOUJDLFFBQVFoekUsRUFBRWd6RSxNQUFNO29CQUNsQjtnQkFDRjtZQUNGO1lBQ0EsT0FBT0g7UUFDVDtJQUNGO0lBQ0FOLGtCQUFrQjtRQUNoQixPQUFPenVELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTW12RCxnQkFBZ0IsTUFBTTV5QixjQUFjLElBQUk7WUFDOUMsSUFBSTR5QixlQUFlO2dCQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDcjRCLE9BQU8sRUFBRTtvQkFDakIsSUFBSSxDQUFDcmlELEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMseUNBQXlDLElBQUksQ0FBQ3cxQixVQUFVO2dCQUN4RTtnQkFDQSxJQUFJLENBQUN6MEIsSUFBSSxDQUFDc3FCLFdBQVcyaEMsb0JBQW9CO1lBQzNDO1lBQ0EsT0FBT0Q7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxjQUFjLEdBQ2QsU0FBU0UsdUJBQXVCdDNCLGdCQUFnQixFQUFFcHRCLFdBQVcsRUFBRWlzQixhQUFhO0lBQzFFLE9BQVFtQixpQkFBaUJoc0MsSUFBSTtRQUMzQixLQUFLO1lBQ0gsT0FBTyxJQUFJc2lFLGdCQUFnQnQyQixrQkFBa0JwdEIsYUFBYSxPQUFPOTBCLFdBQVcrZ0Q7UUFDOUUsS0FBSztZQUNILE9BQU8sSUFBSTA0QixnQkFBZ0J2M0Isa0JBQWtCcHRCLGFBQWEsT0FBT2lzQjtRQUNuRTtZQUNFLE1BQU0sSUFBSWpLLGtCQUFrQiwyQkFBMkJsdUMsTUFBTSxDQUFDczVDLGlCQUFpQmhzQyxJQUFJO0lBQ3ZGO0FBQ0Y7QUFDQSxhQUFhLEdBQ2IsTUFBTXdqRSxhQUFhdjhFLE9BQU8rSSxNQUFNLENBQUMrekM7QUFDakMsYUFBYSxHQUNiLE1BQU0wL0IsWUFBWXg4RSxPQUFPK0ksTUFBTSxDQUFDeTBDO0FBQ2hDLGFBQWEsR0FDYixNQUFNaS9CLHFCQUFxQno4RSxPQUFPK0ksTUFBTSxDQUFDNjBDO0FBQ3pDLGFBQWEsR0FDYixNQUFNOCtCLDZCQUE2QjtJQUFDNS9CLGFBQWFFLElBQUk7SUFBRUYsYUFBYUksSUFBSTtDQUFDO0FBQ3pFLGFBQWEsR0FDYixNQUFNeS9CLDRCQUE0QjtJQUFDbi9CLGVBQWVSLElBQUk7SUFBRVEsZUFBZU4sSUFBSTtDQUFDO0FBQzVFLGFBQWEsR0FDYixNQUFNMC9CLDRDQUE0Q0MsQ0FBQUE7SUFDaEQsTUFBTTcyRCxTQUFTO1FBQUM7WUFDZDRkLHVCQUF1QjtZQUN2QjBkLEtBQUt1N0IsV0FBVzdnQyxRQUFRLENBQUNuWSxZQUFZO1FBQ3ZDO0tBQUU7SUFDRixPQUFPN2QsT0FBT3BmLEdBQUcsQ0FBQ2dDLENBQUFBO1FBQ2hCLElBQUl3RCxJQUFJOFU7UUFDUixPQUFPLElBQUk2NkIsWUFBWS9yQyxLQUFLQyxLQUFLLENBQUM0c0UsV0FBV3oyRCxLQUFLLEdBQUd4ZCxFQUFFZzdCLHFCQUFxQixHQUFHNXpCLEtBQUtDLEtBQUssQ0FBQzRzRSxXQUFXeDJELE1BQU0sR0FBR3pkLEVBQUVnN0IscUJBQXFCLEdBQUc1ekIsS0FBS3NVLEdBQUcsQ0FBQyxRQUFRdFUsS0FBS0MsS0FBSyxDQUFDNHNFLFdBQVc3Z0MsUUFBUSxDQUFDak4sVUFBVSxHQUFJLytCLENBQUFBLEtBQUs2aEQsR0FBRyxDQUFDanBELEVBQUVnN0IscUJBQXFCLEVBQUUsS0FBTSxFQUFDLENBQUN4M0IsS0FBS3l3RSxXQUFXN2dDLFFBQVEsQ0FBQ25ZLFlBQVksTUFBTSxRQUFRejNCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUMsSUFBTSxFQUFDOFUsS0FBS3RZLEVBQUUwNEMsR0FBRyxNQUFNLFFBQVFwZ0MsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBQyxDQUFDLENBQUMsS0FBTXRZLEVBQUUwNEMsR0FBRyxFQUFFdTdCLFdBQVc3Z0MsUUFBUSxDQUFDdFQsUUFBUTtJQUMzWjtBQUNGO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLE1BQU07QUFDTiwwRkFBMEY7QUFDMUYsNEJBQTRCO0FBQzVCLG9FQUFvRTtBQUNwRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDhEQUE4RDtBQUM5RCxhQUFhO0FBQ2IsV0FBVztBQUNYLFdBQVc7QUFDWCxZQUFZO0FBQ1osV0FBVztBQUNYLE9BQU87QUFDUCxLQUFLO0FBQ0wsTUFBTW8wQyxZQUFZO0lBQUM7SUFBSztJQUFLO0NBQUk7QUFDakMsYUFBYSxHQUNiLFNBQVNDLHNCQUFzQkMsYUFBYSxFQUFFNTJELEtBQUssRUFBRUMsTUFBTSxFQUFFM2IsT0FBTztJQUNsRSxJQUFJMEIsSUFBSThVO0lBQ1IsSUFBSSs3RCxnQkFBZ0J2eUUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF1eUUsYUFBYTtJQUMzRixJQUFJRCxlQUFlO1FBQ2pCQyxnQkFBZ0J2eUUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFpaEUsbUJBQW1CO0lBQy9GO0lBQ0EsTUFBTXVSLGVBQWV4eUUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE0YixTQUFTO0lBQ3hGLE1BQU02MkQsa0JBQWtCenlFLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFReXlFLGVBQWU7SUFDakcsTUFBTXRSLGFBQWFuaEUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFtaEUsVUFBVTtJQUN2RixJQUFJLENBQUNvUixpQkFBaUIsQ0FBQ0MsZ0JBQWdCLENBQUNDLG1CQUFtQixDQUFDLzJELFNBQVMsQ0FBQ0MsUUFBUTtRQUM1RSxvRkFBb0Y7UUFDcEYsK0RBQStEO1FBQy9ELE9BQU87WUFBQyxDQUFDO1NBQUU7SUFDYjtJQUNBLElBQUksQ0FBQzQyRCxlQUFlO1FBQ2xCLGdEQUFnRDtRQUNoREEsZ0JBQWdCRyw2QkFBNkJKLGVBQWU1MkQsT0FBT0MsUUFBUXdsRDtRQUMzRXpsRSxjQUFjaEQsS0FBSyxDQUFDLHdCQUF3QjY1RTtJQUM5QztJQUNBLE1BQU03K0IsV0FBVyxJQUFJckMsWUFBWTMxQixPQUFPQyxRQUFRNDJELGNBQWNsdUMsVUFBVSxFQUFFa3VDLGNBQWNwNUMsWUFBWSxFQUFFbzVDLGNBQWN2MEMsUUFBUTtJQUM1SCxJQUFJeTBDLG1CQUFtQnR3QixXQUFXZ2YsYUFBYTtRQUM3Q3psRSxjQUFjaEQsS0FBSyxDQUFDLGtDQUFrQ3FJLE1BQU0sQ0FBQzB4RTtRQUM3RCxNQUFNRSxLQUFLLElBQUlDLGdCQUFnQkg7UUFDL0IsTUFBTW41QyxZQUFZLEVBQUU7UUFDcEIsSUFBSXE1QyxHQUFHRSxPQUFPLEdBQUcsR0FBRztZQUNsQixNQUFNLElBQUk1MUUsTUFBTSxnQ0FBZ0M4RCxNQUFNLENBQUMweEU7UUFDekQ7UUFDQSxJQUFLLElBQUlsNkUsSUFBSSxHQUFHQSxJQUFJbzZFLEdBQUdFLE9BQU8sRUFBRXQ2RSxLQUFLLEVBQUc7WUFDdEMrZ0MsVUFBVXA2QixJQUFJLENBQUM7Z0JBQ2I4NUIsS0FBS281QyxTQUFTLENBQUMsSUFBSTc1RSxFQUFFO2dCQUNyQjhyQyxZQUFZa3VDLGNBQWNsdUMsVUFBVSxHQUFHLytCLEtBQUs2aEQsR0FBRyxDQUFDLEdBQUc1dUQ7Z0JBQ25ELGNBQWMsR0FDZDRnQyxjQUFjdWEsU0FBU3BDLFFBQVEsQ0FBQ25ZLFlBQVk7WUFDOUM7UUFDRjtRQUNBLGNBQWMsR0FDZEcsU0FBUyxDQUFDLEVBQUUsQ0FBQ201QyxlQUFlLEdBQUdBO1FBQy9CLzJFLGNBQWNoRCxLQUFLLENBQUMsYUFBYTRnQztRQUNqQyxPQUFPQTtJQUNUO0lBQ0EsSUFBSSxDQUFDazVDLGNBQWM7UUFDakIsT0FBTztZQUFDRDtTQUFjO0lBQ3hCO0lBQ0EsSUFBSU8sVUFBVSxFQUFFO0lBQ2hCLElBQUlSLGVBQWU7UUFDakJRLFVBQVUsQ0FBQ3B4RSxLQUFLcXhFLFlBQVkveUUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFnekUsMEJBQTBCLE9BQU8sUUFBUXR4RSxPQUFPLEtBQUssSUFBSUEsS0FBS3V4RSx1QkFBdUJYLGVBQWU1K0I7SUFDNUwsT0FBTztRQUNMby9CLFVBQVUsQ0FBQ3Q4RCxLQUFLdThELFlBQVkveUUsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFrekUsb0JBQW9CLE9BQU8sUUFBUTE4RCxPQUFPLEtBQUssSUFBSUEsS0FBS3k4RCx1QkFBdUJYLGVBQWU1K0I7SUFDdEw7SUFDQSxJQUFJeS9CO0lBQ0osSUFBSUwsUUFBUXQ2RSxNQUFNLEdBQUcsR0FBRztRQUN0QixNQUFNNDZFLFlBQVlOLE9BQU8sQ0FBQyxFQUFFO1FBQzVCLElBQUlBLFFBQVF0NkUsTUFBTSxHQUFHLEdBQUc7WUFDdEIsR0FBRzI2RSxVQUFVLEdBQUdMO1FBQ2xCO1FBQ0EsUUFBUTtRQUNSLDhEQUE4RDtRQUM5RCw2REFBNkQ7UUFDN0Qsd0NBQXdDO1FBQ3hDLDREQUE0RDtRQUM1RCx5QkFBeUI7UUFDekIsOERBQThEO1FBQzlELDBEQUEwRDtRQUMxRCxrQ0FBa0M7UUFDbEMsTUFBTS9vRCxPQUFPemtCLEtBQUtzVSxHQUFHLENBQUM4QixPQUFPQztRQUM3QixJQUFJb08sUUFBUSxPQUFPb3BELFdBQVc7WUFDNUIsT0FBT0UscUJBQXFCMzNELE9BQU9DLFFBQVE7Z0JBQUN5M0Q7Z0JBQVdEO2dCQUFXei9CO2FBQVM7UUFDN0U7UUFDQSxJQUFJM3BCLFFBQVEsS0FBSztZQUNmLE9BQU9zcEQscUJBQXFCMzNELE9BQU9DLFFBQVE7Z0JBQUN5M0Q7Z0JBQVcxL0I7YUFBUztRQUNsRTtJQUNGO0lBQ0EsT0FBTzIvQixxQkFBcUIzM0QsT0FBT0MsUUFBUTtRQUFDKzNCO0tBQVM7QUFDdkQ7QUFDQSxTQUFTNC9CLDRCQUE0QjduRCxLQUFLLEVBQUUwMUMsVUFBVSxFQUFFMXlCLElBQUk7SUFDMUQsSUFBSS9zQyxJQUFJOFUsSUFBSUMsSUFBSUM7SUFDaEIsMkZBQTJGO0lBQzNGLElBQUksQ0FBQyszQixLQUFLMnlCLFdBQVcsSUFBSTN5QixLQUFLMnlCLFdBQVcsS0FBSyxRQUFRM3lCLEtBQUsyeUIsV0FBVyxDQUFDcGlDLEtBQUssS0FBS3lQLEtBQUsweUIsVUFBVSxFQUFFO1FBQ2hHLHNDQUFzQztRQUN0QztJQUNGO0lBQ0EsSUFBSUEsZUFBZTF5QixLQUFLMnlCLFdBQVcsQ0FBQ3BpQyxLQUFLLEVBQUU7UUFDekN0akMsY0FBY2dwQixJQUFJLENBQUMsd0RBQXdEO1lBQ3pFNnVELGlCQUFpQnBTO1lBQ2pCdnZCLFFBQVFuRCxLQUFLMnlCLFdBQVcsQ0FBQ3BpQyxLQUFLO1FBQ2hDO0lBQ0Y7SUFDQXlQLEtBQUsweUIsVUFBVSxHQUFHQTtJQUNsQiwyRUFBMkU7SUFDM0UxeUIsS0FBSzhqQyxhQUFhLEdBQUc5akMsS0FBSzJ5QixXQUFXLENBQUM5dkIsUUFBUTtJQUM5QyxNQUFNNGtCLFdBQVd6cUMsTUFBTTR1QixnQkFBZ0IsQ0FBQ2pqQixXQUFXO0lBQ25ELE1BQU0xYixRQUFRLENBQUNoYSxLQUFLdzBELFNBQVN4NkMsS0FBSyxNQUFNLFFBQVFoYSxPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDOFUsS0FBS2lWLE1BQU04K0IsVUFBVSxNQUFNLFFBQVEvekMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa0YsS0FBSztJQUMxSSxNQUFNQyxTQUFTLENBQUNsRixLQUFLeS9DLFNBQVN2NkMsTUFBTSxNQUFNLFFBQVFsRixPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDQyxLQUFLK1UsTUFBTTgrQixVQUFVLE1BQU0sUUFBUTd6QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpRixNQUFNO0lBQzdJLE1BQU0yZCxZQUFZKzRDLHNCQUFzQjVtRCxNQUFNL1gsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUM2RCxXQUFXLEVBQUVuaUMsT0FBT0MsUUFBUTh5QjtJQUNsRyxPQUFPblY7QUFDVDtBQUNBLGFBQWEsR0FDYixTQUFTbzVDLDZCQUE2QkosYUFBYSxFQUFFNTJELEtBQUssRUFBRUMsTUFBTSxFQUFFcWpCLEtBQUs7SUFDdkUsTUFBTTh6QyxVQUFVVSxxQkFBcUJsQixlQUFlNTJELE9BQU9DO0lBQzNELElBQUksRUFDRjIxQixRQUFRLEVBQ1QsR0FBR3doQyxPQUFPLENBQUMsRUFBRTtJQUNkLHlDQUF5QztJQUN6QyxNQUFNL29ELE9BQU96a0IsS0FBS3NVLEdBQUcsQ0FBQzhCLE9BQU9DO0lBQzdCLElBQUssSUFBSXBqQixJQUFJLEdBQUdBLElBQUl1NkUsUUFBUXQ2RSxNQUFNLEVBQUVELEtBQUssRUFBRztRQUMxQyxNQUFNazdFLFNBQVNYLE9BQU8sQ0FBQ3Y2RSxFQUFFO1FBQ3pCKzRDLFdBQVdtaUMsT0FBT25pQyxRQUFRO1FBQzFCLElBQUltaUMsT0FBTy8zRCxLQUFLLElBQUlxTyxNQUFNO1lBQ3hCO1FBQ0Y7SUFDRjtJQUNBLHdEQUF3RDtJQUN4RCwyRkFBMkY7SUFDM0YsOEVBQThFO0lBQzlFLDBFQUEwRTtJQUMxRSxzRUFBc0U7SUFDdEUsSUFBSWlWLE9BQU87UUFDVCxPQUFRQTtZQUNOLEtBQUs7Z0JBQ0hzUyxXQUFXaDhDLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHZ3lDO2dCQUM3QkEsU0FBU2pOLFVBQVUsR0FBR2lOLFNBQVNqTixVQUFVLEdBQUc7Z0JBQzVDO1lBQ0YsS0FBSztnQkFDSGlOLFdBQVdoOEMsT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUdneUM7Z0JBQzdCQSxTQUFTak4sVUFBVSxHQUFHaU4sU0FBU2pOLFVBQVUsR0FBRztnQkFDNUM7UUFDSjtJQUNGO0lBQ0EsT0FBT2lOO0FBQ1Q7QUFDQSxhQUFhLEdBQ2IsU0FBU2tpQyxxQkFBcUJsQixhQUFhLEVBQUU1MkQsS0FBSyxFQUFFQyxNQUFNO0lBQ3hELElBQUkyMkQsZUFBZTtRQUNqQixPQUFPUDtJQUNUO0lBQ0EsTUFBTTJCLFNBQVNoNEQsUUFBUUMsU0FBU0QsUUFBUUMsU0FBU0EsU0FBU0Q7SUFDMUQsSUFBSXBXLEtBQUtxdUUsR0FBRyxDQUFDRCxTQUFTLE9BQU8sS0FBS3B1RSxLQUFLcXVFLEdBQUcsQ0FBQ0QsU0FBUyxNQUFNLElBQUk7UUFDNUQsT0FBTzdCO0lBQ1Q7SUFDQSxPQUFPQztBQUNUO0FBQ0EsYUFBYSxHQUNiLFNBQVNtQix1QkFBdUJYLGFBQWEsRUFBRTUrQixRQUFRO0lBQ3JELElBQUk0K0IsZUFBZTtRQUNqQixPQUFPSiwwQ0FBMEN4K0I7SUFDbkQ7SUFDQSxNQUFNLEVBQ0poNEIsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyszQjtJQUNKLE1BQU1nZ0MsU0FBU2g0RCxRQUFRQyxTQUFTRCxRQUFRQyxTQUFTQSxTQUFTRDtJQUMxRCxJQUFJcFcsS0FBS3F1RSxHQUFHLENBQUNELFNBQVMsT0FBTyxLQUFLcHVFLEtBQUtxdUUsR0FBRyxDQUFDRCxTQUFTLE1BQU0sSUFBSTtRQUM1RCxPQUFPMUI7SUFDVDtJQUNBLE9BQU9DO0FBQ1Q7QUFDQSxpREFBaUQ7QUFDakQsU0FBU29CLHFCQUFxQjMzRCxLQUFLLEVBQUVDLE1BQU0sRUFBRW0zRCxPQUFPO0lBQ2xELE1BQU14NUMsWUFBWSxFQUFFO0lBQ3BCdzVDLFFBQVE1OUUsT0FBTyxDQUFDLENBQUN1K0UsUUFBUXRoRDtRQUN2QixJQUFJQSxPQUFPaWdELFVBQVU1NUUsTUFBTSxFQUFFO1lBQzNCO1FBQ0Y7UUFDQSxNQUFNdXhCLE9BQU96a0IsS0FBS3FVLEdBQUcsQ0FBQytCLE9BQU9DO1FBQzdCLE1BQU1xZCxNQUFNbzVDLFNBQVMsQ0FBQ2pnRCxJQUFJO1FBQzFCLE1BQU1tZixXQUFXO1lBQ2Z0WTtZQUNBRSx1QkFBdUI1ekIsS0FBS3NVLEdBQUcsQ0FBQyxHQUFHbVEsT0FBT3prQixLQUFLcVUsR0FBRyxDQUFDODVELE9BQU8vM0QsS0FBSyxFQUFFKzNELE9BQU85M0QsTUFBTTtZQUM5RTBvQixZQUFZb3ZDLE9BQU9uaUMsUUFBUSxDQUFDak4sVUFBVTtRQUN4QztRQUNBLElBQUlvdkMsT0FBT25pQyxRQUFRLENBQUNuWSxZQUFZLEVBQUU7WUFDaENtWSxTQUFTblksWUFBWSxHQUFHczZDLE9BQU9uaUMsUUFBUSxDQUFDblksWUFBWTtRQUN0RDtRQUNBLE1BQU15NkMsaUJBQWlCMzJCLGVBQWU5cUIsUUFBUTtRQUM5QyxJQUFJc2hELE9BQU9uaUMsUUFBUSxDQUFDdFQsUUFBUSxJQUFJNDFDLGdCQUFnQjtZQUM5Q3RpQyxTQUFTdFQsUUFBUSxHQUFHeTFDLE9BQU9uaUMsUUFBUSxDQUFDdFQsUUFBUTtZQUM1Q3NULFNBQVN1aUMsZUFBZSxHQUFHSixPQUFPbmlDLFFBQVEsQ0FBQ3RULFFBQVE7UUFDckQ7UUFDQTFFLFVBQVVwNkIsSUFBSSxDQUFDb3lDO0lBQ2pCO0lBQ0EsaURBQWlEO0lBQ2pELElBQUl3UixtQkFBbUJPLHVCQUF1QixPQUFPO1FBQ25ELElBQUl5d0IsZUFBZTM3RTtRQUNuQm1oQyxVQUFVcGtDLE9BQU8sQ0FBQ284QyxDQUFBQTtZQUNoQixJQUFJLENBQUN3aUMsY0FBYztnQkFDakJBLGVBQWV4aUMsU0FBU25ZLFlBQVk7WUFDdEMsT0FBTyxJQUFJbVksU0FBU25ZLFlBQVksSUFBSW1ZLFNBQVNuWSxZQUFZLEdBQUcyNkMsY0FBYztnQkFDeEVBLGVBQWV4aUMsU0FBU25ZLFlBQVk7WUFDdEM7UUFDRjtRQUNBLElBQUk0NkMsYUFBYTtRQUNqQno2QyxVQUFVcGtDLE9BQU8sQ0FBQ284QyxDQUFBQTtZQUNoQixJQUFJNXZDO1lBQ0osSUFBSTR2QyxTQUFTblksWUFBWSxJQUFJMjZDLGNBQWM7Z0JBQ3pDLElBQUlDLFlBQVk7b0JBQ2RBLGFBQWE7b0JBQ2JyNEUsY0FBY0MsSUFBSSxDQUFDO2dCQUNyQjtnQkFDQUQsY0FBY0MsSUFBSSxDQUFDLGtDQUFtQ29GLE1BQU0sQ0FBQyxDQUFDVyxLQUFLNHZDLFNBQVN0WSxHQUFHLE1BQU0sUUFBUXQzQixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLFNBQVVYLE1BQU0sQ0FBQyt5RTtnQkFDdkl4aUMsU0FBU25ZLFlBQVksR0FBRzI2QztZQUMxQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPeDZDO0FBQ1Q7QUFDQSxjQUFjLEdBQ2QsU0FBU3k1QyxZQUFZRCxPQUFPO0lBQzFCLElBQUksQ0FBQ0EsU0FBUztJQUNkLE9BQU9BLFFBQVFoK0QsSUFBSSxDQUFDLENBQUNwUyxHQUFHQztRQUN0QixNQUFNLEVBQ0oydUMsVUFBVTBpQyxJQUFJLEVBQ2YsR0FBR3R4RTtRQUNKLE1BQU0sRUFDSjR1QyxVQUFVMmlDLElBQUksRUFDZixHQUFHdHhFO1FBQ0osSUFBSXF4RSxLQUFLM3ZDLFVBQVUsR0FBRzR2QyxLQUFLNXZDLFVBQVUsRUFBRTtZQUNyQyxPQUFPO1FBQ1Q7UUFDQSxJQUFJMnZDLEtBQUszdkMsVUFBVSxHQUFHNHZDLEtBQUs1dkMsVUFBVSxFQUFFLE9BQU8sQ0FBQztRQUMvQyxJQUFJMnZDLEtBQUszdkMsVUFBVSxLQUFLNHZDLEtBQUs1dkMsVUFBVSxJQUFJMnZDLEtBQUs3NkMsWUFBWSxJQUFJODZDLEtBQUs5NkMsWUFBWSxFQUFFO1lBQ2pGLE9BQU82NkMsS0FBSzc2QyxZQUFZLEdBQUc4NkMsS0FBSzk2QyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3REO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFDQSxjQUFjLEdBQ2QsTUFBTXk1QztJQUNKNXdFLFlBQVl5d0UsZUFBZSxDQUFFO1FBQzNCLE1BQU15QixVQUFVekIsZ0JBQWdCejdELEtBQUssQ0FBQztRQUN0QyxJQUFJLENBQUNrOUQsU0FBUztZQUNaLE1BQU0sSUFBSWozRSxNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDNDFFLE9BQU8sR0FBR2pqRSxTQUFTc2tFLE9BQU8sQ0FBQyxFQUFFO1FBQ2xDLElBQUksQ0FBQ0MsUUFBUSxHQUFHdmtFLFNBQVNza0UsT0FBTyxDQUFDLEVBQUU7UUFDbkMsSUFBSUEsUUFBUTE3RSxNQUFNLEdBQUcsR0FBRztZQUN0QixPQUFRMDdFLE9BQU8sQ0FBQyxFQUFFO2dCQUNoQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSCxJQUFJLENBQUNFLE1BQU0sR0FBR0YsT0FBTyxDQUFDLEVBQUU7WUFDNUI7UUFDRjtJQUNGO0lBQ0ExdUUsV0FBVztRQUNULElBQUk5RDtRQUNKLE9BQU8sSUFBSVgsTUFBTSxDQUFDLElBQUksQ0FBQzh4RSxPQUFPLEVBQUUsS0FBSzl4RSxNQUFNLENBQUMsSUFBSSxDQUFDb3pFLFFBQVEsRUFBRXB6RSxNQUFNLENBQUMsQ0FBQ1csS0FBSyxJQUFJLENBQUMweUUsTUFBTSxNQUFNLFFBQVExeUUsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDeEg7QUFDRjtBQUVBLE1BQU0yeUUsc0NBQXNDO0FBQzVDLE1BQU16Qyx3QkFBd0J2b0I7SUFDNUI7Ozs7O0dBS0MsR0FDRHJuRCxZQUFZaTNDLFVBQVUsRUFBRWhzQixXQUFXLENBQUU7UUFDbkMsSUFBSXM4QixvQkFBb0J6eEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDNUYsSUFBSW9oRCxnQkFBZ0JwaEQsVUFBVVUsTUFBTSxHQUFHLElBQUlWLFNBQVMsQ0FBQyxFQUFFLEdBQUdLO1FBQzFELEtBQUssQ0FBQzhnRCxZQUFZRCxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLEVBQUUxdEIsYUFBYXM4QixtQkFBbUJyUTtRQUNwRSxhQUFhLEdBQ2IsSUFBSSxDQUFDdkQsZUFBZSxHQUFHLElBQUloc0I7UUFDM0IsSUFBSSxDQUFDa25ELGFBQWEsR0FBRyxJQUFNdnVELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMwUCxNQUFNLEVBQUU7b0JBQ2hCLElBQUksQ0FBQ3duQixlQUFlLEdBQUc7b0JBQ3ZCO2dCQUNGO2dCQUNBLElBQUlwdUI7Z0JBQ0osSUFBSTtvQkFDRkEsUUFBUSxNQUFNLElBQUksQ0FBQzBsRCxjQUFjO2dCQUNuQyxFQUFFLE9BQU8zN0UsR0FBRztvQkFDVixJQUFJLENBQUM0QixHQUFHLENBQUM2c0IsS0FBSyxDQUFDLG9DQUFvQ3R1QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzt3QkFDbkd0MkIsT0FBT3p1QjtvQkFDVDtvQkFDQTtnQkFDRjtnQkFDQSxNQUFNbS9FLFdBQVcsSUFBSTNxRCxJQUFJeUIsTUFBTWx2QixHQUFHLENBQUNtUCxDQUFBQSxJQUFLO3dCQUFDQSxFQUFFMnRCLEdBQUc7d0JBQUUzdEI7cUJBQUU7Z0JBQ2xELElBQUksSUFBSSxDQUFDaWxFLFNBQVMsRUFBRTtvQkFDbEIsSUFBSWlFLGVBQWU7b0JBQ25CRCxTQUFTcC9FLE9BQU8sQ0FBQyxDQUFDbVcsR0FBRzhEO3dCQUNuQixJQUFJek47d0JBQ0osTUFBTStHLE9BQU8sQ0FBQy9HLEtBQUssSUFBSSxDQUFDNHVFLFNBQVMsTUFBTSxRQUFRNXVFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlMLEdBQUcsQ0FBQ3VaO3dCQUMvRW9sRSxnQkFBZ0JuRSxlQUFlL2tFLEdBQUc1QztvQkFDcEM7b0JBQ0EsSUFBSSxDQUFDK3dDLGVBQWUsR0FBRys2QjtnQkFDekI7Z0JBQ0EsSUFBSSxDQUFDakUsU0FBUyxHQUFHZ0U7WUFDbkI7UUFDQSxJQUFJLENBQUNFLFVBQVUsR0FBRyxJQUFJanRCO0lBQ3hCO0lBQ0EsSUFBSWt0QixjQUFjO1FBQ2hCLElBQUksSUFBSSxDQUFDemlELE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3FILGFBQWEsR0FBR0MsU0FBUyxDQUFDOWdDLE1BQU0sR0FBRyxHQUFHO1lBQ25FLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBLGFBQWEsR0FDYjI0RSxhQUFhdUQsWUFBWSxFQUFFO1FBQ3pCLElBQUloekU7UUFDSixJQUFJLENBQUNnekUsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNqNEIsU0FBUztZQUNaO1FBQ0Y7UUFDQSwwQkFBMEI7UUFDMUIsc0NBQXNDO1FBQ3RDLE1BQU1yakIsU0FBUyxDQUFDMTNCLEtBQUssSUFBSSxDQUFDc3dCLE1BQU0sTUFBTSxRQUFRdHdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzIzQixhQUFhO1FBQ3ZGLElBQUlELFFBQVE7WUFDVixJQUFJLENBQUNFLFNBQVMsR0FBR0YsT0FBT0UsU0FBUztRQUNuQztRQUNBLElBQUksSUFBSSxDQUFDOGlCLGVBQWUsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxlQUFlLEdBQUdqTCxZQUFZO1lBQ2pDLElBQUksQ0FBQzAvQixhQUFhO1FBQ3BCLEdBQUdWO0lBQ0w7SUFDQTNnRCxPQUFPO1FBQ0wsSUFBSSxDQUFDc3FCLGlCQUFpQixDQUFDd1EsY0FBYztRQUNyQyxJQUFJLENBQUMzVSxlQUFlLENBQUN6Z0QsT0FBTyxDQUFDdXJELENBQUFBO1lBQzNCQSxVQUFVcEcsZ0JBQWdCLENBQUM3cUIsSUFBSTtRQUNqQztRQUNBLEtBQUssQ0FBQ0E7SUFDUjtJQUNBbTZCLGdCQUFnQjtRQUNkLE1BQU1vQyxTQUFTejJELE9BQU91SixNQUFNLENBQUMsTUFBTTtZQUNqQzhxRCxlQUFlO2dCQUNiL3pELEtBQUssSUFBTSxLQUFLLENBQUMrekQ7WUFDbkI7UUFDRjtRQUNBLElBQUlqb0QsSUFBSWl6RSxLQUFLbitELElBQUlDO1FBQ2pCLElBQUlDO1FBQ0osT0FBTzRMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXlwQyxPQUFPcEMsYUFBYSxDQUFDbHpELElBQUksQ0FBQyxJQUFJO1lBQ3BDLElBQUk7Z0JBQ0YsSUFBSyxJQUFJb3lFLEtBQUssTUFBTUMsS0FBS3ZsRCxjQUFjLElBQUksQ0FBQ295QixlQUFlLENBQUN0M0MsTUFBTSxLQUFLdTJFLElBQUlBLEtBQUssTUFBTTlMLEdBQUc3bEQsSUFBSSxJQUFJdmhCLEtBQUtrekUsR0FBR3p4RCxJQUFJLEVBQUUsQ0FBQ3poQixJQUFJbW5FLEtBQUssS0FBTTtvQkFDN0hweUQsS0FBS20rRCxHQUFHNTFFLEtBQUs7b0JBQ2I2cEUsS0FBSztvQkFDTCxNQUFNZ00sS0FBS3ArRDtvQkFDWCxNQUFNLENBQUNDLEtBQUttK0QsR0FBRzdpRCxNQUFNLE1BQU0sUUFBUXRiLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3MwQyxZQUFZLENBQUM7Z0JBQzlFO1lBQ0YsRUFBRSxPQUFPOHBCLE9BQU87Z0JBQ2RILE1BQU07b0JBQ0ovd0QsT0FBT2t4RDtnQkFDVDtZQUNGLFNBQVU7Z0JBQ1IsSUFBSTtvQkFDRixJQUFJLENBQUNqTSxNQUFNLENBQUNubkUsTUFBTzhVLENBQUFBLEtBQUtzeUQsR0FBR2lNLE1BQU0sR0FBRyxNQUFNditELEdBQUcvZixJQUFJLENBQUNxeUU7Z0JBQ3BELFNBQVU7b0JBQ1IsSUFBSTZMLEtBQUssTUFBTUEsSUFBSS93RCxLQUFLO2dCQUMxQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBaW1DLGlCQUFpQjtRQUNmLE1BQU1rQyxTQUFTejJELE9BQU91SixNQUFNLENBQUMsTUFBTTtZQUNqQ2dyRCxnQkFBZ0I7Z0JBQ2RqMEQsS0FBSyxJQUFNLEtBQUssQ0FBQ2kwRDtZQUNuQjtRQUNGO1FBQ0EsSUFBSW5vRCxJQUFJc3pFLEtBQUt4K0QsSUFBSUM7UUFDakIsSUFBSUM7UUFDSixPQUFPNEwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNeXBDLE9BQU9sQyxjQUFjLENBQUNwekQsSUFBSSxDQUFDLElBQUk7WUFDckMsSUFBSTtnQkFDRixJQUFLLElBQUlveUUsS0FBSyxNQUFNQyxLQUFLdmxELGNBQWMsSUFBSSxDQUFDb3lCLGVBQWUsQ0FBQ3QzQyxNQUFNLEtBQUt1MkUsSUFBSUEsS0FBSyxNQUFNOUwsR0FBRzdsRCxJQUFJLElBQUl2aEIsS0FBS2t6RSxHQUFHenhELElBQUksRUFBRSxDQUFDemhCLElBQUltbkUsS0FBSyxLQUFNO29CQUM3SHB5RCxLQUFLbStELEdBQUc1MUUsS0FBSztvQkFDYjZwRSxLQUFLO29CQUNMLE1BQU1nTSxLQUFLcCtEO29CQUNYLE1BQU0sQ0FBQ0MsS0FBS20rRCxHQUFHN2lELE1BQU0sTUFBTSxRQUFRdGIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHczBDLFlBQVksQ0FBQzZwQixHQUFHeDZCLGdCQUFnQjtnQkFDakc7WUFDRixFQUFFLE9BQU80NkIsT0FBTztnQkFDZEQsTUFBTTtvQkFDSnB4RCxPQUFPcXhEO2dCQUNUO1lBQ0YsU0FBVTtnQkFDUixJQUFJO29CQUNGLElBQUksQ0FBQ3BNLE1BQU0sQ0FBQ25uRSxNQUFPOFUsQ0FBQUEsS0FBS3N5RCxHQUFHaU0sTUFBTSxHQUFHLE1BQU12K0QsR0FBRy9mLElBQUksQ0FBQ3F5RTtnQkFDcEQsU0FBVTtvQkFDUixJQUFJa00sS0FBSyxNQUFNQSxJQUFJcHhELEtBQUs7Z0JBQzFCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EwbkMsT0FBTztRQUNMLE1BQU1TLFNBQVN6MkQsT0FBT3VKLE1BQU0sQ0FBQyxNQUFNO1lBQ2pDeXNELE1BQU07Z0JBQ0oxMUQsS0FBSyxJQUFNLEtBQUssQ0FBQzAxRDtZQUNuQjtRQUNGO1FBQ0EsT0FBT2hwQyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0ycEMsU0FBUyxNQUFNLElBQUksQ0FBQy9CLFFBQVEsQ0FBQ3ZDLElBQUk7WUFDdkMsSUFBSTtnQkFDRixJQUFJLElBQUksQ0FBQ2owQyxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQ2dOLGNBQWMsRUFBRTtvQkFDL0QsSUFBSSxDQUFDMXpELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyx5QkFBeUIsSUFBSSxDQUFDd2hELFVBQVU7b0JBQ3ZELDhEQUE4RDtvQkFDOUQsSUFBSSxDQUFDSixpQkFBaUIsQ0FBQ3RxQixJQUFJO2dCQUM3QjtnQkFDQSxNQUFNdThCLE9BQU9ULElBQUksQ0FBQzcwRCxJQUFJLENBQUMsSUFBSTtnQkFDM0IsT0FBTyxJQUFJO1lBQ2IsU0FBVTtnQkFDUncxRDtZQUNGO1FBQ0Y7SUFDRjtJQUNBVCxTQUFTO1FBQ1AsTUFBTU8sU0FBU3oyRCxPQUFPdUosTUFBTSxDQUFDLE1BQU07WUFDakMyc0QsUUFBUTtnQkFDTjUxRCxLQUFLLElBQU0sS0FBSyxDQUFDNDFEO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPbHBDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTTJwQyxTQUFTLE1BQU0sSUFBSSxDQUFDL0IsUUFBUSxDQUFDdkMsSUFBSTtZQUN2QyxJQUFJO2dCQUNGLElBQUksSUFBSSxDQUFDajBDLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDeUQsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDZ04sY0FBYyxFQUFFO29CQUMvRCxJQUFJLENBQUMxekQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDRCQUE0QixJQUFJLENBQUN3aEQsVUFBVTtvQkFDMUQsTUFBTSxJQUFJLENBQUMrMkIsWUFBWTtnQkFDekI7Z0JBQ0EsTUFBTWxsQixPQUFPUCxNQUFNLENBQUMvMEQsSUFBSSxDQUFDLElBQUk7Z0JBQzdCLE9BQU8sSUFBSTtZQUNiLFNBQVU7Z0JBQ1J3MUQ7WUFDRjtRQUNGO0lBQ0Y7SUFDQVYsY0FBYzl2QyxLQUFLLEVBQUU7UUFDbkIsS0FBSyxDQUFDOHZDLGNBQWM5dkM7UUFDcEIsS0FBSyxNQUFNbzVELE1BQU0sSUFBSSxDQUFDbC9CLGVBQWUsQ0FBQ3QzQyxNQUFNLEdBQUk7WUFDOUN3MkUsR0FBR3g2QixnQkFBZ0IsQ0FBQzNnQyxPQUFPLEdBQUcsQ0FBQytCO1FBQ2pDO0lBQ0Y7SUFDQXExRCxpQkFBaUI7UUFDZixJQUFJcHZFO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBRSxFQUFDNWdCLEtBQUssSUFBSSxDQUFDc3dCLE1BQU0sTUFBTSxRQUFRdHdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR294QixRQUFRLEdBQUc7Z0JBQzFFLE9BQU8sRUFBRTtZQUNYO1lBQ0EsTUFBTW9pRCxRQUFRLEVBQUU7WUFDaEIsTUFBTTlwRCxRQUFRLE1BQU0sSUFBSSxDQUFDNEcsTUFBTSxDQUFDYyxRQUFRO1lBQ3hDMUgsTUFBTWwyQixPQUFPLENBQUNzSixDQUFBQTtnQkFDWixJQUFJa0Q7Z0JBQ0osSUFBSWxELEVBQUV5QixJQUFJLEtBQUssZ0JBQWdCO29CQUM3QixNQUFNazFFLEtBQUs7d0JBQ1RsMUUsTUFBTTt3QkFDTnMwQixVQUFVLzFCLEVBQUU4c0IsRUFBRTt3QkFDZDhwRCxhQUFhNTJFLEVBQUU0MkUsV0FBVzt3QkFDMUJDLFlBQVk3MkUsRUFBRTYyRSxVQUFVO3dCQUN4QkMsVUFBVTkyRSxFQUFFODJFLFFBQVE7d0JBQ3BCQyxVQUFVLzJFLEVBQUUrMkUsUUFBUTt3QkFDcEJDLFdBQVdoM0UsRUFBRWczRSxTQUFTO3dCQUN0QmxFLGFBQWE5eUUsRUFBRTh5RSxXQUFXO3dCQUMxQlosV0FBV2x5RSxFQUFFa3lFLFNBQVM7d0JBQ3RCK0UsWUFBWWozRSxFQUFFaTNFLFVBQVU7d0JBQ3hCamlELFdBQVdoMUIsRUFBRWcxQixTQUFTO3dCQUN0QndGLEtBQUssQ0FBQ3QzQixLQUFLbEQsRUFBRXc2QixHQUFHLE1BQU0sUUFBUXQzQixPQUFPLEtBQUssSUFBSUEsS0FBS2xELEVBQUU4c0IsRUFBRTt3QkFDdkRvcUQsMEJBQTBCbDNFLEVBQUVrM0Usd0JBQXdCO3dCQUNwREMseUJBQXlCbjNFLEVBQUVtM0UsdUJBQXVCO3dCQUNsREMsb0NBQW9DcDNFLEVBQUVvM0Usa0NBQWtDO29CQUMxRTtvQkFDQSxpREFBaUQ7b0JBQ2pELE1BQU1sakUsSUFBSTBZLE1BQU14MUIsR0FBRyxDQUFDNEksRUFBRW14RCxRQUFRO29CQUM5QixJQUFJajlDLEdBQUc7d0JBQ0x5aUUsR0FBRzNELE1BQU0sR0FBRzkrRCxFQUFFOCtELE1BQU07d0JBQ3BCMkQsR0FBR3QxRCxXQUFXLEdBQUduTixFQUFFbU4sV0FBVzt3QkFDOUJzMUQsR0FBRzVELGFBQWEsR0FBRzcrRCxFQUFFNitELGFBQWE7b0JBQ3BDO29CQUNBMkQsTUFBTWgyRSxJQUFJLENBQUNpMkU7Z0JBQ2I7WUFDRjtZQUNBLE9BQU9EO1FBQ1Q7SUFDRjtJQUNBVyxxQkFBcUJDLFVBQVUsRUFBRTtRQUMvQixNQUFNcitCLFlBQVksRUFBRTtRQUNwQixJQUFLLElBQUlzK0IsSUFBSTU5RCxhQUFhbUUsR0FBRyxFQUFFeTVELEtBQUs1OUQsYUFBYTY5RCxJQUFJLEVBQUVELEtBQUssRUFBRztZQUM3RHQrQixVQUFVdjRDLElBQUksQ0FBQyxJQUFJcTRDLGtCQUFrQjtnQkFDbkNsN0IsU0FBUzA1RDtnQkFDVHI4RCxTQUFTcThELEtBQUtEO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJLENBQUMvK0UsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDJDQUEyQ3FJLE1BQU0sQ0FBQyswRSxhQUFhLElBQUksQ0FBQzU3QixVQUFVO1FBQzdGLElBQUksQ0FBQys3QixtQkFBbUIsQ0FBQ3grQjtJQUMzQjtJQUNBdTVCLFlBQVloakQsUUFBUSxFQUFFO1FBQ3BCLE9BQU8xTCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDZ25DLFlBQVksQ0FBQ3Q3QixRQUFRLEtBQUtBLFlBQVksSUFBSSxDQUFDOHJCLGlCQUFpQixDQUFDMWlCLFdBQVcsR0FBR3BKLFFBQVEsS0FBS2k2QixpQkFBaUJqNkIsV0FBVztnQkFDM0gsT0FBTztZQUNUO1lBQ0EsSUFBSSxDQUFDczdCLFlBQVksQ0FBQ3Q3QixRQUFRLEdBQUdBO1lBQzdCLG9FQUFvRTtZQUNwRSwwQkFBMEI7WUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQ29yQixPQUFPLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSxDQUFDNjNCLFlBQVk7WUFDekI7WUFDQSxPQUFPLElBQUksQ0FBQzczQixPQUFPLElBQUk2TyxpQkFBaUJqNkIsY0FBYyxJQUFJLENBQUM4ckIsaUJBQWlCLENBQUMxaUIsV0FBVyxHQUFHcEosUUFBUTtRQUNyRztJQUNGO0lBQ0FpakQsYUFBYWp4RSxPQUFPLEVBQUU7UUFDcEIsSUFBSTBCLElBQUl3MEUsS0FBSzEvRCxJQUFJQztRQUNqQixPQUFPNkwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJMks7WUFDSixJQUFJanRCLFNBQVM7Z0JBQ1gsTUFBTTByRCxvQkFBb0IvTSxzQkFBc0I7b0JBQzlDdHhCLE9BQU9ydEI7Z0JBQ1Q7Z0JBQ0EsSUFBSSxPQUFPMHJELGtCQUFrQnIrQixLQUFLLEtBQUssV0FBVztvQkFDaERKLGNBQWN5K0Isa0JBQWtCcitCLEtBQUs7Z0JBQ3ZDO1lBQ0Y7WUFDQSxNQUFNLElBQUksQ0FBQzA5QixPQUFPLENBQUM5OUI7WUFDbkIsSUFBSTtnQkFDRixJQUFLLElBQUl2VyxLQUFLLE1BQU1teUQsS0FBS3RsRCxjQUFjLElBQUksQ0FBQ295QixlQUFlLENBQUN0M0MsTUFBTSxLQUFLeXFFLElBQUlBLEtBQUssTUFBTUQsR0FBRzVsRCxJQUFJLElBQUl2aEIsS0FBS29uRSxHQUFHM2xELElBQUksRUFBRSxDQUFDemhCLElBQUlnVixLQUFLLEtBQU07b0JBQzdIRCxLQUFLcXlELEdBQUc5cEUsS0FBSztvQkFDYjBYLEtBQUs7b0JBQ0wsTUFBTW0rRCxLQUFLcCtEO29CQUNYLElBQUlvK0QsR0FBRzdpRCxNQUFNLEVBQUU7d0JBQ2I2aUQsR0FBR3g2QixnQkFBZ0IsR0FBRyxJQUFJLENBQUNBLGdCQUFnQixDQUFDeDZDLEtBQUs7d0JBQ2pELE1BQU1nMUUsR0FBRzdpRCxNQUFNLENBQUNnNUIsWUFBWSxDQUFDNnBCLEdBQUd4NkIsZ0JBQWdCO29CQUNsRDtnQkFDRjtZQUNGLEVBQUUsT0FBTzg3QixPQUFPO2dCQUNkRCxNQUFNO29CQUNKdHlELE9BQU91eUQ7Z0JBQ1Q7WUFDRixTQUFVO2dCQUNSLElBQUk7b0JBQ0YsSUFBSSxDQUFDei9ELE1BQU0sQ0FBQ2hWLE1BQU84VSxDQUFBQSxLQUFLcXlELEdBQUdrTSxNQUFNLEdBQUcsTUFBTXYrRCxHQUFHL2YsSUFBSSxDQUFDb3lFO2dCQUNwRCxTQUFVO29CQUNSLElBQUlxTixLQUFLLE1BQU1BLElBQUl0eUQsS0FBSztnQkFDMUI7WUFDRjtRQUNGO0lBQ0Y7SUFDQTBvQyxhQUFhNUIsU0FBUyxFQUFFO1FBQ3RCLElBQUk2Qiw2QkFBNkJ6MEQsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDckcsTUFBTWkwRCxTQUFTejJELE9BQU91SixNQUFNLENBQUMsTUFBTTtZQUNqQ3l0RCxjQUFjO2dCQUNaMTJELEtBQUssSUFBTSxLQUFLLENBQUMwMkQ7WUFDbkI7UUFDRjtRQUNBLElBQUk1cUQsSUFBSTAwRSxLQUFLNS9ELElBQUlDO1FBQ2pCLElBQUlDLElBQUlteUQ7UUFDUixPQUFPdm1ELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXlwQyxPQUFPTyxZQUFZLENBQUM3MUQsSUFBSSxDQUFDLElBQUksRUFBRWkwRCxXQUFXNkI7WUFDaEQsSUFBSSxDQUFDNzFDLEtBQUssSUFBSSxDQUFDZzBDLFNBQVMsTUFBTSxRQUFRaDBDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2kwQyxjQUFjLEVBQUU7Z0JBQ2hGLElBQUk7b0JBQ0YsSUFBSyxJQUFJbWUsS0FBSyxNQUFNOEwsS0FBS3J4RCxjQUFjLElBQUksQ0FBQ295QixlQUFlLENBQUN0M0MsTUFBTSxLQUFLZzRFLElBQUlBLEtBQUssTUFBTXpCLEdBQUczeEQsSUFBSSxJQUFJdmhCLEtBQUsyMEUsR0FBR2x6RCxJQUFJLEVBQUUsQ0FBQ3poQixJQUFJb25FLEtBQUssS0FBTTt3QkFDN0hyeUQsS0FBSzQvRCxHQUFHcjNFLEtBQUs7d0JBQ2I4cEUsS0FBSzt3QkFDTCxNQUFNK0wsS0FBS3ArRDt3QkFDWCxNQUFNLENBQUNveUQsS0FBS2dNLEdBQUc3aUQsTUFBTSxNQUFNLFFBQVE2MkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHN2QsWUFBWSxDQUFDLElBQUksQ0FBQ04sU0FBUyxDQUFDQyxjQUFjO29CQUMzRztnQkFDRixFQUFFLE9BQU8yckIsT0FBTztvQkFDZEYsTUFBTTt3QkFDSnh5RCxPQUFPMHlEO29CQUNUO2dCQUNGLFNBQVU7b0JBQ1IsSUFBSTt3QkFDRixJQUFJLENBQUN4TixNQUFNLENBQUNwbkUsTUFBTzhVLENBQUFBLEtBQUtvK0QsR0FBR0csTUFBTSxHQUFHLE1BQU12K0QsR0FBRy9mLElBQUksQ0FBQ20rRTtvQkFDcEQsU0FBVTt3QkFDUixJQUFJd0IsS0FBSyxNQUFNQSxJQUFJeHlELEtBQUs7b0JBQzFCO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EyeUQsa0JBQWtCdjNDLEtBQUssRUFBRTFGLFNBQVMsRUFBRTtRQUNsQyxJQUFJLElBQUksQ0FBQ3FjLGVBQWUsQ0FBQzMvQixHQUFHLENBQUNncEIsUUFBUTtZQUNuQyxNQUFNLElBQUkvaEMsTUFBTSxHQUFHOEQsTUFBTSxDQUFDaStCLE9BQU87UUFDbkM7UUFDQSxNQUFNdzNDLHFCQUFxQjtZQUN6QngzQztZQUNBcWIsa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUN4NkMsS0FBSztZQUM3Q215QixRQUFRNzVCO1lBQ1JtaEM7UUFDRjtRQUNBLElBQUksQ0FBQ3FjLGVBQWUsQ0FBQ3R0QyxHQUFHLENBQUMyMkIsT0FBT3czQztRQUNoQyxPQUFPQTtJQUNUO0lBQ0E3Six3QkFBd0IzdEMsS0FBSyxFQUFFaE4sTUFBTSxFQUFFO1FBQ3JDLE1BQU13a0QscUJBQXFCLElBQUksQ0FBQzdnQyxlQUFlLENBQUMvL0MsR0FBRyxDQUFDb3BDO1FBQ3BELElBQUksQ0FBQ3czQyxvQkFBb0I7WUFDdkI7UUFDRjtRQUNBQSxtQkFBbUJ4a0QsTUFBTSxHQUFHQTtRQUM1QixrRkFBa0Y7UUFDbEYsd0RBQXdEO1FBQ3hEc2UsV0FBVztZQUNULElBQUksSUFBSSxDQUFDcUgsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQzgrQixtQkFBbUIsQ0FBQyxJQUFJLENBQUM5K0IsZ0JBQWdCO1lBQ2hEO1FBQ0YsR0FBRzA4QjtJQUNMO0lBQ0E7Ozs7R0FJQyxHQUNEb0Msb0JBQW9CMTZELE1BQU0sRUFBRTtRQUMxQixJQUFJcmEsSUFBSWcxRSxVQUFVQztRQUNsQixJQUFJbmdFLElBQUlvZ0UsS0FBS25nRSxJQUFJQztRQUNqQixPQUFPNEwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLENBQUN2ckIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDZCQUE2QnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUM1Rm4rQjtnQkFDQTg2RCxjQUFjLElBQUksQ0FBQzczQyxLQUFLO1lBQzFCO1lBQ0EsMERBQTBEO1lBQzFELElBQUksQ0FBQyxJQUFJLENBQUNBLEtBQUssSUFBSWpqQixPQUFPdmpCLE1BQU0sR0FBRyxHQUFHO2dCQUNwQyxNQUFNLElBQUksQ0FBQ3k5RSxtQkFBbUIsQ0FBQ2w2RCxNQUFNLENBQUMsRUFBRSxDQUFDMDdCLFNBQVM7Z0JBQ2xELE9BQU8sRUFBRTtZQUNYO1lBQ0EsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRzU3QjtZQUN4QixNQUFNKzZELFlBQVksRUFBRTtZQUNwQixJQUFJO2dCQUNGLElBQUtwMUUsS0FBSyxNQUFNZzFFLFdBQVduekQsY0FBY3hILFNBQVM0NkQsYUFBYSxNQUFNRCxTQUFTenpELElBQUksSUFBSXpNLEtBQUttZ0UsV0FBV3h6RCxJQUFJLEVBQUUsQ0FBQzNNLElBQUk5VSxLQUFLLEtBQU07b0JBQzFIZ1YsS0FBS2lnRSxXQUFXMzNFLEtBQUs7b0JBQ3JCMEMsS0FBSztvQkFDTCxNQUFNczlCLFFBQVF0b0I7b0JBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ3NvQixLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLLEtBQUtBLE1BQU1BLEtBQUssRUFBRTt3QkFDN0MsTUFBTSxJQUFJLENBQUNpM0MsbUJBQW1CLENBQUNqM0MsTUFBTXlZLFNBQVM7b0JBQ2hELE9BQU87d0JBQ0wsTUFBTSsrQixxQkFBcUIsSUFBSSxDQUFDN2dDLGVBQWUsQ0FBQy8vQyxHQUFHLENBQUNvcEMsTUFBTUEsS0FBSzt3QkFDL0QsSUFBSSxDQUFDam9DLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyw4QkFBOEJxSSxNQUFNLENBQUNpK0IsTUFBTUEsS0FBSyxHQUFHMXBDLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHOzRCQUNsSHM4Qjt3QkFDRjt3QkFDQSxJQUFJLENBQUNBLHNCQUFzQixDQUFDQSxtQkFBbUJ4a0QsTUFBTSxFQUFFOzRCQUNyRCxLQUFLLE1BQU0rakQsS0FBSy8yQyxNQUFNeVksU0FBUyxDQUFFO2dDQUMvQixJQUFJcytCLEVBQUVyOEQsT0FBTyxFQUFFO29DQUNibzlELFVBQVU1M0UsSUFBSSxDQUFDOC9CLE1BQU1BLEtBQUs7b0NBQzFCO2dDQUNGOzRCQUNGO3dCQUNGLE9BQU8sSUFBSXczQyxtQkFBbUJsOUMsU0FBUyxFQUFFOzRCQUN2QyxJQUFJLENBQUN2aUMsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLG9DQUFvQ3FJLE1BQU0sQ0FBQ2krQixNQUFNQSxLQUFLLEdBQUcsSUFBSSxDQUFDa2IsVUFBVTs0QkFDdkYsTUFBTTY4Qiw2QkFBNkJQLG1CQUFtQnhrRCxNQUFNLEVBQUV3a0QsbUJBQW1CbDlDLFNBQVMsRUFBRTBGLE1BQU15WSxTQUFTLEVBQUUsSUFBSSxDQUFDKzhCLFVBQVUsRUFBRSxJQUFJLENBQUN6OUUsR0FBRyxFQUFFLElBQUksQ0FBQ21qRCxVQUFVO3dCQUN6SjtvQkFDRjtnQkFDRjtZQUNGLEVBQUUsT0FBTzg4QixPQUFPO2dCQUNkSixNQUFNO29CQUNKaHpELE9BQU9vekQ7Z0JBQ1Q7WUFDRixTQUFVO2dCQUNSLElBQUk7b0JBQ0YsSUFBSSxDQUFDdDFFLE1BQU0sQ0FBQzhVLE1BQU9DLENBQUFBLEtBQUtpZ0UsU0FBUzNCLE1BQU0sR0FBRyxNQUFNdCtELEdBQUdoZ0IsSUFBSSxDQUFDaWdGO2dCQUMxRCxTQUFVO29CQUNSLElBQUlFLEtBQUssTUFBTUEsSUFBSWh6RCxLQUFLO2dCQUMxQjtZQUNGO1lBQ0EsT0FBT2t6RDtRQUNUO0lBQ0Y7SUFDQTs7O0dBR0MsR0FDRGIsb0JBQW9CeCtCLFNBQVMsRUFBRTtRQUM3QixPQUFPbjFCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDdnJCLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyw2QkFBNkJwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDNUZ6QztZQUNGO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3psQixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNzSCxTQUFTLEVBQUU7Z0JBQ25DO1lBQ0Y7WUFDQSxNQUFNeTlDLDZCQUE2QixJQUFJLENBQUMva0QsTUFBTSxFQUFFLElBQUksQ0FBQ3NILFNBQVMsRUFBRW1lLFdBQVcsSUFBSSxDQUFDKzhCLFVBQVUsRUFBRSxJQUFJLENBQUN6OUUsR0FBRyxFQUFFLElBQUksQ0FBQ21qRCxVQUFVO1FBQ3ZIO0lBQ0Y7SUFDQU4sNkJBQTZCO1FBQzNCLE1BQU1tUyxTQUFTejJELE9BQU91SixNQUFNLENBQUMsTUFBTTtZQUNqQys2Qyw0QkFBNEI7Z0JBQzFCaGtELEtBQUssSUFBTSxLQUFLLENBQUNna0Q7WUFDbkI7UUFDRjtRQUNBLE9BQU90M0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNeXBDLE9BQU9uUywwQkFBMEIsQ0FBQ25qRCxJQUFJLENBQUMsSUFBSTtZQUNqRCxJQUFJLENBQUNvc0QsWUFBWTtZQUNqQixJQUFJLElBQUksQ0FBQ3RKLGNBQWMsSUFBSSxJQUFJLENBQUM3bEMsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUN5RCxNQUFNLEVBQUU7Z0JBQzlELElBQUksQ0FBQzNELGlCQUFpQixDQUFDcGdDLE9BQU8sR0FBRztZQUNuQztRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNxOUQsNkJBQTZCL2tELE1BQU0sRUFBRWlsRCxlQUFlLEVBQUV4L0IsU0FBUyxFQUFFKzhCLFVBQVUsRUFBRXo5RSxHQUFHLEVBQUVtakQsVUFBVTtJQUNuRyxPQUFPNTNCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDckMsTUFBTTJwQyxTQUFTLE1BQU11b0IsV0FBVzdzQixJQUFJO1FBQ3BDNXdELElBQUkyQixLQUFLLENBQUMsZ0NBQWdDcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHNDZDLGFBQWE7WUFDckZsb0I7WUFDQXlsQjtZQUNBdy9CO1FBQ0Y7UUFDQSxJQUFJO1lBQ0YsTUFBTTc5QyxTQUFTcEgsT0FBT3FILGFBQWE7WUFDbkMsTUFBTSxFQUNKQyxTQUFTLEVBQ1YsR0FBR0Y7WUFDSixJQUFJLENBQUNFLFdBQVc7Z0JBQ2Q7WUFDRjtZQUNBLElBQUlBLFVBQVU5Z0MsTUFBTSxLQUFLeStFLGdCQUFnQnorRSxNQUFNLEVBQUU7Z0JBQy9DekIsSUFBSTJ0QixJQUFJLENBQUM7Z0JBQ1Q7WUFDRjtZQUNBLElBQUl3eUQsYUFBYTtZQUNqQjs7O2lHQUcyRixHQUMzRixNQUFNQyxrQkFBa0I7WUFDeEIsY0FBYyxHQUNkLElBQUlBLG1CQUFtQjc5QyxTQUFTLENBQUMsRUFBRSxDQUFDbTVDLGVBQWU7aUJBQVM7Z0JBQzFELCtCQUErQjtnQkFDL0JuNUMsVUFBVXBrQyxPQUFPLENBQUMsQ0FBQ284QyxVQUFVbmY7b0JBQzNCLElBQUl6d0I7b0JBQ0osSUFBSXMzQixNQUFNLENBQUN0M0IsS0FBSzR2QyxTQUFTdFksR0FBRyxNQUFNLFFBQVF0M0IsT0FBTyxLQUFLLElBQUlBLEtBQUs7b0JBQy9ELElBQUlzM0IsUUFBUSxJQUFJO3dCQUNkQSxNQUFNO29CQUNSO29CQUNBLE1BQU0zYyxVQUFVKzZELG1CQUFtQnArQztvQkFDbkMsTUFBTXErQyxvQkFBb0I1L0IsVUFBVXpwQyxJQUFJLENBQUMrbkUsQ0FBQUEsSUFBS0EsRUFBRTE1RCxPQUFPLEtBQUtBO29CQUM1RCxJQUFJLENBQUNnN0QsbUJBQW1CO3dCQUN0QjtvQkFDRjtvQkFDQSxJQUFJL2xDLFNBQVN0MEIsTUFBTSxLQUFLcTZELGtCQUFrQjM5RCxPQUFPLEVBQUU7d0JBQ2pEdzlELGFBQWE7d0JBQ2I1bEMsU0FBU3QwQixNQUFNLEdBQUdxNkQsa0JBQWtCMzlELE9BQU87d0JBQzNDM2lCLElBQUkyQixLQUFLLENBQUMsaUJBQWlCcUksTUFBTSxDQUFDczJFLGtCQUFrQmg3RCxPQUFPLEVBQUUsUUFBUXRiLE1BQU0sQ0FBQ3V3QyxTQUFTdDBCLE1BQU0sR0FBRyxZQUFZLGFBQWFrOUI7d0JBQ3ZILG1FQUFtRTt3QkFDbkUsdUVBQXVFO3dCQUN2RSxJQUFJK0MsYUFBYTs0QkFDZixJQUFJbzZCLGtCQUFrQjM5RCxPQUFPLEVBQUU7Z0NBQzdCNDNCLFNBQVNwWSxxQkFBcUIsR0FBRys5QyxlQUFlLENBQUM5a0QsSUFBSSxDQUFDK0cscUJBQXFCO2dDQUMzRW9ZLFNBQVNqTixVQUFVLEdBQUc0eUMsZUFBZSxDQUFDOWtELElBQUksQ0FBQ2tTLFVBQVU7Z0NBQ3JELGNBQWMsR0FDZGlOLFNBQVNuaEIsWUFBWSxHQUFHOG1ELGVBQWUsQ0FBQzlrRCxJQUFJLENBQUNoQyxZQUFZOzRCQUMzRCxPQUFPO2dDQUNMbWhCLFNBQVNwWSxxQkFBcUIsR0FBRztnQ0FDakNvWSxTQUFTak4sVUFBVSxHQUFHO2dDQUN0QixjQUFjLEdBQ2RpTixTQUFTbmhCLFlBQVksR0FBRzs0QkFDMUI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUkrbUQsWUFBWTtnQkFDZDk5QyxPQUFPRSxTQUFTLEdBQUdBO2dCQUNuQnZpQyxJQUFJMkIsS0FBSyxDQUFDLHFCQUFxQnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRzQ2QyxhQUFhO29CQUMxRTVnQixXQUFXRixPQUFPRSxTQUFTO2dCQUM3QjtnQkFDQSxNQUFNdEgsT0FBT3VILGFBQWEsQ0FBQ0g7WUFDN0I7UUFDRixTQUFVO1lBQ1I2eUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTbXJCLG1CQUFtQnArQyxHQUFHO0lBQzdCLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU83Z0IsYUFBYTY5RCxJQUFJO1FBQzFCLEtBQUs7WUFDSCxPQUFPNzlELGFBQWFtL0QsTUFBTTtRQUM1QixLQUFLO1lBQ0gsT0FBT24vRCxhQUFhbUUsR0FBRztRQUN6QjtZQUNFLE9BQU9uRSxhQUFhNjlELElBQUk7SUFDNUI7QUFDRjtBQUNBLFNBQVN1Qix5QkFBeUI3N0QsS0FBSyxFQUFFQyxNQUFNLEVBQUUyZCxTQUFTLEVBQUVrK0MsR0FBRztJQUM3RCxnQ0FBZ0M7SUFDaEMsSUFBSSxDQUFDbCtDLFdBQVc7UUFDZCxPQUFPO1lBQUMsSUFBSS9kLFdBQVc7Z0JBQ3JCYyxTQUFTbEUsYUFBYTY5RCxJQUFJO2dCQUMxQnQ2RDtnQkFDQUM7Z0JBQ0FZLFNBQVM7Z0JBQ1RDLE1BQU07WUFDUjtTQUFHO0lBQ0w7SUFDQSxJQUFJZzdELEtBQUs7UUFDUCxhQUFhO1FBQ2IsY0FBYyxHQUNkLE1BQU1DLGFBQWFuK0MsU0FBUyxDQUFDLEVBQUUsQ0FBQ201QyxlQUFlO1FBQy9DLE1BQU1FLEtBQUssSUFBSUMsZ0JBQWdCNkU7UUFDL0IsTUFBTW44RCxTQUFTLEVBQUU7UUFDakIsSUFBSyxJQUFJL2lCLElBQUksR0FBR0EsSUFBSW82RSxHQUFHRSxPQUFPLEVBQUV0NkUsS0FBSyxFQUFHO1lBQ3RDK2lCLE9BQU9wYyxJQUFJLENBQUMsSUFBSXFjLFdBQVc7Z0JBQ3pCYyxTQUFTbEUsYUFBYTY5RCxJQUFJLEdBQUd6OUU7Z0JBQzdCbWpCLE9BQU9wVyxLQUFLbVMsSUFBSSxDQUFDaUUsUUFBUXBXLEtBQUs2aEQsR0FBRyxDQUFDLEdBQUc1dUQ7Z0JBQ3JDb2pCLFFBQVFyVyxLQUFLbVMsSUFBSSxDQUFDa0UsU0FBU3JXLEtBQUs2aEQsR0FBRyxDQUFDLEdBQUc1dUQ7Z0JBQ3ZDZ2tCLFNBQVMrYyxTQUFTLENBQUMsRUFBRSxDQUFDK0ssVUFBVSxHQUFHLytCLEtBQUttUyxJQUFJLENBQUM2aEIsU0FBUyxDQUFDLEVBQUUsQ0FBQytLLFVBQVUsR0FBRy8rQixLQUFLNmhELEdBQUcsQ0FBQyxHQUFHNXVELE1BQU07Z0JBQ3pGaWtCLE1BQU07WUFDUjtRQUNGO1FBQ0EsT0FBT2xCO0lBQ1Q7SUFDQSxPQUFPZ2UsVUFBVXA5QixHQUFHLENBQUNvMUMsQ0FBQUE7UUFDbkIsSUFBSTV2QyxJQUFJOFUsSUFBSUM7UUFDWixNQUFNaWhFLFFBQVEsQ0FBQ2gyRSxLQUFLNHZDLFNBQVNwWSxxQkFBcUIsTUFBTSxRQUFReDNCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3JGLElBQUkyYSxVQUFVKzZELG1CQUFtQixDQUFDNWdFLEtBQUs4NkIsU0FBU3RZLEdBQUcsTUFBTSxRQUFReGlCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3RGLE9BQU8sSUFBSStFLFdBQVc7WUFDcEJjO1lBQ0FYLE9BQU9wVyxLQUFLbVMsSUFBSSxDQUFDaUUsUUFBUWc4RDtZQUN6Qi83RCxRQUFRclcsS0FBS21TLElBQUksQ0FBQ2tFLFNBQVMrN0Q7WUFDM0JuN0QsU0FBUyxDQUFDOUYsS0FBSzY2QixTQUFTak4sVUFBVSxNQUFNLFFBQVE1dEIsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDckUrRixNQUFNO1FBQ1I7SUFDRjtBQUNGO0FBRUEsTUFBTW03RCxvQkFBb0IzK0I7SUFDeEJoM0MsWUFBWWkzQyxVQUFVLEVBQUVyZ0MsR0FBRyxFQUFFdkssSUFBSSxFQUFFNlYsUUFBUSxFQUFFZzFCLGFBQWEsQ0FBRTtRQUMxRCxLQUFLLENBQUNELFlBQVk1cUMsTUFBTTZxQztRQUN4QixJQUFJLENBQUN0Z0MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3NMLFFBQVEsR0FBR0E7SUFDbEI7SUFDQSxjQUFjLEdBQ2QwekQsU0FBU244RCxLQUFLLEVBQUU7UUFDZCxJQUFJLElBQUksQ0FBQzI5QixPQUFPLEtBQUszOUIsT0FBTztZQUMxQixJQUFJLENBQUMyOUIsT0FBTyxHQUFHMzlCO1lBQ2YsSUFBSSxDQUFDcStCLGlCQUFpQixDQUFDcGdDLE9BQU8sR0FBRyxDQUFDK0I7WUFDbEMsSUFBSSxDQUFDZ0ssSUFBSSxDQUFDaEssUUFBUXMwQixXQUFXNmIsS0FBSyxHQUFHN2IsV0FBVzhiLE9BQU8sRUFBRSxJQUFJO1FBQy9EO0lBQ0Y7SUFDQSxjQUFjLEdBQ2Rnc0IsZUFBZXo3RCxNQUFNLEVBQUU7UUFDckIseURBQXlEO1FBQ3pELElBQUksQ0FBQ3NnQyxXQUFXLEdBQUd0Z0M7UUFDbkIsTUFBTTA3RCxnQkFBZ0I5bUQsQ0FBQUE7WUFDcEIsSUFBSUEsTUFBTXZGLEtBQUssS0FBSyxJQUFJLENBQUNxdUIsaUJBQWlCLEVBQUU7Z0JBQzFDMTlCLE9BQU9vTSxtQkFBbUIsQ0FBQyxlQUFlc3ZEO2dCQUMxQyxJQUFJLENBQUM1ekQsUUFBUSxHQUFHL3JCO2dCQUNoQixJQUFJLENBQUNxaEQsZUFBZSxHQUFHO2dCQUN2QixJQUFJLENBQUMvekIsSUFBSSxDQUFDc3FCLFdBQVdpYSxLQUFLLEVBQUUsSUFBSTtZQUNsQztRQUNGO1FBQ0E1dEMsT0FBT2tNLGdCQUFnQixDQUFDLGVBQWV3dkQ7SUFDekM7SUFDQW50RSxRQUFRO1FBQ04sSUFBSSxDQUFDd21FLFlBQVk7UUFDakIseURBQXlEO1FBQ3pELEtBQUssQ0FBQ2oxQjtJQUNSO0lBQ0Exc0IsT0FBTztRQUNMLElBQUksQ0FBQ3lzQixXQUFXO1FBQ2hCLHlEQUF5RDtRQUN6RCxLQUFLLENBQUNFO0lBQ1I7SUFDQTs7Ozs7R0FLQyxHQUNEaVEsb0JBQW9CO1FBQ2xCLElBQUkxcUQ7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFFLEVBQUM1Z0IsS0FBSyxJQUFJLENBQUN3aUIsUUFBUSxNQUFNLFFBQVF4aUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb3hCLFFBQVEsR0FBRztnQkFDNUU7WUFDRjtZQUNBLE1BQU11NUIsY0FBYyxNQUFNLElBQUksQ0FBQ25vQyxRQUFRLENBQUM0TyxRQUFRO1lBQ2hELE9BQU91NUI7UUFDVDtJQUNGO0lBQ0EsYUFBYSxHQUNiOGtCLGVBQWU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLzBCLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBR2pMLFlBQVksSUFBTSxJQUFJLENBQUM0bUMsZUFBZSxJQUFJNUg7UUFDbkU7SUFDRjtBQUNGO0FBRUEsTUFBTTZILHlCQUF5Qkw7SUFDN0IzMUUsWUFBWWkzQyxVQUFVLEVBQUVyZ0MsR0FBRyxFQUFFc0wsUUFBUSxFQUFFMGlDLFlBQVksRUFBRXF4QixXQUFXLEVBQUUvK0IsYUFBYSxDQUFFO1FBQy9FLEtBQUssQ0FBQ0QsWUFBWXJnQyxLQUFLb2dDLE1BQU0wQixJQUFJLENBQUMwQyxLQUFLLEVBQUVsNUIsVUFBVWcxQjtRQUNuRCxJQUFJLENBQUM2K0IsZUFBZSxHQUFHLElBQU16MUQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQzRCLFFBQVEsRUFBRTtvQkFDbEIsSUFBSSxDQUFDczFCLGVBQWUsR0FBRztvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsTUFBTXB1QixRQUFRLE1BQU0sSUFBSSxDQUFDOHNELGdCQUFnQjtnQkFDekMsSUFBSTlzRCxTQUFTLElBQUksQ0FBQ2tsRCxTQUFTLElBQUksSUFBSSxDQUFDcHNELFFBQVEsRUFBRTtvQkFDNUMsSUFBSSxDQUFDczFCLGVBQWUsR0FBRzQyQixlQUFlaGxELE9BQU8sSUFBSSxDQUFDa2xELFNBQVM7Z0JBQzdEO2dCQUNBLElBQUksQ0FBQ0EsU0FBUyxHQUFHbGxEO1lBQ25CO1FBQ0EsSUFBSSxDQUFDdzdCLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDdXhCLG1CQUFtQixHQUFHLEVBQUU7UUFDN0IsSUFBSUYsYUFBYTtZQUNmLElBQUksQ0FBQ0csTUFBTSxHQUFHSCxZQUFZanFELFFBQVE7UUFDcEM7SUFDRjtJQUNBOztHQUVDLEdBQ0RxcUQsVUFBVWp4QixNQUFNLEVBQUU7UUFDaEIsSUFBSTFsRDtRQUNKLEtBQUssTUFBTW1wRCxNQUFNLElBQUksQ0FBQzFSLGdCQUFnQixDQUFFO1lBQ3RDLElBQUksSUFBSSxDQUFDeU4sWUFBWSxFQUFFO2dCQUNwQmxsRCxDQUFBQSxLQUFLLElBQUksQ0FBQzQyRSxRQUFRLE1BQU0sUUFBUTUyRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxa0QsSUFBSSxDQUFDd3lCLGVBQWUsQ0FBQ254QixRQUFRLEdBQUc7WUFDL0YsT0FBTztnQkFDTHlELEdBQUd6RCxNQUFNLEdBQUdBO1lBQ2Q7UUFDRjtRQUNBLElBQUl0RSxpQkFBaUI7WUFDbkIsYUFBYTtZQUNiLElBQUksQ0FBQ2hKLGlCQUFpQixDQUFDMCtCLFVBQVUsQ0FBQ3B4QjtRQUNwQztRQUNBLElBQUksQ0FBQ3F4QixhQUFhLEdBQUdyeEI7SUFDdkI7SUFDQTs7R0FFQyxHQUNEc3hCLFlBQVk7UUFDVixJQUFJLElBQUksQ0FBQ0QsYUFBYSxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDQSxhQUFhO1FBQzNCO1FBQ0EsSUFBSTMxQixpQkFBaUI7WUFDbkIsMERBQTBEO1lBQzFELE9BQU87UUFDVDtRQUNBLElBQUk2MUIsZ0JBQWdCO1FBQ3BCLElBQUksQ0FBQ3gvQixnQkFBZ0IsQ0FBQ2prRCxPQUFPLENBQUNzbEQsQ0FBQUE7WUFDNUIsSUFBSUEsUUFBUTRNLE1BQU0sR0FBR3V4QixlQUFlO2dCQUNsQ0EsZ0JBQWdCbitCLFFBQVE0TSxNQUFNO1lBQ2hDO1FBQ0Y7UUFDQSxPQUFPdXhCO0lBQ1Q7SUFDQTs7O0dBR0MsR0FDREMsVUFBVTVxRCxRQUFRLEVBQUU7UUFDbEIsT0FBTzFMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDODFELE1BQU0sR0FBR3BxRDtZQUNkLE1BQU1uTCxRQUFRak8sR0FBRyxDQUFDLElBQUksQ0FBQ3VrQyxnQkFBZ0IsQ0FBQ2o5QyxHQUFHLENBQUM2L0MsQ0FBQUE7Z0JBQzFDLElBQUksQ0FBQ3FHLGtCQUFrQnJHLE1BQU07b0JBQzNCO2dCQUNGO2dCQUNBLGNBQWMsR0FDZCxPQUFPQSxJQUFJNjhCLFNBQVMsQ0FBQzVxRDtZQUN2QjtRQUNGO0lBQ0Y7SUFDQXVzQixPQUFPQyxPQUFPLEVBQUU7UUFDZCxNQUFNcStCLDZCQUE2QixJQUFJLENBQUMxL0IsZ0JBQWdCLENBQUMzZ0QsTUFBTSxLQUFLO1FBQ3BFLElBQUksQ0FBQ2dpRCxTQUFTO1lBQ1pBLFVBQVUsS0FBSyxDQUFDRDtRQUNsQixPQUFPO1lBQ0wsS0FBSyxDQUFDQSxPQUFPQztRQUNmO1FBQ0EsSUFBSSxJQUFJLENBQUM0OUIsTUFBTSxJQUFJaDJCLGtCQUFrQjVILFVBQVU7WUFDN0MsY0FBYyxHQUNkQSxRQUFRbytCLFNBQVMsQ0FBQyxJQUFJLENBQUNSLE1BQU07UUFDL0I7UUFDQSxJQUFJLElBQUksQ0FBQ3h4QixZQUFZLElBQUlpeUIsNEJBQTRCO1lBQ25ELElBQUksQ0FBQzloRixHQUFHLENBQUMyQixLQUFLLENBQUMsK0JBQStCLElBQUksQ0FBQ3doRCxVQUFVO1lBQzdELElBQUksQ0FBQzQrQixlQUFlLENBQUMsSUFBSSxDQUFDbHlCLFlBQVksRUFBRXBNO1lBQ3hDQSxRQUFRNE0sTUFBTSxHQUFHO1lBQ2pCNU0sUUFBUS8rQixLQUFLLEdBQUc7UUFDbEI7UUFDQSxJQUFJLElBQUksQ0FBQ2c5RCxhQUFhLEVBQUU7WUFDdEIsMEVBQTBFO1lBQzFFLElBQUksQ0FBQ0osU0FBUyxDQUFDLElBQUksQ0FBQ0ksYUFBYTtRQUNuQztRQUNBLE9BQU9qK0I7SUFDVDtJQUNBa0IsT0FBT2xCLE9BQU8sRUFBRTtRQUNkLElBQUlzQjtRQUNKLElBQUksQ0FBQ3RCLFNBQVM7WUFDWnNCLFdBQVcsS0FBSyxDQUFDSjtZQUNqQixJQUFJLENBQUNxOUIsa0JBQWtCO1FBQ3pCLE9BQU87WUFDTGo5QixXQUFXLEtBQUssQ0FBQ0osT0FBT2xCO1lBQ3hCLDhHQUE4RztZQUM5RyxnQ0FBZ0M7WUFDaEMsSUFBSSxJQUFJLENBQUNvTSxZQUFZLEVBQUU7Z0JBQ3JCLElBQUksSUFBSSxDQUFDek4sZ0JBQWdCLENBQUMzZ0QsTUFBTSxHQUFHLEdBQUc7b0JBQ3BDLElBQUksQ0FBQ3NnRixlQUFlLENBQUMsSUFBSSxDQUFDbHlCLFlBQVksRUFBRSxJQUFJLENBQUN6TixnQkFBZ0IsQ0FBQyxFQUFFO2dCQUNsRSxPQUFPO29CQUNMLElBQUksQ0FBQzQvQixrQkFBa0I7Z0JBQ3pCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9qOUI7SUFDVDtJQUNBOzs7R0FHQyxHQUNEczFCLGdCQUFnQnhxQixZQUFZLEVBQUU7UUFDNUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdBO1FBQ3BCLElBQUlBLGdCQUFnQixJQUFJLENBQUN6TixnQkFBZ0IsQ0FBQzNnRCxNQUFNLEdBQUcsR0FBRztZQUNwRCxJQUFJLENBQUNzZ0YsZUFBZSxDQUFDbHlCLGNBQWMsSUFBSSxDQUFDek4sZ0JBQWdCLENBQUMsRUFBRTtRQUM3RCxPQUFPLElBQUksQ0FBQ3lOLGNBQWM7WUFDeEIsSUFBSSxDQUFDbXlCLGtCQUFrQjtRQUN6QjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEQyxtQkFBbUJDLEtBQUssRUFBRTtRQUN4QixJQUFJLENBQUNkLG1CQUFtQixHQUFHYztRQUMzQixJQUFJLElBQUksQ0FBQzkvQixnQkFBZ0IsQ0FBQzNnRCxNQUFNLEdBQUcsS0FBSyxJQUFJLENBQUNvdUQsWUFBWSxFQUFFO1lBQ3pELElBQUksQ0FBQ2t5QixlQUFlLENBQUMsSUFBSSxDQUFDbHlCLFlBQVksRUFBRSxJQUFJLENBQUN6TixnQkFBZ0IsQ0FBQyxFQUFFO1FBQ2xFO0lBQ0Y7SUFDQTIvQixnQkFBZ0JoOEUsT0FBTyxFQUFFMDlDLE9BQU8sRUFBRTtRQUNoQyxJQUFJLENBQUN1K0Isa0JBQWtCO1FBQ3ZCLDJEQUEyRDtRQUMzRCxJQUFJLENBQUNHLFVBQVUsR0FBR3A4RSxRQUFReWlELHVCQUF1QixDQUFDL0UsUUFBUVMsU0FBUztRQUNuRSxJQUFJaytCLFdBQVcsSUFBSSxDQUFDRCxVQUFVO1FBQzlCLElBQUksQ0FBQ2YsbUJBQW1CLENBQUNqakYsT0FBTyxDQUFDa2tGLENBQUFBO1lBQy9CRCxTQUFTMzVCLE9BQU8sQ0FBQzQ1QjtZQUNqQkQsV0FBV0M7UUFDYjtRQUNBLElBQUksQ0FBQ2QsUUFBUSxHQUFHeDdFLFFBQVFrcEQsVUFBVTtRQUNsQ216QixTQUFTMzVCLE9BQU8sQ0FBQyxJQUFJLENBQUM4NEIsUUFBUTtRQUM5QixJQUFJLENBQUNBLFFBQVEsQ0FBQzk0QixPQUFPLENBQUMxaUQsUUFBUXU4RSxXQUFXO1FBQ3pDLElBQUksSUFBSSxDQUFDWixhQUFhLEVBQUU7WUFDdEIsSUFBSSxDQUFDSCxRQUFRLENBQUN2eUIsSUFBSSxDQUFDd3lCLGVBQWUsQ0FBQyxJQUFJLENBQUNFLGFBQWEsRUFBRSxHQUFHO1FBQzVEO1FBQ0Esd0RBQXdEO1FBQ3hELElBQUkzN0UsUUFBUTBkLEtBQUssS0FBSyxXQUFXO1lBQy9CMWQsUUFBUXc4RSxNQUFNLEdBQUdsMkQsSUFBSSxDQUFDO2dCQUNwQixJQUFJdG1CLFFBQVEwZCxLQUFLLEtBQUssV0FBVztvQkFDL0IsSUFBSSxDQUFDaUwsSUFBSSxDQUFDc3FCLFdBQVd3TCxtQkFBbUIsRUFBRSxJQUFJdCtDLE1BQU07Z0JBQ3REO1lBQ0YsR0FBR3U4QixLQUFLLENBQUNya0MsQ0FBQUE7Z0JBQ1AsSUFBSSxDQUFDc3dCLElBQUksQ0FBQ3NxQixXQUFXd0wsbUJBQW1CLEVBQUVwbUQ7WUFDNUM7UUFDRjtJQUNGO0lBQ0E0akYscUJBQXFCO1FBQ25CLElBQUlyM0UsSUFBSThVO1FBQ1A5VSxDQUFBQSxLQUFLLElBQUksQ0FBQzQyRSxRQUFRLE1BQU0sUUFBUTUyRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3bEUsVUFBVTtRQUN0RTF3RCxDQUFBQSxLQUFLLElBQUksQ0FBQzBpRSxVQUFVLE1BQU0sUUFBUTFpRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwd0QsVUFBVTtRQUN6RSxJQUFJLENBQUNvUixRQUFRLEdBQUduZ0Y7UUFDaEIsSUFBSSxDQUFDK2dGLFVBQVUsR0FBRy9nRjtJQUNwQjtJQUNBKy9FLG1CQUFtQjtRQUNqQixPQUFPNTFELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQzRCLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQ0EsUUFBUSxDQUFDNE8sUUFBUSxFQUFFO2dCQUM3QztZQUNGO1lBQ0EsTUFBTTFILFFBQVEsTUFBTSxJQUFJLENBQUNsSCxRQUFRLENBQUM0TyxRQUFRO1lBQzFDLElBQUl5bUQ7WUFDSm51RCxNQUFNbDJCLE9BQU8sQ0FBQ3NKLENBQUFBO2dCQUNaLElBQUlBLEVBQUV5QixJQUFJLEtBQUssZUFBZTtvQkFDNUJzNUUsZ0JBQWdCO3dCQUNkdDVFLE1BQU07d0JBQ051ekIsV0FBV2gxQixFQUFFZzFCLFNBQVM7d0JBQ3RCZytDLFFBQVFoekUsRUFBRWd6RSxNQUFNO3dCQUNoQmYsZUFBZWp5RSxFQUFFaXlFLGFBQWE7d0JBQzlCK0ksa0JBQWtCaDdFLEVBQUVnN0UsZ0JBQWdCO3dCQUNwQ0MsbUJBQW1CajdFLEVBQUVpN0UsaUJBQWlCO3dCQUN0Q0Msd0JBQXdCbDdFLEVBQUVrN0Usc0JBQXNCO3dCQUNoREMseUJBQXlCbjdFLEVBQUVtN0UsdUJBQXVCO3dCQUNsREMsa0JBQWtCcDdFLEVBQUVvN0UsZ0JBQWdCO3dCQUNwQ0Msc0JBQXNCcjdFLEVBQUVxN0Usb0JBQW9CO29CQUM5QztnQkFDRjtZQUNGO1lBQ0EsT0FBT047UUFDVDtJQUNGO0FBQ0Y7QUFFQSxNQUFNTyxpQkFBaUI7QUFDdkIsTUFBTUMseUJBQXlCcEM7SUFDN0IzMUUsWUFBWWkzQyxVQUFVLEVBQUVyZ0MsR0FBRyxFQUFFc0wsUUFBUSxFQUFFODFELHNCQUFzQixFQUFFOWdDLGFBQWEsQ0FBRTtRQUM1RSxLQUFLLENBQUNELFlBQVlyZ0MsS0FBS29nQyxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLEVBQUV6MkIsVUFBVWcxQjtRQUNuRCxJQUFJLENBQUMrZ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDbEMsZUFBZSxHQUFHLElBQU16MUQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQzRCLFFBQVEsRUFBRTtvQkFDbEIsSUFBSSxDQUFDczFCLGVBQWUsR0FBRztvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsTUFBTXB1QixRQUFRLE1BQU0sSUFBSSxDQUFDOHNELGdCQUFnQjtnQkFDekMsSUFBSTlzRCxTQUFTLElBQUksQ0FBQ2tsRCxTQUFTLElBQUksSUFBSSxDQUFDcHNELFFBQVEsRUFBRTtvQkFDNUMsSUFBSSxDQUFDczFCLGVBQWUsR0FBRzQyQixlQUFlaGxELE9BQU8sSUFBSSxDQUFDa2xELFNBQVM7Z0JBQzdEO2dCQUNBLElBQUksQ0FBQ0EsU0FBUyxHQUFHbGxEO1lBQ25CO1FBQ0EsSUFBSSxDQUFDOHVELHFCQUFxQixHQUFHeG5FLEVBQUU7WUFDN0IsSUFBSSxDQUFDeW5FLGdCQUFnQjtRQUN2QixHQUFHTDtRQUNILElBQUksQ0FBQ0Usc0JBQXNCLEdBQUdBO0lBQ2hDO0lBQ0EsSUFBSUksbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDSixzQkFBc0IsS0FBSzdoRjtJQUN6QztJQUNBOztHQUVDLEdBQ0QsSUFBSWtpRCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNQLGlCQUFpQjtJQUMvQjtJQUNBLGNBQWMsR0FDZDg5QixTQUFTbjhELEtBQUssRUFBRTtRQUNkLEtBQUssQ0FBQ204RCxTQUFTbjhEO1FBQ2YsSUFBSSxDQUFDMDlCLGdCQUFnQixDQUFDamtELE9BQU8sQ0FBQ3NsRCxDQUFBQTtZQUM1QixtQkFBbUI7WUFDbkIsSUFBSS8rQixPQUFPO2dCQUNUa2dDLFlBQVksSUFBSSxDQUFDN0IsaUJBQWlCLEVBQUVVO1lBQ3RDLE9BQU87Z0JBQ0xPLGdCQUFnQixJQUFJLENBQUNqQixpQkFBaUIsRUFBRVU7WUFDMUM7UUFDRjtJQUNGO0lBQ0FELE9BQU9DLE9BQU8sRUFBRTtRQUNkLElBQUksQ0FBQ0EsU0FBUztZQUNaQSxVQUFVLEtBQUssQ0FBQ0Q7UUFDbEIsT0FBTztZQUNMLEtBQUssQ0FBQ0EsT0FBT0M7UUFDZjtRQUNBLDJFQUEyRTtRQUMzRSw2REFBNkQ7UUFDN0QsSUFBSSxJQUFJLENBQUN3L0Isc0JBQXNCLElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUNqc0UsSUFBSSxDQUFDclMsQ0FBQUEsT0FBUUEsS0FBSzYrQyxPQUFPLEtBQUtBLGFBQWFyaUQsV0FBVztZQUN6RyxNQUFNa2lGLGNBQWMsSUFBSUMsZ0JBQWdCOS9CO1lBQ3hDLElBQUksQ0FBQysvQixrQkFBa0IsQ0FBQ0Y7UUFDMUI7UUFDQSxPQUFPNy9CO0lBQ1Q7SUFDQTs7OztHQUlDLEdBQ0QrL0IsbUJBQW1CRixXQUFXLEVBQUU7UUFDOUIsSUFBSSxJQUFJLENBQUNMLHNCQUFzQixJQUFJLElBQUksQ0FBQ0MsWUFBWSxDQUFDanNFLElBQUksQ0FBQ3JTLENBQUFBLE9BQVFBLFNBQVMwK0UsaUJBQWlCbGlGLFdBQVc7WUFDckdraUYsWUFBWXAyQixZQUFZLEdBQUc7Z0JBQ3pCLElBQUksQ0FBQ2kyQixxQkFBcUI7WUFDNUI7WUFDQUcsWUFBWWwyQix1QkFBdUIsR0FBRztnQkFDcEMsSUFBSSxDQUFDcTJCLGdCQUFnQjtZQUN2QjtZQUNBLElBQUksQ0FBQ1AsWUFBWSxDQUFDLzZFLElBQUksQ0FBQ203RTtZQUN2QkEsWUFBWUksT0FBTztZQUNuQix3Q0FBd0M7WUFDeEMsMkVBQTJFO1lBQzNFLCtDQUErQztZQUMvQyxJQUFJLENBQUNQLHFCQUFxQjtZQUMxQixJQUFJLENBQUNNLGdCQUFnQjtRQUN2QixPQUFPO1lBQ0wsSUFBSSxDQUFDempGLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsNENBQTRDLElBQUksQ0FBQ3cxQixVQUFVO1FBQzNFO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0R3Z0MseUJBQXlCTCxXQUFXLEVBQUU7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQ0QsZ0JBQWdCLEVBQUU7WUFDMUIsSUFBSSxDQUFDcmpGLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsb0NBQW9DLElBQUksQ0FBQ3cxQixVQUFVO1lBQ2pFO1FBQ0Y7UUFDQSxNQUFNeWdDLG1CQUFtQixJQUFJLENBQUNWLFlBQVksQ0FBQ24rRSxNQUFNLENBQUNILENBQUFBLE9BQVFBLFNBQVMwK0U7UUFDbkUsS0FBSyxNQUFNMStFLFFBQVFnL0UsaUJBQWtCO1lBQ25DaC9FLEtBQUtpL0UsYUFBYTtRQUNwQjtRQUNBLElBQUksQ0FBQ1gsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxDQUFDbitFLE1BQU0sQ0FBQ0gsQ0FBQUEsT0FBUUEsU0FBUzArRTtRQUM5RCxJQUFJLENBQUNHLGdCQUFnQjtRQUNyQixJQUFJLENBQUNOLHFCQUFxQjtJQUM1QjtJQUNBeCtCLE9BQU9sQixPQUFPLEVBQUU7UUFDZCxJQUFJcWdDLG1CQUFtQixFQUFFO1FBQ3pCLElBQUlyZ0MsU0FBUztZQUNYLElBQUksQ0FBQ3NnQyxvQkFBb0IsQ0FBQ3RnQztZQUMxQixPQUFPLEtBQUssQ0FBQ2tCLE9BQU9sQjtRQUN0QjtRQUNBcWdDLG1CQUFtQixLQUFLLENBQUNuL0I7UUFDekIsS0FBSyxNQUFNdm1ELEtBQUswbEYsaUJBQWtCO1lBQ2hDLElBQUksQ0FBQ0Msb0JBQW9CLENBQUMzbEY7UUFDNUI7UUFDQSxPQUFPMGxGO0lBQ1Q7SUFDQSxjQUFjLEdBQ2RFLDJCQUEyQjtRQUN6QixJQUFJcjVFO1FBQ0osT0FBTyxDQUFDQSxLQUFLLElBQUksQ0FBQzR1RSxTQUFTLE1BQU0sUUFBUTV1RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzNUUscUJBQXFCO0lBQzVGO0lBQ0E5QyxtQkFBbUI7UUFDakIsT0FBTzUxRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUM0QixRQUFRLElBQUksQ0FBQyxJQUFJLENBQUNBLFFBQVEsQ0FBQzRPLFFBQVEsRUFBRTtnQkFDN0M7WUFDRjtZQUNBLE1BQU0xSCxRQUFRLE1BQU0sSUFBSSxDQUFDbEgsUUFBUSxDQUFDNE8sUUFBUTtZQUMxQyxJQUFJeW1EO1lBQ0osSUFBSTBCLFVBQVU7WUFDZCxJQUFJbC9ELFNBQVMsSUFBSTROO1lBQ2pCeUIsTUFBTWwyQixPQUFPLENBQUNzSixDQUFBQTtnQkFDWixJQUFJQSxFQUFFeUIsSUFBSSxLQUFLLGVBQWU7b0JBQzVCZzdFLFVBQVV6OEUsRUFBRTA4RSxPQUFPO29CQUNuQjNCLGdCQUFnQjt3QkFDZHQ1RSxNQUFNO3dCQUNOazdFLGVBQWUzOEUsRUFBRTI4RSxhQUFhO3dCQUM5QkMsZUFBZTU4RSxFQUFFNDhFLGFBQWE7d0JBQzlCQyxnQkFBZ0I3OEUsRUFBRTY4RSxjQUFjO3dCQUNoQ0MsaUJBQWlCOThFLEVBQUU4OEUsZUFBZTt3QkFDbEN6N0QsYUFBYXJoQixFQUFFcWhCLFdBQVc7d0JBQzFCdzFELFlBQVk3MkUsRUFBRTYyRSxVQUFVO3dCQUN4QkQsYUFBYTUyRSxFQUFFNDJFLFdBQVc7d0JBQzFCRyxVQUFVLzJFLEVBQUUrMkUsUUFBUTt3QkFDcEJELFVBQVU5MkUsRUFBRTgyRSxRQUFRO3dCQUNwQkUsV0FBV2gzRSxFQUFFZzNFLFNBQVM7d0JBQ3RCaEUsUUFBUWh6RSxFQUFFZ3pFLE1BQU07d0JBQ2hCaCtDLFdBQVdoMUIsRUFBRWcxQixTQUFTO3dCQUN0Qmk5QyxlQUFlanlFLEVBQUVpeUUsYUFBYTt3QkFDOUJ1Syx1QkFBdUJ4OEUsRUFBRXc4RSxxQkFBcUI7b0JBQ2hEO2dCQUNGLE9BQU8sSUFBSXg4RSxFQUFFeUIsSUFBSSxLQUFLLFNBQVM7b0JBQzdCOGIsT0FBTzFULEdBQUcsQ0FBQzdKLEVBQUU4c0IsRUFBRSxFQUFFOXNCO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSSs2RSxpQkFBaUIwQixZQUFZLE1BQU1sL0QsT0FBT25tQixHQUFHLENBQUNxbEYsVUFBVTtnQkFDMUQxQixjQUFjbitELFFBQVEsR0FBR1csT0FBT25tQixHQUFHLENBQUNxbEYsU0FBUzcvRCxRQUFRO1lBQ3ZEO1lBQ0EsT0FBT20rRDtRQUNUO0lBQ0Y7SUFDQXVCLHFCQUFxQnRnQyxPQUFPLEVBQUU7UUFDNUIsTUFBTW1nQyxtQkFBbUIsSUFBSSxDQUFDVixZQUFZLENBQUNuK0UsTUFBTSxDQUFDSCxDQUFBQSxPQUFRQSxLQUFLNitDLE9BQU8sS0FBS0E7UUFDM0UsS0FBSyxNQUFNNytDLFFBQVFnL0UsaUJBQWtCO1lBQ25DLElBQUksQ0FBQ0Qsd0JBQXdCLENBQUMvK0U7UUFDaEM7SUFDRjtJQUNBaStDLDZCQUE2QjtRQUMzQixNQUFNbVMsU0FBU3oyRCxPQUFPdUosTUFBTSxDQUFDLE1BQU07WUFDakMrNkMsNEJBQTRCO2dCQUMxQmhrRCxLQUFLLElBQU0sS0FBSyxDQUFDZ2tEO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPdDNCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXlwQyxPQUFPblMsMEJBQTBCLENBQUNuakQsSUFBSSxDQUFDLElBQUk7WUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQzJqRixnQkFBZ0IsRUFBRTtZQUM1QixJQUFJLENBQUNJLGdCQUFnQjtRQUN2QjtJQUNGO0lBQ0FBLG1CQUFtQjtRQUNqQixJQUFJOTRFLElBQUk4VTtRQUNSLE1BQU0ra0UsdUJBQXVCLElBQUksQ0FBQ3RCLFlBQVksQ0FBQ2x2RCxNQUFNLENBQUMsQ0FBQ3RpQixNQUFNOU0sT0FBUzJKLEtBQUtzVSxHQUFHLENBQUNuUixNQUFNOU0sS0FBSzYvRSxtQkFBbUIsSUFBSSxJQUFJO1FBQ3JILE1BQU1DLGtCQUFrQixDQUFDLENBQUNqbEUsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUNzNEUsc0JBQXNCLE1BQU0sUUFBUXQ0RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnNkUsc0JBQXNCLE1BQU0sUUFBUWxsRSxPQUFPLEtBQUssSUFBSUEsS0FBSyxLQUFLLGtCQUFrQjtRQUFwQixJQUNsSyxJQUFJLENBQUMraUMsY0FBYyxHQUFHO1FBQzFCLE1BQU1vaUMsWUFBWSxJQUFJLENBQUMxQixZQUFZLENBQUNwc0QsSUFBSSxDQUFDbHlCLENBQUFBLE9BQVFBLEtBQUtpZ0YsZ0JBQWdCO1FBQ3RFLE1BQU1DLFlBQVksSUFBSSxDQUFDNUIsWUFBWSxDQUFDcHNELElBQUksQ0FBQ2x5QixDQUFBQSxPQUFRQSxLQUFLbWdGLE9BQU8sS0FBSyxDQUFDTCxtQkFBbUJFO1FBQ3RGLElBQUksSUFBSSxDQUFDSSxXQUFXLEtBQUtGLFdBQVc7WUFDbEM7UUFDRjtRQUNBLElBQUksQ0FBQ0EsYUFBYTNrRSxLQUFLUSxHQUFHLEtBQUs2akUsdUJBQXVCekIsZ0JBQWdCO1lBQ3BFLHNCQUFzQjtZQUN0QjVvQyxlQUFlWixVQUFVLENBQUM7Z0JBQ3hCLElBQUksQ0FBQ2txQyxnQkFBZ0I7WUFDdkIsR0FBR1Y7WUFDSDtRQUNGO1FBQ0EsSUFBSSxDQUFDaUMsV0FBVyxHQUFHRjtRQUNuQixJQUFJLENBQUNwMkQsSUFBSSxDQUFDc3FCLFdBQVdpc0MsaUJBQWlCLEVBQUVILFdBQVcsSUFBSTtJQUN6RDtJQUNBMUIsbUJBQW1CO1FBQ2pCLElBQUl6NEUsSUFBSThVO1FBQ1IsSUFBSTRaLFdBQVc7UUFDZixJQUFJQyxZQUFZO1FBQ2hCLE1BQU00ckQsZUFBZSxJQUFJLENBQUNDLGVBQWU7UUFDekMsS0FBSyxNQUFNdmdGLFFBQVEsSUFBSSxDQUFDcytFLFlBQVksQ0FBRTtZQUNwQyxNQUFNa0Msc0JBQXNCeGdGLEtBQUsrZixLQUFLLEtBQUt1Z0U7WUFDM0MsTUFBTUcsdUJBQXVCemdGLEtBQUtnZ0IsTUFBTSxLQUFLc2dFO1lBQzdDLElBQUlFLHNCQUFzQkMsdUJBQXVCaHNELFdBQVdDLFdBQVc7Z0JBQ3JFRCxXQUFXK3JEO2dCQUNYOXJELFlBQVkrckQ7WUFDZDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMxNkUsS0FBSyxJQUFJLENBQUMyNkUsY0FBYyxNQUFNLFFBQVEzNkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZ2EsS0FBSyxNQUFNMFUsWUFBWSxDQUFDLENBQUM1WixLQUFLLElBQUksQ0FBQzZsRSxjQUFjLE1BQU0sUUFBUTdsRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtRixNQUFNLE1BQU0wVSxXQUFXO1lBQ3hMO1FBQ0Y7UUFDQSxJQUFJLENBQUNnc0QsY0FBYyxHQUFHO1lBQ3BCM2dFLE9BQU8wVTtZQUNQelUsUUFBUTBVO1FBQ1Y7UUFDQSxJQUFJLENBQUM1SyxJQUFJLENBQUNzcUIsV0FBV3VzQyxzQkFBc0IsRUFBRSxJQUFJLENBQUNELGNBQWMsRUFBRSxJQUFJO0lBQ3hFO0lBQ0FILGtCQUFrQjtRQUNoQixJQUFJeDZFO1FBQ0osTUFBTXU2RSxlQUFlLENBQUN2NkUsS0FBSyxJQUFJLENBQUNzNEUsc0JBQXNCLE1BQU0sUUFBUXQ0RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1NkUsWUFBWTtRQUM1RyxJQUFJQSxpQkFBaUIsVUFBVTtZQUM3QixPQUFPMTRCO1FBQ1QsT0FBTyxJQUFJLENBQUMwNEIsY0FBYztZQUN4Qiw4Q0FBOEM7WUFDOUMscUVBQXFFO1lBQ3JFLDZCQUE2QjtZQUM3QixNQUFNejRCLG1CQUFtQkQ7WUFDekIsSUFBSUMsbUJBQW1CLEdBQUc7Z0JBQ3hCLE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBT3k0QjtJQUNUO0FBQ0Y7QUFDQSxNQUFNM0I7SUFDSixJQUFJd0IsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDUyxLQUFLLElBQUksSUFBSSxDQUFDQyxjQUFjO0lBQzFDO0lBQ0EsSUFBSVosbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDVyxLQUFLO0lBQ25CO0lBQ0F2NkUsWUFBWXc0QyxPQUFPLEVBQUVzaEMsT0FBTyxDQUFFO1FBQzVCLElBQUksQ0FBQ1csbUJBQW1CLEdBQUd6NEIsQ0FBQUE7WUFDekIsSUFBSXRpRDtZQUNKLE1BQU0sRUFDSnVNLE1BQU0sRUFDTnV1RSxjQUFjLEVBQ2YsR0FBR3g0QjtZQUNKLElBQUkvMUMsV0FBVyxJQUFJLENBQUN1c0MsT0FBTyxFQUFFO2dCQUMzQixJQUFJLENBQUNnaUMsY0FBYyxHQUFHQTtnQkFDdEIsSUFBSSxDQUFDaEIsbUJBQW1CLEdBQUd0a0UsS0FBS1EsR0FBRztnQkFDbENoVyxDQUFBQSxLQUFLLElBQUksQ0FBQ3lpRCx1QkFBdUIsTUFBTSxRQUFRemlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJO1lBQ3ZGO1FBQ0Y7UUFDQSxJQUFJLENBQUNpbUYsVUFBVSxHQUFHO1lBQ2hCLElBQUloN0U7WUFDSixJQUFJLENBQUM2NkUsS0FBSyxHQUFHO1lBQ1o3NkUsQ0FBQUEsS0FBSyxJQUFJLENBQUN5aUQsdUJBQXVCLE1BQU0sUUFBUXppRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTCxJQUFJLENBQUMsSUFBSTtRQUN2RjtRQUNBLElBQUksQ0FBQ2ttRixVQUFVLEdBQUc7WUFDaEIsSUFBSWo3RTtZQUNKLElBQUksQ0FBQzY2RSxLQUFLLEdBQUc7WUFDWjc2RSxDQUFBQSxLQUFLLElBQUksQ0FBQ3lpRCx1QkFBdUIsTUFBTSxRQUFRemlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJO1FBQ3ZGO1FBQ0EsSUFBSSxDQUFDK2pELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNnaUMsY0FBYyxHQUFHVixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVYyxvQkFBb0JwaUM7UUFDN0YsSUFBSSxDQUFDK2hDLEtBQUssR0FBRzkvQixXQUFXaGpELFNBQVNvakYsdUJBQXVCLEtBQUtyaUM7UUFDN0QsSUFBSSxDQUFDZ2hDLG1CQUFtQixHQUFHO0lBQzdCO0lBQ0E5L0QsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDOCtCLE9BQU8sQ0FBQ3NpQyxXQUFXO0lBQ2pDO0lBQ0FuaEUsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDNitCLE9BQU8sQ0FBQ3VpQyxZQUFZO0lBQ2xDO0lBQ0F0QyxVQUFVO1FBQ1IseUVBQXlFO1FBQ3pFLElBQUksQ0FBQytCLGNBQWMsR0FBR0ksb0JBQW9CLElBQUksQ0FBQ3BpQyxPQUFPO1FBQ3RELElBQUksQ0FBQytoQyxLQUFLLEdBQUc5aUYsU0FBU29qRix1QkFBdUIsS0FBSyxJQUFJLENBQUNyaUMsT0FBTztRQUM5RCxJQUFJLENBQUNBLE9BQU8sQ0FBQ3lKLFlBQVksR0FBRztZQUMxQixJQUFJdmlEO1lBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDdWlELFlBQVksTUFBTSxRQUFRdmlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pMLElBQUksQ0FBQyxJQUFJO1FBQzVFO1FBQ0EsSUFBSSxDQUFDK2pELE9BQU8sQ0FBQzJKLHVCQUF1QixHQUFHLElBQUksQ0FBQ3M0QixtQkFBbUI7UUFDL0RsNEIsMEJBQTBCazJCLE9BQU8sQ0FBQyxJQUFJLENBQUNqZ0MsT0FBTztRQUM5QzZKLG9CQUFvQm8yQixPQUFPLENBQUMsSUFBSSxDQUFDamdDLE9BQU87UUFDeEMsSUFBSSxDQUFDQSxPQUFPLENBQUNseUIsZ0JBQWdCLENBQUMseUJBQXlCLElBQUksQ0FBQ28wRCxVQUFVO1FBQ3RFLElBQUksQ0FBQ2xpQyxPQUFPLENBQUNseUIsZ0JBQWdCLENBQUMseUJBQXlCLElBQUksQ0FBQ3EwRCxVQUFVO0lBQ3hFO0lBQ0EvQixnQkFBZ0I7UUFDZCxJQUFJbDVFLElBQUk4VTtRQUNQOVUsQ0FBQUEsS0FBSzZpRCx5QkFBd0IsTUFBTyxRQUFRN2lELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3M3RSxTQUFTLENBQUMsSUFBSSxDQUFDeGlDLE9BQU87UUFDOUZoa0MsQ0FBQUEsS0FBSzZ0QyxtQkFBa0IsTUFBTyxRQUFRN3RDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dtRSxTQUFTLENBQUMsSUFBSSxDQUFDeGlDLE9BQU87UUFDekYsSUFBSSxDQUFDQSxPQUFPLENBQUNoeUIsbUJBQW1CLENBQUMseUJBQXlCLElBQUksQ0FBQ2swRCxVQUFVO1FBQ3pFLElBQUksQ0FBQ2xpQyxPQUFPLENBQUNoeUIsbUJBQW1CLENBQUMseUJBQXlCLElBQUksQ0FBQ20wRCxVQUFVO0lBQzNFO0FBQ0Y7QUFDQSxtREFBbUQ7QUFDbkQsU0FBU0Msb0JBQW9CL3hCLEVBQUU7SUFDN0IsSUFBSW95QixNQUFNcHlCLEdBQUdxeUIsU0FBUztJQUN0QixJQUFJQyxPQUFPdHlCLEdBQUd1eUIsVUFBVTtJQUN4QixNQUFNMWhFLFFBQVFtdkMsR0FBR3d5QixXQUFXO0lBQzVCLE1BQU0xaEUsU0FBU2t2QyxHQUFHeXlCLFlBQVk7SUFDOUIsTUFBTSxFQUNKcGpFLE1BQU0sRUFDUCxHQUFHMndDO0lBQ0osTUFBTSxFQUNKMHlCLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUdDLGlCQUFpQjV5QjtJQUNyQixNQUFPQSxHQUFHNnlCLFlBQVksQ0FBRTtRQUN0Qjd5QixLQUFLQSxHQUFHNnlCLFlBQVk7UUFDcEJULE9BQU9weUIsR0FBR3F5QixTQUFTO1FBQ25CQyxRQUFRdHlCLEdBQUd1eUIsVUFBVTtJQUN2QjtJQUNBLE9BQU9ILE1BQU1obkYsT0FBTzBuRixXQUFXLEdBQUcxbkYsT0FBTzJuRixXQUFXLElBQUlULE9BQU9sbkYsT0FBTzRuRixXQUFXLEdBQUc1bkYsT0FBTzZuRixVQUFVLElBQUliLE1BQU10aEUsU0FBUzFsQixPQUFPMG5GLFdBQVcsSUFBSVIsT0FBT3poRSxRQUFRemxCLE9BQU80bkYsV0FBVyxJQUFJLENBQUMzakUsVUFBV3FqRSxDQUFBQSxZQUFZLEtBQUt0a0QsV0FBV3NrRCxXQUFXLElBQUksSUFBRyxLQUFNQyxZQUFZO0FBQ2pRO0FBRUEsTUFBTU8seUJBQXlCdDFELGNBQWM3RCxZQUFZO0lBQ3ZENWlCLFlBQVlxTSxJQUFJLEVBQUVpZCxFQUFFLEVBQUV4eUIsSUFBSSxFQUFFb2dELGFBQWEsQ0FBRTtRQUN6QyxJQUFJeDNDO1FBQ0osS0FBSztRQUNMLElBQUksQ0FBQ3M4RSxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDOWhFLFVBQVUsR0FBR2hCLGdCQUFnQmlCLElBQUk7UUFDdEMsSUFBSSxDQUFDcGxCLEdBQUcsR0FBRzJFO1FBQ1gsSUFBSSxDQUFDdWlGLFdBQVcsR0FBRztZQUNqQixJQUFJLENBQUN4NEQsSUFBSSxDQUFDc3FCLFdBQVc2YixLQUFLO1FBQzVCO1FBQ0EsSUFBSSxDQUFDc3lCLGFBQWEsR0FBRztZQUNuQixJQUFJLENBQUN6NEQsSUFBSSxDQUFDc3FCLFdBQVc4YixPQUFPO1FBQzlCO1FBQ0EsSUFBSSxDQUFDOTBELEdBQUcsR0FBR2tFLFVBQVUsQ0FBQ3lHLEtBQUt3M0Msa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjNWdELFVBQVUsTUFBTSxRQUFRb0osT0FBTyxLQUFLLElBQUlBLEtBQUtqRyxZQUFZMGlGLFdBQVc7UUFDM0ssSUFBSSxDQUFDdGtDLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWU7UUFDM0MsSUFBSSxDQUFDeDBCLGVBQWUsQ0FBQztRQUNyQixJQUFJLENBQUNoWCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDa29DLFFBQVEsR0FBR2pyQjtRQUNoQixJQUFJLENBQUN3MUIsU0FBUyxHQUFHaG9EO1FBQ2pCLElBQUksQ0FBQzRhLE1BQU0sR0FBR3NsQyxNQUFNZ0IsTUFBTSxDQUFDQyxPQUFPO0lBQ3BDO0lBQ0EsY0FBYyxHQUNkbWtDLFNBQVMzeUQsS0FBSyxFQUFFO1FBQ2QsSUFBSSxJQUFJLENBQUNBLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQ0EsS0FBSyxDQUFDbkUsR0FBRyxDQUFDeW9CLFdBQVc2YixLQUFLLEVBQUUsSUFBSSxDQUFDcXlCLFdBQVc7WUFDakQsSUFBSSxDQUFDeHlELEtBQUssQ0FBQ25FLEdBQUcsQ0FBQ3lvQixXQUFXOGIsT0FBTyxFQUFFLElBQUksQ0FBQ3F5QixhQUFhO1FBQ3ZEO1FBQ0EsSUFBSSxDQUFDenlELEtBQUssR0FBR0E7UUFDYixJQUFJQSxPQUFPO1lBQ1QsaUJBQWlCO1lBQ2pCQSxNQUFNL0UsRUFBRSxDQUFDcXBCLFdBQVc2YixLQUFLLEVBQUUsSUFBSSxDQUFDcXlCLFdBQVc7WUFDM0N4eUQsTUFBTS9FLEVBQUUsQ0FBQ3FwQixXQUFXOGIsT0FBTyxFQUFFLElBQUksQ0FBQ3F5QixhQUFhO1FBQ2pEO0lBQ0Y7SUFDQSxJQUFJaGtDLGFBQWE7UUFDZixJQUFJeDRDO1FBQ0osT0FBT3BNLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDb0MsS0FBSyxJQUFJLENBQUNtNEMsZUFBZSxNQUFNLFFBQVFuNEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHakwsSUFBSSxDQUFDLElBQUksSUFBSTBqRCx1QkFBdUIsSUFBSTtJQUNySjtJQUNBLElBQUlmLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQzRrQyxhQUFhO0lBQzNCO0lBQ0EsSUFBSWo5QixZQUFZO1FBQ2QsT0FBTztJQUNUO0lBQ0EsSUFBSXM5QixlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDNXlELEtBQUssS0FBS3R6QjtJQUN4QjtJQUNBLElBQUk4b0QsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQy9rQyxVQUFVLEtBQUtoQixnQkFBZ0JpQixJQUFJO0lBQ2pEO0lBQ0E7O0dBRUMsR0FDRCxJQUFJbWlFLGFBQWE7UUFDZixJQUFJLElBQUksQ0FBQzd5RCxLQUFLLFlBQVlrbEQsbUJBQW1CLElBQUksQ0FBQ2xsRCxLQUFLLFlBQVl1c0Qsa0JBQWtCO1lBQ25GLE9BQU8sSUFBSSxDQUFDdnNELEtBQUs7UUFDbkI7SUFDRjtJQUNBOztHQUVDLEdBQ0QsSUFBSTh5RCxhQUFhO1FBQ2YsSUFBSSxJQUFJLENBQUM5eUQsS0FBSyxZQUFZbW1ELG1CQUFtQixJQUFJLENBQUNubUQsS0FBSyxZQUFZc3VELGtCQUFrQjtZQUNuRixPQUFPLElBQUksQ0FBQ3R1RCxLQUFLO1FBQ25CO0lBQ0Y7SUFDQSxjQUFjLEdBQ2QreUQsV0FBVzdpRixJQUFJLEVBQUU7UUFDZixJQUFJLENBQUM0NkMsUUFBUSxHQUFHNTZDLEtBQUtpZCxHQUFHO1FBQ3hCLElBQUksQ0FBQ2tvQyxTQUFTLEdBQUdubEQsS0FBSzdDLElBQUk7UUFDMUIsSUFBSSxDQUFDNGEsTUFBTSxHQUFHc2xDLE1BQU1pRixlQUFlLENBQUN0aUQsS0FBSytYLE1BQU07UUFDL0MsSUFBSSxDQUFDMEgsUUFBUSxHQUFHemYsS0FBS3lmLFFBQVE7UUFDN0IsSUFBSSxJQUFJLENBQUMvTSxJQUFJLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQ0MsS0FBSyxJQUFJaC9DLEtBQUsrZixLQUFLLEdBQUcsR0FBRztZQUNwRCxJQUFJLENBQUM2dUMsVUFBVSxHQUFHO2dCQUNoQjd1QyxPQUFPL2YsS0FBSytmLEtBQUs7Z0JBQ2pCQyxRQUFRaGdCLEtBQUtnZ0IsTUFBTTtZQUNyQjtZQUNBLElBQUksQ0FBQzhpRSxXQUFXLEdBQUc5aUYsS0FBS2lnQixTQUFTO1FBQ25DO1FBQ0EsSUFBSSxDQUFDTSxVQUFVLEdBQUd2Z0IsS0FBS3VnQixVQUFVO1FBQ2pDLElBQUksQ0FBQ3VrQyxTQUFTLEdBQUc5a0Q7UUFDakIsSUFBSSxDQUFDNUUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDJCQUEyQnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO1lBQzFGditDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0MsVUFBVW9pRixnQkFBZ0I7SUFDeEIsVUFBVVcsa0JBQWtCO1FBQzNCQSxrQkFBa0IsQ0FBQyxVQUFVLEdBQUc7UUFDaENBLGtCQUFrQixDQUFDLGFBQWEsR0FBRztRQUNuQ0Esa0JBQWtCLENBQUMsZUFBZSxHQUFHO0lBQ3ZDLEdBQUdYLGlCQUFpQlcsa0JBQWtCLElBQUtYLENBQUFBLGlCQUFpQlcsa0JBQWtCLEdBQUcsQ0FBQztJQUNqRixVQUFVQyxnQkFBZ0I7UUFDekJBLGdCQUFnQixDQUFDLFVBQVUsR0FBRztRQUM5QkEsZ0JBQWdCLENBQUMsYUFBYSxHQUFHO0lBQ25DLEdBQUdaLGlCQUFpQlksZ0JBQWdCLElBQUtaLENBQUFBLGlCQUFpQlksZ0JBQWdCLEdBQUcsQ0FBQztBQUNoRixHQUFHWixvQkFBcUJBLENBQUFBLG1CQUFtQixDQUFDO0FBRTVDLE1BQU1hLDhCQUE4QmI7SUFDbEMsSUFBSXZ6QixtQkFBbUI7UUFDckIsSUFBSTlvRDtRQUNKLE9BQU8sQ0FBQ0EsS0FBSyxJQUFJLENBQUMrcEIsS0FBSyxNQUFNLFFBQVEvcEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOG9ELGdCQUFnQjtJQUNuRjtJQUNBeG9ELFlBQVlxTSxJQUFJLEVBQUV3d0UsRUFBRSxFQUFFcHpELEtBQUssRUFBRXl0QixhQUFhLENBQUU7UUFDMUMsS0FBSyxDQUFDN3FDLE1BQU13d0UsR0FBR2ptRSxHQUFHLEVBQUVpbUUsR0FBRy9sRixJQUFJLEVBQUVvZ0Q7UUFDN0IsSUFBSSxDQUFDenRCLEtBQUssR0FBR3R6QjtRQUNiLElBQUksQ0FBQzJtRixnQkFBZ0IsR0FBRztZQUN0QixJQUFJLENBQUNyNUQsSUFBSSxDQUFDc3FCLFdBQVdpYSxLQUFLO1FBQzVCO1FBQ0EsSUFBSSxDQUFDdzBCLFVBQVUsQ0FBQ0s7UUFDaEIsSUFBSSxDQUFDVCxRQUFRLENBQUMzeUQ7SUFDaEI7SUFDQTJ5RCxTQUFTM3lELEtBQUssRUFBRTtRQUNkLElBQUksSUFBSSxDQUFDQSxLQUFLLEVBQUU7WUFDZCxJQUFJLENBQUNBLEtBQUssQ0FBQ25FLEdBQUcsQ0FBQ3lvQixXQUFXaWEsS0FBSyxFQUFFLElBQUksQ0FBQzgwQixnQkFBZ0I7UUFDeEQ7UUFDQSxLQUFLLENBQUNWLFNBQVMzeUQ7UUFDZixJQUFJQSxPQUFPO1lBQ1RBLE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV2lhLEtBQUssRUFBRSxJQUFJLENBQUM4MEIsZ0JBQWdCO1FBQ2xEO0lBQ0Y7SUFDQSxJQUFJMWxDLFVBQVU7UUFDWixJQUFJLElBQUksQ0FBQzN0QixLQUFLLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQ0EsS0FBSyxDQUFDMnRCLE9BQU87UUFDM0I7UUFDQSxPQUFPLEtBQUssQ0FBQ0E7SUFDZjtJQUNBLElBQUlrbEMsYUFBYTtRQUNmLE9BQU8sS0FBSyxDQUFDQTtJQUNmO0lBQ0EsSUFBSUMsYUFBYTtRQUNmLE9BQU8sS0FBSyxDQUFDQTtJQUNmO0lBQ0E7O0dBRUMsR0FDRGp6QixPQUFPO1FBQ0wsSUFBSTVwRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxPQUFPLENBQUM1Z0IsS0FBSyxJQUFJLENBQUMrcEIsS0FBSyxNQUFNLFFBQVEvcEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNHBELElBQUk7UUFDdkU7SUFDRjtJQUNBOztHQUVDLEdBQ0RFLFNBQVM7UUFDUCxJQUFJOXBEO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE9BQU8sQ0FBQzVnQixLQUFLLElBQUksQ0FBQytwQixLQUFLLE1BQU0sUUFBUS9wQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4cEQsTUFBTTtRQUN6RTtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEN0IsZ0JBQWdCO1FBQ2QsSUFBSWpvRDtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNLENBQUM1Z0IsS0FBSyxJQUFJLENBQUMrcEIsS0FBSyxNQUFNLFFBQVEvcEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaW9ELGFBQWE7UUFDL0U7SUFDRjtJQUNBOzs7R0FHQyxHQUNERSxpQkFBaUI7UUFDZixJQUFJbm9EO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0sQ0FBQzVnQixLQUFLLElBQUksQ0FBQytwQixLQUFLLE1BQU0sUUFBUS9wQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtb0QsY0FBYztRQUNoRjtJQUNGO0FBQ0Y7QUFFQSxJQUFJeHhDO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQzFCQSxpQkFBaUIsQ0FBQyxZQUFZLEdBQUc7SUFDakNBLGlCQUFpQixDQUFDLE9BQU8sR0FBRztJQUM1QkEsaUJBQWlCLENBQUMsT0FBTyxHQUFHO0lBQzVCOzs7R0FHQyxHQUNEQSxpQkFBaUIsQ0FBQyxPQUFPLEdBQUc7SUFDNUJBLGlCQUFpQixDQUFDLFVBQVUsR0FBRztBQUNqQyxHQUFHQSxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBQzlDLFNBQVMwbUUsaUJBQWlCaEosQ0FBQztJQUN6QixPQUFRQTtRQUNOLEtBQUszOUQsb0JBQW9CNG1FLFNBQVM7WUFDaEMsT0FBTzNtRSxrQkFBa0I0bUUsU0FBUztRQUNwQyxLQUFLN21FLG9CQUFvQjhtRSxJQUFJO1lBQzNCLE9BQU83bUUsa0JBQWtCOG1FLElBQUk7UUFDL0IsS0FBSy9tRSxvQkFBb0I2K0IsSUFBSTtZQUMzQixPQUFPNStCLGtCQUFrQittRSxJQUFJO1FBQy9CLEtBQUtobkUsb0JBQW9CaW5FLElBQUk7WUFDM0IsT0FBT2huRSxrQkFBa0JpbkUsSUFBSTtRQUMvQjtZQUNFLE9BQU9qbkUsa0JBQWtCNGhDLE9BQU87SUFDcEM7QUFDRjtBQUNBLE1BQU1zbEMsb0JBQW9COTJELGNBQWM3RCxZQUFZO0lBQ2xELElBQUlzMUIsYUFBYTtRQUNmLElBQUl4NEMsSUFBSThVO1FBQ1IsT0FBT2xoQixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQ2tYLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDdzNDLGFBQWEsTUFBTSxRQUFReDNDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR200QyxlQUFlLE1BQU0sUUFBUXJqQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcvZixJQUFJLENBQUNpTCxNQUFNO1lBQ2pMdWIsZ0JBQWdCLElBQUksQ0FBQ3JFLEdBQUc7WUFDeEIyMkMsZUFBZSxJQUFJLENBQUNoMUMsUUFBUTtRQUM5QjtJQUNGO0lBQ0EsSUFBSTBtQyxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDdG1DLE1BQU0sQ0FBQ29QLElBQUksR0FBRyxLQUFLMzBCLE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQ3p6QixNQUFNLENBQUN0YyxNQUFNLElBQUkyVixLQUFLLENBQUNtbkMsQ0FBQUEsS0FBTUEsR0FBRzhGLFdBQVc7SUFDNUY7SUFDQSxJQUFJdStCLFVBQVU7UUFDWixJQUFJOTlFLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUMrOUUsV0FBVyxNQUFNLFFBQVEvOUUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMlksS0FBSyxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN2SDtJQUNBLGNBQWMsR0FDZHhVLFlBQVk0VyxHQUFHLEVBQUUyQixRQUFRLEVBQUV6aEIsSUFBSSxFQUFFb2dCLFFBQVEsRUFBRWdnQyxhQUFhLENBQUU7UUFDeEQsSUFBSXgzQztRQUNKLEtBQUs7UUFDTCxnRUFBZ0UsR0FDaEUsSUFBSSxDQUFDZytFLFVBQVUsR0FBRztRQUNsQix5Q0FBeUMsR0FDekMsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR3ZuRSxrQkFBa0I0aEMsT0FBTztRQUNuRCxJQUFJLENBQUNsakQsR0FBRyxHQUFHMkU7UUFDWCxJQUFJLENBQUMzRSxHQUFHLEdBQUdrRSxVQUFVLENBQUN5RyxLQUFLdzNDLGtCQUFrQixRQUFRQSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYzVnRCxVQUFVLE1BQU0sUUFBUW9KLE9BQU8sS0FBSyxJQUFJQSxLQUFLakcsWUFBWThqRixXQUFXO1FBQzNLLElBQUksQ0FBQ3JtQyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQzd6QixlQUFlLENBQUM7UUFDckIsSUFBSSxDQUFDek0sR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQzJCLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDemhCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNvZ0IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUMybUUsV0FBVyxHQUFHLElBQUlsMkQ7UUFDdkIsSUFBSSxDQUFDbTJELFdBQVcsR0FBRyxJQUFJbjJEO1FBQ3ZCLElBQUksQ0FBQ2hQLE1BQU0sR0FBRyxJQUFJZ1A7SUFDcEI7SUFDQTRGLFlBQVk7UUFDVixPQUFPbjZCLE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQ3p6QixNQUFNLENBQUN0YyxNQUFNO0lBQ3RDO0lBQ0E7Ozs7O0dBS0MsR0FDRDBoRixTQUFTcnNFLE1BQU0sRUFBRTtRQUNmLEtBQUssTUFBTSxHQUFHZzdDLElBQUksSUFBSSxJQUFJLENBQUMvekMsTUFBTSxDQUFFO1lBQ2pDLElBQUkrekMsSUFBSWg3QyxNQUFNLEtBQUtBLFFBQVE7Z0JBQ3pCLE9BQU9nN0M7WUFDVDtRQUNGO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0RzeEIsZUFBZWxuRixJQUFJLEVBQUU7UUFDbkIsS0FBSyxNQUFNLEdBQUc0MUQsSUFBSSxJQUFJLElBQUksQ0FBQy96QyxNQUFNLENBQUU7WUFDakMsSUFBSSt6QyxJQUFJNU4sU0FBUyxLQUFLaG9ELE1BQU07Z0JBQzFCLE9BQU80MUQ7WUFDVDtRQUNGO0lBQ0Y7SUFDQSxJQUFJdXhCLG9CQUFvQjtRQUN0QixPQUFPLElBQUksQ0FBQ0wsa0JBQWtCO0lBQ2hDO0lBQ0EsSUFBSU0sa0JBQWtCO1FBQ3BCLElBQUl4K0U7UUFDSixNQUFNK3BCLFFBQVEsSUFBSSxDQUFDczBELFFBQVEsQ0FBQy9tQyxNQUFNZ0IsTUFBTSxDQUFDeUQsTUFBTTtRQUMvQyxPQUFPLENBQUUsRUFBQy83QyxLQUFLK3BCLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNMnRCLE9BQU8sTUFBTSxRQUFRMTNDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUc7SUFDbEg7SUFDQSxJQUFJeStFLHNCQUFzQjtRQUN4QixJQUFJeitFO1FBQ0osTUFBTStwQixRQUFRLElBQUksQ0FBQ3MwRCxRQUFRLENBQUMvbUMsTUFBTWdCLE1BQU0sQ0FBQzJELFVBQVU7UUFDbkQsT0FBTyxDQUFFLEVBQUNqOEMsS0FBSytwQixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTTJ0QixPQUFPLE1BQU0sUUFBUTEzQyxPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFHO0lBQ2xIO0lBQ0EsSUFBSTArRSx1QkFBdUI7UUFDekIsTUFBTTMwRCxRQUFRLElBQUksQ0FBQ3MwRCxRQUFRLENBQUMvbUMsTUFBTWdCLE1BQU0sQ0FBQzZELFdBQVc7UUFDcEQsT0FBTyxDQUFDLENBQUNweUI7SUFDWDtJQUNBLElBQUkySyxVQUFVO1FBQ1osT0FBTztJQUNUO0lBQ0EscUNBQXFDLEdBQ3JDLElBQUl4YixXQUFXO1FBQ2IsSUFBSSxJQUFJLENBQUN5bEUsZUFBZSxFQUFFO1lBQ3hCLE9BQU8sSUFBSW5wRSxLQUFLelosT0FBT21TLFFBQVEsQ0FBQyxJQUFJLENBQUN5d0UsZUFBZSxDQUFDemxFLFFBQVEsQ0FBQ3BWLFFBQVEsTUFBTTtRQUM5RTtRQUNBLE9BQU8sSUFBSTBSO0lBQ2I7SUFDQSxjQUFjLEdBQ2RzbkUsV0FBVzdpRixJQUFJLEVBQUU7UUFDZixzRUFBc0U7UUFDdEUsMEVBQTBFO1FBQzFFLDJFQUEyRTtRQUMzRSxtQ0FBbUM7UUFDbkMsaUZBQWlGO1FBQ2pGLDZDQUE2QztRQUM3QyxJQUFJLElBQUksQ0FBQzBrRixlQUFlLElBQUksSUFBSSxDQUFDQSxlQUFlLENBQUN6bkUsR0FBRyxLQUFLamQsS0FBS2lkLEdBQUcsSUFBSSxJQUFJLENBQUN5bkUsZUFBZSxDQUFDeGxFLE9BQU8sR0FBR2xmLEtBQUtrZixPQUFPLEVBQUU7WUFDaEgsT0FBTztRQUNUO1FBQ0EsSUFBSSxDQUFDTixRQUFRLEdBQUc1ZSxLQUFLNGUsUUFBUTtRQUM3QixJQUFJLENBQUMzQixHQUFHLEdBQUdqZCxLQUFLaWQsR0FBRztRQUNuQixJQUFJLENBQUMwbkUsUUFBUSxDQUFDM2tGLEtBQUs3QyxJQUFJO1FBQ3ZCLElBQUksQ0FBQ3luRixZQUFZLENBQUM1a0YsS0FBS3VkLFFBQVE7UUFDL0IsSUFBSXZkLEtBQUs2a0YsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQ0MsY0FBYyxDQUFDOWtGLEtBQUs2a0YsVUFBVTtRQUNyQztRQUNBLGtEQUFrRDtRQUNsRCxJQUFJLENBQUNILGVBQWUsR0FBRzFrRjtRQUN2QixJQUFJLENBQUM1RSxHQUFHLENBQUNrQixLQUFLLENBQUMsMkJBQTJCM0MsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7WUFDMUZ2K0M7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBOztJQUVFLEdBQ0Y0a0YsYUFBYUcsRUFBRSxFQUFFO1FBQ2YsTUFBTUMsVUFBVSxJQUFJLENBQUN6bkUsUUFBUSxLQUFLd25FO1FBQ2xDLE1BQU1FLGVBQWUsSUFBSSxDQUFDMW5FLFFBQVE7UUFDbEMsSUFBSSxDQUFDQSxRQUFRLEdBQUd3bkU7UUFDaEIsSUFBSUMsU0FBUztZQUNYLElBQUksQ0FBQ2w3RCxJQUFJLENBQUNvcUIsaUJBQWlCZ3hDLDBCQUEwQixFQUFFRDtRQUN6RDtJQUNGO0lBQ0FOLFNBQVN4bkYsSUFBSSxFQUFFO1FBQ2IsTUFBTTZuRixVQUFVLElBQUksQ0FBQzduRixJQUFJLEtBQUtBO1FBQzlCLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaLElBQUk2bkYsU0FBUztZQUNYLElBQUksQ0FBQ2w3RCxJQUFJLENBQUNvcUIsaUJBQWlCaXhDLHNCQUFzQixFQUFFaG9GO1FBQ3JEO0lBQ0Y7SUFDQSxjQUFjLEdBQ2QybkYsZUFBZWhCLFdBQVcsRUFBRTtRQUMxQixJQUFJLzlFLElBQUk4VSxJQUFJQyxJQUFJQyxJQUFJbXlEO1FBQ3BCLE1BQU1rWSxrQkFBa0IsSUFBSSxDQUFDdEIsV0FBVztRQUN4QyxNQUFNa0IsVUFBVWxCLFlBQVkxbEUsVUFBVSxLQUFNLEVBQUNyWSxLQUFLLElBQUksQ0FBQys5RSxXQUFXLE1BQU0sUUFBUS85RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxWSxVQUFVLEtBQUswbEUsWUFBWTNsRSxZQUFZLEtBQU0sRUFBQ3RELEtBQUssSUFBSSxDQUFDaXBFLFdBQVcsTUFBTSxRQUFRanBFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NELFlBQVksS0FBSzJsRSxZQUFZemxFLGNBQWMsS0FBTSxFQUFDdkQsS0FBSyxJQUFJLENBQUNncEUsV0FBVyxNQUFNLFFBQVFocEUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdUQsY0FBYyxLQUFLeWxFLFlBQVl2bEUsTUFBTSxLQUFNLEVBQUN4RCxLQUFLLElBQUksQ0FBQytvRSxXQUFXLE1BQU0sUUFBUS9vRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3RCxNQUFNLEtBQUt1bEUsWUFBWXRsRSxRQUFRLEtBQU0sRUFBQzB1RCxLQUFLLElBQUksQ0FBQzRXLFdBQVcsTUFBTSxRQUFRNVcsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMXVELFFBQVEsS0FBS3NsRSxZQUFZeGxFLGlCQUFpQixDQUFDemhCLE1BQU0sS0FBSyxJQUFJLENBQUNpbkYsV0FBVyxDQUFDeGxFLGlCQUFpQixDQUFDemhCLE1BQU0sSUFBSWluRixZQUFZeGxFLGlCQUFpQixDQUFDNFQsSUFBSSxDQUFDLENBQUM3dUIsT0FBTytvQjtZQUN0cUIsSUFBSXJtQjtZQUNKLE9BQU8xQyxVQUFXLEVBQUMwQyxLQUFLLElBQUksQ0FBQys5RSxXQUFXLE1BQU0sUUFBUS85RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1WSxpQkFBaUIsQ0FBQzhOLE1BQU07UUFDNUc7UUFDQSxJQUFJLENBQUMwM0QsV0FBVyxHQUFHQTtRQUNuQixJQUFJa0IsU0FBUztZQUNYLElBQUksQ0FBQ2w3RCxJQUFJLENBQUNvcUIsaUJBQWlCbXhDLDZCQUE2QixFQUFFRDtRQUM1RDtRQUNBLE9BQU9KO0lBQ1Q7SUFDQSxjQUFjLEdBQ2RNLGNBQWNDLFFBQVEsRUFBRTtRQUN0QixJQUFJQSxhQUFhLElBQUksQ0FBQ3ZCLFVBQVUsRUFBRTtZQUNoQztRQUNGO1FBQ0EsSUFBSSxDQUFDQSxVQUFVLEdBQUd1QjtRQUNsQixJQUFJQSxVQUFVO1lBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSWpxRTtRQUN6QjtRQUNBLElBQUksQ0FBQ3VPLElBQUksQ0FBQ29xQixpQkFBaUJ1eEMsaUJBQWlCLEVBQUVGO0lBQ2hEO0lBQ0EsY0FBYyxHQUNkRyxxQkFBcUJ0TCxDQUFDLEVBQUU7UUFDdEIsTUFBTXVMLGNBQWMsSUFBSSxDQUFDMUIsa0JBQWtCO1FBQzNDLElBQUksQ0FBQ0Esa0JBQWtCLEdBQUdiLGlCQUFpQmhKO1FBQzNDLElBQUl1TCxnQkFBZ0IsSUFBSSxDQUFDMUIsa0JBQWtCLEVBQUU7WUFDM0MsSUFBSSxDQUFDbjZELElBQUksQ0FBQ29xQixpQkFBaUIweEMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDM0Isa0JBQWtCO1FBQzlFO0lBQ0Y7SUFDQTs7R0FFQyxHQUNEeE8sZ0JBQWdCcnlCLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUM2SCxZQUFZLEdBQUc3SDtRQUNwQixJQUFJLENBQUM4Z0MsV0FBVyxDQUFDM3FGLE9BQU8sQ0FBQ3UyQixDQUFBQSxRQUFTLENBQUNBLE1BQU1BLEtBQUssWUFBWXVzRCxvQkFBb0J2c0QsTUFBTUEsS0FBSyxZQUFZa2xELGVBQWMsS0FBTWxsRCxNQUFNQSxLQUFLLENBQUMybEQsZUFBZSxDQUFDcnlCO0lBQ3ZKO0lBQ0F5aUMsb0JBQW9CbnlCLFdBQVcsRUFBRTtRQUMvQixvQ0FBb0M7UUFDcENBLFlBQVkzb0MsRUFBRSxDQUFDcXBCLFdBQVc2YixLQUFLLEVBQUU7WUFDL0IsSUFBSSxDQUFDbm1DLElBQUksQ0FBQ29xQixpQkFBaUI0eEMsVUFBVSxFQUFFcHlCO1FBQ3pDO1FBQ0FBLFlBQVkzb0MsRUFBRSxDQUFDcXBCLFdBQVc4YixPQUFPLEVBQUU7WUFDakMsSUFBSSxDQUFDcG1DLElBQUksQ0FBQ29xQixpQkFBaUI2eEMsWUFBWSxFQUFFcnlCO1FBQzNDO1FBQ0EsTUFBTVgsTUFBTVc7UUFDWixJQUFJWCxJQUFJampDLEtBQUssRUFBRTtZQUNiaWpDLElBQUlqakMsS0FBSyxDQUFDN1MsR0FBRyxHQUFHeTJDLFlBQVk5WSxRQUFRO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDNTdCLE1BQU0sQ0FBQ3RTLEdBQUcsQ0FBQ2duRCxZQUFZOVksUUFBUSxFQUFFOFk7UUFDdEMsT0FBUUEsWUFBWWhoRCxJQUFJO1lBQ3RCLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQzBDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQ3lpQyxXQUFXLENBQUN4M0UsR0FBRyxDQUFDZ25ELFlBQVk5WSxRQUFRLEVBQUU4WTtnQkFDM0M7WUFDRixLQUFLclcsTUFBTTBCLElBQUksQ0FBQ0MsS0FBSztnQkFDbkIsSUFBSSxDQUFDbWxDLFdBQVcsQ0FBQ3ozRSxHQUFHLENBQUNnbkQsWUFBWTlZLFFBQVEsRUFBRThZO2dCQUMzQztRQUNKO0lBQ0Y7QUFDRjtBQUVBLFNBQVNzeUIsdUJBQXVCQyxLQUFLO0lBQ25DLElBQUlsZ0YsSUFBSThVLElBQUlDO0lBQ1osSUFBSSxDQUFDbXJFLE1BQU0za0UsY0FBYyxJQUFJLENBQUMya0UsTUFBTTFrRSxtQkFBbUIsRUFBRTtRQUN2RCxNQUFNLElBQUlqZ0IsTUFBTTtJQUNsQjtJQUNBLE9BQU8sSUFBSTI2QyxnQkFBZ0I7UUFDekIxNkIscUJBQXFCLENBQUN4YixLQUFLa2dGLE1BQU0xa0UsbUJBQW1CLE1BQU0sUUFBUXhiLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3ZGdWIsZ0JBQWdCLENBQUN6RyxLQUFLb3JFLE1BQU0za0UsY0FBYyxNQUFNLFFBQVF6RyxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUM3RXFoQyxXQUFXLENBQUNwaEMsS0FBS21yRSxNQUFNQyxRQUFRLE1BQU0sUUFBUXByRSxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsRThHLFdBQVdxa0UsTUFBTUUsZ0JBQWdCLElBQUksRUFBRTtJQUN6QztBQUNGO0FBRUEsTUFBTUMsK0JBQStCaEU7SUFDbkMvN0UsWUFBWXFNLElBQUksRUFBRXd3RSxFQUFFLEVBQUUzbUIsYUFBYSxFQUFFaGYsYUFBYSxDQUFFO1FBQ2xELEtBQUssQ0FBQzdxQyxNQUFNd3dFLEdBQUdqbUUsR0FBRyxFQUFFaW1FLEdBQUcvbEYsSUFBSSxFQUFFb2dEO1FBQzdCLElBQUksQ0FBQ3p0QixLQUFLLEdBQUd0ekI7UUFDYixjQUFjLEdBQ2QsSUFBSSxDQUFDNi9DLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ3JCLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNxckMsbUJBQW1CLEdBQUc3cEUsYUFBYTY5RCxJQUFJO1FBQzVDLElBQUksQ0FBQ2xzQixXQUFXLEdBQUdyK0IsQ0FBQUE7WUFDakIsSUFBSSxDQUFDMnlELFFBQVEsQ0FBQ2ptRjtZQUNkLElBQUksQ0FBQ3N0QixJQUFJLENBQUNzcUIsV0FBV2lhLEtBQUssRUFBRXYrQjtRQUM5QjtRQUNBLElBQUksQ0FBQ3cyRCxzQkFBc0IsR0FBR25HLENBQUFBO1lBQzVCLElBQUksQ0FBQy9rRixHQUFHLENBQUMyQixLQUFLLENBQUMsbUNBQW1DcUksTUFBTSxDQUFDLElBQUksQ0FBQ3cxQyxRQUFRLEVBQUUsY0FBY3gxQyxNQUFNLENBQUMrNkUsVUFBVSxJQUFJLENBQUM1aEMsVUFBVTtZQUN0SCxJQUFJLENBQUN2RCxRQUFRLEdBQUcsQ0FBQ21sQztZQUNqQixJQUFJLENBQUNvRyxlQUFlO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDQywyQkFBMkIsR0FBRzUzQixDQUFBQTtZQUNqQyxJQUFJLENBQUN4ekQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLG1DQUFtQ3FJLE1BQU0sQ0FBQ3dwRCxXQUFXN3VDLEtBQUssRUFBRSxLQUFLM2EsTUFBTSxDQUFDd3BELFdBQVc1dUMsTUFBTSxHQUFHLElBQUksQ0FBQ3UrQixVQUFVO1lBQzFILElBQUksQ0FBQ2tvQyxlQUFlLEdBQUc3M0I7WUFDdkIsSUFBSSxDQUFDMjNCLGVBQWU7UUFDdEI7UUFDQSxJQUFJLENBQUNHLFVBQVUsR0FBR25xQjtRQUNsQixJQUFJLENBQUNzbUIsVUFBVSxDQUFDSztJQUNsQjtJQUNBOzs7R0FHQyxHQUNEeUQsY0FBY0QsVUFBVSxFQUFFO1FBQ3hCLE1BQU1FLGFBQWEsSUFBSSxDQUFDQyxrQkFBa0I7UUFDMUMsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQzVDLElBQUksQ0FBQ0wsVUFBVSxHQUFHQTtRQUNsQiwrREFBK0Q7UUFDL0QsbUVBQW1FO1FBQ25FLElBQUlBLFlBQVk7WUFDZCxJQUFJLENBQUNycUMsT0FBTyxHQUFHO1FBQ2pCO1FBQ0EsTUFBTW9lLE1BQU0sSUFBSWppQixtQkFBbUI7WUFDakM1MkIsV0FBVztnQkFBQyxJQUFJLENBQUNnNUIsUUFBUTthQUFDO1lBQzFCRSxXQUFXLElBQUksQ0FBQzRyQyxVQUFVO1lBQzFCM3JDLG1CQUFtQjtnQkFBQyxJQUFJcDVCLGtCQUFrQjtvQkFDeEMseUVBQXlFO29CQUN6RSxrRUFBa0U7b0JBQ2xFTCxnQkFBZ0I7b0JBQ2hCTSxXQUFXO3dCQUFDLElBQUksQ0FBQ2c1QixRQUFRO3FCQUFDO2dCQUM1QjthQUFHO1FBQ0w7UUFDQSxJQUFJLENBQUM5d0IsSUFBSSxDQUFDc3FCLFdBQVdvRSxrQkFBa0IsRUFBRWlpQjtRQUN6QyxJQUFJLENBQUN1c0IsK0JBQStCLENBQUNKO1FBQ3JDLElBQUksQ0FBQ0ssNkJBQTZCLENBQUNIO0lBQ3JDO0lBQ0EsSUFBSUQscUJBQXFCO1FBQ3ZCLElBQUksSUFBSSxDQUFDSCxVQUFVLEtBQUssT0FBTztZQUM3QixPQUFPdEUsaUJBQWlCVyxrQkFBa0IsQ0FBQ21FLFlBQVk7UUFDekQ7UUFDQSxJQUFJLENBQUMsS0FBSyxDQUFDeEUsY0FBYztZQUN2QixPQUFPTixpQkFBaUJXLGtCQUFrQixDQUFDb0UsT0FBTztRQUNwRDtRQUNBLE9BQU8vRSxpQkFBaUJXLGtCQUFrQixDQUFDcUUsVUFBVTtJQUN2RDtJQUNBLElBQUlMLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQzFxQyxPQUFPLEdBQUcrbEMsaUJBQWlCWSxnQkFBZ0IsQ0FBQ3FFLE9BQU8sR0FBR2pGLGlCQUFpQlksZ0JBQWdCLENBQUNzRSxVQUFVO0lBQ2hIO0lBQ0E7O0dBRUMsR0FDRCxJQUFJNUUsZUFBZTtRQUNqQixJQUFJLElBQUksQ0FBQ2dFLFVBQVUsS0FBSyxPQUFPO1lBQzdCLE9BQU87UUFDVDtRQUNBLE9BQU8sS0FBSyxDQUFDaEU7SUFDZjtJQUNBLHlGQUF5RjtJQUN6RixJQUFJeFAsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDd1QsVUFBVSxLQUFLO0lBQzdCO0lBQ0EsSUFBSXRoQyxZQUFZO1FBQ2QsT0FBTyxDQUFDLElBQUksQ0FBQ3BLLFFBQVE7SUFDdkI7SUFDQTs7Ozs7R0FLQyxHQUNEdXNDLFdBQVd4cEUsT0FBTyxFQUFFO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUN5cEUsd0JBQXdCLE1BQU0sSUFBSSxDQUFDeHNDLFFBQVEsS0FBSyxDQUFDajlCLFNBQVM7WUFDbEU7UUFDRjtRQUNBLElBQUksQ0FBQ2k5QixRQUFRLEdBQUcsQ0FBQ2o5QjtRQUNqQixJQUFJLENBQUN3b0UsZUFBZTtJQUN0QjtJQUNBOzs7Ozs7R0FNQyxHQUNEa0IsZ0JBQWdCL21FLE9BQU8sRUFBRTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDOG1FLHdCQUF3QixNQUFNLElBQUksQ0FBQ25CLG1CQUFtQixLQUFLM2xFLFNBQVM7WUFDNUU7UUFDRjtRQUNBLElBQUksQ0FBQzJsRSxtQkFBbUIsR0FBRzNsRTtRQUMzQixJQUFJLENBQUMrbEUsZUFBZSxHQUFHanFGO1FBQ3ZCLElBQUksQ0FBQytwRixlQUFlO0lBQ3RCO0lBQ0FtQixtQkFBbUI5NEIsVUFBVSxFQUFFO1FBQzdCLElBQUk3b0QsSUFBSThVO1FBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQzJzRSx3QkFBd0IsSUFBSTtZQUNwQztRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN6aEYsS0FBSyxJQUFJLENBQUMwZ0YsZUFBZSxNQUFNLFFBQVExZ0YsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZ2EsS0FBSyxNQUFNNnVDLFdBQVc3dUMsS0FBSyxJQUFJLENBQUMsQ0FBQ2xGLEtBQUssSUFBSSxDQUFDNHJFLGVBQWUsTUFBTSxRQUFRNXJFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR21GLE1BQU0sTUFBTTR1QyxXQUFXNXVDLE1BQU0sRUFBRTtZQUMxTTtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUM4UCxLQUFLLFlBQVlzdUQsa0JBQWtCO1lBQzFDLElBQUksQ0FBQ3FJLGVBQWUsR0FBRzczQjtRQUN6QjtRQUNBLElBQUksQ0FBQ3kzQixtQkFBbUIsR0FBRzdwRjtRQUMzQixJQUFJLENBQUMrcEYsZUFBZTtJQUN0QjtJQUNBb0IsWUFBWTFzQyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDdXNDLHdCQUF3QixJQUFJO1lBQ3BDO1FBQ0Y7UUFDQSxJQUFJLENBQUUsS0FBSSxDQUFDMTNELEtBQUssWUFBWXN1RCxnQkFBZSxHQUFJO1lBQzdDO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ25qQyxHQUFHLEtBQUtBLEtBQUs7WUFDcEI7UUFDRjtRQUNBLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3NyQyxlQUFlO0lBQ3RCO0lBQ0EsSUFBSXFCLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUN2QixtQkFBbUI7SUFDakM7SUFDQSxjQUFjLEdBQ2Q1RCxTQUFTM3lELEtBQUssRUFBRTtRQUNkLE1BQU04MkQsYUFBYSxJQUFJLENBQUNDLGtCQUFrQjtRQUMxQyxNQUFNQyxpQkFBaUIsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDNUMsTUFBTWMsWUFBWSxJQUFJLENBQUMvM0QsS0FBSztRQUM1QixJQUFJKzNELGNBQWMvM0QsT0FBTztZQUN2QjtRQUNGO1FBQ0EsSUFBSSszRCxXQUFXO1lBQ2Isc0JBQXNCO1lBQ3RCQSxVQUFVbDhELEdBQUcsQ0FBQ3lvQixXQUFXdXNDLHNCQUFzQixFQUFFLElBQUksQ0FBQzZGLDJCQUEyQjtZQUNqRnFCLFVBQVVsOEQsR0FBRyxDQUFDeW9CLFdBQVdpc0MsaUJBQWlCLEVBQUUsSUFBSSxDQUFDaUcsc0JBQXNCO1lBQ3ZFdUIsVUFBVWw4RCxHQUFHLENBQUN5b0IsV0FBV2lhLEtBQUssRUFBRSxJQUFJLENBQUNGLFdBQVc7WUFDaEQwNUIsVUFBVTluQyxNQUFNO1lBQ2hCOG5DLFVBQVV2bkMsV0FBVztZQUNyQixJQUFJLENBQUN4MkIsSUFBSSxDQUFDc3FCLFdBQVc4eUMsWUFBWSxFQUFFVztRQUNyQztRQUNBLEtBQUssQ0FBQ3BGLFNBQVMzeUQ7UUFDZixJQUFJQSxPQUFPO1lBQ1RBLE1BQU03UyxHQUFHLEdBQUcsSUFBSSxDQUFDMjlCLFFBQVE7WUFDekI5cUIsTUFBTS9FLEVBQUUsQ0FBQ3FwQixXQUFXdXNDLHNCQUFzQixFQUFFLElBQUksQ0FBQzZGLDJCQUEyQjtZQUM1RTEyRCxNQUFNL0UsRUFBRSxDQUFDcXBCLFdBQVdpc0MsaUJBQWlCLEVBQUUsSUFBSSxDQUFDaUcsc0JBQXNCO1lBQ2xFeDJELE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV2lhLEtBQUssRUFBRSxJQUFJLENBQUNGLFdBQVc7WUFDM0MsSUFBSSxDQUFDcmtDLElBQUksQ0FBQ3NxQixXQUFXZ3pDLFVBQVUsRUFBRXQzRDtRQUNuQztRQUNBLElBQUksQ0FBQ20zRCw2QkFBNkIsQ0FBQ0g7UUFDbkMsSUFBSSxDQUFDRSwrQkFBK0IsQ0FBQ0o7SUFDdkM7SUFDQSxjQUFjLEdBQ2RrQixXQUFXenJDLE9BQU8sRUFBRTtRQUNsQixNQUFNdXFDLGFBQWEsSUFBSSxDQUFDQyxrQkFBa0I7UUFDMUMsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQzVDLElBQUksQ0FBQzFxQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDNHFDLDZCQUE2QixDQUFDSDtRQUNuQyxJQUFJLENBQUNFLCtCQUErQixDQUFDSjtJQUN2QztJQUNBLGNBQWMsR0FDZG1CLHFCQUFxQjkvRCxLQUFLLEVBQUU7UUFDMUIsSUFBSSxDQUFDNkIsSUFBSSxDQUFDc3FCLFdBQVc0ekMsa0JBQWtCLEVBQUUvL0Q7SUFDM0M7SUFDQSxjQUFjLEdBQ2Q0NkQsV0FBVzdpRixJQUFJLEVBQUU7UUFDZixLQUFLLENBQUM2aUYsV0FBVzdpRjtRQUNqQixNQUFNaW9GLG9CQUFvQixJQUFJLENBQUM1RixhQUFhO1FBQzVDLElBQUksQ0FBQ0EsYUFBYSxHQUFHcmlGLEtBQUs4ZixLQUFLO1FBQy9CLElBQUksSUFBSSxDQUFDZ1EsS0FBSyxFQUFFO1lBQ2QsSUFBSSxDQUFDQSxLQUFLLENBQUNtc0QsUUFBUSxDQUFDajhFLEtBQUs4ZixLQUFLO1FBQ2hDLE9BQU8sSUFBSW1vRSxzQkFBc0Jqb0YsS0FBSzhmLEtBQUssRUFBRTtZQUMzQyxJQUFJLENBQUNnSyxJQUFJLENBQUM5cEIsS0FBSzhmLEtBQUssR0FBR3MwQixXQUFXNmIsS0FBSyxHQUFHN2IsV0FBVzhiLE9BQU87UUFDOUQ7SUFDRjtJQUNBODJCLGdDQUFnQ2tCLGNBQWMsRUFBRTtRQUM5QyxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDdEIsa0JBQWtCO1FBQzdDLElBQUlxQixtQkFBbUJDLGVBQWU7WUFDcEM7UUFDRjtRQUNBLElBQUksQ0FBQ3IrRCxJQUFJLENBQUNzcUIsV0FBV2cwQyx5QkFBeUIsRUFBRUQsZUFBZUQ7SUFDakU7SUFDQWpCLDhCQUE4Qm9CLHdCQUF3QixFQUFFO1FBQ3RELE1BQU1DLDBCQUEwQixJQUFJLENBQUN2QixnQkFBZ0I7UUFDckQsSUFBSXVCLDRCQUE0QkQsMEJBQTBCO1lBQ3hELElBQUksQ0FBQ3YrRCxJQUFJLENBQUNzcUIsV0FBV20wQyw2QkFBNkIsRUFBRSxJQUFJLENBQUN4QixnQkFBZ0IsRUFBRXNCO1FBQzdFO0lBQ0Y7SUFDQWIsMkJBQTJCO1FBQ3pCLElBQUksSUFBSSxDQUFDOTBFLElBQUksS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLElBQUksSUFBSSxDQUFDeS9CLGdCQUFnQixFQUFFO1lBQzNELElBQUksQ0FBQ3JqRixHQUFHLENBQUMydEIsSUFBSSxDQUFDLGtFQUFrRSxJQUFJLENBQUN3MUIsVUFBVTtZQUMvRixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDMjBCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUM5M0UsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxvREFBb0QsSUFBSSxDQUFDdzFCLFVBQVU7WUFDakYsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSWtnQyxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMzdUQsS0FBSyxZQUFZc3VELG9CQUFvQixJQUFJLENBQUN0dUQsS0FBSyxDQUFDMnVELGdCQUFnQjtJQUM5RTtJQUNBLGFBQWEsR0FDYjhILGtCQUFrQjtRQUNoQixNQUFNaHNCLFdBQVcsSUFBSTloQixvQkFBb0I7WUFDdkM3MkIsV0FBVztnQkFBQyxJQUFJLENBQUNnNUIsUUFBUTthQUFDO1lBQzFCSSxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkMsS0FBSyxJQUFJLENBQUNBLEdBQUc7UUFDZjtRQUNBLElBQUksSUFBSSxDQUFDd3JDLGVBQWUsRUFBRTtZQUN4QmxzQixTQUFTeDZDLEtBQUssR0FBR3BXLEtBQUttUyxJQUFJLENBQUMsSUFBSSxDQUFDMnFFLGVBQWUsQ0FBQzFtRSxLQUFLO1lBQ3JEdzZDLFNBQVN2NkMsTUFBTSxHQUFHclcsS0FBS21TLElBQUksQ0FBQyxJQUFJLENBQUMycUUsZUFBZSxDQUFDem1FLE1BQU07UUFDekQsT0FBTyxJQUFJLElBQUksQ0FBQ3FtRSxtQkFBbUIsS0FBSzdwRixXQUFXO1lBQ2pEKzlELFNBQVM3NUMsT0FBTyxHQUFHLElBQUksQ0FBQzJsRSxtQkFBbUI7UUFDN0MsT0FBTztZQUNMLDJCQUEyQjtZQUMzQjlyQixTQUFTNzVDLE9BQU8sR0FBR2xFLGFBQWE2OUQsSUFBSTtRQUN0QztRQUNBLElBQUksQ0FBQ3Z3RCxJQUFJLENBQUNzcUIsV0FBV28wQyxjQUFjLEVBQUVqdUI7SUFDdkM7QUFDRjtBQUVBLE1BQU1rdUIsMEJBQTBCN0U7SUFDOUIsY0FBYyxHQUNkLE9BQU84RSxvQkFBb0IzUCxZQUFZLEVBQUU0UCxFQUFFLEVBQUU7UUFDM0MsT0FBTyxJQUFJRixrQkFBa0IxUCxjQUFjNFAsR0FBRzFyRSxHQUFHLEVBQUUwckUsR0FBRy9wRSxRQUFRLEVBQUUrcEUsR0FBR3hyRixJQUFJLEVBQUV3ckYsR0FBR3ByRSxRQUFRO0lBQ3RGO0lBQ0EsY0FBYyxHQUNkbFgsWUFBWTB5RSxZQUFZLEVBQUU5N0QsR0FBRyxFQUFFMkIsUUFBUSxFQUFFemhCLElBQUksRUFBRW9nQixRQUFRLEVBQUVnZ0MsYUFBYSxDQUFFO1FBQ3RFLEtBQUssQ0FBQ3RnQyxLQUFLMkIsWUFBWSxJQUFJemhCLE1BQU1vZ0IsVUFBVWdnQztRQUMzQyxJQUFJLENBQUN3N0IsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUMvNUQsTUFBTSxHQUFHLElBQUlnUDtRQUNsQixJQUFJLENBQUNrMkQsV0FBVyxHQUFHLElBQUlsMkQ7UUFDdkIsSUFBSSxDQUFDbTJELFdBQVcsR0FBRyxJQUFJbjJEO1FBQ3ZCLElBQUksQ0FBQzQ2RCxTQUFTLEdBQUcsSUFBSTU2RDtJQUN2QjtJQUNBNjNELG9CQUFvQm55QixXQUFXLEVBQUU7UUFDL0IsS0FBSyxDQUFDbXlCLG9CQUFvQm55QjtRQUMxQix5QkFBeUI7UUFDekJBLFlBQVkzb0MsRUFBRSxDQUFDcXBCLFdBQVdvMEMsY0FBYyxFQUFFanVCLENBQUFBO1lBQ3hDLElBQUksQ0FBQ24vRCxHQUFHLENBQUMyQixLQUFLLENBQUMsd0JBQXdCcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QmtWO1lBQ2hILElBQUksQ0FBQ3FsQixZQUFZLENBQUN6ZSx1QkFBdUIsQ0FBQ0M7UUFDNUM7UUFDQTdHLFlBQVkzb0MsRUFBRSxDQUFDcXBCLFdBQVdvRSxrQkFBa0IsRUFBRWlpQixDQUFBQTtZQUM1Q0EsSUFBSTFmLGlCQUFpQixDQUFDeGhELE9BQU8sQ0FBQytwQyxDQUFBQTtnQkFDNUJBLEdBQUdoaUIsY0FBYyxHQUFHLElBQUksQ0FBQ3JFLEdBQUc7WUFDOUI7WUFDQSxJQUFJLENBQUM4N0QsWUFBWSxDQUFDdmUsc0JBQXNCLENBQUNDO1FBQzNDO1FBQ0EvRyxZQUFZM29DLEVBQUUsQ0FBQ3FwQixXQUFXbTBDLDZCQUE2QixFQUFFbjFDLENBQUFBO1lBQ3ZELElBQUksQ0FBQ3RwQixJQUFJLENBQUNvcUIsaUJBQWlCMjBDLGtDQUFrQyxFQUFFbjFCLGFBQWF0Z0I7UUFDOUU7UUFDQXNnQixZQUFZM29DLEVBQUUsQ0FBQ3FwQixXQUFXZzBDLHlCQUF5QixFQUFFaDFDLENBQUFBO1lBQ25ELElBQUksQ0FBQ3RwQixJQUFJLENBQUNvcUIsaUJBQWlCNDBDLDhCQUE4QixFQUFFcDFCLGFBQWF0Z0I7UUFDMUU7UUFDQXNnQixZQUFZM29DLEVBQUUsQ0FBQ3FwQixXQUFXZ3pDLFVBQVUsRUFBRXQzRCxDQUFBQTtZQUNwQyxJQUFJLENBQUNoRyxJQUFJLENBQUNvcUIsaUJBQWlCbWYsZUFBZSxFQUFFdmpDLE9BQU80akM7UUFDckQ7UUFDQUEsWUFBWTNvQyxFQUFFLENBQUNxcEIsV0FBVzh5QyxZQUFZLEVBQUU2QixDQUFBQTtZQUN0QyxJQUFJLENBQUNqL0QsSUFBSSxDQUFDb3FCLGlCQUFpQmlmLGlCQUFpQixFQUFFNDFCLGVBQWVyMUI7UUFDL0Q7UUFDQUEsWUFBWTNvQyxFQUFFLENBQUNxcEIsV0FBVzR6QyxrQkFBa0IsRUFBRS8vRCxDQUFBQTtZQUM1QyxJQUFJLENBQUM2QixJQUFJLENBQUNvcUIsaUJBQWlCODBDLHVCQUF1QixFQUFFdDFCLFlBQVk5WSxRQUFRLEVBQUUzeUI7UUFDNUU7SUFDRjtJQUNBbThELFNBQVNyc0UsTUFBTSxFQUFFO1FBQ2YsTUFBTStYLFFBQVEsS0FBSyxDQUFDczBELFNBQVNyc0U7UUFDN0IsSUFBSStYLE9BQU87WUFDVCxPQUFPQTtRQUNUO0lBQ0Y7SUFDQXUwRCxlQUFlbG5GLElBQUksRUFBRTtRQUNuQixNQUFNMnlCLFFBQVEsS0FBSyxDQUFDdTBELGVBQWVsbkY7UUFDbkMsSUFBSTJ5QixPQUFPO1lBQ1QsT0FBT0E7UUFDVDtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FDRDRzRCxVQUFVanhCLE1BQU0sRUFBRTtRQUNoQixJQUFJMXpDLFNBQVM1YixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBR2toRCxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTtRQUN4RyxJQUFJLENBQUM0bUMsU0FBUyxDQUFDbDhFLEdBQUcsQ0FBQ3FMLFFBQVEwekM7UUFDM0IsTUFBTXc5QixtQkFBbUIsSUFBSSxDQUFDN0UsUUFBUSxDQUFDcnNFO1FBQ3ZDLElBQUlreEUsb0JBQW9CQSxpQkFBaUJuNUQsS0FBSyxFQUFFO1lBQzlDbTVELGlCQUFpQm41RCxLQUFLLENBQUM0c0QsU0FBUyxDQUFDanhCO1FBQ25DO0lBQ0Y7SUFDQTs7R0FFQyxHQUNEc3hCLFlBQVk7UUFDVixJQUFJaGxFLFNBQVM1YixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBR2toRCxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTtRQUN4RyxNQUFNaW5DLG1CQUFtQixJQUFJLENBQUM3RSxRQUFRLENBQUNyc0U7UUFDdkMsSUFBSWt4RSxvQkFBb0JBLGlCQUFpQm41RCxLQUFLLEVBQUU7WUFDOUMsT0FBT201RCxpQkFBaUJuNUQsS0FBSyxDQUFDaXRELFNBQVM7UUFDekM7UUFDQSxPQUFPLElBQUksQ0FBQzZMLFNBQVMsQ0FBQzN1RixHQUFHLENBQUM4ZDtJQUM1QjtJQUNBLGNBQWMsR0FDZG14RSx3QkFBd0I1ckMsVUFBVSxFQUFFcmdDLEdBQUcsRUFBRThqQyxXQUFXLEVBQUV4NEIsUUFBUSxFQUFFODFELHNCQUFzQixFQUFFOEssU0FBUyxFQUFFO1FBQ2pHLDZCQUE2QjtRQUM3QixzRUFBc0U7UUFDdEUsSUFBSXoxQixjQUFjLElBQUksQ0FBQzAxQixtQkFBbUIsQ0FBQ25zRTtRQUMzQyx5RUFBeUU7UUFDekUsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ3kyQyxhQUFhO1lBQ2hCLElBQUksQ0FBQ3oyQyxJQUFJM2MsVUFBVSxDQUFDLE9BQU87Z0JBQ3pCLHlDQUF5QztnQkFDekMsSUFBSSxDQUFDMGUsTUFBTSxDQUFDemxCLE9BQU8sQ0FBQzRiLENBQUFBO29CQUNsQixJQUFJLENBQUN1K0MsZUFBZXBXLFdBQVc1cUMsSUFBSSxLQUFLeUMsRUFBRXpDLElBQUksQ0FBQzdJLFFBQVEsSUFBSTt3QkFDekQ2cEQsY0FBY3YrQztvQkFDaEI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsNEVBQTRFO1FBQzVFLG9FQUFvRTtRQUNwRSxJQUFJLENBQUN1K0MsYUFBYTtZQUNoQixJQUFJeTFCLGNBQWMsR0FBRztnQkFDbkIsSUFBSSxDQUFDL3RGLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsa0NBQWtDdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO29CQUNqRzNELFVBQVUzOUI7Z0JBQ1o7Z0JBQ0EsSUFBSSxDQUFDNk0sSUFBSSxDQUFDb3FCLGlCQUFpQjgwQyx1QkFBdUIsRUFBRS9yRTtnQkFDcEQ7WUFDRjtZQUNBLElBQUlrc0UsY0FBYzNzRixXQUFXMnNGLFlBQVk7WUFDekN4MEMsV0FBVztnQkFDVCxJQUFJLENBQUN1MEMsdUJBQXVCLENBQUM1ckMsWUFBWXJnQyxLQUFLOGpDLGFBQWF4NEIsVUFBVTgxRCx3QkFBd0I4SyxZQUFZO1lBQzNHLEdBQUc7WUFDSDtRQUNGO1FBQ0EsSUFBSTdyQyxXQUFXdlEsVUFBVSxLQUFLLFNBQVM7WUFDckMsSUFBSSxDQUFDM3hDLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsOEZBQThGdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUJrVjtZQUN0TCxJQUFJLENBQUM1cEMsSUFBSSxDQUFDb3FCLGlCQUFpQjgwQyx1QkFBdUIsRUFBRS9yRTtZQUNwRDtRQUNGO1FBQ0EsTUFBTW9zRSxVQUFVL3JDLFdBQVc1cUMsSUFBSSxLQUFLO1FBQ3BDLElBQUlvZDtRQUNKLElBQUl1NUQsU0FBUztZQUNYdjVELFFBQVEsSUFBSXN1RCxpQkFBaUI5Z0MsWUFBWXJnQyxLQUFLc0wsVUFBVTgxRDtRQUMxRCxPQUFPO1lBQ0x2dUQsUUFBUSxJQUFJdXNELGlCQUFpQi8rQixZQUFZcmdDLEtBQUtzTCxVQUFVLElBQUksQ0FBQzBpQyxZQUFZLEVBQUUsSUFBSSxDQUFDcXhCLFdBQVc7UUFDN0Y7UUFDQSxpQkFBaUI7UUFDakJ4c0QsTUFBTS9YLE1BQU0sR0FBRzI3QyxZQUFZMzdDLE1BQU07UUFDakMsa0NBQWtDO1FBQ2xDK1gsTUFBTTJ0QixPQUFPLEdBQUdpVyxZQUFZalcsT0FBTztRQUNuQzN0QixNQUFNb3NELGNBQWMsQ0FBQ243QjtRQUNyQmp4QixNQUFNOWdCLEtBQUs7UUFDWDBrRCxZQUFZK3VCLFFBQVEsQ0FBQzN5RDtRQUNyQiw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUM4NEQsU0FBUyxDQUFDdnVFLEdBQUcsQ0FBQ3E1QyxZQUFZMzdDLE1BQU0sS0FBSytYLGlCQUFpQnVzRCxrQkFBa0I7WUFDL0V2c0QsTUFBTTRzRCxTQUFTLENBQUMsSUFBSSxDQUFDa00sU0FBUyxDQUFDM3VGLEdBQUcsQ0FBQ3k1RCxZQUFZMzdDLE1BQU07UUFDdkQ7UUFDQSxPQUFPMjdDO0lBQ1Q7SUFDQSxjQUFjLEdBQ2QsSUFBSTQxQixjQUFjO1FBQ2hCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQzVFLGVBQWU7SUFDL0I7SUFDQTBFLG9CQUFvQm5zRSxHQUFHLEVBQUU7UUFDdkIsT0FBTyxJQUFJLENBQUMrQixNQUFNLENBQUMva0IsR0FBRyxDQUFDZ2pCO0lBQ3pCO0lBQ0EsY0FBYyxHQUNkNGxFLFdBQVc3aUYsSUFBSSxFQUFFO1FBQ2YsSUFBSSxDQUFDLEtBQUssQ0FBQzZpRixXQUFXN2lGLE9BQU87WUFDM0IsT0FBTztRQUNUO1FBQ0EsbUVBQW1FO1FBQ25FLGtDQUFrQztRQUNsQyxpRkFBaUY7UUFDakYsc0RBQXNEO1FBQ3RELE1BQU11cEYsY0FBYyxJQUFJdjdEO1FBQ3hCLE1BQU13N0QsWUFBWSxJQUFJeDdEO1FBQ3RCaHVCLEtBQUtnZixNQUFNLENBQUN6bEIsT0FBTyxDQUFDMnBGLENBQUFBO1lBQ2xCLElBQUluOUUsSUFBSThVO1lBQ1IsSUFBSTY0QyxjQUFjLElBQUksQ0FBQzAxQixtQkFBbUIsQ0FBQ2xHLEdBQUdqbUUsR0FBRztZQUNqRCxJQUFJLENBQUN5MkMsYUFBYTtnQkFDaEIsa0JBQWtCO2dCQUNsQixNQUFNaGhELE9BQU8ycUMsTUFBTXVFLGFBQWEsQ0FBQ3NoQyxHQUFHNStFLElBQUk7Z0JBQ3hDLElBQUksQ0FBQ29PLE1BQU07b0JBQ1Q7Z0JBQ0Y7Z0JBQ0FnaEQsY0FBYyxJQUFJMHlCLHVCQUF1QjF6RSxNQUFNd3dFLElBQUksQ0FBQ245RSxLQUFLLElBQUksQ0FBQ2d6RSxZQUFZLENBQUNsaEIsY0FBYyxNQUFNLFFBQVE5eEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdzJELGFBQWEsRUFBRTtvQkFDaEpyZSxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7b0JBQ3RDNWhELFlBQVksQ0FBQ2tlLEtBQUssSUFBSSxDQUFDMGlDLGFBQWEsTUFBTSxRQUFRMWlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2xlLFVBQVU7Z0JBQzFGO2dCQUNBKzJELFlBQVltdkIsVUFBVSxDQUFDSztnQkFDdkJzRyxVQUFVOThFLEdBQUcsQ0FBQ3cyRSxHQUFHam1FLEdBQUcsRUFBRXkyQztnQkFDdEIsTUFBTSsxQix3QkFBd0Jod0YsTUFBTWc1QyxJQUFJLENBQUMsSUFBSSxDQUFDenpCLE1BQU0sQ0FBQ3RjLE1BQU0sSUFBSTJQLElBQUksQ0FBQ3EzRSxDQUFBQSxpQkFBa0JBLGVBQWUzeEUsTUFBTSxLQUFNMjdDLENBQUFBLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWTM3QyxNQUFNO2dCQUM3TCxJQUFJMHhFLHlCQUF5Qi8xQixZQUFZMzdDLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDQyxPQUFPLEVBQUU7b0JBQ3hFLElBQUksQ0FBQ2xqRCxHQUFHLENBQUMyQixLQUFLLENBQUMsMkNBQTJDcUksTUFBTSxDQUFDLElBQUksQ0FBQ3daLFFBQVEsRUFBRSwyQkFBMkJ4WixNQUFNLENBQUNzdUQsWUFBWTM3QyxNQUFNLEdBQUdwZSxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzt3QkFDdkxvckMsVUFBVW5yQyx1QkFBdUJpckM7d0JBQ2pDeDZCLFVBQVV6USx1QkFBdUJrVjtvQkFDbkM7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDbXlCLG1CQUFtQixDQUFDbnlCO1lBQzNCLE9BQU87Z0JBQ0xBLFlBQVltdkIsVUFBVSxDQUFDSztZQUN6QjtZQUNBcUcsWUFBWTc4RSxHQUFHLENBQUN3MkUsR0FBR2ptRSxHQUFHLEVBQUV5MkM7UUFDMUI7UUFDQSx3QkFBd0I7UUFDeEIsSUFBSSxDQUFDMTBDLE1BQU0sQ0FBQ3psQixPQUFPLENBQUNtNkQsQ0FBQUE7WUFDbEIsSUFBSSxDQUFDNjFCLFlBQVlsdkUsR0FBRyxDQUFDcTVDLFlBQVk5WSxRQUFRLEdBQUc7Z0JBQzFDLElBQUksQ0FBQ3gvQyxHQUFHLENBQUNrQixLQUFLLENBQUMsOERBQThEM0MsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QmtWO2dCQUN0SixJQUFJLENBQUNrMkIsY0FBYyxDQUFDbDJCLFlBQVk5WSxRQUFRLEVBQUU7WUFDNUM7UUFDRjtRQUNBLHdGQUF3RjtRQUN4RjR1QyxVQUFVandGLE9BQU8sQ0FBQ202RCxDQUFBQTtZQUNoQixJQUFJLENBQUM1cEMsSUFBSSxDQUFDb3FCLGlCQUFpQjRlLGNBQWMsRUFBRVk7UUFDN0M7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxjQUFjLEdBQ2RrMkIsZUFBZTNzRSxHQUFHLEVBQUU0c0UsYUFBYSxFQUFFO1FBQ2pDLE1BQU1uMkIsY0FBYyxJQUFJLENBQUMxMEMsTUFBTSxDQUFDL2tCLEdBQUcsQ0FBQ2dqQjtRQUNwQyxJQUFJLENBQUN5MkMsYUFBYTtZQUNoQjtRQUNGO1FBQ0EseURBQXlEO1FBQ3pELE1BQU0sRUFDSjVqQyxLQUFLLEVBQ04sR0FBRzRqQztRQUNKLElBQUk1akMsT0FBTztZQUNUQSxNQUFNK0QsSUFBSTtZQUNWNi9CLFlBQVkrdUIsUUFBUSxDQUFDam1GO1FBQ3ZCO1FBQ0EsZ0VBQWdFO1FBQ2hFLElBQUksQ0FBQ3dpQixNQUFNLENBQUNtUCxNQUFNLENBQUNsUjtRQUNuQixpQ0FBaUM7UUFDakMsT0FBUXkyQyxZQUFZaGhELElBQUk7WUFDdEIsS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDMEMsS0FBSztnQkFDbkIsSUFBSSxDQUFDeWlDLFdBQVcsQ0FBQy8xRCxNQUFNLENBQUNsUjtnQkFDeEI7WUFDRixLQUFLb2dDLE1BQU0wQixJQUFJLENBQUNDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQ21sQyxXQUFXLENBQUNoMkQsTUFBTSxDQUFDbFI7Z0JBQ3hCO1FBQ0o7UUFDQSxJQUFJNHNFLGVBQWU7WUFDakIsSUFBSSxDQUFDLy9ELElBQUksQ0FBQ29xQixpQkFBaUI0MUMsZ0JBQWdCLEVBQUVwMkI7UUFDL0M7SUFDRjtJQUNBOztHQUVDLEdBQ0RxMkIsZUFBZTcvQyxNQUFNLEVBQUU7UUFDckIsT0FBT3ZqQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksQ0FBQzIxRCxXQUFXLEdBQUdweUM7WUFDbkIsTUFBTTgvQyxXQUFXLEVBQUU7WUFDbkIsSUFBSSxDQUFDOUYsV0FBVyxDQUFDM3FGLE9BQU8sQ0FBQ3c1RCxDQUFBQTtnQkFDdkIsSUFBSWh0RDtnQkFDSixJQUFJZ3RELElBQUlqakMsS0FBSyxZQUFZdXNELGtCQUFrQjtvQkFDekMyTixTQUFTem1GLElBQUksQ0FBQ3d2RCxJQUFJampDLEtBQUssQ0FBQ210RCxTQUFTLENBQUMsQ0FBQ2wzRSxLQUFLbWtDLE9BQU83WCxRQUFRLE1BQU0sUUFBUXRzQixPQUFPLEtBQUssSUFBSUEsS0FBSztnQkFDNUY7WUFDRjtZQUNBLE1BQU1taEIsUUFBUWpPLEdBQUcsQ0FBQyt3RTtRQUNwQjtJQUNGO0lBQ0EsY0FBYyxHQUNkbGdFLEtBQUt1TCxLQUFLLEVBQUU7UUFDVixJQUFLLElBQUlzSixPQUFPeGlDLFVBQVVVLE1BQU0sRUFBRTJyQixPQUFPLElBQUkvdUIsTUFBTWtsQyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7WUFDMUdwVyxJQUFJLENBQUNvVyxPQUFPLEVBQUUsR0FBR3ppQyxTQUFTLENBQUN5aUMsS0FBSztRQUNsQztRQUNBLElBQUksQ0FBQ3hqQyxHQUFHLENBQUNrQixLQUFLLENBQUMscUJBQXFCM0MsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7WUFDcEZscEI7WUFDQTdNO1FBQ0Y7UUFDQSxPQUFPLEtBQUssQ0FBQ3NCLEtBQUt1TCxVQUFVN007SUFDOUI7QUFDRjtBQUVBLE1BQU15aEUseUJBQXlCckc7SUFDN0IsY0FBYyxHQUNkdjlFLFlBQVk0VyxHQUFHLEVBQUUyQixRQUFRLEVBQUU4ekMsTUFBTSxFQUFFcnVELE9BQU8sQ0FBRTtRQUMxQyxLQUFLLENBQUM0WSxLQUFLMkIsVUFBVXBpQixXQUFXQSxXQUFXO1lBQ3pDRyxZQUFZMEgsUUFBUTFILFVBQVU7WUFDOUJ1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDd1UsTUFBTSxDQUFDblUsVUFBVTtRQUMvQztRQUNBLElBQUksQ0FBQzJyQyxpQkFBaUIsR0FBRyxJQUFJaHdFO1FBQzdCLElBQUksQ0FBQ2l3RSxzQkFBc0IsR0FBRyxJQUFJbjhEO1FBQ2xDLElBQUksQ0FBQ284RCwyQkFBMkIsR0FBRyxFQUFFO1FBQ3JDLElBQUksQ0FBQ0MsaUNBQWlDLEdBQUc7UUFDekMsSUFBSSxDQUFDQyxjQUFjLEdBQUcvcUUsZ0JBQWdCaUIsSUFBSTtRQUMxQyxJQUFJLENBQUMrcEUsa0JBQWtCLEdBQUc7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJLy9CO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJLENBQUNnZ0MsaUJBQWlCLEdBQUc7WUFDdkIsSUFBSTFrRixJQUFJOFU7WUFDUEEsQ0FBQUEsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUN5a0YsZUFBZSxNQUFNLFFBQVF6a0YsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2hCLE9BQU8sTUFBTSxRQUFRcE0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHL2YsSUFBSSxDQUFDaUw7WUFDaEksSUFBSSxDQUFDeWtGLGVBQWUsR0FBR2h1RjtZQUN2QixJQUFJLENBQUNrdUYsa0NBQWtDO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztZQUN4QixJQUFJNWtGLElBQUk4VTtZQUNSLElBQUksSUFBSSxDQUFDMnZFLGVBQWUsRUFBRTtnQkFDeEIsSUFBSSxDQUFDQSxlQUFlLENBQUNsckQsT0FBTyxDQUFDekIsS0FBSyxDQUFDcmtDLENBQUFBLElBQUssSUFBSSxDQUFDNEIsR0FBRyxDQUFDMnRCLElBQUksQ0FBQ3Z2QixFQUFFNkwsT0FBTyxFQUFFLElBQUksQ0FBQ2s1QyxVQUFVO2dCQUMvRTFqQyxDQUFBQSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ3lrRixlQUFlLE1BQU0sUUFBUXprRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdvaEIsTUFBTSxNQUFNLFFBQVF0TSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcvZixJQUFJLENBQUNpTCxJQUFJO2dCQUNuSSxJQUFJLENBQUN5a0YsZUFBZSxHQUFHaHVGO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNrdUYsa0NBQWtDLEdBQUc7WUFDeEMsSUFBSSxDQUFDdHZGLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQywyQ0FBMkNwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDMUdxc0Msd0JBQXdCLElBQUksQ0FBQ1AsaUNBQWlDO2dCQUM5REQsNkJBQTZCLElBQUksQ0FBQ0EsMkJBQTJCO1lBQy9EO1lBQ0EsSUFBSSxDQUFDMTNCLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQzlSLGlDQUFpQyxDQUFDLElBQUksQ0FBQ3d2QixpQ0FBaUMsRUFBRSxJQUFJLENBQUNELDJCQUEyQixDQUFDN3BGLEdBQUcsQ0FBQzRVLENBQUFBLElBQUs2d0UsdUJBQXVCN3dFO1FBQ2hLO1FBQ0EsY0FBYyxHQUNkLElBQUksQ0FBQzAxRSxjQUFjLEdBQUcvNkQsQ0FBQUE7WUFDcEIsSUFBSSxDQUFDZzdELFlBQVksQ0FBQ2g3RCxPQUFPQSxNQUFNKytCLGdCQUFnQjtRQUNqRDtRQUNBLDJFQUEyRTtRQUMzRSxjQUFjLEdBQ2QsSUFBSSxDQUFDaThCLFlBQVksR0FBRyxDQUFDaDdELE9BQU9oUTtZQUMxQixJQUFJQSxVQUFVdGpCLFdBQVc7Z0JBQ3ZCc2pCLFFBQVE7WUFDVjtZQUNBLElBQUksQ0FBQ2dRLE1BQU03UyxHQUFHLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDN2hCLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsc0RBQXNEdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUIxdUI7Z0JBQzlJO1lBQ0Y7WUFDQSxJQUFJLENBQUM0aUMsTUFBTSxDQUFDNmIsZ0JBQWdCLENBQUN6K0MsTUFBTTdTLEdBQUcsRUFBRTZDO1FBQzFDO1FBQ0EsSUFBSSxDQUFDaXJFLHFCQUFxQixHQUFHajdELENBQUFBO1lBQzNCLElBQUksQ0FBQzEwQixHQUFHLENBQUMyQixLQUFLLENBQUMsbUJBQW1CcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QjF1QjtZQUMzRyxJQUFJLENBQUNnN0QsWUFBWSxDQUFDaDdELE9BQU87UUFDM0I7UUFDQSxJQUFJLENBQUNrN0Qsc0JBQXNCLEdBQUdsN0QsQ0FBQUE7WUFDNUIsSUFBSSxDQUFDMTBCLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxvQkFBb0JwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCMXVCO1lBQzVHLElBQUksQ0FBQ2c3RCxZQUFZLENBQUNoN0QsT0FBT0EsTUFBTTJ0QixPQUFPO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDd3RDLDZCQUE2QixHQUFHamUsQ0FBQUEsU0FBVXJtRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUM3RSxJQUFJNWdCLElBQUlpekUsS0FBS24rRCxJQUFJQztnQkFDakIsSUFBSUMsSUFBSW15RDtnQkFDUixJQUFJLENBQUUsRUFBQ255RCxLQUFLLElBQUksQ0FBQ213RSxXQUFXLE1BQU0sUUFBUW53RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrcUQsUUFBUSxHQUFHO29CQUMvRTtnQkFDRjtnQkFDQSxNQUFNL1MsTUFBTSxJQUFJLENBQUNveEIsV0FBVyxDQUFDbHFGLEdBQUcsQ0FBQyt5RSxPQUFPcHlCLFFBQVE7Z0JBQ2hELElBQUksQ0FBQ21ZLEtBQUs7b0JBQ1IsSUFBSSxDQUFDMzNELEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsd0RBQXdEcHZCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO3dCQUN0SDNELFVBQVVveUIsT0FBT3B5QixRQUFRO29CQUMzQjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJb3lCLE9BQU9oeEIsZ0JBQWdCLENBQUNuL0MsTUFBTSxHQUFHLEdBQUc7b0JBQ3RDLElBQUksQ0FBQ2syRCxJQUFJNnZCLFVBQVUsRUFBRTt3QkFDbkI7b0JBQ0Y7b0JBQ0EsTUFBTXpILFlBQVksTUFBTXBvQixJQUFJNnZCLFVBQVUsQ0FBQzlILG1CQUFtQixDQUFDOU4sT0FBT2h4QixnQkFBZ0I7b0JBQ2xGLElBQUk7d0JBQ0YsSUFBSyxJQUFJbXhCLEtBQUssTUFBTWdlLGNBQWN2akUsY0FBY3V6RCxZQUFZaVEsZUFBZUEsZ0JBQWdCLE1BQU1ELFlBQVk3akUsSUFBSSxJQUFJdmhCLEtBQUtxbEYsY0FBYzVqRSxJQUFJLEVBQUUsQ0FBQ3poQixJQUFJb25FLEtBQUssS0FBTTs0QkFDNUpyeUQsS0FBS3N3RSxjQUFjL25GLEtBQUs7NEJBQ3hCOHBFLEtBQUs7NEJBQ0wsTUFBTTlwQyxRQUFRdm9COzRCQUNkLElBQUlrN0IsY0FBYzNTLFFBQVE7Z0NBQ3hCLElBQUksQ0FBQ2pvQyxHQUFHLENBQUMyQixLQUFLLENBQUMsV0FBV3FJLE1BQU0sQ0FBQ2krQixPQUFPLFNBQVNqK0IsTUFBTSxDQUFDMnRELElBQUk2dkIsVUFBVSxDQUFDM2xFLEdBQUcsR0FBR3RqQixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCdVU7Z0NBQ3RKLE1BQU0sSUFBSSxDQUFDczRCLDhCQUE4QixDQUFDdDRCLElBQUk2dkIsVUFBVSxFQUFFdi9DLE9BQU8wdkIsSUFBSTF1RCxPQUFPOzRCQUM5RTt3QkFDRjtvQkFDRixFQUFFLE9BQU84MEUsT0FBTzt3QkFDZEgsTUFBTTs0QkFDSi93RCxPQUFPa3hEO3dCQUNUO29CQUNGLFNBQVU7d0JBQ1IsSUFBSTs0QkFDRixJQUFJLENBQUNoTSxNQUFNLENBQUNwbkUsTUFBTzhVLENBQUFBLEtBQUtzd0UsWUFBWS9SLE1BQU0sR0FBRyxNQUFNditELEdBQUcvZixJQUFJLENBQUNxd0Y7d0JBQzdELFNBQVU7NEJBQ1IsSUFBSW5TLEtBQUssTUFBTUEsSUFBSS93RCxLQUFLO3dCQUMxQjtvQkFDRjtnQkFDRixPQUFPLElBQUkra0QsT0FBT2p4QixtQkFBbUIsQ0FBQ2wvQyxNQUFNLEdBQUcsR0FBRztvQkFDaEQsTUFBTSxDQUFDcXdFLEtBQUtuYSxJQUFJNnZCLFVBQVUsTUFBTSxRQUFRMVYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb04sbUJBQW1CLENBQUN0TixPQUFPanhCLG1CQUFtQjtnQkFDcEg7WUFDRjtRQUNBLElBQUksQ0FBQ3V2QywyQkFBMkIsR0FBR0MsQ0FBQUE7WUFDakMsTUFBTXo3RCxRQUFRLElBQUksQ0FBQzlRLE1BQU0sQ0FBQy9rQixHQUFHLENBQUNzeEYsWUFBWTN3QyxRQUFRO1lBQ2xELElBQUksQ0FBQzlxQixPQUFPO2dCQUNWLElBQUksQ0FBQzEwQixHQUFHLENBQUMydEIsSUFBSSxDQUFDLGdEQUFnRHB2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztvQkFDOUczRCxVQUFVMndDLFlBQVkzd0MsUUFBUTtnQkFDaEM7Z0JBQ0E7WUFDRjtZQUNBLElBQUksQ0FBQ2d2QyxjQUFjLENBQUM5NUQsTUFBTUEsS0FBSztRQUNqQztRQUNBLElBQUksQ0FBQ3F6RCxnQkFBZ0IsR0FBR3J6RCxDQUFBQSxRQUFTbkosVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDL0QsSUFBSW1KLE1BQU0vWCxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQzZELFdBQVcsSUFBSXB5QixNQUFNL1gsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUMrRCxnQkFBZ0IsRUFBRTtvQkFDL0YsSUFBSSxDQUFDaG5ELEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyw4Q0FBOENwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCMXVCO29CQUN0SSxJQUFJLENBQUM4NUQsY0FBYyxDQUFDOTVEO2dCQUN0QixPQUFPLElBQUlBLE1BQU1nL0IsY0FBYyxFQUFFO29CQUMvQixNQUFNaC9CLE1BQU02L0IsSUFBSTtnQkFDbEIsT0FBTyxJQUFJNy9CLGlCQUFpQmtsRCxtQkFBbUJsbEQsaUJBQWlCbW1ELGlCQUFpQjtvQkFDL0UsSUFBSTt3QkFDRixJQUFJbjFCLFNBQVM7NEJBQ1gsSUFBSTtnQ0FDRixNQUFNMHFDLHFCQUFxQixNQUFNaHdGLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVc29GLFdBQVcsQ0FBQzJILEtBQUssQ0FBQztvQ0FDakgsK0ZBQStGO29DQUMvRixhQUFhO29DQUNidHVGLE1BQU0yeUIsTUFBTS9YLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDeUQsTUFBTSxHQUFHLFdBQVc7Z0NBQzFEO2dDQUNBLElBQUkwcEMsc0JBQXNCQSxtQkFBbUIzc0UsS0FBSyxLQUFLLFVBQVU7b0NBQy9ELElBQUksQ0FBQ3pqQixHQUFHLENBQUMydEIsSUFBSSxDQUFDLDhCQUE4QjNqQixNQUFNLENBQUMwcUIsTUFBTS9YLE1BQU0sR0FBR3BlLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUIxdUI7b0NBQzNJLDZFQUE2RTtvQ0FDN0UwN0QsbUJBQW1CRSxRQUFRLEdBQUc7d0NBQzVCLElBQUlGLG1CQUFtQjNzRSxLQUFLLEtBQUssVUFBVTs0Q0FDekMsSUFBSSxDQUFDaVIsTUFBTTJ0QixPQUFPLEVBQUU7Z0RBQ2xCM3RCLE1BQU13bEQsWUFBWTs0Q0FDcEI7NENBQ0FrVyxtQkFBbUJFLFFBQVEsR0FBRzt3Q0FDaEM7b0NBQ0Y7b0NBQ0EsTUFBTSxJQUFJcHFGLE1BQU07Z0NBQ2xCOzRCQUNGLEVBQUUsT0FBTzlILEdBQUc7NEJBQ1YsZ0ZBQWdGOzRCQUNsRjt3QkFDRjt3QkFDQSxJQUFJLENBQUNzMkIsTUFBTTJ0QixPQUFPLEVBQUU7NEJBQ2xCLElBQUksQ0FBQ3JpRCxHQUFHLENBQUMyQixLQUFLLENBQUMscURBQXFEcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QjF1Qjs0QkFDN0ksTUFBTUEsTUFBTXdsRCxZQUFZO3dCQUMxQjtvQkFDRixFQUFFLE9BQU85N0UsR0FBRzt3QkFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLDJDQUEyQ3B2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCMXVCO3dCQUNsSSxNQUFNQSxNQUFNNi9CLElBQUk7b0JBQ2xCO2dCQUNGO1lBQ0Y7UUFDQSxJQUFJLENBQUN1MEIsV0FBVyxHQUFHLElBQUlsMkQ7UUFDdkIsSUFBSSxDQUFDbTJELFdBQVcsR0FBRyxJQUFJbjJEO1FBQ3ZCLElBQUksQ0FBQ2hQLE1BQU0sR0FBRyxJQUFJZ1A7UUFDbEIsSUFBSSxDQUFDMGtDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN3NEIsV0FBVyxHQUFHN21GO1FBQ25CLElBQUksQ0FBQ291RCxXQUFXLENBQUNDO1FBQ2pCLElBQUksQ0FBQ2k1QixlQUFlLEdBQUcsSUFBSTM5RDtJQUM3QjtJQUNBLElBQUk0OUQsa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxXQUFXO0lBQ3pCO0lBQ0EsSUFBSUMsc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDQyxlQUFlO0lBQzdCO0lBQ0EsSUFBSXY0QixnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUM4MkIsY0FBYyxLQUFLL3FFLGdCQUFnQmlCLElBQUk7SUFDckQ7SUFDQTRqRSxTQUFTcnNFLE1BQU0sRUFBRTtRQUNmLE1BQU0rWCxRQUFRLEtBQUssQ0FBQ3MwRCxTQUFTcnNFO1FBQzdCLElBQUkrWCxPQUFPO1lBQ1QsT0FBT0E7UUFDVDtJQUNGO0lBQ0F1MEQsZUFBZWxuRixJQUFJLEVBQUU7UUFDbkIsTUFBTTJ5QixRQUFRLEtBQUssQ0FBQ3UwRCxlQUFlbG5GO1FBQ25DLElBQUkyeUIsT0FBTztZQUNULE9BQU9BO1FBQ1Q7SUFDRjtJQUNBOztHQUVDLEdBQ0QyaUMsWUFBWUMsTUFBTSxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0EsTUFBTSxDQUFDM25DLEVBQUUsQ0FBQ29wQixZQUFZbTdCLFVBQVUsRUFBRSxDQUFDMTBCLFVBQVU5NkI7WUFDaEQsTUFBTWl6QyxNQUFNLElBQUksQ0FBQy96QyxNQUFNLENBQUMva0IsR0FBRyxDQUFDMmdEO1lBQzVCLElBQUksQ0FBQ21ZLE9BQU8sQ0FBQ0EsSUFBSWpqQyxLQUFLLEVBQUU7Z0JBQ3RCO1lBQ0Y7WUFDQSxJQUFJaFEsT0FBTztnQkFDVGl6QyxJQUFJcEQsSUFBSTtZQUNWLE9BQU87Z0JBQ0xvRCxJQUFJbEQsTUFBTTtZQUNaO1FBQ0Y7UUFDQSxJQUFJLENBQUM2QyxNQUFNLENBQUMzbkMsRUFBRSxDQUFDb3BCLFlBQVkrZSxTQUFTLEVBQUUsSUFBSSxDQUFDdTNCLGlCQUFpQixFQUFFMS9ELEVBQUUsQ0FBQ29wQixZQUFZcTlCLGVBQWUsRUFBRSxJQUFJLENBQUNpWixpQkFBaUIsRUFBRTEvRCxFQUFFLENBQUNvcEIsWUFBWTI5QixhQUFhLEVBQUUsSUFBSSxDQUFDMlksaUJBQWlCLEVBQUUxL0QsRUFBRSxDQUFDb3BCLFlBQVlvOUIsVUFBVSxFQUFFLElBQUksQ0FBQ2daLGtCQUFrQixFQUFFeC9ELEVBQUUsQ0FBQ29wQixZQUFZMDlCLFFBQVEsRUFBRSxJQUFJLENBQUMwWSxrQkFBa0IsRUFBRXgvRCxFQUFFLENBQUNvcEIsWUFBWWs3QixxQkFBcUIsRUFBRSxJQUFJLENBQUNpYywyQkFBMkIsRUFBRXZnRSxFQUFFLENBQUNvcEIsWUFBWXNGLHVCQUF1QixFQUFFLElBQUksQ0FBQ3d4Qyw2QkFBNkIsRUFBRWxnRSxFQUFFLENBQUNvcEIsWUFBWXEzQixZQUFZLEVBQUUsSUFBSSxDQUFDbWYsa0JBQWtCO0lBQzVkO0lBQ0E7Ozs7OztHQU1DLEdBQ0RxQixZQUFZenVFLFFBQVEsRUFBRTtRQUNwQixJQUFJeFg7UUFDSixJQUFJLENBQUMyc0QsTUFBTSxDQUFDaWEsTUFBTSxDQUFDdFMsdUJBQXVCLENBQUM5OEMsVUFBVSxDQUFDeFgsS0FBSyxJQUFJLENBQUM1SSxJQUFJLE1BQU0sUUFBUTRJLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ3pHO0lBQ0E7Ozs7OztHQU1DLEdBQ0RrbUYsUUFBUTl1RixJQUFJLEVBQUU7UUFDWixJQUFJNEk7UUFDSixJQUFJLENBQUMyc0QsTUFBTSxDQUFDaWEsTUFBTSxDQUFDdFMsdUJBQXVCLENBQUMsQ0FBQ3QwRCxLQUFLLElBQUksQ0FBQ3dYLFFBQVEsTUFBTSxRQUFReFgsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSTVJO0lBQ3ZHO0lBQ0E7Ozs7O0dBS0MsR0FDRCt1RixpQkFBaUJudUUsT0FBTyxFQUFFMVosT0FBTyxFQUFFOG5GLGNBQWMsRUFBRTtRQUNqRCxPQUFPLElBQUksQ0FBQ0MsZUFBZSxDQUFDL3VDLE1BQU1nQixNQUFNLENBQUN5RCxNQUFNLEVBQUUvakMsU0FBUzFaLFNBQVM4bkY7SUFDckU7SUFDQTs7Ozs7R0FLQyxHQUNERSxxQkFBcUJ0dUUsT0FBTyxFQUFFMVosT0FBTyxFQUFFOG5GLGNBQWMsRUFBRTtRQUNyRCxPQUFPLElBQUksQ0FBQ0MsZUFBZSxDQUFDL3VDLE1BQU1nQixNQUFNLENBQUMyRCxVQUFVLEVBQUVqa0MsU0FBUzFaLFNBQVM4bkY7SUFDekU7SUFDQTs7O0dBR0MsR0FDREcsc0JBQXNCdnVFLE9BQU8sRUFBRTFaLE9BQU8sRUFBRThuRixjQUFjLEVBQUU7UUFDdEQsT0FBTyxJQUFJLENBQUNDLGVBQWUsQ0FBQy91QyxNQUFNZ0IsTUFBTSxDQUFDNkQsV0FBVyxFQUFFbmtDLFNBQVMxWixTQUFTOG5GO0lBQzFFO0lBQ0EsY0FBYyxHQUNkckgsZUFBZWhCLFdBQVcsRUFBRTtRQUMxQixNQUFNc0Isa0JBQWtCLElBQUksQ0FBQ3RCLFdBQVc7UUFDeEMsTUFBTWtCLFVBQVUsS0FBSyxDQUFDRixlQUFlaEI7UUFDckMsSUFBSWtCLFdBQVdJLGlCQUFpQjtZQUM5QixJQUFJLENBQUN0N0QsSUFBSSxDQUFDb3FCLGlCQUFpQm14Qyw2QkFBNkIsRUFBRUQ7UUFDNUQ7UUFDQSxPQUFPSjtJQUNUO0lBQ0EsY0FBYyxHQUNkdUgsZUFBZXh1RSxPQUFPLEVBQUU7UUFDdEIsT0FBTzRJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDMmpFLGNBQWMsR0FBR3ZzRSxVQUFVd0IsZ0JBQWdCaXRFLEdBQUcsR0FBR2p0RSxnQkFBZ0JpQixJQUFJO1lBQzFFLE1BQU0sSUFBSSxDQUFDaXNFLGtCQUFrQixDQUFDandGLFdBQVc7UUFDM0M7SUFDRjtJQUNBNHZGLGdCQUFnQnIwRSxNQUFNLEVBQUVnRyxPQUFPLEVBQUUxWixPQUFPLEVBQUU4bkYsY0FBYyxFQUFFO1FBQ3hELElBQUlwbUYsSUFBSThVO1FBQ1IsT0FBTzhMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxDQUFDdnJCLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxtQkFBbUJwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDbEZ4bUM7Z0JBQ0FnRztZQUNGO1lBQ0EsSUFBSStSLFFBQVEsSUFBSSxDQUFDczBELFFBQVEsQ0FBQ3JzRTtZQUMxQixJQUFJZ0csU0FBUztnQkFDWCxJQUFJK1IsT0FBTztvQkFDVCxNQUFNQSxNQUFNKy9CLE1BQU07Z0JBQ3BCLE9BQU87b0JBQ0wsSUFBSWtqQjtvQkFDSixJQUFJLElBQUksQ0FBQ21YLGlCQUFpQixDQUFDN3ZFLEdBQUcsQ0FBQ3RDLFNBQVM7d0JBQ3RDLElBQUksQ0FBQzNjLEdBQUcsQ0FBQzRFLElBQUksQ0FBQyx1Q0FBdUNyRyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzs0QkFDckd4bUM7d0JBQ0Y7d0JBQ0Esb0NBQW9DO3dCQUNwQztvQkFDRjtvQkFDQSxJQUFJLENBQUNteUUsaUJBQWlCLENBQUN3QyxHQUFHLENBQUMzMEU7b0JBQzNCLElBQUk7d0JBQ0YsT0FBUUE7NEJBQ04sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDeUQsTUFBTTtnQ0FDdEJpeEIsY0FBYyxNQUFNLElBQUksQ0FBQzRaLFlBQVksQ0FBQztvQ0FDcENqN0QsT0FBTyxDQUFDM3JCLEtBQUsxQixPQUFNLE1BQU8sUUFBUTBCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dDQUN6RDtnQ0FDQTs0QkFDRixLQUFLczNDLE1BQU1nQixNQUFNLENBQUMyRCxVQUFVO2dDQUMxQit3QixjQUFjLE1BQU0sSUFBSSxDQUFDNFosWUFBWSxDQUFDO29DQUNwQ243RCxPQUFPLENBQUMzVyxLQUFLeFcsT0FBTSxNQUFPLFFBQVF3VyxPQUFPLEtBQUssSUFBSUEsS0FBSztnQ0FDekQ7Z0NBQ0E7NEJBQ0YsS0FBS3dpQyxNQUFNZ0IsTUFBTSxDQUFDNkQsV0FBVztnQ0FDM0I2d0IsY0FBYyxNQUFNLElBQUksQ0FBQzZaLGtCQUFrQixDQUFDanpGLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHVTtnQ0FDOUQ7NEJBQ0Y7Z0NBQ0UsTUFBTSxJQUFJaXZDLGtCQUFrQnY3Qjt3QkFDaEM7d0JBQ0EsTUFBTTgwRSxrQkFBa0IsRUFBRTt3QkFDMUIsS0FBSyxNQUFNQyxjQUFjL1osWUFBYTs0QkFDcEMsSUFBSSxDQUFDMzNFLEdBQUcsQ0FBQzRFLElBQUksQ0FBQyxvQkFBb0JyRyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCc3VDOzRCQUMzR0QsZ0JBQWdCdHBGLElBQUksQ0FBQyxJQUFJLENBQUN3cEYsWUFBWSxDQUFDRCxZQUFZWDt3QkFDckQ7d0JBQ0EsTUFBTWEsa0JBQWtCLE1BQU05bEUsUUFBUWpPLEdBQUcsQ0FBQzR6RTt3QkFDMUMsb0lBQW9JO3dCQUNwSSxpRUFBaUU7d0JBQ2pFLENBQUMvOEQsTUFBTSxHQUFHazlEO29CQUNaLEVBQUUsT0FBT3h6RixHQUFHO3dCQUNWdTVFLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWXg1RSxPQUFPLENBQUNpbUQsQ0FBQUE7NEJBQzVFQSxHQUFHM3JCLElBQUk7d0JBQ1Q7d0JBQ0EsSUFBSXI2QixhQUFhOEgsU0FBUyxDQUFFOUgsQ0FBQUEsYUFBYTg1QyxpQkFBZ0IsR0FBSTs0QkFDM0QsSUFBSSxDQUFDeHBCLElBQUksQ0FBQ29xQixpQkFBaUIrNEMsaUJBQWlCLEVBQUV6ekY7d0JBQ2hEO3dCQUNBLE1BQU1BO29CQUNSLFNBQVU7d0JBQ1IsSUFBSSxDQUFDMHdGLGlCQUFpQixDQUFDLzdELE1BQU0sQ0FBQ3BXO29CQUNoQztnQkFDRjtZQUNGLE9BQU8sSUFBSStYLFNBQVNBLE1BQU1BLEtBQUssRUFBRTtnQkFDL0IsaURBQWlEO2dCQUNqRCxJQUFJL1gsV0FBV3NsQyxNQUFNZ0IsTUFBTSxDQUFDNkQsV0FBVyxFQUFFO29CQUN2Q3B5QixRQUFRLE1BQU0sSUFBSSxDQUFDODVELGNBQWMsQ0FBQzk1RCxNQUFNQSxLQUFLO29CQUM3QyxNQUFNbzlELG1CQUFtQixJQUFJLENBQUM5SSxRQUFRLENBQUMvbUMsTUFBTWdCLE1BQU0sQ0FBQytELGdCQUFnQjtvQkFDcEUsSUFBSThxQyxvQkFBb0JBLGlCQUFpQnA5RCxLQUFLLEVBQUU7d0JBQzlDLElBQUksQ0FBQzg1RCxjQUFjLENBQUNzRCxpQkFBaUJwOUQsS0FBSztvQkFDNUM7Z0JBQ0YsT0FBTztvQkFDTCxNQUFNQSxNQUFNNi9CLElBQUk7Z0JBQ2xCO1lBQ0Y7WUFDQSxPQUFPNy9CO1FBQ1Q7SUFDRjtJQUNBOzs7R0FHQyxHQUNEcTlELDRCQUE0QjtRQUMxQixPQUFPeG1FLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxJQUFJLENBQUN1akUsaUJBQWlCLENBQUM3dkUsR0FBRyxDQUFDZ2pDLE1BQU1nQixNQUFNLENBQUN5RCxNQUFNLEtBQUssSUFBSSxDQUFDb29DLGlCQUFpQixDQUFDN3ZFLEdBQUcsQ0FBQ2dqQyxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVSxHQUFHO2dCQUMxRyxvQ0FBb0M7Z0JBQ3BDO1lBQ0Y7WUFDQSxJQUFJLENBQUNrb0MsaUJBQWlCLENBQUN3QyxHQUFHLENBQUNydkMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU07WUFDOUMsSUFBSSxDQUFDb29DLGlCQUFpQixDQUFDd0MsR0FBRyxDQUFDcnZDLE1BQU1nQixNQUFNLENBQUMyRCxVQUFVO1lBQ2xELElBQUk7Z0JBQ0YsTUFBTWhqQyxTQUFTLE1BQU0sSUFBSSxDQUFDMnRFLFlBQVksQ0FBQztvQkFDckNuN0QsT0FBTztvQkFDUEUsT0FBTztnQkFDVDtnQkFDQSxNQUFNeEssUUFBUWpPLEdBQUcsQ0FBQytGLE9BQU96ZSxHQUFHLENBQUN1dkIsQ0FBQUEsUUFBUyxJQUFJLENBQUNpOUQsWUFBWSxDQUFDajlEO1lBQzFELFNBQVU7Z0JBQ1IsSUFBSSxDQUFDbzZELGlCQUFpQixDQUFDLzdELE1BQU0sQ0FBQ2t2QixNQUFNZ0IsTUFBTSxDQUFDeUQsTUFBTTtnQkFDakQsSUFBSSxDQUFDb29DLGlCQUFpQixDQUFDLzdELE1BQU0sQ0FBQ2t2QixNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTtZQUN2RDtRQUNGO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0QycUMsYUFBYXRvRixPQUFPLEVBQUU7UUFDcEIsSUFBSTBCLElBQUk4VTtRQUNSLE9BQU84TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU1tc0IsT0FBTzRQLG9CQUFvQnIrQyxTQUFTLENBQUMwQixLQUFLLElBQUksQ0FBQ21sRixXQUFXLE1BQU0sUUFBUW5sRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxbkYsb0JBQW9CLEVBQUUsQ0FBQ3Z5RSxLQUFLLElBQUksQ0FBQ3F3RSxXQUFXLE1BQU0sUUFBUXJ3RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3eUUsb0JBQW9CO1lBQ3BOLE1BQU0vN0QsY0FBYzB4QixzQkFBc0JsUTtZQUMxQyxJQUFJcnlCO1lBQ0osSUFBSTtnQkFDRkEsU0FBUyxNQUFNamxCLFVBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxDQUFDakM7WUFDckQsRUFBRSxPQUFPckgsS0FBSztnQkFDWixJQUFJQSxlQUFlM29CLE9BQU87b0JBQ3hCLElBQUlnd0IsWUFBWUUsS0FBSyxFQUFFO3dCQUNyQixJQUFJLENBQUN1NkQsZUFBZSxHQUFHOWhFO29CQUN6QjtvQkFDQSxJQUFJcUgsWUFBWUksS0FBSyxFQUFFO3dCQUNyQixJQUFJLENBQUNtNkQsV0FBVyxHQUFHNWhFO29CQUNyQjtnQkFDRjtnQkFDQSxNQUFNQTtZQUNSO1lBQ0EsSUFBSXFILFlBQVlFLEtBQUssRUFBRTtnQkFDckIsSUFBSSxDQUFDdTZELGVBQWUsR0FBR3Z2RjtnQkFDdkIsSUFBSSxDQUFDc3RCLElBQUksQ0FBQ29xQixpQkFBaUJvNUMsbUJBQW1CO1lBQ2hEO1lBQ0EsSUFBSWg4RCxZQUFZSSxLQUFLLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQ202RCxXQUFXLEdBQUdydkY7WUFDckI7WUFDQSxPQUFPaWtCLE9BQU9tVCxTQUFTLEdBQUdyekIsR0FBRyxDQUFDbStDLENBQUFBO2dCQUM1QixNQUFNNnVDLFVBQVU3dUMsaUJBQWlCaHNDLElBQUksS0FBSztnQkFDMUM2NkUsVUFBVWxwRixRQUFRbXRCLEtBQUssR0FBR250QixRQUFRcXRCLEtBQUs7Z0JBQ3ZDLElBQUk4N0Q7Z0JBQ0osTUFBTUMsWUFBWUYsVUFBVWo4RCxZQUFZRSxLQUFLLEdBQUdGLFlBQVlJLEtBQUs7Z0JBQ2pFLElBQUksT0FBTys3RCxjQUFjLFdBQVc7b0JBQ2xDRCxtQkFBbUJDO2dCQUNyQjtnQkFDQSxNQUFNMzlELFFBQVFrbUQsdUJBQXVCdDNCLGtCQUFrQjh1QyxrQkFBa0I7b0JBQ3ZFN3dGLFlBQVksSUFBSSxDQUFDdXVGLFdBQVcsQ0FBQ3Z1RixVQUFVO29CQUN2Q3VoRCxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7Z0JBQ3hDO2dCQUNBLElBQUl6dUIsTUFBTXBkLElBQUksS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLEVBQUU7b0JBQ25DbHZCLE1BQU0vWCxNQUFNLEdBQUdzbEMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU07Z0JBQ3BDLE9BQU8sSUFBSWh5QixNQUFNcGQsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUMwQyxLQUFLLEVBQUU7b0JBQzFDM3hCLE1BQU0vWCxNQUFNLEdBQUdzbEMsTUFBTWdCLE1BQU0sQ0FBQzJELFVBQVU7Z0JBQ3hDO2dCQUNBbHlCLE1BQU1peEIsV0FBVyxHQUFHdGdDO2dCQUNwQixPQUFPcVA7WUFDVDtRQUNGO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0Q4OEQsbUJBQW1Cdm9GLE9BQU8sRUFBRTtRQUMxQixPQUFPc2lCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSXRpQixZQUFZN0gsV0FBVztnQkFDekI2SCxVQUFVLENBQUM7WUFDYjtZQUNBLElBQUk3SSxVQUFVaTFCLFlBQVksQ0FBQ3dELGVBQWUsS0FBS3ozQixXQUFXO2dCQUN4RCxNQUFNLElBQUk2MkMsdUJBQXVCO1lBQ25DO1lBQ0EsSUFBSWh2QyxRQUFRdXhDLFVBQVUsS0FBS3A1QyxhQUFhLENBQUN5cUQsY0FBYztnQkFDckQsOEVBQThFO2dCQUM5RSxpRkFBaUY7Z0JBQ2pGLHlFQUF5RTtnQkFDekU1aUQsUUFBUXV4QyxVQUFVLEdBQUcyQixtQkFBbUJPLFVBQVUsQ0FBQ2xDLFVBQVU7WUFDL0Q7WUFDQSxNQUFNdGtCLGNBQWMreUIseUNBQXlDaGdEO1lBQzdELE1BQU1vYyxTQUFTLE1BQU1qbEIsVUFBVWkxQixZQUFZLENBQUN3RCxlQUFlLENBQUMzQztZQUM1RCxNQUFNdFMsU0FBU3lCLE9BQU9rVCxjQUFjO1lBQ3BDLElBQUkzVSxPQUFPbmlCLE1BQU0sS0FBSyxHQUFHO2dCQUN2QixNQUFNLElBQUl5MkMsa0JBQWtCO1lBQzlCO1lBQ0EsTUFBTW82QyxjQUFjLElBQUl6WCxnQkFBZ0JqM0QsTUFBTSxDQUFDLEVBQUUsRUFBRXhpQixXQUFXLE9BQU87Z0JBQ25FRyxZQUFZLElBQUksQ0FBQ3V1RixXQUFXLENBQUN2dUYsVUFBVTtnQkFDdkN1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO1lBQ3hDO1lBQ0FtdkMsWUFBWTMxRSxNQUFNLEdBQUdzbEMsTUFBTWdCLE1BQU0sQ0FBQzZELFdBQVc7WUFDN0MsSUFBSTc5QyxRQUFRc3BGLFdBQVcsRUFBRTtnQkFDdkJELFlBQVlodkMsZ0JBQWdCLENBQUNpdkMsV0FBVyxHQUFHdHBGLFFBQVFzcEYsV0FBVztZQUNoRTtZQUNBLE1BQU01YSxjQUFjO2dCQUFDMmE7YUFBWTtZQUNqQyxJQUFJanRFLE9BQU9pVCxjQUFjLEdBQUc3MkIsTUFBTSxHQUFHLEdBQUc7Z0JBQ3RDLElBQUksQ0FBQ2l0QixJQUFJLENBQUNvcUIsaUJBQWlCbzVDLG1CQUFtQjtnQkFDOUMsTUFBTU0sY0FBYyxJQUFJNVksZ0JBQWdCdjBELE9BQU9pVCxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQUVsM0IsV0FBVyxPQUFPLElBQUksQ0FBQ3l1RCxZQUFZLEVBQUU7b0JBQ3ZHdHVELFlBQVksSUFBSSxDQUFDdXVGLFdBQVcsQ0FBQ3Z1RixVQUFVO29CQUN2Q3VoRCxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7Z0JBQ3hDO2dCQUNBcXZDLFlBQVk3MUUsTUFBTSxHQUFHc2xDLE1BQU1nQixNQUFNLENBQUMrRCxnQkFBZ0I7Z0JBQ2xEMndCLFlBQVl4dkUsSUFBSSxDQUFDcXFGO1lBQ25CO1lBQ0EsT0FBTzdhO1FBQ1Q7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRGdhLGFBQWFqOUQsS0FBSyxFQUFFenJCLE9BQU8sRUFBRTtRQUMzQixJQUFJMEIsSUFBSThVLElBQUlDLElBQUlDO1FBQ2hCLE9BQU80TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0sQ0FBQzVnQixLQUFLLElBQUksQ0FBQ3lrRixlQUFlLE1BQU0sUUFBUXprRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1NUIsT0FBTztZQUNqRixJQUFJeFAsaUJBQWlCNDlCLGNBQWMsSUFBSSxDQUFDeThCLHNCQUFzQixDQUFDOXZFLEdBQUcsQ0FBQ3lWLFFBQVE7Z0JBQ3pFLE1BQU0sSUFBSSxDQUFDcTZELHNCQUFzQixDQUFDbHdGLEdBQUcsQ0FBQzYxQjtZQUN4QztZQUNBLElBQUkrOUQ7WUFDSixJQUFJLzlELGlCQUFpQjBJLGtCQUFrQjtnQkFDckNxMUQscUJBQXFCLzlELE1BQU02K0IsY0FBYztZQUMzQyxPQUFPO2dCQUNMLHFFQUFxRTtnQkFDckUseUVBQXlFO2dCQUN6RWsvQixxQkFBcUIvOUQsTUFBTXdCLFdBQVc7Z0JBQ3RDLElBQUl3OEQsYUFBYXR4RjtnQkFDakIsT0FBUXN6QixNQUFNL1gsTUFBTTtvQkFDbEIsS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTt3QkFDMUI4ckMsYUFBYTt3QkFDYjtvQkFDRixLQUFLendDLE1BQU1nQixNQUFNLENBQUN5RCxNQUFNO3dCQUN0QmdzQyxhQUFhO2dCQUNqQjtnQkFDQSxJQUFJQSxjQUFjLElBQUksQ0FBQ25DLGVBQWUsQ0FBQ3R4RSxHQUFHLENBQUN5ekUsYUFBYTtvQkFDdERELHFCQUFxQmwwRixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUdrcUYscUJBQXFCO3dCQUN4RXg3RCxVQUFVLElBQUksQ0FBQ3M1RCxlQUFlLENBQUMxeEYsR0FBRyxDQUFDNnpGO29CQUNyQztnQkFDRjtZQUNGO1lBQ0Esb0RBQW9EO1lBQ3BELElBQUloK0QsaUJBQWlCMEksa0JBQWtCO2dCQUNyQyxPQUFRMUksTUFBTXBkLElBQUk7b0JBQ2hCLEtBQUs7d0JBQ0hvZCxRQUFRLElBQUlrbEQsZ0JBQWdCbGxELE9BQU8rOUQsb0JBQW9CLE1BQU0sSUFBSSxDQUFDNWlDLFlBQVksRUFBRTs0QkFDOUV0dUQsWUFBWSxJQUFJLENBQUN1dUYsV0FBVyxDQUFDdnVGLFVBQVU7NEJBQ3ZDdWhELGlCQUFpQixJQUFNLElBQUksQ0FBQ0ssVUFBVTt3QkFDeEM7d0JBQ0E7b0JBQ0YsS0FBSzt3QkFDSHp1QixRQUFRLElBQUltbUQsZ0JBQWdCbm1ELE9BQU8rOUQsb0JBQW9CLE1BQU07NEJBQzNEbHhGLFlBQVksSUFBSSxDQUFDdXVGLFdBQVcsQ0FBQ3Z1RixVQUFVOzRCQUN2Q3VoRCxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7d0JBQ3hDO3dCQUNBO29CQUNGO3dCQUNFLE1BQU0sSUFBSWpMLGtCQUFrQixxQ0FBcUNsdUMsTUFBTSxDQUFDMHFCLE1BQU1wZCxJQUFJO2dCQUN0RjtZQUNGLE9BQU87Z0JBQ0xvZCxNQUFNNHdCLG1CQUFtQixDQUFDO29CQUN4Qi9qRCxZQUFZLElBQUksQ0FBQ3V1RixXQUFXLENBQUN2dUYsVUFBVTtvQkFDdkN1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO2dCQUN4QztZQUNGO1lBQ0EsSUFBSXp1QixpQkFBaUJrbEQsaUJBQWlCO2dCQUNwQ2xsRCxNQUFNMmxELGVBQWUsQ0FBQyxJQUFJLENBQUN4cUIsWUFBWTtZQUN6QztZQUNBLHNDQUFzQztZQUN0QyxJQUFJOGlDO1lBQ0osSUFBSSxDQUFDL3VFLE1BQU0sQ0FBQ3psQixPQUFPLENBQUNtNkQsQ0FBQUE7Z0JBQ2xCLElBQUksQ0FBQ0EsWUFBWTVqQyxLQUFLLEVBQUU7b0JBQ3RCO2dCQUNGO2dCQUNBLElBQUk0akMsWUFBWTVqQyxLQUFLLEtBQUtBLE9BQU87b0JBQy9CaStELHNCQUFzQnI2QjtnQkFDeEI7WUFDRjtZQUNBLElBQUlxNkIscUJBQXFCO2dCQUN2QixJQUFJLENBQUMzeUYsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyw4Q0FBOENwdkIsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QnV2QztnQkFDckksT0FBT0E7WUFDVDtZQUNBLE1BQU1DLGdCQUFnQixrQkFBa0JsK0QsTUFBTTR1QixnQkFBZ0IsQ0FBQ2pqQixXQUFXLE1BQzFFLGdPQUFnTztZQUNoTzNMLE1BQU00dUIsZ0JBQWdCLENBQUNqakIsV0FBVyxHQUFHd3lELFlBQVksS0FBSyxLQUFLbitELE1BQU00dUIsZ0JBQWdCLENBQUNpUSxjQUFjLEdBQUdzL0IsWUFBWSxLQUFLO1lBQ3BILE1BQU1DLFdBQVcsQ0FBQ3J6RSxLQUFLeFcsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFnaEUsV0FBVyxNQUFNLFFBQVF4cUQsT0FBTyxLQUFLLElBQUlBLEtBQUttekU7WUFDL0gseURBQXlEO1lBQ3pELElBQUlFLFVBQVU7Z0JBQ1osSUFBSSxDQUFDN3BGLFNBQVM7b0JBQ1pBLFVBQVUsQ0FBQztnQkFDYjtnQkFDQSxJQUFJQSxRQUFROGdFLEdBQUcsS0FBSzNvRSxXQUFXO29CQUM3QixJQUFJLENBQUNwQixHQUFHLENBQUM0RSxJQUFJLENBQUMsbUdBQW1HckcsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QjF1QjtnQkFDNUw7Z0JBQ0EsSUFBSXpyQixRQUFRK2dFLEdBQUcsS0FBSzVvRSxXQUFXO29CQUM3QixJQUFJLENBQUNwQixHQUFHLENBQUM0RSxJQUFJLENBQUM7Z0JBQ2hCO2dCQUNDOGEsQ0FBQUEsS0FBS3pXLFFBQVE4Z0UsR0FBRyxNQUFNLFFBQVFycUQsT0FBTyxLQUFLLElBQUlBLEtBQUt6VyxRQUFROGdFLEdBQUcsR0FBRztnQkFDakVwcUQsQ0FBQUEsS0FBSzFXLFFBQVErZ0UsR0FBRyxNQUFNLFFBQVFycUQsT0FBTyxLQUFLLElBQUlBLEtBQUsxVyxRQUFRK2dFLEdBQUcsR0FBRztZQUNwRTtZQUNBLE1BQU10eUIsT0FBT241QyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDdW5GLFdBQVcsQ0FBQ2xtQixlQUFlLEdBQUczZ0U7WUFDaEYsNkNBQTZDO1lBQzdDLElBQUk2OEMsY0FBYyxJQUFJLENBQUNncUMsV0FBVyxDQUFDaUQsSUFBSSxFQUFFO2dCQUN2QyxJQUFJLENBQUMveUYsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLG9GQUFvRnJHLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVO2dCQUNuSXpMLEtBQUs3eUIsU0FBUyxHQUFHO1lBQ25CO1lBQ0EsSUFBSTZ5QixLQUFLLzZCLE1BQU0sRUFBRTtnQkFDZitYLE1BQU0vWCxNQUFNLEdBQUcrNkIsS0FBSy82QixNQUFNO1lBQzVCO1lBQ0EsTUFBTXEyRSxpQkFBaUIsSUFBSSxDQUFDL3FFLE9BQU8sQ0FBQ3lNLE9BQU9nakIsTUFBTW83QztZQUNqRCxJQUFJLENBQUMvRCxzQkFBc0IsQ0FBQ3o5RSxHQUFHLENBQUNvakIsT0FBT3MrRDtZQUN2QyxJQUFJO2dCQUNGLE1BQU0xNkIsY0FBYyxNQUFNMDZCO2dCQUMxQixPQUFPMTZCO1lBQ1QsRUFBRSxPQUFPbDZELEdBQUc7Z0JBQ1YsTUFBTUE7WUFDUixTQUFVO2dCQUNSLElBQUksQ0FBQzJ3RixzQkFBc0IsQ0FBQ2g4RCxNQUFNLENBQUMyQjtZQUNyQztRQUNGO0lBQ0Y7SUFDQXpNLFFBQVF5TSxLQUFLLEVBQUVnakIsSUFBSSxFQUFFbzdDLFFBQVEsRUFBRTtRQUM3QixJQUFJbm9GLElBQUk4VSxJQUFJQyxJQUFJQyxJQUFJbXlELElBQUlDLElBQUk4TCxJQUFJeUIsSUFBSTJULElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ3BELE9BQU85bkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNOGlFLHdCQUF3Qmh3RixNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUN6ekIsTUFBTSxDQUFDdGMsTUFBTSxJQUFJMlAsSUFBSSxDQUFDcTNFLENBQUFBLGlCQUFrQjU1RCxpQkFBaUI0OUIsY0FBY2c4QixlQUFlM3hFLE1BQU0sS0FBSytYLE1BQU0vWCxNQUFNO1lBQzNKLElBQUkweEUseUJBQXlCMzVELE1BQU0vWCxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQ0MsT0FBTyxFQUFFO2dCQUNsRSxJQUFJLENBQUNsakQsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLG1EQUFtRG9GLE1BQU0sQ0FBQzBxQixNQUFNL1gsTUFBTSxHQUFHcGUsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUdDLHVCQUF1QjF1QjtZQUNsSztZQUNBLElBQUlnakIsS0FBS3l5QixrQkFBa0IsSUFBSXoxQyxpQkFBaUJrbEQsaUJBQWlCO2dCQUMvRGxsRCxNQUFNbWxELFVBQVUsR0FBRztZQUNyQjtZQUNBLElBQUlubEQsTUFBTS9YLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDNkQsV0FBVyxJQUFJWixhQUFhO2dCQUM1RCwyREFBMkQ7Z0JBQzNELG9EQUFvRDtnQkFDcER4TyxLQUFLN3lCLFNBQVMsR0FBRztZQUNuQjtZQUNBLHFEQUFxRDtZQUNyRCxJQUFJNnlCLEtBQUsweUIsVUFBVSxLQUFLLFNBQVMsQ0FBQ3ZmLGVBQWU7Z0JBQy9DblQsS0FBSzB5QixVQUFVLEdBQUdocEU7WUFDcEI7WUFDQSxJQUFJczJDLEtBQUsweUIsVUFBVSxLQUFLLFNBQVMsQ0FBQ25mLGVBQWU7Z0JBQy9DdlQsS0FBSzB5QixVQUFVLEdBQUdocEU7WUFDcEI7WUFDQSxJQUFJczJDLEtBQUsweUIsVUFBVSxLQUFLaHBFLFdBQVc7Z0JBQ2pDczJDLEtBQUsweUIsVUFBVSxHQUFHVDtZQUNwQjtZQUNBLE1BQU1TLGFBQWExeUIsS0FBSzB5QixVQUFVO1lBQ2xDLHVCQUF1QjtZQUN2QjExQyxNQUFNL0UsRUFBRSxDQUFDcXBCLFdBQVc2YixLQUFLLEVBQUUsSUFBSSxDQUFDNjZCLFlBQVk7WUFDNUNoN0QsTUFBTS9FLEVBQUUsQ0FBQ3FwQixXQUFXOGIsT0FBTyxFQUFFLElBQUksQ0FBQzI2QixjQUFjO1lBQ2hELzZELE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV2lhLEtBQUssRUFBRSxJQUFJLENBQUM4MEIsZ0JBQWdCO1lBQ2hEcnpELE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV21jLGNBQWMsRUFBRSxJQUFJLENBQUN3NkIscUJBQXFCO1lBQzlEajdELE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV29jLGVBQWUsRUFBRSxJQUFJLENBQUN3NkIsc0JBQXNCO1lBQ2hFLHNDQUFzQztZQUN0QyxNQUFNdDFCLE1BQU0sSUFBSXBkLGdCQUFnQjtnQkFDOUIsK0NBQStDO2dCQUMvQzU0QixLQUFLb1EsTUFBTTR1QixnQkFBZ0IsQ0FBQy91QixFQUFFO2dCQUM5Qnh5QixNQUFNMjFDLEtBQUszMUMsSUFBSTtnQkFDZm1ILE1BQU0rNEMsTUFBTW1FLFdBQVcsQ0FBQzF4QixNQUFNcGQsSUFBSTtnQkFDbENvTixPQUFPZ1EsTUFBTTJ0QixPQUFPO2dCQUNwQjFsQyxRQUFRc2xDLE1BQU13RSxhQUFhLENBQUMveEIsTUFBTS9YLE1BQU07Z0JBQ3hDbUksWUFBWSxDQUFFLEVBQUNuYSxLQUFLK3NDLEtBQUtxeUIsR0FBRyxNQUFNLFFBQVFwL0QsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBRztnQkFDbEV3YSxZQUFZLElBQUksQ0FBQytwRSxjQUFjO2dCQUMvQmpxRSxRQUFRNnRFO2dCQUNSNXRFLFlBQVksSUFBSSxDQUFDa3pDLGFBQWEsSUFBSSxDQUFFLEVBQUMzNEMsS0FBS2k0QixLQUFLc3lCLEdBQUcsTUFBTSxRQUFRdnFELE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUc7Z0JBQ3hGNEYsUUFBUXF5QixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS3J5QixNQUFNO1lBQ2pFO1lBQ0EseUNBQXlDO1lBQ3pDLElBQUlrZDtZQUNKLElBQUk3TixNQUFNcGQsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRTtnQkFDbkMsSUFBSXlRLE9BQU87b0JBQ1QxdkMsT0FBTztvQkFDUEMsUUFBUTtnQkFDVjtnQkFDQSxJQUFJO29CQUNGeXZDLE9BQU8sTUFBTTMvQixNQUFNdy9CLGlCQUFpQjtnQkFDdEMsRUFBRSxPQUFPOTFELEdBQUc7b0JBQ1YsNEVBQTRFO29CQUM1RSxzREFBc0Q7b0JBQ3RELE1BQU1rMUYsYUFBYSxDQUFDM3pFLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNvd0UsV0FBVyxDQUFDbUMsb0JBQW9CLE1BQU0sUUFBUXZ5RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4NkIsVUFBVSxNQUFNLFFBQVE3NkIsT0FBTyxLQUFLLElBQUlBLEtBQUswN0IsYUFBYU0sSUFBSSxDQUFDbkIsVUFBVTtvQkFDdkw2WixPQUFPO3dCQUNMMXZDLE9BQU8ydUUsV0FBVzN1RSxLQUFLO3dCQUN2QkMsUUFBUTB1RSxXQUFXMXVFLE1BQU07b0JBQzNCO29CQUNBLGNBQWM7b0JBQ2QsSUFBSSxDQUFDNWtCLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsd0RBQXdEdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR0MsdUJBQXVCMXVCLFNBQVM7d0JBQ3JLMi9CO29CQUNGO2dCQUNGO2dCQUNBLCtDQUErQztnQkFDL0NpRyxJQUFJMzFDLEtBQUssR0FBRzB2QyxLQUFLMXZDLEtBQUs7Z0JBQ3RCMjFDLElBQUkxMUMsTUFBTSxHQUFHeXZDLEtBQUt6dkMsTUFBTTtnQkFDeEIsaUVBQWlFO2dCQUNqRSxJQUFJOFAsaUJBQWlCbW1ELGlCQUFpQjtvQkFDcEMsSUFBSXp2QixXQUFXZ2YsYUFBYTt3QkFDMUIsdUVBQXVFO3dCQUN2RSxJQUFJMTFDLE1BQU0vWCxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQzZELFdBQVcsSUFBSXNqQixlQUFlLE9BQU87NEJBQ3JFMXlCLEtBQUtna0MsZUFBZSxHQUFHO3dCQUN6Qjt3QkFDQSwrQ0FBK0M7d0JBQy9DaGtDLEtBQUtna0MsZUFBZSxHQUFHLENBQUM1SixLQUFLcDZCLEtBQUtna0MsZUFBZSxNQUFNLFFBQVE1SixPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDdEY7b0JBQ0F4WCxJQUFJMWIsZUFBZSxHQUFHO3dCQUFDLElBQUlELGVBQWU7NEJBQ3hDMVcsT0FBT21pQzs0QkFDUDlsRCxLQUFLb1EsTUFBTTR1QixnQkFBZ0IsQ0FBQy91QixFQUFFO3dCQUNoQztxQkFBRztvQkFDSCxnQkFBZ0I7b0JBQ2hCLElBQUltakIsS0FBSzJ5QixXQUFXLEtBQUssTUFBTTt3QkFDN0IzeUIsS0FBSzJ5QixXQUFXLEdBQUc7NEJBQ2pCcGlDLE9BQU8waEM7d0JBQ1Q7b0JBQ0Y7b0JBQ0EsSUFBSWp5QixLQUFLMnlCLFdBQVcsSUFBSUQsZUFBZTF5QixLQUFLMnlCLFdBQVcsQ0FBQ3BpQyxLQUFLLElBQzdELDREQUE0RDtvQkFDNURxeUIsSUFBSW4xQyxVQUFVLEtBQUtoQixnQkFBZ0JpQixJQUFJLEVBQUU7d0JBQ3ZDLDBDQUEwQzt3QkFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQzBxRSxXQUFXLENBQUNwbEIsUUFBUSxFQUFFOzRCQUM5QixJQUFJLENBQUNvbEIsV0FBVyxDQUFDcGxCLFFBQVEsR0FBRzt3QkFDOUI7d0JBQ0FwUSxJQUFJMWIsZUFBZSxDQUFDejJDLElBQUksQ0FBQyxJQUFJdzJDLGVBQWU7NEJBQzFDMVcsT0FBT3lQLEtBQUsyeUIsV0FBVyxDQUFDcGlDLEtBQUs7NEJBQzdCM2pCLEtBQUs7d0JBQ1A7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FpZSxZQUFZKzRDLHNCQUFzQjVtRCxNQUFNL1gsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUM2RCxXQUFXLEVBQUV3VCxJQUFJMzFDLEtBQUssRUFBRTIxQyxJQUFJMTFDLE1BQU0sRUFBRTh5QjtnQkFDcEc0aUIsSUFBSS8xQyxNQUFNLEdBQUdpOEQseUJBQXlCbG1CLElBQUkzMUMsS0FBSyxFQUFFMjFDLElBQUkxMUMsTUFBTSxFQUFFMmQsV0FBVzZvQixXQUFXMVQsS0FBSzB5QixVQUFVO1lBQ3BHLE9BQU8sSUFBSTExQyxNQUFNcGQsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUMwQyxLQUFLLEVBQUU7Z0JBQzFDOWpCLFlBQVk7b0JBQUM7d0JBQ1grSyxZQUFZLENBQUN1d0MsS0FBSyxDQUFDOUwsS0FBS3I2QixLQUFLb3lCLFdBQVcsTUFBTSxRQUFRaUksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHemtDLFVBQVUsTUFBTSxRQUFRdXdDLE9BQU8sS0FBSyxJQUFJQSxLQUFLbm1DLEtBQUtteUIsWUFBWTt3QkFDaEo1aUMsVUFBVSxDQUFDZ3NELEtBQUssQ0FBQzNULEtBQUs1bkMsS0FBS295QixXQUFXLE1BQU0sUUFBUXdWLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3I0QyxRQUFRLE1BQU0sUUFBUWdzRCxPQUFPLEtBQUssSUFBSUEsS0FBSzt3QkFDM0huVyxpQkFBaUIsQ0FBQ3FXLEtBQUssQ0FBQ0QsS0FBS3g3QyxLQUFLb3lCLFdBQVcsTUFBTSxRQUFRb3BCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pzRCxRQUFRLE1BQU0sUUFBUWtzRCxPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDcEk7aUJBQUU7WUFDSjtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUM3N0IsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxDQUFDNlcsUUFBUSxFQUFFO2dCQUN4QyxNQUFNLElBQUkvMUIsMEJBQTBCO1lBQ3RDO1lBQ0EsTUFBTTB2QyxLQUFLLE1BQU0sSUFBSSxDQUFDeHdCLE1BQU0sQ0FBQ3Q4QixRQUFRLENBQUNzL0I7WUFDdEMsc0ZBQXNGO1lBQ3RGLHVCQUF1QjtZQUN2QixJQUFJaTVCO1lBQ0p6TCxHQUFHOWlFLE1BQU0sQ0FBQzdtQixPQUFPLENBQUM4cEMsQ0FBQUE7Z0JBQ2hCLElBQUlzckQscUJBQXFCbnlGLFdBQVc7b0JBQ2xDbXlGLG1CQUFtQnRyRCxNQUFNNWpCLFFBQVE7Z0JBQ25DO1lBQ0Y7WUFDQSxJQUFJa3ZFLG9CQUFvQjcrRCxNQUFNcGQsSUFBSSxLQUFLMnFDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRTtnQkFDdkQsTUFBTTR2QyxlQUFlanFDLDJCQUEyQmdxQztnQkFDaEQsSUFBSUMsaUJBQWlCcHBCLFlBQVk7b0JBQy9CLElBQUksQ0FBQ3BxRSxHQUFHLENBQUMyQixLQUFLLENBQUMseUNBQXlDcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUIxdUIsU0FBUzt3QkFDdEp1VCxPQUFPdXJEO29CQUNUO29CQUNBLGNBQWMsR0FDZDk3QyxLQUFLMHlCLFVBQVUsR0FBR29wQjtvQkFDbEIsNERBQTREO29CQUM1RGp4RCxZQUFZKzRDLHNCQUFzQjVtRCxNQUFNL1gsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUM2RCxXQUFXLEVBQUV3VCxJQUFJMzFDLEtBQUssRUFBRTIxQyxJQUFJMTFDLE1BQU0sRUFBRTh5QjtnQkFDdEc7WUFDRjtZQUNBLE1BQU00Z0IsY0FBYyxJQUFJdXZCLHNCQUFzQm56RCxNQUFNcGQsSUFBSSxFQUFFd3dFLElBQUlwekQsT0FBTztnQkFDbkVuekIsWUFBWSxJQUFJLENBQUN1dUYsV0FBVyxDQUFDdnVGLFVBQVU7Z0JBQ3ZDdWhELGlCQUFpQixJQUFNLElBQUksQ0FBQ0ssVUFBVTtZQUN4QztZQUNBLHlEQUF5RDtZQUN6RG1WLFlBQVlydkQsT0FBTyxHQUFHeXVDO1lBQ3RCaGpCLE1BQU03UyxHQUFHLEdBQUdpbUUsR0FBR2ptRSxHQUFHO1lBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUN5MUMsTUFBTSxDQUFDK2EsU0FBUyxFQUFFO2dCQUMxQixNQUFNLElBQUlqNkIsMEJBQTBCO1lBQ3RDO1lBQ0EsSUFBSSxDQUFDcDRDLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQyxjQUFjcUksTUFBTSxDQUFDMHFCLE1BQU1wZCxJQUFJLEVBQUUsb0JBQW9CL1ksT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7Z0JBQ3BINWdCO2dCQUNBbW5CLFdBQVdvK0I7WUFDYjtZQUNBcHpELE1BQU11RyxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUNxOEIsTUFBTSxDQUFDZ2UsWUFBWSxDQUFDNWdELE9BQU9nakIsTUFBTW5WO1lBQzNELElBQUlBLFdBQVc7Z0JBQ2IsSUFBSTJqQixlQUFleHhCLE1BQU1wZCxJQUFJLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQzBDLEtBQUssRUFBRTtvQkFDbEQ7Ozs7OztXQU1DLEdBQ0QsSUFBSW90QyxtQkFBbUJyeUY7b0JBQ3ZCLEtBQUssTUFBTSs0QixlQUFlLElBQUksQ0FBQ205QixNQUFNLENBQUMrYSxTQUFTLENBQUNwRyxTQUFTLENBQUMxbUMsZUFBZSxHQUFJO3dCQUMzRSxJQUFJcEwsWUFBWWMsTUFBTSxLQUFLdkcsTUFBTXVHLE1BQU0sRUFBRTs0QkFDdkN3NEQsbUJBQW1CdDVEOzRCQUNuQjt3QkFDRjtvQkFDRjtvQkFDQSxJQUFJczVELGtCQUFrQjt3QkFDcEIsSUFBSSxDQUFDbjhCLE1BQU0sQ0FBQythLFNBQVMsQ0FBQ3BHLFNBQVMsQ0FBQy9ELG9CQUFvQixDQUFDOzRCQUNuRC90QyxhQUFhczVEOzRCQUNieHJELE9BQU87NEJBQ1BzL0IsT0FBTyxDQUFDLENBQUM2ckIsS0FBSzd3RCxTQUFTLENBQUMsRUFBRSxNQUFNLFFBQVE2d0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOWxELFVBQVUsSUFBSS9LLFNBQVMsQ0FBQyxFQUFFLENBQUMrSyxVQUFVLEdBQUcsT0FBTzt3QkFDckg7b0JBQ0Y7Z0JBQ0YsT0FBTyxJQUFJNVksTUFBTXVULEtBQUssSUFBSW1qQixXQUFXMTJCLE1BQU11VCxLQUFLLEtBQU0sRUFBQ29yRCxLQUFLOXdELFNBQVMsQ0FBQyxFQUFFLE1BQU0sUUFBUTh3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcvbEQsVUFBVSxHQUFHO29CQUM3SCxJQUFJLENBQUNncUIsTUFBTSxDQUFDK2EsU0FBUyxDQUFDcEcsU0FBUyxDQUFDL0Qsb0JBQW9CLENBQUM7d0JBQ25ENWpELEtBQUtnMkMsSUFBSWgyQyxHQUFHO3dCQUNaMmpCLE9BQU92VCxNQUFNdVQsS0FBSzt3QkFDbEJzL0IsT0FBT2hsQyxTQUFTLENBQUMsRUFBRSxDQUFDK0ssVUFBVSxHQUFHO29CQUNuQztnQkFDRjtZQUNGO1lBQ0EsTUFBTSxJQUFJLENBQUNncUIsTUFBTSxDQUFDb08sU0FBUztZQUMzQixJQUFJaHhDLGlCQUFpQm1tRCxpQkFBaUI7Z0JBQ3BDbm1ELE1BQU0wbEQsWUFBWSxDQUFDLElBQUksQ0FBQzlpQixNQUFNLENBQUNpYSxNQUFNO1lBQ3ZDLE9BQU8sSUFBSTc4QyxpQkFBaUJrbEQsaUJBQWlCO2dCQUMzQ2xsRCxNQUFNMGxELFlBQVk7WUFDcEI7WUFDQSxJQUFJLENBQUNxUSxtQkFBbUIsQ0FBQ255QjtZQUN6Qiw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDNXBDLElBQUksQ0FBQ29xQixpQkFBaUJ1ZixtQkFBbUIsRUFBRUM7WUFDaEQsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsSUFBSWo1QixVQUFVO1FBQ1osT0FBTztJQUNUO0lBQ0E7O0dBRUMsR0FDRDR3RCwrQkFBK0J2N0QsS0FBSyxFQUFFMDFDLFVBQVUsRUFBRW5oRSxPQUFPLEVBQUU7UUFDekQsSUFBSTBCO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLHVEQUF1RDtZQUN2RCxJQUFJLElBQUksQ0FBQzJqRSxjQUFjLEtBQUsvcUUsZ0JBQWdCaUIsSUFBSSxFQUFFO2dCQUNoRDtZQUNGO1lBQ0Esa0NBQWtDO1lBQ2xDLElBQUl1dEU7WUFDSixJQUFJLENBQUMvdUUsTUFBTSxDQUFDemxCLE9BQU8sQ0FBQ202RCxDQUFBQTtnQkFDbEIsSUFBSSxDQUFDQSxZQUFZNWpDLEtBQUssRUFBRTtvQkFDdEI7Z0JBQ0Y7Z0JBQ0EsSUFBSTRqQyxZQUFZNWpDLEtBQUssS0FBS0EsT0FBTztvQkFDL0JpK0Qsc0JBQXNCcjZCO2dCQUN4QjtZQUNGO1lBQ0EsSUFBSSxDQUFDcTZCLHFCQUFxQjtnQkFDeEIsTUFBTSxJQUFJejZDLGtCQUFrQjtZQUM5QjtZQUNBLElBQUksQ0FBRXhqQixDQUFBQSxpQkFBaUJtbUQsZUFBYyxHQUFJO2dCQUN2QyxNQUFNLElBQUkzaUMsa0JBQWtCO1lBQzlCO1lBQ0EsTUFBTVIsT0FBT241QyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQ29DLEtBQUssSUFBSSxDQUFDbWxGLFdBQVcsTUFBTSxRQUFRbmxGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2kvRCxlQUFlLEdBQUczZ0U7WUFDL0gsTUFBTXM1QixZQUFZZzZDLDRCQUE0QjduRCxPQUFPMDFDLFlBQVkxeUI7WUFDakUsSUFBSSxDQUFDblYsV0FBVztnQkFDZCxJQUFJLENBQUN2aUMsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLHNGQUFzRnJHLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUIxdUI7Z0JBQzdLO1lBQ0Y7WUFDQSxNQUFNZ2hELGlCQUFpQmhoRCxNQUFNOHFELGlCQUFpQixDQUFDcFYsWUFBWTduQztZQUMzRCxNQUFNKzNCLE1BQU0sSUFBSXBkLGdCQUFnQjtnQkFDOUI1NEIsS0FBS294RCxlQUFlcHlCLGdCQUFnQixDQUFDL3VCLEVBQUU7Z0JBQ3ZDcnJCLE1BQU0rNEMsTUFBTW1FLFdBQVcsQ0FBQzF4QixNQUFNcGQsSUFBSTtnQkFDbENvTixPQUFPZ1EsTUFBTTJ0QixPQUFPO2dCQUNwQjFsQyxRQUFRc2xDLE1BQU13RSxhQUFhLENBQUMveEIsTUFBTS9YLE1BQU07Z0JBQ3hDa0YsS0FBSzZTLE1BQU03UyxHQUFHO2dCQUNkKzhCLGlCQUFpQjtvQkFBQzt3QkFDaEIzVyxPQUFPeVAsS0FBSzB5QixVQUFVO3dCQUN0QjlsRCxLQUFLb3hELGVBQWVweUIsZ0JBQWdCLENBQUMvdUIsRUFBRTtvQkFDekM7aUJBQUU7WUFDSjtZQUNBK2xDLElBQUkvMUMsTUFBTSxHQUFHaThELHlCQUF5QmxtQixJQUFJMzFDLEtBQUssRUFBRTIxQyxJQUFJMTFDLE1BQU0sRUFBRTJkO1lBQzdELElBQUksQ0FBQyxJQUFJLENBQUMrMEIsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxDQUFDNlcsUUFBUSxFQUFFO2dCQUN4QyxNQUFNLElBQUkvMUIsMEJBQTBCO1lBQ3RDO1lBQ0EsTUFBTTB2QyxLQUFLLE1BQU0sSUFBSSxDQUFDeHdCLE1BQU0sQ0FBQ3Q4QixRQUFRLENBQUNzL0I7WUFDdEMsTUFBTSxJQUFJLENBQUNoRCxNQUFNLENBQUNtZSxxQkFBcUIsQ0FBQy9nRCxPQUFPZ2hELGdCQUFnQmgrQixNQUFNblY7WUFDckUsTUFBTSxJQUFJLENBQUMrMEIsTUFBTSxDQUFDb08sU0FBUztZQUMzQixJQUFJLENBQUMxbEUsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLGFBQWFxSSxNQUFNLENBQUNvZ0UsWUFBWSxlQUFlcGdFLE1BQU0sQ0FBQzBxQixNQUFNN1MsR0FBRyxHQUFHdGpCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUNqSTVnQjtnQkFDQW1uQixXQUFXbytCO1lBQ2I7UUFDRjtJQUNGO0lBQ0EwRyxlQUFlOTVELEtBQUssRUFBRWcvRCxlQUFlLEVBQUU7UUFDckMsSUFBSS9vRixJQUFJOFU7UUFDUixPQUFPOEwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQywyREFBMkQ7WUFDM0QsTUFBTStzQyxjQUFjLElBQUksQ0FBQ3E3QixzQkFBc0IsQ0FBQ2ovRDtZQUNoRCxNQUFNay9ELGdCQUFnQnQ3QixjQUFjbFYsdUJBQXVCa1YsZUFBZWwzRDtZQUMxRSxJQUFJLENBQUNwQixHQUFHLENBQUMyQixLQUFLLENBQUMsc0JBQXNCcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUd5d0M7WUFDdkYsSUFBSSxDQUFDdDdCLGVBQWUsQ0FBQ0EsWUFBWTVqQyxLQUFLLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQzEwQixHQUFHLENBQUMydEIsSUFBSSxDQUFDLDhEQUE4RHB2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBR3l3QztnQkFDOUgsT0FBT3h5RjtZQUNUO1lBQ0FzekIsUUFBUTRqQyxZQUFZNWpDLEtBQUs7WUFDekJBLE1BQU1uRSxHQUFHLENBQUN5b0IsV0FBVzZiLEtBQUssRUFBRSxJQUFJLENBQUM2NkIsWUFBWTtZQUM3Q2g3RCxNQUFNbkUsR0FBRyxDQUFDeW9CLFdBQVc4YixPQUFPLEVBQUUsSUFBSSxDQUFDMjZCLGNBQWM7WUFDakQvNkQsTUFBTW5FLEdBQUcsQ0FBQ3lvQixXQUFXaWEsS0FBSyxFQUFFLElBQUksQ0FBQzgwQixnQkFBZ0I7WUFDakRyekQsTUFBTW5FLEdBQUcsQ0FBQ3lvQixXQUFXbWMsY0FBYyxFQUFFLElBQUksQ0FBQ3c2QixxQkFBcUI7WUFDL0RqN0QsTUFBTW5FLEdBQUcsQ0FBQ3lvQixXQUFXb2MsZUFBZSxFQUFFLElBQUksQ0FBQ3c2QixzQkFBc0I7WUFDakUsSUFBSThELG9CQUFvQnR5RixXQUFXO2dCQUNqQ3N5RixrQkFBa0IsQ0FBQ2owRSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ21sRixXQUFXLE1BQU0sUUFBUW5sRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnZ0UseUJBQXlCLE1BQU0sUUFBUWxyRCxPQUFPLEtBQUssSUFBSUEsS0FBSztZQUN0SjtZQUNBLElBQUlpMEUsaUJBQWlCO2dCQUNuQmgvRCxNQUFNK0QsSUFBSTtZQUNaO1lBQ0EsSUFBSW83RCxvQkFBb0I7WUFDeEIsTUFBTUMsY0FBY3AvRCxNQUFNdUcsTUFBTTtZQUNoQ3ZHLE1BQU11RyxNQUFNLEdBQUc3NUI7WUFDZixJQUFJLElBQUksQ0FBQ2syRCxNQUFNLENBQUMrYSxTQUFTLElBQUksSUFBSSxDQUFDL2EsTUFBTSxDQUFDK2EsU0FBUyxDQUFDM1gsWUFBWSxHQUFHd1EsaUJBQWlCVyxNQUFNLElBQUlpb0IsYUFBYTtnQkFDeEcsSUFBSTtvQkFDRixLQUFLLE1BQU0zNUQsZUFBZSxJQUFJLENBQUNtOUIsTUFBTSxDQUFDK2EsU0FBUyxDQUFDcEcsU0FBUyxDQUFDMW1DLGVBQWUsR0FBSTt3QkFDM0UsZ0VBQWdFO3dCQUNoRSxvQ0FBb0M7d0JBQ3BDLG9FQUFvRTt3QkFDcEUsOEJBQThCO3dCQUM5QixJQUFJcEwsWUFBWWMsTUFBTSxLQUFLNjRELGFBQWE7NEJBQ3RDMzVELFlBQVlxTCxTQUFTLEdBQUc7NEJBQ3hCcXVELG9CQUFvQjt3QkFDdEI7b0JBQ0Y7b0JBQ0EsSUFBSSxJQUFJLENBQUN2OEIsTUFBTSxDQUFDbjhCLFdBQVcsQ0FBQzI0RCxjQUFjO3dCQUN4Q0Qsb0JBQW9CO29CQUN0QjtvQkFDQSxJQUFJbi9ELGlCQUFpQm1tRCxpQkFBaUI7d0JBQ3BDLEtBQUssTUFBTSxHQUFHbnhCLFVBQVUsSUFBSWgxQixNQUFNa3FCLGVBQWUsQ0FBRTs0QkFDakQsSUFBSThLLFVBQVV6dUIsTUFBTSxFQUFFO2dDQUNwQixJQUFJLElBQUksQ0FBQ3E4QixNQUFNLENBQUNuOEIsV0FBVyxDQUFDdXVCLFVBQVV6dUIsTUFBTSxHQUFHO29DQUM3QzQ0RCxvQkFBb0I7Z0NBQ3RCO2dDQUNBbnFDLFVBQVV6dUIsTUFBTSxHQUFHNzVCOzRCQUNyQjt3QkFDRjt3QkFDQXN6QixNQUFNa3FCLGVBQWUsQ0FBQ20xQyxLQUFLO29CQUM3QjtnQkFDRixFQUFFLE9BQU8zMUYsR0FBRztvQkFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLDZCQUE2QnB2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUd5d0MsZ0JBQWdCO3dCQUN6SC9tRSxPQUFPenVCO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSx1QkFBdUI7WUFDdkIsSUFBSSxDQUFDd2xCLE1BQU0sQ0FBQ21QLE1BQU0sQ0FBQ3VsQyxZQUFZOVksUUFBUTtZQUN2QyxPQUFROFksWUFBWWhoRCxJQUFJO2dCQUN0QixLQUFLMnFDLE1BQU0wQixJQUFJLENBQUMwQyxLQUFLO29CQUNuQixJQUFJLENBQUN5aUMsV0FBVyxDQUFDLzFELE1BQU0sQ0FBQ3VsQyxZQUFZOVksUUFBUTtvQkFDNUM7Z0JBQ0YsS0FBS3lDLE1BQU0wQixJQUFJLENBQUNDLEtBQUs7b0JBQ25CLElBQUksQ0FBQ21sQyxXQUFXLENBQUNoMkQsTUFBTSxDQUFDdWxDLFlBQVk5WSxRQUFRO29CQUM1QztZQUNKO1lBQ0EsSUFBSSxDQUFDOXdCLElBQUksQ0FBQ29xQixpQkFBaUJtN0IscUJBQXFCLEVBQUUzYjtZQUNsREEsWUFBWSt1QixRQUFRLENBQUNqbUY7WUFDckIsSUFBSXl5RixtQkFBbUI7Z0JBQ3JCLE1BQU0sSUFBSSxDQUFDdjhCLE1BQU0sQ0FBQ29PLFNBQVM7WUFDN0I7WUFDQSxPQUFPcE47UUFDVDtJQUNGO0lBQ0EwN0IsZ0JBQWdCcHdFLE1BQU0sRUFBRTtRQUN0QixPQUFPMkgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNNHhELFVBQVUsTUFBTXJ4RCxRQUFRak8sR0FBRyxDQUFDK0YsT0FBT3plLEdBQUcsQ0FBQ3V2QixDQUFBQSxRQUFTLElBQUksQ0FBQzg1RCxjQUFjLENBQUM5NUQ7WUFDMUUsT0FBT3lvRCxRQUFRcDRFLE1BQU0sQ0FBQzJ2QixDQUFBQSxRQUFTQSxpQkFBaUJtekQ7UUFDbEQ7SUFDRjtJQUNBd0osbUJBQW1CcG9GLE9BQU8sRUFBRTtRQUMxQixJQUFJZ3JGLGdCQUFnQmx6RixVQUFVVSxNQUFNLEdBQUcsS0FBS1YsU0FBUyxDQUFDLEVBQUUsS0FBS0ssWUFBWUwsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4RixPQUFPd3FCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTTJvRSxZQUFZLEVBQUU7WUFDcEIsSUFBSSxDQUFDdHdFLE1BQU0sQ0FBQ3psQixPQUFPLENBQUN3NUQsQ0FBQUE7Z0JBQ2xCLElBQUlBLElBQUlqakMsS0FBSyxFQUFFO29CQUNiLElBQUl6ckIsU0FBUzt3QkFDWDB1RCxJQUFJMXVELE9BQU8sR0FBRzFLLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBR292RCxJQUFJMXVELE9BQU8sR0FBR0E7b0JBQzlEO29CQUNBaXJGLFVBQVUvckYsSUFBSSxDQUFDd3ZEO2dCQUNqQjtZQUNGO1lBQ0EsTUFBTTdyQyxRQUFRak8sR0FBRyxDQUFDcTJFLFVBQVUvdUYsR0FBRyxDQUFDd3lELENBQUFBLE1BQU9wc0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDckUsTUFBTW1KLFFBQVFpakMsSUFBSWpqQyxLQUFLO29CQUN2QixNQUFNLElBQUksQ0FBQzg1RCxjQUFjLENBQUM5NUQsT0FBTztvQkFDakMsSUFBSXUvRCxpQkFBaUIsQ0FBQ3YvRCxNQUFNMnRCLE9BQU8sSUFBSTN0QixNQUFNL1gsTUFBTSxLQUFLc2xDLE1BQU1nQixNQUFNLENBQUM2RCxXQUFXLElBQUlweUIsTUFBTS9YLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDK0QsZ0JBQWdCLElBQUt0eUIsQ0FBQUEsaUJBQWlCa2xELG1CQUFtQmxsRCxpQkFBaUJtbUQsZUFBYyxLQUFNLENBQUNubUQsTUFBTWcvQixjQUFjLEVBQUU7d0JBQ3JPLG1GQUFtRjt3QkFDbkYsbURBQW1EO3dCQUNuRCxJQUFJLENBQUMxekQsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDZCQUE2QnBELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHOzRCQUM1Rnp1QixPQUFPaWpDLElBQUluWSxRQUFRO3dCQUNyQjt3QkFDQSxNQUFNOXFCLE1BQU13bEQsWUFBWTtvQkFDMUI7b0JBQ0EsTUFBTSxJQUFJLENBQUN5WCxZQUFZLENBQUNqOUQsT0FBT2lqQyxJQUFJMXVELE9BQU87Z0JBQzVDO1FBQ0Y7SUFDRjtJQUNBa3JGLFlBQVk3b0YsSUFBSSxFQUFFZ00sSUFBSSxFQUFFO1FBQ3RCLElBQUl5NUUsaUJBQWlCaHdGLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDMUYsT0FBT3dxQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU0rMkQsY0FBY2prRixNQUFNQyxPQUFPLENBQUN5eUYsa0JBQWtCQSxpQkFBaUJBLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZXpPLFdBQVc7WUFDL0osTUFBTWo4RCxrQkFBa0IsRUFBRTtZQUMxQixNQUFNK3RFLFFBQVEsQ0FBQy8xRixNQUFNQyxPQUFPLENBQUN5eUYsa0JBQWtCQSxlQUFlcUQsS0FBSyxHQUFHaHpGO1lBQ3RFLElBQUlraEYsZ0JBQWdCbGhGLFdBQVc7Z0JBQzdCa2hGLFlBQVlua0YsT0FBTyxDQUFDa2EsQ0FBQUE7b0JBQ2xCLElBQUlBLGVBQWVnMUUsbUJBQW1CO3dCQUNwQ2huRSxnQkFBZ0JsZSxJQUFJLENBQUNrUSxJQUFJd0osR0FBRztvQkFDOUIsT0FBTzt3QkFDTHdFLGdCQUFnQmxlLElBQUksQ0FBQ2tRO29CQUN2QjtnQkFDRjtZQUNGO1lBQ0EsTUFBTTArRCxTQUFTLElBQUlyeEQsV0FBVztnQkFDNUJwTztnQkFDQXJQLE9BQU87b0JBQ0xvUCxNQUFNO29CQUNOcFAsT0FBTyxJQUFJNGQsV0FBVzt3QkFDcEJLLGdCQUFnQixJQUFJLENBQUNyRSxHQUFHO3dCQUN4QnVFLFNBQVM5YTt3QkFDVCthLGlCQUFpQkE7d0JBQ2pCK3RFO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNLElBQUksQ0FBQzk4QixNQUFNLENBQUN3ZixjQUFjLENBQUNDLFFBQVF6L0Q7UUFDM0M7SUFDRjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JDLEdBQ0QrOEUsZ0NBQWdDN0Usc0JBQXNCLEVBQUU7UUFDdEQsSUFBSVIsOEJBQThCanVGLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUU7UUFDeEcsSUFBSSxDQUFDaXVGLDJCQUEyQixHQUFHQTtRQUNuQyxJQUFJLENBQUNDLGlDQUFpQyxHQUFHTztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDbDRCLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQzVXLGNBQWMsRUFBRTtZQUN0QyxJQUFJLENBQUMyMEIsa0NBQWtDO1FBQ3pDO0lBQ0Y7SUFDQSxjQUFjLEdBQ2Q3SCxXQUFXN2lGLElBQUksRUFBRTtRQUNmLElBQUlBLEtBQUtpZCxHQUFHLEtBQUssSUFBSSxDQUFDQSxHQUFHLEVBQUU7WUFDekIseUNBQXlDO1lBQ3pDLGtGQUFrRjtZQUNsRixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMsS0FBSyxDQUFDNGxFLFdBQVc3aUYsT0FBTztZQUMzQixPQUFPO1FBQ1Q7UUFDQSwrQkFBK0I7UUFDL0IsMkVBQTJFO1FBQzNFLG9CQUFvQjtRQUNwQkEsS0FBS2dmLE1BQU0sQ0FBQ3psQixPQUFPLENBQUMycEYsQ0FBQUE7WUFDbEIsSUFBSW45RSxJQUFJOFU7WUFDUixNQUFNazRDLE1BQU0sSUFBSSxDQUFDL3pDLE1BQU0sQ0FBQy9rQixHQUFHLENBQUNpcEYsR0FBR2ptRSxHQUFHO1lBQ2xDLElBQUk4MUMsS0FBSztnQkFDUCxNQUFNMjhCLGdCQUFnQjM4QixJQUFJdFYsT0FBTyxJQUFLLEVBQUM1aUMsS0FBSyxDQUFDOVUsS0FBS2d0RCxJQUFJampDLEtBQUssTUFBTSxRQUFRL3BCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhvRCxnQkFBZ0IsTUFBTSxRQUFRaDBDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEtBQUk7Z0JBQzVKLElBQUk2MEUsa0JBQWtCeE0sR0FBR3BqRSxLQUFLLEVBQUU7b0JBQzlCLElBQUksQ0FBQzFrQixHQUFHLENBQUMyQixLQUFLLENBQUMsOENBQThDcEQsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHQyx1QkFBdUJ1VSxPQUFPO3dCQUN6SjI4QjtvQkFDRjtvQkFDQSxJQUFJLENBQUNoOUIsTUFBTSxDQUFDaWEsTUFBTSxDQUFDeFMsYUFBYSxDQUFDK29CLEdBQUdqbUUsR0FBRyxFQUFFeXlFO2dCQUMzQztZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQVgsdUJBQXVCai9ELEtBQUssRUFBRTtRQUM1QixJQUFJNGpDO1FBQ0osSUFBSSxDQUFDMTBDLE1BQU0sQ0FBQ3psQixPQUFPLENBQUN3NUQsQ0FBQUE7WUFDbEIsTUFBTSs1QixhQUFhLzVCLElBQUlqakMsS0FBSztZQUM1QixJQUFJLENBQUNnOUQsWUFBWTtnQkFDZjtZQUNGO1lBQ0Esd0RBQXdEO1lBQ3hELElBQUloOUQsaUJBQWlCMEksa0JBQWtCO2dCQUNyQyxJQUFJczBELHNCQUFzQjlYLG1CQUFtQjhYLHNCQUFzQjdXLGlCQUFpQjtvQkFDbEYsSUFBSTZXLFdBQVdwdUMsZ0JBQWdCLEtBQUs1dUIsT0FBTzt3QkFDekM0akMsY0FBY1g7b0JBQ2hCO2dCQUNGO1lBQ0YsT0FBTyxJQUFJampDLFVBQVVnOUQsWUFBWTtnQkFDL0JwNUIsY0FBY1g7WUFDaEI7UUFDRjtRQUNBLE9BQU9XO0lBQ1Q7QUFDRjtBQUVBLElBQUlUO0FBQ0gsVUFBVUEsZUFBZTtJQUN4QkEsZUFBZSxDQUFDLGVBQWUsR0FBRztJQUNsQ0EsZUFBZSxDQUFDLGFBQWEsR0FBRztJQUNoQ0EsZUFBZSxDQUFDLFlBQVksR0FBRztJQUMvQkEsZUFBZSxDQUFDLGVBQWUsR0FBRztBQUNwQyxHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLE1BQU0wOEIsK0JBQStCLElBQUk7QUFDekMsa0VBQWtFLEdBQ2xFLE1BQU1DLFlBQVkzOEI7QUFDbEI7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1qMkMsYUFBYThQLGNBQWM3RCxZQUFZO0lBQzNDOzs7R0FHQyxHQUNENWlCLFlBQVloQyxPQUFPLENBQUU7UUFDbkIsSUFBSXdyRjtRQUNKLElBQUk5cEYsSUFBSThVO1FBQ1IsS0FBSztRQUNMZzFFLFFBQVEsSUFBSTtRQUNaLElBQUksQ0FBQ2h4RSxLQUFLLEdBQUdvMEMsZ0JBQWdCdVksWUFBWTtRQUN6Qzs7O0tBR0MsR0FDRCxJQUFJLENBQUNza0IsY0FBYyxHQUFHLEVBQUU7UUFDeEIsbUVBQW1FLEdBQ25FLElBQUksQ0FBQ3Q4QixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDdThCLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQzUwRixHQUFHLEdBQUcyRTtRQUNYLElBQUksQ0FBQzhqRCxPQUFPLEdBQUcsQ0FBQ3pqQixLQUFLbTNCLE9BQU96a0IsT0FBU25zQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUNuRSxJQUFJN0w7Z0JBQ0osdUlBQXVJO2dCQUN2SSxNQUFNbTFFLG1CQUFtQixNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDbGtDLElBQUk7Z0JBQ3ZELElBQUksSUFBSSxDQUFDbnRDLEtBQUssS0FBS28wQyxnQkFBZ0JDLFNBQVMsRUFBRTtvQkFDNUMsaUZBQWlGO29CQUNqRixJQUFJLENBQUM5M0QsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLDZCQUE2Qm9GLE1BQU0sQ0FBQyxJQUFJLENBQUNqSSxJQUFJLEdBQUcsSUFBSSxDQUFDb2hELFVBQVU7b0JBQzdFMHhDO29CQUNBLE9BQU8vb0UsUUFBUUQsT0FBTztnQkFDeEI7Z0JBQ0EsSUFBSSxJQUFJLENBQUNrcEUsYUFBYSxFQUFFO29CQUN0QkY7b0JBQ0EsT0FBTyxJQUFJLENBQUNFLGFBQWEsQ0FBQzd3RCxPQUFPO2dCQUNuQztnQkFDQSxJQUFJLENBQUM4d0QseUJBQXlCLENBQUNuOUIsZ0JBQWdCbzlCLFVBQVU7Z0JBQ3pELElBQUksQ0FBQyxDQUFDdjFFLEtBQUssSUFBSSxDQUFDK3dELGlCQUFpQixNQUFNLFFBQVEvd0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHODRELFlBQVksR0FBRy9wRSxRQUFRLEVBQUMsTUFBT3UyQixLQUFLO29CQUM3RyxJQUFJLENBQUNreEMsU0FBUyxHQUFHOTBFO29CQUNqQixJQUFJLENBQUNxdkUsaUJBQWlCLEdBQUdydkU7Z0JBQzNCO2dCQUNBLElBQUk2cUQsUUFBUSxJQUFJc3NCLElBQUl2ekMsT0FBTztvQkFDekIsSUFBSSxJQUFJLENBQUN5ckMsaUJBQWlCLEtBQUtydkUsV0FBVzt3QkFDeEMsSUFBSSxDQUFDcXZFLGlCQUFpQixHQUFHLElBQUkwSCxrQkFBa0JuekMsS0FBS20zQjtvQkFDdEQsT0FBTzt3QkFDTCxJQUFJLENBQUNzVSxpQkFBaUIsQ0FBQ0MsV0FBVyxDQUFDdlU7b0JBQ3JDO29CQUNBLHlEQUF5RDtvQkFDekQsdUVBQXVFO29CQUN2RSxxQkFBcUI7b0JBQ3JCLElBQUksQ0FBQ3NVLGlCQUFpQixDQUFDaUksbUJBQW1CLEdBQUdqMkMsS0FBSyxDQUFDcmtDLENBQUFBO3dCQUNqRCxJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLG1DQUFtQ3B2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzs0QkFDakd0MkIsT0FBT3p1Qjt3QkFDVDtvQkFDRjtnQkFDRjtnQkFDQSxNQUFNODJGLFlBQVksQ0FBQ3JwRSxTQUFTRSxRQUFRbXFELFlBQWMzcUQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzt3QkFDaEYsSUFBSTVMO3dCQUNKLElBQUksSUFBSSxDQUFDdXRELGVBQWUsRUFBRTs0QkFDeEIsSUFBSSxDQUFDQSxlQUFlLENBQUNzSyxLQUFLO3dCQUM1Qjt3QkFDQSxtSEFBbUg7d0JBQ25ILE1BQU10SyxrQkFBa0IsSUFBSW9LO3dCQUM1QixJQUFJLENBQUNwSyxlQUFlLEdBQUdBO3dCQUN2QixnSUFBZ0k7d0JBQ2hJMm5CLHFCQUFxQixRQUFRQSxxQkFBcUIsS0FBSyxJQUFJLEtBQUssSUFBSUE7d0JBQ3BFLElBQUk7NEJBQ0YsTUFBTSxJQUFJLENBQUNNLGlCQUFpQixDQUFDamYsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSUEsWUFBWWx4QyxLQUFLbTNCLE9BQU96a0IsTUFBTXcxQjs0QkFDeEcsSUFBSSxDQUFDQSxlQUFlLEdBQUc5ckU7NEJBQ3ZCeXFCO3dCQUNGLEVBQUUsT0FBT3p0QixHQUFHOzRCQUNWLElBQUksSUFBSSxDQUFDcXlFLGlCQUFpQixJQUFJcnlFLGFBQWEwNUMsbUJBQW1CMTVDLEVBQUUyNUMsTUFBTSxLQUFLLEVBQUUsbUNBQW1DLE9BQU0zNUMsRUFBRTI1QyxNQUFNLEtBQUssRUFBRSxvQ0FBb0MsS0FBSTtnQ0FDM0ssSUFBSXE5QyxVQUFVO2dDQUNkLElBQUk7b0NBQ0ZBLFVBQVUsTUFBTSxJQUFJLENBQUMza0IsaUJBQWlCLENBQUMrRixvQkFBb0IsQ0FBQyxDQUFDNzJELEtBQUssSUFBSSxDQUFDdXRELGVBQWUsTUFBTSxRQUFRdnRELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzJ0RCxNQUFNO2dDQUN4SSxFQUFFLE9BQU96Z0QsT0FBTztvQ0FDZCxJQUFJQSxpQkFBaUJpckIsbUJBQW9CanJCLENBQUFBLE1BQU1tckIsTUFBTSxLQUFLLE9BQU9uckIsTUFBTWtyQixNQUFNLEtBQUssRUFBRSxtQ0FBbUMsR0FBckMsR0FBMEM7d0NBQzFILElBQUksQ0FBQ2s0QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNobkUsT0FBTyxDQUFDMGhFLHlCQUF5Qjt3Q0FDNUQ1K0MsT0FBT2M7d0NBQ1A7b0NBQ0Y7Z0NBQ0Y7Z0NBQ0EsSUFBSXVvRSxTQUFTO29DQUNYLElBQUksQ0FBQ3AxRixHQUFHLENBQUM0RSxJQUFJLENBQUMsbURBQW1Eb0YsTUFBTSxDQUFDNUwsRUFBRTZMLE9BQU8sRUFBRSxvQ0FBb0NELE1BQU0sQ0FBQ29yRixVQUFVLElBQUksQ0FBQ2p5QyxVQUFVO29DQUN2SixNQUFNK3hDLFVBQVVycEUsU0FBU0UsUUFBUXFwRTtnQ0FDbkMsT0FBTztvQ0FDTCxJQUFJLENBQUNubEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDaG5FLE9BQU8sQ0FBQzBoRSx5QkFBeUI7b0NBQzVENStDLE9BQU8zdEI7Z0NBQ1Q7NEJBQ0YsT0FBTztnQ0FDTCxJQUFJLENBQUM2eEUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDaG5FLE9BQU8sQ0FBQzBoRSx5QkFBeUI7Z0NBQzVENStDLE9BQU8zdEI7NEJBQ1Q7d0JBQ0Y7b0JBQ0Y7Z0JBQ0EsTUFBTTgzRSxZQUFZLElBQUksQ0FBQ0EsU0FBUztnQkFDaEMsSUFBSSxDQUFDQSxTQUFTLEdBQUc5MEU7Z0JBQ2pCLElBQUksQ0FBQzJ6RixhQUFhLEdBQUcsSUFBSTFsQyxPQUFPLENBQUN4akMsU0FBU0U7b0JBQ3hDbXBFLFVBQVVycEUsU0FBU0UsUUFBUW1xRDtnQkFDN0IsR0FBRztvQkFDRCxJQUFJLENBQUNtZixzQkFBc0I7Z0JBQzdCO2dCQUNBLE9BQU8sSUFBSSxDQUFDTixhQUFhLENBQUM3d0QsT0FBTztZQUNuQztRQUNBLElBQUksQ0FBQ294RCxhQUFhLEdBQUcsQ0FBQ3R3RCxLQUFLbTNCLE9BQU83RSxRQUFRbUYsZ0JBQWdCcXpCLGFBQWE1aUIsa0JBQW9CM2hELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ3pILElBQUl1bUQsSUFBSUMsSUFBSThMO2dCQUNaLE1BQU16TCxlQUFlLE1BQU05YSxPQUFPOWxELElBQUksQ0FBQ3d6QixLQUFLbTNCLE9BQU87b0JBQ2pEZ0YsZUFBZTFFLGVBQWUwRSxhQUFhO29CQUMzQ0MsYUFBYTNFLGVBQWUyRSxXQUFXO29CQUN2Q0MsZ0JBQWdCLE9BQU95dUIsWUFBWXp1QixjQUFjLEtBQUssV0FBVyxPQUFPeXVCLFlBQVl6dUIsY0FBYztvQkFDbEcySixZQUFZdk8sZUFBZXVPLFVBQVU7b0JBQ3JDcUosYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDa2hCLFdBQVc7b0JBQy9CejRCLGtCQUFrQkwsZUFBZUssZ0JBQWdCO2dCQUNuRCxHQUFHb1EsZ0JBQWdCSSxNQUFNO2dCQUN6QixJQUFJa29CLGFBQWFwakIsYUFBYW9qQixVQUFVO2dCQUN4QyxJQUFJLENBQUNBLFlBQVk7b0JBQ2ZBLGFBQWE7d0JBQ1gxeEUsU0FBU3N1RCxhQUFhcHpCLGFBQWE7d0JBQ25DajdCLFFBQVFxdUQsYUFBYWp6QixZQUFZO29CQUNuQztnQkFDRjtnQkFDQSxJQUFJLENBQUNuL0MsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLCtCQUErQnFJLE1BQU0sQ0FBQ3pMLE9BQU91RyxPQUFPLENBQUMwd0YsWUFBWXJ3RixHQUFHLENBQUNILENBQUFBO29CQUNsRixJQUFJLENBQUNvVCxLQUFLblEsTUFBTSxHQUFHakQ7b0JBQ25CLE9BQU8sR0FBR2dGLE1BQU0sQ0FBQ29PLEtBQUssTUFBTXBPLE1BQU0sQ0FBQy9CO2dCQUNyQyxHQUFHdUosSUFBSSxDQUFDLFFBQVE7b0JBQ2Qya0QsTUFBTSxDQUFDMmIsS0FBS00sYUFBYWpjLElBQUksTUFBTSxRQUFRMmIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHL3ZFLElBQUk7b0JBQzNFa3dFLFNBQVMsQ0FBQ0YsS0FBS0ssYUFBYWpjLElBQUksTUFBTSxRQUFRNGIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbHdELEdBQUc7b0JBQzdFMkIsVUFBVSxDQUFDcTZELEtBQUt6TCxhQUFhOWIsV0FBVyxNQUFNLFFBQVF1bkIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcjZELFFBQVE7Z0JBQzVGO2dCQUNBLElBQUksQ0FBQzR1RCxhQUFhcHpCLGFBQWEsRUFBRTtvQkFDL0IsTUFBTSxJQUFJN0csa0JBQWtCO2dCQUM5QjtnQkFDQSxJQUFJaTZCLGFBQWFwekIsYUFBYSxLQUFLLFlBQVksSUFBSSxDQUFDLzFDLE9BQU8sQ0FBQ3loRSxRQUFRLEVBQUU7b0JBQ3BFLElBQUksQ0FBQzFxRSxHQUFHLENBQUMyQixLQUFLLENBQUMsNENBQTRDLElBQUksQ0FBQ3doRCxVQUFVO29CQUMxRSx5REFBeUQ7b0JBQ3pEMnNDLFlBQVlwbEIsUUFBUSxHQUFHO2dCQUN6QjtnQkFDQSxPQUFPMEg7WUFDVDtRQUNBLElBQUksQ0FBQ3FqQixpQkFBaUIsR0FBR3JqQixDQUFBQTtZQUN2QixNQUFNbWIsS0FBS25iLGFBQWE5YixXQUFXO1lBQ25DLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUN2MEMsR0FBRyxHQUFHMHJFLEdBQUcxckUsR0FBRztZQUNsQyxJQUFJLENBQUN1MEMsZ0JBQWdCLENBQUM1eUMsUUFBUSxHQUFHK3BFLEdBQUcvcEUsUUFBUTtZQUM1QyxvRUFBb0U7WUFDcEUsSUFBSSxDQUFDa3lFLHdCQUF3QixDQUFDO2dCQUFDbkk7bUJBQU9uYixhQUFhcnpCLGlCQUFpQjthQUFDO1lBQ3JFLElBQUlxekIsYUFBYWpjLElBQUksRUFBRTtnQkFDckIsSUFBSSxDQUFDdy9CLGdCQUFnQixDQUFDdmpCLGFBQWFqYyxJQUFJO1lBQ3pDO1lBQ0EsSUFBSSxJQUFJLENBQUNsdEQsT0FBTyxDQUFDOHBGLElBQUksSUFBSSxJQUFJLENBQUN3QyxXQUFXLEVBQUU7Z0JBQ3pDLElBQUksQ0FBQ0EsV0FBVyxDQUFDcitCLGFBQWEsQ0FBQ2tiLGFBQWE5eUIsVUFBVTtZQUN4RDtRQUNGO1FBQ0EsSUFBSSxDQUFDNjFDLGlCQUFpQixHQUFHLENBQUNud0QsS0FBS20zQixPQUFPemtCLE1BQU13MUIsa0JBQW9CM2hELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQzlGLElBQUkrekQsSUFBSTJUO2dCQUNSLElBQUksSUFBSSxDQUFDeHZFLEtBQUssS0FBS28wQyxnQkFBZ0JnZixZQUFZLEVBQUU7b0JBQy9DLElBQUksQ0FBQzcyRSxHQUFHLENBQUM0RSxJQUFJLENBQUMsMkRBQTJELElBQUksQ0FBQ3UrQyxVQUFVO29CQUN4RiwySEFBMkg7b0JBQzNILElBQUksQ0FBQ3l5QyxjQUFjO2dCQUNyQixPQUFPO29CQUNMLDJDQUEyQztvQkFDM0MsSUFBSSxDQUFDQyxpQkFBaUI7Z0JBQ3hCO2dCQUNBLElBQUksQ0FBQ3ZXLEtBQUssSUFBSSxDQUFDN08saUJBQWlCLE1BQU0sUUFBUTZPLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3J6QixPQUFPLElBQUk7b0JBQ25GLElBQUksQ0FBQ3FMLE1BQU0sQ0FBQ2djLG9CQUFvQixDQUFDLElBQUksQ0FBQzdDLGlCQUFpQjtnQkFDekQ7Z0JBQ0EsSUFBSSxDQUFDcWxCLG1CQUFtQjtnQkFDeEIsSUFBSSxDQUFDQyxXQUFXLEdBQUd4M0YsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHd2lFLDRCQUE0QnJ6QjtnQkFDL0UsSUFBSSxJQUFJLENBQUNxK0MsV0FBVyxDQUFDM3RCLFNBQVMsRUFBRTtvQkFDOUIsSUFBSSxDQUFDOVEsTUFBTSxDQUFDOFEsU0FBUyxHQUFHLElBQUksQ0FBQzJ0QixXQUFXLENBQUMzdEIsU0FBUztnQkFDcEQ7Z0JBQ0EsSUFBSSxJQUFJLENBQUMydEIsV0FBVyxDQUFDOXFCLHFCQUFxQixFQUFFO29CQUMxQyxJQUFJLENBQUMzVCxNQUFNLENBQUMyVCxxQkFBcUIsR0FBRyxJQUFJLENBQUM4cUIsV0FBVyxDQUFDOXFCLHFCQUFxQjtnQkFDNUU7Z0JBQ0EsSUFBSTtvQkFDRixNQUFNbUgsZUFBZSxNQUFNLElBQUksQ0FBQ2tqQixhQUFhLENBQUN0d0QsS0FBS20zQixPQUFPLElBQUksQ0FBQzdFLE1BQU0sRUFBRSxJQUFJLENBQUN5K0IsV0FBVyxFQUFFLElBQUksQ0FBQzlzRixPQUFPLEVBQUVpa0U7b0JBQ3ZHLElBQUksQ0FBQ3VvQixpQkFBaUIsQ0FBQ3JqQjtvQkFDdkIscURBQXFEO29CQUNyRCxJQUFJLENBQUM0akIsMkJBQTJCO29CQUNoQyxJQUFJLENBQUN0bkUsSUFBSSxDQUFDbXFCLFVBQVVzZixlQUFlO2dCQUNyQyxFQUFFLE9BQU90cEMsS0FBSztvQkFDWixNQUFNLElBQUksQ0FBQ3lvQyxNQUFNLENBQUN4TyxLQUFLO29CQUN2QixJQUFJLENBQUM4c0MsY0FBYztvQkFDbkIsTUFBTUssaUJBQWlCLElBQUluK0MsZ0JBQWdCO29CQUMzQyxJQUFJanBCLGVBQWUzb0IsT0FBTzt3QkFDeEIrdkYsZUFBZWhzRixPQUFPLEdBQUcsR0FBR0QsTUFBTSxDQUFDaXNGLGVBQWVoc0YsT0FBTyxFQUFFLE1BQU1ELE1BQU0sQ0FBQzZrQixJQUFJNWtCLE9BQU87b0JBQ3JGO29CQUNBLElBQUk0a0IsZUFBZWlwQixpQkFBaUI7d0JBQ2xDbStDLGVBQWVsK0MsTUFBTSxHQUFHbHBCLElBQUlrcEIsTUFBTTt3QkFDbENrK0MsZUFBZWorQyxNQUFNLEdBQUducEIsSUFBSW1wQixNQUFNO29CQUNwQztvQkFDQSxJQUFJLENBQUNoNEMsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLCtDQUErQ3BELE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO3dCQUM5R3QyQixPQUFPZ0M7b0JBQ1Q7b0JBQ0EsTUFBTW9uRTtnQkFDUjtnQkFDQSxJQUFJL29CLGdCQUFnQkksTUFBTSxDQUFDdlEsT0FBTyxFQUFFO29CQUNsQyxNQUFNLElBQUksQ0FBQ3pGLE1BQU0sQ0FBQ3hPLEtBQUs7b0JBQ3ZCLElBQUksQ0FBQzhzQyxjQUFjO29CQUNuQixNQUFNLElBQUk5OUMsZ0JBQWdCO2dCQUM1QjtnQkFDQSxJQUFJO29CQUNGLE1BQU0sSUFBSSxDQUFDd2YsTUFBTSxDQUFDc2YsMEJBQTBCLENBQUMsSUFBSSxDQUFDbWYsV0FBVyxDQUFDOXFCLHFCQUFxQixFQUFFaUM7Z0JBQ3ZGLEVBQUUsT0FBTzl1RSxHQUFHO29CQUNWLE1BQU0sSUFBSSxDQUFDazVELE1BQU0sQ0FBQ3hPLEtBQUs7b0JBQ3ZCLElBQUksQ0FBQzhzQyxjQUFjO29CQUNuQixNQUFNeDNGO2dCQUNSO2dCQUNBLHlCQUF5QjtnQkFDekIsSUFBSXNuRCxXQUFXLElBQUksQ0FBQ3o4QyxPQUFPLENBQUM0aEUscUJBQXFCLEVBQUU7b0JBQ2pELDRGQUE0RjtvQkFDNUYzckUsT0FBT3F5QixnQkFBZ0IsQ0FBQyxZQUFZLElBQUksQ0FBQzJrRSxXQUFXO29CQUNwRGgzRixPQUFPcXlCLGdCQUFnQixDQUFDLGdCQUFnQixJQUFJLENBQUMya0UsV0FBVztnQkFDMUQ7Z0JBQ0EsSUFBSXh3QyxTQUFTO29CQUNYaGpELFNBQVM2dUIsZ0JBQWdCLENBQUMsVUFBVSxJQUFJLENBQUMya0UsV0FBVztvQkFDbkRqRCxDQUFBQSxLQUFLN3lGLFVBQVVpMUIsWUFBWSxNQUFNLFFBQVE0OUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMWhFLGdCQUFnQixDQUFDLGdCQUFnQixJQUFJLENBQUM0a0Usa0JBQWtCO2dCQUNoSTtnQkFDQSxJQUFJLENBQUNuQix5QkFBeUIsQ0FBQ245QixnQkFBZ0JDLFNBQVM7Z0JBQ3hELElBQUksQ0FBQ3BwQyxJQUFJLENBQUNtcUIsVUFBVWlmLFNBQVM7Z0JBQzdCLElBQUksQ0FBQ3MrQiwyQkFBMkI7WUFDbEM7UUFDQTs7S0FFQyxHQUNELElBQUksQ0FBQ2ptQixVQUFVLEdBQUc7WUFDaEIsSUFBSWttQixhQUFhdDFGLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ3JGLE9BQU93cUIsVUFBVWtwRSxPQUFPLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ3RDLElBQUl2QixJQUFJQyxJQUFJQyxJQUFJQztnQkFDaEIsTUFBTW4rQixTQUFTLE1BQU0sSUFBSSxDQUFDNC9CLGNBQWMsQ0FBQ2xrQyxJQUFJO2dCQUM3QyxJQUFJO29CQUNGLElBQUksSUFBSSxDQUFDbnRDLEtBQUssS0FBS28wQyxnQkFBZ0J1WSxZQUFZLEVBQUU7d0JBQy9DLElBQUksQ0FBQ3B3RSxHQUFHLENBQUMyQixLQUFLLENBQUMsd0JBQXdCLElBQUksQ0FBQ3doRCxVQUFVO3dCQUN0RDtvQkFDRjtvQkFDQSxJQUFJLENBQUNuakQsR0FBRyxDQUFDNEUsSUFBSSxDQUFDLHdCQUF3QnJHLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVO29CQUN2RSxJQUFJLElBQUksQ0FBQzEvQixLQUFLLEtBQUtvMEMsZ0JBQWdCbzlCLFVBQVUsSUFBSSxJQUFJLENBQUN4eEUsS0FBSyxLQUFLbzBDLGdCQUFnQmdmLFlBQVksRUFBRTt3QkFDNUYsMENBQTBDO3dCQUMxQyxJQUFJLENBQUM3MkUsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyw0QkFBNEIsSUFBSSxDQUFDdzFCLFVBQVU7d0JBQ3hEK3ZDLENBQUFBLEtBQUssSUFBSSxDQUFDaG1CLGVBQWUsTUFBTSxRQUFRZ21CLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFiLEtBQUs7d0JBQ3pFLHFIQUFxSDt3QkFDcEg0YixDQUFBQSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDNEIsYUFBYSxNQUFNLFFBQVE1QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdwbkUsTUFBTSxNQUFNLFFBQVFxbkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMXpGLElBQUksQ0FBQ3l6RixJQUFJLElBQUlyN0MsZ0JBQWdCO3dCQUNySixJQUFJLENBQUNpOUMsYUFBYSxHQUFHM3pGO29CQUN2QjtvQkFDQSxhQUFhO29CQUNiLElBQUksQ0FBRSxFQUFDaXlGLEtBQUssSUFBSSxDQUFDLzdCLE1BQU0sTUFBTSxRQUFRKzdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzloQixNQUFNLENBQUM1VyxjQUFjLEdBQUc7d0JBQ3ZGLE1BQU0sSUFBSSxDQUFDckQsTUFBTSxDQUFDaWEsTUFBTSxDQUFDM1IsU0FBUztvQkFDcEM7b0JBQ0Esb0NBQW9DO29CQUNwQyxJQUFJLElBQUksQ0FBQ3RJLE1BQU0sRUFBRTt3QkFDZixNQUFNLElBQUksQ0FBQ0EsTUFBTSxDQUFDeE8sS0FBSztvQkFDekI7b0JBQ0EsSUFBSSxDQUFDbW5CLGdCQUFnQixDQUFDb21CLFlBQVk3MEUsaUJBQWlCcStDLGdCQUFnQjtvQkFDbkUsY0FBYyxHQUNkLElBQUksQ0FBQ3ZJLE1BQU0sR0FBR2wyRDtnQkFDaEIsU0FBVTtvQkFDUjh6RDtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNnaEMsV0FBVyxHQUFHLElBQU0zcUUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDdkQsTUFBTSxJQUFJLENBQUM0a0QsVUFBVTtZQUN2QjtRQUNBOzs7Ozs7S0FNQyxHQUNELElBQUksQ0FBQ21tQixVQUFVLEdBQUcsSUFBTS9xRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUN0RCxNQUFNZ3JFLFdBQVcsRUFBRTtnQkFDbkIsTUFBTWp2RSxVQUFVb3lCO2dCQUNoQixJQUFJcHlCLFdBQVdBLFFBQVFILEVBQUUsS0FBSyxPQUFPO29CQUNuQzs7Ozs7OztTQU9DLEdBQ0QsTUFBTXF2RSxVQUFVO29CQUNoQixJQUFJQyxlQUFlL3pGLFNBQVNnMEYsY0FBYyxDQUFDRjtvQkFDM0MsSUFBSSxDQUFDQyxjQUFjO3dCQUNqQkEsZUFBZS96RixTQUFTcWhELGFBQWEsQ0FBQzt3QkFDdEMweUMsYUFBYWxpRSxFQUFFLEdBQUdpaUU7d0JBQ2xCQyxhQUFhendDLFFBQVEsR0FBRzt3QkFDeEJ5d0MsYUFBYXR6RSxNQUFNLEdBQUc7d0JBQ3RCLE1BQU11UixRQUFRbTZCO3dCQUNkbjZCLE1BQU0vUixPQUFPLEdBQUc7d0JBQ2hCLE1BQU0wQyxTQUFTLElBQUltVSxZQUFZOzRCQUFDOUU7eUJBQU07d0JBQ3RDK2hFLGFBQWF2eUMsU0FBUyxHQUFHNytCO3dCQUN6QjNpQixTQUFTNnVCLGdCQUFnQixDQUFDLG9CQUFvQjs0QkFDNUMsSUFBSSxDQUFDa2xFLGNBQWM7Z0NBQ2pCOzRCQUNGOzRCQUNBLG9HQUFvRzs0QkFDcEdBLGFBQWF2eUMsU0FBUyxHQUFHeGhELFNBQVN5Z0IsTUFBTSxHQUFHLE9BQU9rQzt3QkFDcEQ7d0JBQ0EzaUIsU0FBU2kwRixJQUFJLENBQUNDLE1BQU0sQ0FBQ0g7d0JBQ3JCLElBQUksQ0FBQzFvRSxJQUFJLENBQUM4cUIsVUFBVXUzQixZQUFZLEVBQUU7NEJBQ2hDcW1CLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYTlnQyxNQUFNO3dCQUNqRjtvQkFDRjtvQkFDQTRnQyxTQUFTcHVGLElBQUksQ0FBQ3N1RjtnQkFDaEI7Z0JBQ0EsSUFBSSxDQUFDaDNDLFlBQVksQ0FBQ3RoRCxPQUFPLENBQUM0YixDQUFBQTtvQkFDeEJBLEVBQUUrdUUsV0FBVyxDQUFDM3FGLE9BQU8sQ0FBQ2dKLENBQUFBO3dCQUNwQixJQUFJQSxFQUFFdXRCLEtBQUssRUFBRTs0QkFDWHZ0QixFQUFFdXRCLEtBQUssQ0FBQzB0QixnQkFBZ0IsQ0FBQ2prRCxPQUFPLENBQUNDLENBQUFBO2dDQUMvQm00RixTQUFTcHVGLElBQUksQ0FBQy9KOzRCQUNoQjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJO29CQUNGLE1BQU0wdEIsUUFBUWpPLEdBQUcsQ0FBQzt3QkFBQyxJQUFJLENBQUNpNEUsbUJBQW1COzJCQUFPUyxTQUFTcHhGLEdBQUcsQ0FBQy9HLENBQUFBOzRCQUM3REEsRUFBRXNtQixLQUFLLEdBQUc7NEJBQ1YsT0FBT3RtQixFQUFFaW1ELElBQUk7d0JBQ2Y7cUJBQUc7b0JBQ0gsSUFBSSxDQUFDd3lDLDBCQUEwQjtnQkFDakMsRUFBRSxPQUFPaG9FLEtBQUs7b0JBQ1osSUFBSSxDQUFDaW9FLHlCQUF5QixDQUFDam9FO29CQUMvQixNQUFNQTtnQkFDUjtZQUNGO1FBQ0EsSUFBSSxDQUFDa29FLFVBQVUsR0FBRyxJQUFNeHJFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ3RELE1BQU1nckUsV0FBVyxFQUFFO2dCQUNuQixLQUFLLE1BQU14OEUsS0FBSyxJQUFJLENBQUMwbEMsWUFBWSxDQUFDbjRDLE1BQU0sR0FBSTtvQkFDMUN5UyxFQUFFZ3ZFLFdBQVcsQ0FBQzVxRixPQUFPLENBQUNpbUQsQ0FBQUE7d0JBQ3BCLElBQUl6NUM7d0JBQ0hBLENBQUFBLEtBQUt5NUMsR0FBRzF2QixLQUFLLE1BQU0sUUFBUS9wQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd5M0MsZ0JBQWdCLENBQUNqa0QsT0FBTyxDQUFDMjFELENBQUFBOzRCQUMvRSxJQUFJLENBQUN5aUMsU0FBU3YvRCxRQUFRLENBQUM4OEIsS0FBSztnQ0FDMUJ5aUMsU0FBU3B1RixJQUFJLENBQUMyckQ7NEJBQ2hCO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLE1BQU1ob0MsUUFBUWpPLEdBQUcsQ0FBQzA0RSxTQUFTcHhGLEdBQUcsQ0FBQzJ1RCxDQUFBQSxLQUFNQSxHQUFHelAsSUFBSSxLQUFLaDRCLElBQUksQ0FBQztvQkFDcEQsSUFBSSxDQUFDMnFFLDBCQUEwQjtnQkFDakMsR0FBR3YwRCxLQUFLLENBQUNya0MsQ0FBQUE7b0JBQ1AsSUFBSUEsRUFBRTJELElBQUksS0FBSyxtQkFBbUI7d0JBQ2hDLElBQUksQ0FBQ2sxRix5QkFBeUI7b0JBQ2hDLE9BQU87d0JBQ0wsSUFBSSxDQUFDajNGLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsc0dBQXNHLElBQUksQ0FBQ3cxQixVQUFVO29CQUNySTtnQkFDRjtZQUNGO1FBQ0EsSUFBSSxDQUFDK3pDLGdCQUFnQixHQUFHO1lBQ3RCLElBQUksQ0FBQ0Msd0JBQXdCO1lBQzdCLDZEQUE2RDtZQUM3RCxLQUFLLE1BQU1wOUUsS0FBSyxJQUFJLENBQUMwbEMsWUFBWSxDQUFDbjRDLE1BQU0sR0FBSTtnQkFDMUMsSUFBSSxDQUFDOHZGLDZCQUE2QixDQUFDcjlFLEVBQUU4SCxHQUFHLEVBQUU5SDtZQUM1QztZQUNBLElBQUksSUFBSSxDQUFDaTdFLHlCQUF5QixDQUFDbjlCLGdCQUFnQmdmLFlBQVksR0FBRztnQkFDaEUsSUFBSSxDQUFDbm9ELElBQUksQ0FBQ21xQixVQUFVZytCLFlBQVk7WUFDbEM7UUFDRjtRQUNBLElBQUksQ0FBQ3dnQixxQkFBcUIsR0FBR2psQixDQUFBQSxlQUFnQjdtRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUMzRSxJQUFJLENBQUN2ckIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLHdDQUF3Q3FJLE1BQU0sQ0FBQ29vRSxhQUFhanpCLFlBQVksR0FBRzVnRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztvQkFDMUlwL0IsUUFBUXF1RCxhQUFhanpCLFlBQVk7Z0JBQ25DO2dCQUNBLElBQUksQ0FBQ200QyxxQkFBcUIsR0FBRyxFQUFFO2dCQUMvQixJQUFJLENBQUM3QixpQkFBaUIsQ0FBQ3JqQjtnQkFDdkIsSUFBSTtvQkFDRiwrQkFBK0I7b0JBQy9CLE1BQU0sSUFBSSxDQUFDaGMsZ0JBQWdCLENBQUNpN0Isa0JBQWtCLENBQUNqd0YsV0FBVztnQkFDNUQsRUFBRSxPQUFPeXJCLE9BQU87b0JBQ2QsSUFBSSxDQUFDN3NCLEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsd0RBQXdEdHVCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO3dCQUN2SHQyQjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJO29CQUNGLE1BQU0sSUFBSSxDQUFDeXFDLE1BQU0sQ0FBQ3VaLGdCQUFnQjtvQkFDbEMsSUFBSSxDQUFDN3dFLEdBQUcsQ0FBQzJCLEtBQUssQ0FBQywrQkFBK0JwRCxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRzt3QkFDOUZwL0IsUUFBUXF1RCxhQUFhanpCLFlBQVk7b0JBQ25DO2dCQUNGLEVBQUUsT0FBT280QyxJQUFJO29CQUNYLG1GQUFtRjtvQkFDbkY7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDdkMseUJBQXlCLENBQUNuOUIsZ0JBQWdCQyxTQUFTO2dCQUN4RCxJQUFJLENBQUNwcEMsSUFBSSxDQUFDbXFCLFVBQVUyK0MsV0FBVztnQkFDL0IsSUFBSSxDQUFDcEIsMkJBQTJCO2dCQUNoQyw2RUFBNkU7Z0JBQzdFLElBQUksQ0FBQzMyQyxZQUFZLENBQUN0aEQsT0FBTyxDQUFDbTRELENBQUFBO29CQUN4QixJQUFJLENBQUM1bkMsSUFBSSxDQUFDbXFCLFVBQVU0K0Msb0JBQW9CLEVBQUVuaEM7Z0JBQzVDO1lBQ0Y7UUFDQSxJQUFJLENBQUNvL0Isd0JBQXdCLEdBQUdnQyxDQUFBQTtZQUM5Qix1REFBdUQ7WUFDdkRBLGlCQUFpQnY1RixPQUFPLENBQUN5RyxDQUFBQTtnQkFDdkIsSUFBSUEsS0FBSzRlLFFBQVEsS0FBSyxJQUFJLENBQUM0eUMsZ0JBQWdCLENBQUM1eUMsUUFBUSxFQUFFO29CQUNwRCxJQUFJLENBQUM0eUMsZ0JBQWdCLENBQUNxeEIsVUFBVSxDQUFDN2lGO29CQUNqQztnQkFDRjtnQkFDQSxrQ0FBa0M7Z0JBQ2xDLE1BQU1pZCxNQUFNLElBQUksQ0FBQzgxRSxhQUFhLENBQUM5NEYsR0FBRyxDQUFDK0YsS0FBSzRlLFFBQVE7Z0JBQ2hELElBQUkzQixPQUFPQSxRQUFRamQsS0FBS2lkLEdBQUcsRUFBRTtvQkFDM0IsdURBQXVEO29CQUN2RCxJQUFJLENBQUN1MUUsNkJBQTZCLENBQUN2MUUsS0FBSyxJQUFJLENBQUM0OUIsWUFBWSxDQUFDNWdELEdBQUcsQ0FBQ2dqQjtnQkFDaEU7Z0JBQ0EsSUFBSSsxRSxvQkFBb0IsSUFBSSxDQUFDbjRDLFlBQVksQ0FBQzVnRCxHQUFHLENBQUMrRixLQUFLaWQsR0FBRztnQkFDdEQsTUFBTWcyRSxtQkFBbUIsQ0FBQ0Q7Z0JBQzFCLHVDQUF1QztnQkFDdkMsSUFBSWh6RixLQUFLNmUsS0FBSyxLQUFLQyxzQkFBc0JtM0MsWUFBWSxFQUFFO29CQUNyRCxJQUFJLENBQUN1OEIsNkJBQTZCLENBQUN4eUYsS0FBS2lkLEdBQUcsRUFBRSsxRTtnQkFDL0MsT0FBTztvQkFDTCxzQ0FBc0M7b0JBQ3RDQSxvQkFBb0IsSUFBSSxDQUFDRSxzQkFBc0IsQ0FBQ2x6RixLQUFLaWQsR0FBRyxFQUFFamQ7b0JBQzFELElBQUksQ0FBQ2l6RixrQkFBa0I7d0JBQ3JCLHlCQUF5Qjt3QkFDekJELGtCQUFrQm5RLFVBQVUsQ0FBQzdpRjtvQkFDL0I7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0Esa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ216RiwwQkFBMEIsR0FBR2h5RSxDQUFBQTtZQUNoQyxNQUFNMnVFLGlCQUFpQixFQUFFO1lBQ3pCLE1BQU1zRCxXQUFXLENBQUM7WUFDbEJqeUUsU0FBUzVuQixPQUFPLENBQUM4NUYsQ0FBQUE7Z0JBQ2ZELFFBQVEsQ0FBQ0MsUUFBUXAyRSxHQUFHLENBQUMsR0FBRztnQkFDeEIsSUFBSW8yRSxRQUFRcDJFLEdBQUcsS0FBSyxJQUFJLENBQUN1MEMsZ0JBQWdCLENBQUN2MEMsR0FBRyxFQUFFO29CQUM3QyxJQUFJLENBQUN1MEMsZ0JBQWdCLENBQUN1eUIsVUFBVSxHQUFHc1AsUUFBUTMyRixLQUFLO29CQUNoRCxJQUFJLENBQUM4MEQsZ0JBQWdCLENBQUM4ekIsYUFBYSxDQUFDO29CQUNwQ3dLLGVBQWV2c0YsSUFBSSxDQUFDLElBQUksQ0FBQ2l1RCxnQkFBZ0I7Z0JBQzNDLE9BQU87b0JBQ0wsTUFBTXI4QyxJQUFJLElBQUksQ0FBQzBsQyxZQUFZLENBQUM1Z0QsR0FBRyxDQUFDbzVGLFFBQVFwMkUsR0FBRztvQkFDM0MsSUFBSTlILEdBQUc7d0JBQ0xBLEVBQUU0dUUsVUFBVSxHQUFHc1AsUUFBUTMyRixLQUFLO3dCQUM1QnlZLEVBQUVtd0UsYUFBYSxDQUFDO3dCQUNoQndLLGVBQWV2c0YsSUFBSSxDQUFDNFI7b0JBQ3RCO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJLENBQUNpK0UsUUFBUSxDQUFDLElBQUksQ0FBQzVoQyxnQkFBZ0IsQ0FBQ3YwQyxHQUFHLENBQUMsRUFBRTtnQkFDeEMsSUFBSSxDQUFDdTBDLGdCQUFnQixDQUFDdXlCLFVBQVUsR0FBRztnQkFDbkMsSUFBSSxDQUFDdnlCLGdCQUFnQixDQUFDOHpCLGFBQWEsQ0FBQztZQUN0QztZQUNBLElBQUksQ0FBQ3pxQyxZQUFZLENBQUN0aEQsT0FBTyxDQUFDNGIsQ0FBQUE7Z0JBQ3hCLElBQUksQ0FBQ2krRSxRQUFRLENBQUNqK0UsRUFBRThILEdBQUcsQ0FBQyxFQUFFO29CQUNwQjlILEVBQUU0dUUsVUFBVSxHQUFHO29CQUNmNXVFLEVBQUVtd0UsYUFBYSxDQUFDO2dCQUNsQjtZQUNGO1lBQ0EsSUFBSSxDQUFDd0ssY0FBYyxHQUFHQTtZQUN0QixJQUFJLENBQUN3RCxpQkFBaUIsQ0FBQ3IvQyxVQUFVcy9DLHFCQUFxQixFQUFFekQ7UUFDMUQ7UUFDQSxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDMEQscUJBQXFCLEdBQUdDLENBQUFBO1lBQzNCLE1BQU1DLGVBQWUsSUFBSTFsRTtZQUN6QixJQUFJLENBQUM4aEUsY0FBYyxDQUFDdjJGLE9BQU8sQ0FBQzRiLENBQUFBO2dCQUMxQnUrRSxhQUFhaG5GLEdBQUcsQ0FBQ3lJLEVBQUU4SCxHQUFHLEVBQUU5SDtZQUMxQjtZQUNBcytFLGVBQWVsNkYsT0FBTyxDQUFDODVGLENBQUFBO2dCQUNyQixJQUFJbCtFLElBQUksSUFBSSxDQUFDMGxDLFlBQVksQ0FBQzVnRCxHQUFHLENBQUNvNUYsUUFBUXAyRSxHQUFHO2dCQUN6QyxJQUFJbzJFLFFBQVFwMkUsR0FBRyxLQUFLLElBQUksQ0FBQ3UwQyxnQkFBZ0IsQ0FBQ3YwQyxHQUFHLEVBQUU7b0JBQzdDOUgsSUFBSSxJQUFJLENBQUNxOEMsZ0JBQWdCO2dCQUMzQjtnQkFDQSxJQUFJLENBQUNyOEMsR0FBRztvQkFDTjtnQkFDRjtnQkFDQUEsRUFBRTR1RSxVQUFVLEdBQUdzUCxRQUFRMzJGLEtBQUs7Z0JBQzVCeVksRUFBRW13RSxhQUFhLENBQUMrTixRQUFRaHlFLE1BQU07Z0JBQzlCLElBQUlneUUsUUFBUWh5RSxNQUFNLEVBQUU7b0JBQ2xCcXlFLGFBQWFobkYsR0FBRyxDQUFDMm1GLFFBQVFwMkUsR0FBRyxFQUFFOUg7Z0JBQ2hDLE9BQU87b0JBQ0x1K0UsYUFBYXZsRSxNQUFNLENBQUNrbEUsUUFBUXAyRSxHQUFHO2dCQUNqQztZQUNGO1lBQ0EsTUFBTTZ5RSxpQkFBaUJyMkYsTUFBTWc1QyxJQUFJLENBQUNpaEQsYUFBYWh4RixNQUFNO1lBQ3JEb3RGLGVBQWUzMkUsSUFBSSxDQUFDLENBQUNwUyxHQUFHQyxJQUFNQSxFQUFFKzhFLFVBQVUsR0FBR2g5RSxFQUFFZzlFLFVBQVU7WUFDekQsSUFBSSxDQUFDK0wsY0FBYyxHQUFHQTtZQUN0QixJQUFJLENBQUN3RCxpQkFBaUIsQ0FBQ3IvQyxVQUFVcy9DLHFCQUFxQixFQUFFekQ7UUFDMUQ7UUFDQSxJQUFJLENBQUM2RCx1QkFBdUIsR0FBR0MsQ0FBQUE7WUFDN0JBLGtCQUFrQmo0QyxZQUFZLENBQUNwaUQsT0FBTyxDQUFDbWtELENBQUFBO2dCQUNyQyxNQUFNZ1UsY0FBYyxJQUFJLENBQUM3VyxZQUFZLENBQUM1Z0QsR0FBRyxDQUFDeWpELFlBQVlwOEIsY0FBYztnQkFDcEUsSUFBSSxDQUFDb3dDLGFBQWE7b0JBQ2hCO2dCQUNGO2dCQUNBLE1BQU1xQixNQUFNckIsWUFBWTAzQixtQkFBbUIsQ0FBQzFyQyxZQUFZOUMsUUFBUTtnQkFDaEUsSUFBSSxDQUFDbVksT0FBTyxDQUFDQSxJQUFJampDLEtBQUssRUFBRTtvQkFDdEI7Z0JBQ0Y7Z0JBQ0FpakMsSUFBSWpqQyxLQUFLLENBQUM0dEIsV0FBVyxHQUFHTCxNQUFNa0Ysb0JBQW9CLENBQUM3RSxZQUFZNytCLEtBQUs7Z0JBQ3BFNnlDLFlBQVk1bkMsSUFBSSxDQUFDb3FCLGlCQUFpQjIvQyx1QkFBdUIsRUFBRTlnQyxLQUFLQSxJQUFJampDLEtBQUssQ0FBQzR0QixXQUFXO2dCQUNyRixJQUFJLENBQUM0MUMsaUJBQWlCLENBQUNyL0MsVUFBVTQvQyx1QkFBdUIsRUFBRTlnQyxLQUFLQSxJQUFJampDLEtBQUssQ0FBQzR0QixXQUFXLEVBQUVnVTtZQUN4RjtRQUNGO1FBQ0EsSUFBSSxDQUFDb2lDLGtDQUFrQyxHQUFHOW1CLENBQUFBO1lBQ3hDLE1BQU10YixjQUFjLElBQUksQ0FBQzdXLFlBQVksQ0FBQzVnRCxHQUFHLENBQUMreUUsT0FBTzFyRCxjQUFjO1lBQy9ELElBQUksQ0FBQ293QyxhQUFhO2dCQUNoQjtZQUNGO1lBQ0EsTUFBTXFCLE1BQU1yQixZQUFZMDNCLG1CQUFtQixDQUFDcGMsT0FBT3B5QixRQUFRO1lBQzNELElBQUksQ0FBQ21ZLEtBQUs7Z0JBQ1I7WUFDRjtZQUNBQSxJQUFJKzBCLFVBQVUsQ0FBQzlhLE9BQU8zd0IsT0FBTztRQUMvQjtRQUNBLElBQUksQ0FBQzAzQyx1QkFBdUIsR0FBRy9tQixDQUFBQTtZQUM3QixNQUFNdGIsY0FBY2o0RCxNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUNvSSxZQUFZLENBQUNuNEMsTUFBTSxJQUFJMlAsSUFBSSxDQUFDOEMsQ0FBQUEsSUFBS0EsRUFBRTZKLE1BQU0sQ0FBQzNFLEdBQUcsQ0FBQzJ5RCxPQUFPcHlCLFFBQVE7WUFDakcsSUFBSSxDQUFDOFcsYUFBYTtnQkFDaEI7WUFDRjtZQUNBLE1BQU1xQixNQUFNckIsWUFBWTAzQixtQkFBbUIsQ0FBQ3BjLE9BQU9weUIsUUFBUTtZQUMzRCxJQUFJLENBQUNtWSxLQUFLO2dCQUNSO1lBQ0Y7WUFDQUEsSUFBSWcxQixvQkFBb0IsQ0FBQy9hLE9BQU8vaUQsR0FBRztRQUNyQztRQUNBLElBQUksQ0FBQytwRSxnQkFBZ0IsR0FBRyxDQUFDQyxZQUFZdmhGO1lBQ25DLHVCQUF1QjtZQUN2QixNQUFNZy9DLGNBQWMsSUFBSSxDQUFDN1csWUFBWSxDQUFDNWdELEdBQUcsQ0FBQ2c2RixXQUFXM3lFLGNBQWM7WUFDbkUsSUFBSSxDQUFDd0ksSUFBSSxDQUFDbXFCLFVBQVVpZ0QsWUFBWSxFQUFFRCxXQUFXenlFLE9BQU8sRUFBRWt3QyxhQUFhaC9DLE1BQU11aEYsV0FBV3pFLEtBQUs7WUFDekYsK0JBQStCO1lBQy9COTlCLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWTVuQyxJQUFJLENBQUNvcUIsaUJBQWlCZ2dELFlBQVksRUFBRUQsV0FBV3p5RSxPQUFPLEVBQUU5TztRQUNoSTtRQUNBLElBQUksQ0FBQ3UvRSwwQkFBMEIsR0FBRztZQUNoQyxJQUFJLElBQUksQ0FBQ2tDLGdCQUFnQixFQUFFO2dCQUN6QjtZQUNGO1lBQ0EsSUFBSSxDQUFDcEUsWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ2ptRSxJQUFJLENBQUNtcUIsVUFBVW1nRCwwQkFBMEIsRUFBRTtRQUNsRDtRQUNBLElBQUksQ0FBQ2xDLHlCQUF5QixHQUFHMTRGLENBQUFBO1lBQy9CLElBQUksQ0FBQzRCLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsNEJBQTRCcHZCLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM0NkMsVUFBVSxHQUFHO2dCQUMxRnQyQixPQUFPenVCO1lBQ1Q7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDMjZGLGdCQUFnQixFQUFFO2dCQUMxQjtZQUNGO1lBQ0EsSUFBSSxDQUFDcEUsWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ2ptRSxJQUFJLENBQUNtcUIsVUFBVW1nRCwwQkFBMEIsRUFBRTtRQUNsRDtRQUNBLElBQUksQ0FBQ2hDLDBCQUEwQixHQUFHO1lBQ2hDLElBQUksSUFBSSxDQUFDcEMsc0JBQXNCLEVBQUU7Z0JBQy9CLElBQUksQ0FBQ0Esc0JBQXNCLEdBQUc7Z0JBQzlCLElBQUksQ0FBQ2xtRSxJQUFJLENBQUNtcUIsVUFBVW9nRCwwQkFBMEIsRUFBRTtZQUNsRDtRQUNGO1FBQ0EsSUFBSSxDQUFDaEMseUJBQXlCLEdBQUc7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ3JDLHNCQUFzQixFQUFFO2dCQUNoQyxJQUFJLENBQUNBLHNCQUFzQixHQUFHO2dCQUM5QixJQUFJLENBQUNsbUUsSUFBSSxDQUFDbXFCLFVBQVVvZ0QsMEJBQTBCLEVBQUU7WUFDbEQ7UUFDRjtRQUNBLElBQUksQ0FBQzlDLGtCQUFrQixHQUFHLElBQU01cUUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDOUQsSUFBSSxDQUFDbUQsSUFBSSxDQUFDbXFCLFVBQVVxZ0QsbUJBQW1CO1lBQ3pDO1FBQ0EsSUFBSSxDQUFDdkQsZ0JBQWdCLEdBQUd4L0IsQ0FBQUE7WUFDdEIsTUFBTWdqQyxVQUFVLElBQUksQ0FBQ0MsUUFBUTtZQUM3QixJQUFJLENBQUNBLFFBQVEsR0FBR2pqQztZQUNoQixJQUFJZ2pDLFdBQVdBLFFBQVFoM0UsUUFBUSxLQUFLZzBDLEtBQUtoMEMsUUFBUSxFQUFFO2dCQUNqRCxJQUFJLENBQUMrMUUsaUJBQWlCLENBQUNyL0MsVUFBVXdnRCxtQkFBbUIsRUFBRWxqQyxLQUFLaDBDLFFBQVE7WUFDckU7WUFDQSxJQUFJLENBQUNnM0UsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE3MkUsZUFBZSxNQUFNNnpDLEtBQUs3ekMsZUFBZSxFQUFFO2dCQUN4RyxJQUFJLENBQUM0MUUsaUJBQWlCLENBQUNyL0MsVUFBVXlnRCxzQkFBc0IsRUFBRW5qQyxLQUFLN3pDLGVBQWU7WUFDL0U7UUFDRjtRQUNBLElBQUksQ0FBQ2kzRSw2QkFBNkIsR0FBRzNuQixDQUFBQTtZQUNuQ0EsT0FBT3h4QixPQUFPLENBQUNqaUQsT0FBTyxDQUFDeUcsQ0FBQUE7Z0JBQ3JCLElBQUlBLEtBQUtzaEIsY0FBYyxLQUFLLElBQUksQ0FBQ2t3QyxnQkFBZ0IsQ0FBQ3YwQyxHQUFHLEVBQUU7b0JBQ3JELElBQUksQ0FBQ3UwQyxnQkFBZ0IsQ0FBQ2swQixvQkFBb0IsQ0FBQzFsRixLQUFLMGdCLE9BQU87b0JBQ3ZEO2dCQUNGO2dCQUNBLE1BQU1neEMsY0FBYyxJQUFJLENBQUM3VyxZQUFZLENBQUM1Z0QsR0FBRyxDQUFDK0YsS0FBS3NoQixjQUFjO2dCQUM3RCxJQUFJb3dDLGFBQWE7b0JBQ2ZBLFlBQVlnMEIsb0JBQW9CLENBQUMxbEYsS0FBSzBnQixPQUFPO2dCQUMvQztZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNrMEUsaUNBQWlDLEdBQUdyM0UsQ0FBQUE7WUFDdkMsSUFBSSxDQUFDdU0sSUFBSSxDQUFDbXFCLFVBQVVpeEMsMEJBQTBCLEVBQUUzbkUsVUFBVSxJQUFJLENBQUNpMEMsZ0JBQWdCO1FBQ2pGO1FBQ0EsSUFBSSxDQUFDcWpDLDZCQUE2QixHQUFHMTNGLENBQUFBO1lBQ25DLElBQUksQ0FBQzJzQixJQUFJLENBQUNtcUIsVUFBVWt4QyxzQkFBc0IsRUFBRWhvRixNQUFNLElBQUksQ0FBQ3EwRCxnQkFBZ0I7UUFDekU7UUFDQSxJQUFJLENBQUNzakMsaUJBQWlCLEdBQUcvaEMsQ0FBQUE7WUFDdkIsSUFBSSxDQUFDanBDLElBQUksQ0FBQ21xQixVQUFVNnhDLFVBQVUsRUFBRS95QixLQUFLLElBQUksQ0FBQ3ZCLGdCQUFnQjtRQUM1RDtRQUNBLElBQUksQ0FBQ3VqQyxtQkFBbUIsR0FBR2hpQyxDQUFBQTtZQUN6QixJQUFJLENBQUNqcEMsSUFBSSxDQUFDbXFCLFVBQVU4eEMsWUFBWSxFQUFFaHpCLEtBQUssSUFBSSxDQUFDdkIsZ0JBQWdCO1FBQzlEO1FBQ0EsSUFBSSxDQUFDaUYscUJBQXFCLEdBQUcxRCxDQUFBQSxNQUFPcHNDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ2xFLElBQUlxdUU7Z0JBQ0osSUFBSSxDQUFDbHJFLElBQUksQ0FBQ21xQixVQUFVd2YsbUJBQW1CLEVBQUVWLEtBQUssSUFBSSxDQUFDdkIsZ0JBQWdCO2dCQUNuRSxJQUFJdUIsSUFBSWpqQyxLQUFLLFlBQVlrbEQsaUJBQWlCO29CQUN4QyxNQUFNYyxnQkFBZ0IsTUFBTS9pQixJQUFJampDLEtBQUssQ0FBQ3NsRCxlQUFlO29CQUNyRCxJQUFJVSxlQUFlO3dCQUNqQixJQUFJLENBQUNoc0QsSUFBSSxDQUFDbXFCLFVBQVVnaEQseUJBQXlCLEVBQUVsaUM7b0JBQ2pEO2dCQUNGO2dCQUNBLE1BQU0xZ0MsV0FBVyxNQUFNLENBQUMyaUUsS0FBS2ppQyxJQUFJampDLEtBQUssTUFBTSxRQUFRa2xFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3RsQyxXQUFXO2dCQUMzRixNQUFNbytCLGFBQWExcEMsYUFBYTJPLElBQUloN0MsTUFBTTtnQkFDMUMsSUFBSSsxRSxjQUFjejdELFlBQVlBLGFBQWEsSUFBSSxDQUFDbS9CLGdCQUFnQixDQUFDbTZCLGVBQWUsQ0FBQzF4RixHQUFHLENBQUM2ekYsYUFBYTtvQkFDaEcsSUFBSSxDQUFDdDhCLGdCQUFnQixDQUFDbTZCLGVBQWUsQ0FBQ2ovRSxHQUFHLENBQUNvaEYsWUFBWXo3RDtvQkFDdEQsSUFBSSxDQUFDdkksSUFBSSxDQUFDbXFCLFVBQVVpaEQsbUJBQW1CLEVBQUVwSCxZQUFZejdEO2dCQUN2RDtZQUNGO1FBQ0EsSUFBSSxDQUFDcWtDLHVCQUF1QixHQUFHM0QsQ0FBQUE7WUFDN0IsSUFBSSxDQUFDanBDLElBQUksQ0FBQ21xQixVQUFVbzdCLHFCQUFxQixFQUFFdGMsS0FBSyxJQUFJLENBQUN2QixnQkFBZ0I7UUFDdkU7UUFDQSxJQUFJLENBQUMyakMsK0JBQStCLEdBQUd6MEUsQ0FBQUE7WUFDckMsSUFBSSxDQUFDb0osSUFBSSxDQUFDbXFCLFVBQVUyeEMsd0JBQXdCLEVBQUVsbEUsU0FBUyxJQUFJLENBQUM4d0MsZ0JBQWdCO1FBQzlFO1FBQ0EsSUFBSSxDQUFDNGpDLG1CQUFtQixHQUFHNTdGLENBQUFBO1lBQ3pCLElBQUksQ0FBQ3N3QixJQUFJLENBQUNtcUIsVUFBVWc1QyxpQkFBaUIsRUFBRXp6RjtRQUN6QztRQUNBLElBQUksQ0FBQzY3RixvQ0FBb0MsR0FBR2pRLENBQUFBO1lBQzFDLElBQUksQ0FBQ3Q3RCxJQUFJLENBQUNtcUIsVUFBVW94Qyw2QkFBNkIsRUFBRUQsaUJBQWlCLElBQUksQ0FBQzV6QixnQkFBZ0I7UUFDM0Y7UUFDQSxJQUFJLENBQUM5bkMsZUFBZSxDQUFDO1FBQ3JCLElBQUksQ0FBQ214QixZQUFZLEdBQUcsSUFBSTdzQjtRQUN4QixJQUFJLENBQUMwa0UscUJBQXFCLEdBQUcsRUFBRTtRQUMvQixJQUFJLENBQUNLLGFBQWEsR0FBRyxJQUFJL2tFO1FBQ3pCLElBQUksQ0FBQzNwQixPQUFPLEdBQUcxSyxPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUdraUUscUJBQXFCeGhFO1FBQ3BFLElBQUksQ0FBQ2pKLEdBQUcsR0FBR2tFLFVBQVUsQ0FBQ3lHLEtBQUssSUFBSSxDQUFDMUIsT0FBTyxDQUFDMUgsVUFBVSxNQUFNLFFBQVFvSixPQUFPLEtBQUssSUFBSUEsS0FBS2pHLFlBQVlrZCxJQUFJO1FBQ3JHLElBQUksQ0FBQzNZLE9BQU8sQ0FBQytvRixvQkFBb0IsR0FBR3p6RixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUdnL0MsZ0JBQWdCdCtDLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRK29GLG9CQUFvQjtRQUNsSyxJQUFJLENBQUMvb0YsT0FBTyxDQUFDZ3BGLG9CQUFvQixHQUFHMXpGLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBR2kvQyxnQkFBZ0J2K0MsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFncEYsb0JBQW9CO1FBQ2xLLElBQUksQ0FBQ2hwRixPQUFPLENBQUMyZ0UsZUFBZSxHQUFHcnJFLE9BQU9nSyxNQUFNLENBQUNoSyxPQUFPZ0ssTUFBTSxDQUFDLENBQUMsR0FBR3FoRSxrQkFBa0IzZ0UsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVEyZ0UsZUFBZTtRQUMxSixJQUFJLENBQUNpc0IsaUJBQWlCO1FBQ3RCLElBQUksQ0FBQ2YsY0FBYyxHQUFHLElBQUl0a0M7UUFDMUIsSUFBSSxDQUFDNEYsZ0JBQWdCLEdBQUcsSUFBSXk0QixpQkFBaUIsSUFBSSxJQUFJLElBQUksQ0FBQ3YzQixNQUFNLEVBQUUsSUFBSSxDQUFDcnVELE9BQU87UUFDOUUsSUFBSSxJQUFJLENBQUNBLE9BQU8sQ0FBQ2dwRixvQkFBb0IsQ0FBQ2g3RCxRQUFRLEVBQUU7WUFDOUMsSUFBSSxDQUFDbS9CLGdCQUFnQixDQUFDbTZCLGVBQWUsQ0FBQ2ovRSxHQUFHLENBQUMsY0FBYzQvQyxpQkFBaUIsSUFBSSxDQUFDam9ELE9BQU8sQ0FBQ2dwRixvQkFBb0IsQ0FBQ2g3RCxRQUFRO1FBQ3JIO1FBQ0EsSUFBSSxJQUFJLENBQUNodUIsT0FBTyxDQUFDK29GLG9CQUFvQixDQUFDLzZELFFBQVEsRUFBRTtZQUM5QyxJQUFJLENBQUNtL0IsZ0JBQWdCLENBQUNtNkIsZUFBZSxDQUFDai9FLEdBQUcsQ0FBQyxjQUFjNC9DLGlCQUFpQixJQUFJLENBQUNqb0QsT0FBTyxDQUFDK29GLG9CQUFvQixDQUFDLzZELFFBQVE7UUFDckg7UUFDQSxJQUFJLENBQUN4WCxLQUFLLElBQUksQ0FBQ3hXLE9BQU8sQ0FBQ2k0RSxXQUFXLE1BQU0sUUFBUXpoRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3WCxRQUFRLEVBQUU7WUFDcEYsSUFBSSxDQUFDaWpFLGtCQUFrQixDQUFDLGVBQWVocEMsaUJBQWlCLElBQUksQ0FBQ2pvRCxPQUFPLENBQUNpNEUsV0FBVyxDQUFDanFELFFBQVEsR0FBR3dMLEtBQUssQ0FBQ3JrQyxDQUFBQSxJQUFLLElBQUksQ0FBQzRCLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsK0JBQStCM2pCLE1BQU0sQ0FBQzVMLEVBQUU2TCxPQUFPLEdBQUcsSUFBSSxDQUFDazVDLFVBQVU7UUFDeEw7UUFDQSxJQUFJLElBQUksQ0FBQ2w2QyxPQUFPLENBQUM4cEYsSUFBSSxFQUFFO1lBQ3JCLElBQUksQ0FBQ29ILFNBQVM7UUFDaEI7SUFDRjtJQUNBOztHQUVDLEdBQ0RoSixlQUFleHVFLE9BQU8sRUFBRTtRQUN0QixPQUFPNEksVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLElBQUksQ0FBQ2dxRSxXQUFXLEVBQUU7Z0JBQ3BCLE1BQU16cEUsUUFBUWpPLEdBQUcsQ0FBQztvQkFBQyxJQUFJLENBQUN1NEMsZ0JBQWdCLENBQUMrNkIsY0FBYyxDQUFDeHVFO2lCQUFTO2dCQUNqRSxJQUFJLElBQUksQ0FBQ3l6QyxnQkFBZ0IsQ0FBQzV5QyxRQUFRLEtBQUssSUFBSTtvQkFDekMsSUFBSSxDQUFDK3hFLFdBQVcsQ0FBQ3YrQiw0QkFBNEIsQ0FBQ3IwQyxTQUFTLElBQUksQ0FBQ3l6QyxnQkFBZ0IsQ0FBQzV5QyxRQUFRO2dCQUN2RjtZQUNGLE9BQU87Z0JBQ0wsTUFBTXRkLE1BQU07WUFDZDtRQUNGO0lBQ0Y7SUFDQWkwRixZQUFZO1FBQ1YsSUFBSXh2RjtRQUNKLElBQUksSUFBSSxDQUFDMUIsT0FBTyxDQUFDOHBGLElBQUksRUFBRTtZQUNyQixJQUFJLENBQUN3QyxXQUFXLEdBQUcsSUFBSTMvQixZQUFZLElBQUksQ0FBQzNzRCxPQUFPLENBQUM4cEYsSUFBSTtZQUNwRCxJQUFJLENBQUN3QyxXQUFXLENBQUM1bEUsRUFBRSxDQUFDdWtCLGdCQUFnQm1pQixrQ0FBa0MsRUFBRSxDQUFDMXpDLFNBQVMyekM7Z0JBQ2hGLElBQUlBLHVCQUF1QnU0QixrQkFBa0I7b0JBQzNDLElBQUksQ0FBQ3oyQixhQUFhLEdBQUd6MUM7Z0JBQ3ZCO2dCQUNBLElBQUksQ0FBQytMLElBQUksQ0FBQ21xQixVQUFVd2Qsa0NBQWtDLEVBQUUxekMsU0FBUzJ6QztZQUNuRTtZQUNBLElBQUksQ0FBQ2kvQixXQUFXLENBQUM1bEUsRUFBRSxDQUFDdWtCLGdCQUFnQjZoQixlQUFlLEVBQUVscEMsQ0FBQUEsUUFBUyxJQUFJLENBQUM2QixJQUFJLENBQUNtcUIsVUFBVWtkLGVBQWUsRUFBRWxwQztZQUNsR2xpQixDQUFBQSxLQUFLLElBQUksQ0FBQzRxRixXQUFXLE1BQU0sUUFBUTVxRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrckQsS0FBSyxDQUFDLElBQUk7UUFDNUU7SUFDRjtJQUNBLElBQUl2VCxhQUFhO1FBQ2YsT0FBTztZQUNMZ1QsTUFBTSxJQUFJLENBQUNwMEQsSUFBSTtZQUNma3dFLFNBQVMsSUFBSSxDQUFDcHdELEdBQUc7WUFDakIyQixVQUFVLElBQUksQ0FBQzR5QyxnQkFBZ0IsQ0FBQzV5QyxRQUFRO1FBQzFDO0lBQ0Y7SUFDQTs7SUFFRSxHQUNGLElBQUk0MkUsY0FBYztRQUNoQixJQUFJenZGLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUN5dUYsUUFBUSxNQUFNLFFBQVF6dUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMlgsZUFBZSxNQUFNLFFBQVE3QyxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUM5SDtJQUNBLG1DQUFtQyxHQUNuQyxJQUFJb0MsTUFBTTtRQUNSLElBQUlsWCxJQUFJOFU7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDeXVGLFFBQVEsTUFBTSxRQUFRenVGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tYLEdBQUcsTUFBTSxRQUFRcEMsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDbEg7SUFDQSwrQ0FBK0MsR0FDL0MsSUFBSTFkLE9BQU87UUFDVCxJQUFJNEksSUFBSThVO1FBQ1IsT0FBTyxDQUFDQSxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQ3l1RixRQUFRLE1BQU0sUUFBUXp1RixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc1SSxJQUFJLE1BQU0sUUFBUTBkLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ25IO0lBQ0Esa0JBQWtCLEdBQ2xCLElBQUkwQyxXQUFXO1FBQ2IsSUFBSXhYO1FBQ0osT0FBTyxDQUFDQSxLQUFLLElBQUksQ0FBQ3l1RixRQUFRLE1BQU0sUUFBUXp1RixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3WCxRQUFRO0lBQzlFO0lBQ0EsSUFBSUMsa0JBQWtCO1FBQ3BCLElBQUl6WCxJQUFJOFU7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDeXVGLFFBQVEsTUFBTSxRQUFRenVGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3lYLGVBQWUsTUFBTSxRQUFRM0MsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDOUg7SUFDQSxJQUFJNEMsZ0JBQWdCO1FBQ2xCLElBQUkxWCxJQUFJOFU7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQzlVLEtBQUssSUFBSSxDQUFDeXVGLFFBQVEsTUFBTSxRQUFRenVGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBYLGFBQWEsTUFBTSxRQUFRNUMsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDNUg7SUFDQW8yRSxvQkFBb0I7UUFDbEIsSUFBSSxJQUFJLENBQUN2K0IsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQSxNQUFNLENBQUM2VyxRQUFRLEVBQUU7WUFDeEM7UUFDRjtRQUNBLElBQUksQ0FBQzdXLE1BQU0sR0FBRyxJQUFJNFcsVUFBVSxJQUFJLENBQUNqbEUsT0FBTztRQUN4QyxJQUFJLENBQUNxdUQsTUFBTSxDQUFDM25DLEVBQUUsQ0FBQ29wQixZQUFZZ0YsaUJBQWlCLEVBQUUsSUFBSSxDQUFDMjNDLHdCQUF3QixFQUFFL2xFLEVBQUUsQ0FBQ29wQixZQUFZbUYsVUFBVSxFQUFFLElBQUksQ0FBQ3kzQyxnQkFBZ0IsRUFBRWhtRSxFQUFFLENBQUNvcEIsWUFBWWtGLGVBQWUsRUFBRSxJQUFJLENBQUNtNkMscUJBQXFCLEVBQUV6b0UsRUFBRSxDQUFDb3BCLFlBQVk4NEIsa0JBQWtCLEVBQUUsSUFBSSxDQUFDMG1CLHVCQUF1QixFQUFFNW9FLEVBQUUsQ0FBQ29wQixZQUFZb0YsdUJBQXVCLEVBQUUsSUFBSSxDQUFDbzdDLDZCQUE2QixFQUFFNXBFLEVBQUUsQ0FBQ29wQixZQUFZcjNCLGlCQUFpQixFQUFFLElBQUksQ0FBQ2kzRSx1QkFBdUIsRUFBRWhwRSxFQUFFLENBQUNvcEIsWUFBWXVGLDRCQUE0QixFQUFFLElBQUksQ0FBQ282QyxrQ0FBa0MsRUFBRS9vRSxFQUFFLENBQUNvcEIsWUFBWWc3QixlQUFlLEVBQUUsQ0FBQzd4QixZQUFZNzhCLFFBQVE4SDtZQUNqaEIsSUFBSSxDQUFDa3RFLFlBQVksQ0FBQ240QyxZQUFZNzhCLFFBQVE4SDtRQUN4QyxHQUFHd0MsRUFBRSxDQUFDb3BCLFlBQVlxM0IsWUFBWSxFQUFFcjRCLENBQUFBO1lBQzlCLElBQUksQ0FBQ2s0QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNobkUsT0FBTyxDQUFDMGhFLHlCQUF5QixFQUFFNXlCO1FBQ2hFLEdBQUdwb0IsRUFBRSxDQUFDb3BCLFlBQVl3MkIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDd29CLDBCQUEwQixFQUFFcG9FLEVBQUUsQ0FBQ29wQixZQUFZeTJCLGtCQUFrQixFQUFFLElBQUksQ0FBQ29wQixnQkFBZ0IsRUFBRWpwRSxFQUFFLENBQUNvcEIsWUFBWTA5QixRQUFRLEVBQUU7WUFDMUosSUFBSSxDQUFDMGdCLHdCQUF3QjtZQUM3QixJQUFJLElBQUksQ0FBQ25DLHlCQUF5QixDQUFDbjlCLGdCQUFnQmdmLFlBQVksR0FBRztnQkFDaEUsSUFBSSxDQUFDbm9ELElBQUksQ0FBQ21xQixVQUFVZytCLFlBQVk7WUFDbEM7WUFDQSxJQUFJLENBQUN5Z0IscUJBQXFCLEdBQUdqNUYsTUFBTWc1QyxJQUFJLENBQUMsSUFBSSxDQUFDb0ksWUFBWSxDQUFDamhELElBQUk7UUFDaEUsR0FBR214QixFQUFFLENBQUNvcEIsWUFBWTQ5QixPQUFPLEVBQUU7WUFDekIsSUFBSSxDQUFDcWUseUJBQXlCLENBQUNuOUIsZ0JBQWdCQyxTQUFTO1lBQ3hELElBQUksQ0FBQ3BwQyxJQUFJLENBQUNtcUIsVUFBVTIrQyxXQUFXO1lBQy9CLElBQUksQ0FBQ3BCLDJCQUEyQjtZQUNoQyxJQUFJLENBQUNrRSxtQkFBbUI7WUFDeEIscUdBQXFHO1lBQ3JHLE1BQU1DLG1CQUFtQmw4RixNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUNvSSxZQUFZLENBQUNuNEMsTUFBTSxJQUFJdkMsTUFBTSxDQUFDZ1YsQ0FBQUEsSUFBSyxDQUFDLElBQUksQ0FBQ3U5RSxxQkFBcUIsQ0FBQ3RnRSxRQUFRLENBQUNqZCxFQUFFOEgsR0FBRztZQUN0SDA0RSxpQkFBaUJwOEYsT0FBTyxDQUFDNGIsQ0FBQUEsSUFBSyxJQUFJLENBQUMyVSxJQUFJLENBQUNtcUIsVUFBVTQrQyxvQkFBb0IsRUFBRTE5RTtZQUN4RSxJQUFJLENBQUN1OUUscUJBQXFCLEdBQUcsRUFBRTtRQUNqQyxHQUFHM25FLEVBQUUsQ0FBQ29wQixZQUFZMjlCLGFBQWEsRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQ2p6RCxLQUFLLEtBQUtvMEMsZ0JBQWdCZ2YsWUFBWSxFQUFFO2dCQUMvQyxJQUFJLENBQUN2WCxhQUFhO1lBQ3BCO1FBQ0YsR0FBRzN2QyxFQUFFLENBQUNvcEIsWUFBWW85QixVQUFVLEVBQUUsSUFBSSxDQUFDK2dCLGdCQUFnQixFQUFFdm5FLEVBQUUsQ0FBQ29wQixZQUFZcTlCLGVBQWUsRUFBRSxJQUFJLENBQUNpaEIscUJBQXFCLEVBQUUxbkUsRUFBRSxDQUFDb3BCLFlBQVltNEIscUJBQXFCLEVBQUUsQ0FBQ2w1QixRQUFRMWdDO1lBQzlKLElBQUksQ0FBQ29YLElBQUksQ0FBQ21xQixVQUFVcTRCLHFCQUFxQixFQUFFbDVCLFFBQVExZ0M7UUFDckQ7UUFDQSxJQUFJLElBQUksQ0FBQzgrQyxnQkFBZ0IsRUFBRTtZQUN6QixJQUFJLENBQUNBLGdCQUFnQixDQUFDaUIsV0FBVyxDQUFDLElBQUksQ0FBQ0MsTUFBTTtRQUMvQztRQUNBLElBQUksSUFBSSxDQUFDaStCLFdBQVcsRUFBRTtZQUNwQixJQUFJLENBQUNBLFdBQVcsQ0FBQ2wrQixXQUFXLENBQUMsSUFBSSxDQUFDQyxNQUFNO1FBQzFDO0lBQ0Y7SUFDQTs7Ozs7OztHQU9DLEdBQ0QsT0FBT2tqQyxnQkFBZ0JsakYsSUFBSSxFQUFFO1FBQzNCLElBQUlvNkMscUJBQXFCM3dELFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzdGLE9BQU91d0QsY0FBY0MsV0FBVyxHQUFHRSxVQUFVLENBQUNuNkMsTUFBTW82QztJQUN0RDtJQUNBOzs7Ozs7OztHQVFDLEdBQ0Qrb0Msa0JBQWtCejFELEdBQUcsRUFBRW0zQixLQUFLLEVBQUU7UUFDNUIsT0FBTzV3QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDOUgsS0FBSyxLQUFLbzBDLGdCQUFnQnVZLFlBQVksRUFBRTtnQkFDL0M7WUFDRjtZQUNBLElBQUksQ0FBQ3B3RSxHQUFHLENBQUMyQixLQUFLLENBQUMsd0JBQXdCcUksTUFBTSxDQUFDZzdCLE1BQU0sSUFBSSxDQUFDbWUsVUFBVTtZQUNuRSxJQUFJO2dCQUNGLElBQUk4SSxRQUFRLElBQUlzc0IsSUFBSXZ6QyxTQUFTbTNCLE9BQU87b0JBQ2xDLElBQUksQ0FBQ3NVLGlCQUFpQixHQUFHLElBQUkwSCxrQkFBa0JuekMsS0FBS20zQjtvQkFDcEQsTUFBTStaLFlBQVksTUFBTSxJQUFJLENBQUN6RixpQkFBaUIsQ0FBQytGLG9CQUFvQjtvQkFDbkUsc0VBQXNFO29CQUN0RSwyRUFBMkU7b0JBQzNFLElBQUlOLGFBQWEsSUFBSSxDQUFDenlELEtBQUssS0FBS28wQyxnQkFBZ0J1WSxZQUFZLEVBQUU7d0JBQzVELElBQUksQ0FBQzhGLFNBQVMsR0FBR0E7d0JBQ2pCLE1BQU01WSxNQUFNbE0sVUFBVThrQixZQUFZOzRCQUNoQ3YxRSxRQUFRO3dCQUNWO3dCQUNBLElBQUksQ0FBQ1gsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLDBCQUEwQnFJLE1BQU0sQ0FBQ2tzRSxZQUFZLElBQUksQ0FBQy95QixVQUFVO29CQUM3RTtnQkFDRixPQUFPO29CQUNMLE1BQU1tYSxNQUFNbE0sVUFBVXBzQixNQUFNO3dCQUMxQnJrQyxRQUFRO29CQUNWO2dCQUNGO1lBQ0YsRUFBRSxPQUFPdkMsR0FBRztnQkFDVixJQUFJLENBQUM0QixHQUFHLENBQUMydEIsSUFBSSxDQUFDLGdDQUFnQ3B2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztvQkFDOUZ0MkIsT0FBT3p1QjtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRG00RCx5QkFBeUIveUMsUUFBUSxFQUFFO1FBQ2pDLElBQUksSUFBSSxDQUFDNHlDLGdCQUFnQixDQUFDNXlDLFFBQVEsS0FBS0EsVUFBVTtZQUMvQyxPQUFPLElBQUksQ0FBQzR5QyxnQkFBZ0I7UUFDOUI7UUFDQSxNQUFNdjBDLE1BQU0sSUFBSSxDQUFDODFFLGFBQWEsQ0FBQzk0RixHQUFHLENBQUMya0I7UUFDbkMsSUFBSTNCLEtBQUs7WUFDUCxPQUFPLElBQUksQ0FBQzQ5QixZQUFZLENBQUM1Z0QsR0FBRyxDQUFDZ2pCO1FBQy9CO0lBQ0Y7SUFDQXd6RSx5QkFBeUI7UUFDdkIsSUFBSSxDQUFDTixhQUFhLEdBQUczekY7SUFDdkI7SUFDQTs7R0FFQyxHQUNEczVGLGlCQUFpQnI1QyxRQUFRLEVBQUU1NkMsR0FBRyxFQUFFO1FBQzlCLE9BQU84a0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJb3ZFLGFBQWEsS0FBTztZQUN4QixJQUFJcmdDO1lBQ0osT0FBUWpaO2dCQUNOLEtBQUs7b0JBQ0gsdUNBQXVDO29CQUN2QyxNQUFNLElBQUksQ0FBQ2lXLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQ3JULGFBQWEsQ0FBQztvQkFDdkM7Z0JBQ0YsS0FBSztvQkFDSDVELE1BQU0sSUFBSTVjLGlCQUFpQjt3QkFDekIyRCxVQUFVOzRCQUNSaHFDLE1BQU07NEJBQ05wUCxPQUFPO3dCQUNUO29CQUNGO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0hxeUQsTUFBTSxJQUFJNWMsaUJBQWlCO3dCQUN6QjJELFVBQVU7NEJBQ1JocUMsTUFBTTs0QkFDTnBQLE9BQU87d0JBQ1Q7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSHF5RCxNQUFNLElBQUk1YyxpQkFBaUI7d0JBQ3pCMkQsVUFBVTs0QkFDUmhxQyxNQUFNOzRCQUNOcFAsT0FBTzt3QkFDVDtvQkFDRjtvQkFDQTtnQkFDRixLQUFLO29CQUNIcXlELE1BQU0sSUFBSTVjLGlCQUFpQjt3QkFDekIyRCxVQUFVOzRCQUNSaHFDLE1BQU07NEJBQ05wUCxPQUFPO3dCQUNUO29CQUNGO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDcXZELE1BQU0sQ0FBQzJnQixRQUFRO29CQUNwQix1Q0FBdUM7b0JBQ3ZDLE1BQU0sSUFBSSxDQUFDM2dCLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQ3JULGFBQWEsQ0FBQztvQkFDdkM7Z0JBQ0YsS0FBSztvQkFDSHk4QixhQUFhLElBQU1wdkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDakQsdUNBQXVDOzRCQUN2QyxNQUFNLElBQUksQ0FBQytyQyxNQUFNLENBQUNpYSxNQUFNLENBQUNyVCxhQUFhLENBQUM7d0JBQ3pDO29CQUNBNUQsTUFBTSxJQUFJNWMsaUJBQWlCO3dCQUN6QjJELFVBQVU7NEJBQ1JocUMsTUFBTTs0QkFDTnBQLE9BQU87d0JBQ1Q7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSDB5RixhQUFhLElBQU1wdkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDakQsdUNBQXVDOzRCQUN2QyxNQUFNLElBQUksQ0FBQytyQyxNQUFNLENBQUNpYSxNQUFNLENBQUNyVCxhQUFhLENBQUM7d0JBQ3pDO29CQUNBNUQsTUFBTSxJQUFJNWMsaUJBQWlCO3dCQUN6QjJELFVBQVU7NEJBQ1JocUMsTUFBTTs0QkFDTnBQLE9BQU87d0JBQ1Q7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUNxdkQsTUFBTSxDQUFDK1csbUJBQW1CLEdBQUc7b0JBQ2xDLHVDQUF1QztvQkFDdkMsTUFBTSxJQUFJLENBQUMvVyxNQUFNLENBQUNpYSxNQUFNLENBQUNyVCxhQUFhLENBQUM7b0JBQ3ZDO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDVELE1BQU0sSUFBSTVjLGlCQUFpQjt3QkFDekIyRCxVQUFVOzRCQUNSaHFDLE1BQU07NEJBQ05wUCxPQUFPbzVDLGFBQWEsY0FBYyxJQUFJO3dCQUN4QztvQkFDRjtvQkFDQXM1QyxhQUFhLElBQU1wdkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzs0QkFDakQsTUFBTTZ2QyxVQUFVLElBQUksQ0FBQzlELE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQ25XLE9BQU87NEJBQzFDLElBQUlBLFNBQVM7Z0NBQ1hBLFFBQVEsSUFBSTlkLGFBQWE7b0NBQ3ZCdkYsUUFBUXYyQixpQkFBaUJxK0MsZ0JBQWdCO29DQUN6Qy9mLGNBQWM7Z0NBQ2hCOzRCQUNGO3dCQUNGO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSXI1QyxRQUFRckYsYUFBYSxPQUFPcUYsUUFBUSxVQUFVO3dCQUNoRCxNQUFNLElBQUlQLE1BQU07b0JBQ2xCO29CQUNBbzBELE1BQU0sSUFBSTVjLGlCQUFpQjt3QkFDekIyRCxVQUFVOzRCQUNSaHFDLE1BQU07NEJBQ05wUCxPQUFPb0gsT0FBTzVJO3dCQUNoQjtvQkFDRjtvQkFDQTtZQUNKO1lBQ0EsSUFBSTZ6RCxLQUFLO2dCQUNQLE1BQU0sSUFBSSxDQUFDaEQsTUFBTSxDQUFDaWEsTUFBTSxDQUFDN1Isb0JBQW9CLENBQUNwRjtnQkFDOUMsTUFBTXFnQztZQUNSO1FBQ0Y7SUFDRjtJQUNBOztHQUVDLEdBQ0QsSUFBSTVCLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ3BFLFlBQVk7SUFDMUI7SUFDQTs7R0FFQyxHQUNELElBQUlpRyxtQkFBbUI7UUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQ2hHLHNCQUFzQjtJQUNyQztJQUNBOzs7O0dBSUMsR0FDRGlHLDZCQUE2QjtRQUMzQixJQUFJbHdGLElBQUk4VTtRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDOVUsS0FBSyxJQUFJLENBQUMxQixPQUFPLENBQUNpNEUsV0FBVyxNQUFNLFFBQVF2MkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHc3NCLFFBQVEsTUFBTSxRQUFReFgsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDbEk7SUFDQXE3RSxnQkFBZ0J4akYsSUFBSSxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDOCtDLGdCQUFnQixDQUFDbTZCLGVBQWUsQ0FBQzF4RixHQUFHLENBQUN5WTtJQUNuRDtJQUNBOzs7Ozs7Ozs7R0FTQyxHQUNENGlGLG1CQUFtQjVpRixJQUFJLEVBQUUyZixRQUFRLEVBQUU7UUFDakMsSUFBSXRCLFFBQVE1MEIsVUFBVVUsTUFBTSxHQUFHLEtBQUtWLFNBQVMsQ0FBQyxFQUFFLEtBQUtLLFlBQVlMLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDaEYsSUFBSTRKLElBQUk4VTtRQUNSLElBQUlDO1FBQ0osT0FBTzZMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSTR1RCxtQkFBbUI7WUFDdkIsSUFBSTRnQixVQUFVO1lBQ2QsTUFBTUMsbUJBQW1CcmxFLFFBQVE7Z0JBQy9CQSxPQUFPc0I7WUFDVCxJQUFJQTtZQUNKLElBQUkzZixTQUFTLGNBQWM7Z0JBQ3pCLE1BQU0yakYsZUFBZSxJQUFJLENBQUNoeUYsT0FBTyxDQUFDK29GLG9CQUFvQixDQUFDLzZELFFBQVE7Z0JBQy9ELElBQUksQ0FBQ2h1QixPQUFPLENBQUMrb0Ysb0JBQW9CLENBQUMvNkQsUUFBUSxHQUFHK2pFO2dCQUM3QzdnQixtQkFBbUI4Z0IsaUJBQWlCRDtnQkFDcEMsTUFBTXAzRSxTQUFTdmxCLE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQytlLGdCQUFnQixDQUFDMHlCLFdBQVcsQ0FBQ3hoRixNQUFNLElBQUl2QyxNQUFNLENBQUMydkIsQ0FBQUEsUUFBU0EsTUFBTS9YLE1BQU0sS0FBS3NsQyxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTtnQkFDOUgsSUFBSTtvQkFDRm0wQyxVQUFVLENBQUMsTUFBTWp2RSxRQUFRak8sR0FBRyxDQUFDK0YsT0FBT3plLEdBQUcsQ0FBQ2dDLENBQUFBO3dCQUN0QyxJQUFJd0Q7d0JBQ0osT0FBTyxDQUFDQSxLQUFLeEQsRUFBRW9nRixVQUFVLE1BQU0sUUFBUTU4RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzdkUsV0FBVyxDQUFDK2dCO29CQUNqRixHQUFFLEVBQUcvOUUsS0FBSyxDQUFDNUUsQ0FBQUEsTUFBT0EsUUFBUTtnQkFDNUIsRUFBRSxPQUFPamEsR0FBRztvQkFDVixJQUFJLENBQUM2SyxPQUFPLENBQUMrb0Ysb0JBQW9CLENBQUMvNkQsUUFBUSxHQUFHZ2tFO29CQUM3QyxNQUFNNzhGO2dCQUNSO1lBQ0YsT0FBTyxJQUFJa1osU0FBUyxjQUFjO2dCQUNoQyxNQUFNMmpGLGVBQWUsSUFBSSxDQUFDaHlGLE9BQU8sQ0FBQ2dwRixvQkFBb0IsQ0FBQ2g3RCxRQUFRO2dCQUMvRCxJQUFJLENBQUNodUIsT0FBTyxDQUFDZ3BGLG9CQUFvQixDQUFDaDdELFFBQVEsR0FBRytqRTtnQkFDN0M3Z0IsbUJBQW1COGdCLGlCQUFpQkQ7Z0JBQ3BDLE1BQU1wM0UsU0FBU3ZsQixNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUMrZSxnQkFBZ0IsQ0FBQzJ5QixXQUFXLENBQUN6aEYsTUFBTSxJQUFJdkMsTUFBTSxDQUFDMnZCLENBQUFBLFFBQVNBLE1BQU0vWCxNQUFNLEtBQUtzbEMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU07Z0JBQzFILElBQUk7b0JBQ0ZxMEMsVUFBVSxDQUFDLE1BQU1qdkUsUUFBUWpPLEdBQUcsQ0FBQytGLE9BQU96ZSxHQUFHLENBQUNnQyxDQUFBQTt3QkFDdEMsSUFBSXdEO3dCQUNKLE9BQU8sQ0FBQ0EsS0FBS3hELEVBQUVxZ0YsVUFBVSxNQUFNLFFBQVE3OEUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHc3ZFLFdBQVcsQ0FBQytnQjtvQkFDakYsR0FBRSxFQUFHLzlFLEtBQUssQ0FBQzVFLENBQUFBLE1BQU9BLFFBQVE7Z0JBQzVCLEVBQUUsT0FBT2phLEdBQUc7b0JBQ1YsSUFBSSxDQUFDNkssT0FBTyxDQUFDZ3BGLG9CQUFvQixDQUFDaDdELFFBQVEsR0FBR2drRTtvQkFDN0MsTUFBTTc4RjtnQkFDUjtZQUNGLE9BQU8sSUFBSWtaLFNBQVMsZUFBZTtnQkFDakMsSUFBSSxDQUFDK3pDLHVCQUF1QixDQUFDLElBQUksQ0FBQ3BpRCxPQUFPLENBQUM2aEUsY0FBYyxJQUFJLElBQUksQ0FBQzdoRSxPQUFPLENBQUM2aEUsY0FBYyxJQUFJLElBQUksQ0FBQ2piLFlBQVksSUFBSSxDQUFFLGdCQUFlLElBQUksQ0FBQ0EsWUFBWSxHQUFHO29CQUNuSixNQUFNLElBQUkzcEQsTUFBTTtnQkFDbEI7Z0JBQ0N5RSxDQUFBQSxLQUFLLENBQUMrVSxLQUFLLElBQUksQ0FBQ3pXLE9BQU8sRUFBRWk0RSxXQUFXLE1BQU0sUUFBUXYyRSxPQUFPLEtBQUssSUFBSUEsS0FBSytVLEdBQUd3aEUsV0FBVyxHQUFHLENBQUM7Z0JBQzFGLE1BQU0rWixlQUFlLElBQUksQ0FBQ2h5RixPQUFPLENBQUNpNEUsV0FBVyxDQUFDanFELFFBQVE7Z0JBQ3RELElBQUksQ0FBQ2h1QixPQUFPLENBQUNpNEUsV0FBVyxDQUFDanFELFFBQVEsR0FBR0E7Z0JBQ3BDa2pELG1CQUFtQjhnQixpQkFBaUJEO2dCQUNwQyxJQUFJO29CQUNGLElBQUksSUFBSSxDQUFDL3hGLE9BQU8sQ0FBQzZoRSxjQUFjLEVBQUU7d0JBQy9CLCtFQUErRTt3QkFDOUVyckQsQ0FBQUEsS0FBSyxJQUFJLENBQUNvd0MsWUFBWSxNQUFNLFFBQVFwd0MsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb2lFLFNBQVMsQ0FBQzVxRDtvQkFDN0UsT0FBTzt3QkFDTCxNQUFNbkwsUUFBUWpPLEdBQUcsQ0FBQ3hmLE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQ29JLFlBQVksQ0FBQ240QyxNQUFNLElBQUluQyxHQUFHLENBQUM0VSxDQUFBQSxJQUFLQSxFQUFFNDBFLGNBQWMsQ0FBQztnQ0FDakYxM0Q7NEJBQ0Y7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPNzRCLEdBQUc7b0JBQ1YsSUFBSSxDQUFDNkssT0FBTyxDQUFDaTRFLFdBQVcsQ0FBQ2pxRCxRQUFRLEdBQUdna0U7b0JBQ3BDLE1BQU03OEY7Z0JBQ1I7WUFDRjtZQUNBLElBQUkrN0Usb0JBQW9CNGdCLFNBQVM7Z0JBQy9CLElBQUksQ0FBQzNrQyxnQkFBZ0IsQ0FBQ202QixlQUFlLENBQUNqL0UsR0FBRyxDQUFDZ0csTUFBTTJmO2dCQUNoRCxJQUFJLENBQUN2SSxJQUFJLENBQUNtcUIsVUFBVWloRCxtQkFBbUIsRUFBRXhpRixNQUFNMmY7WUFDakQ7WUFDQSxPQUFPOGpFO1FBQ1Q7SUFDRjtJQUNBL0UsOEJBQThCO1FBQzVCLElBQUksQ0FBQzUvQixnQkFBZ0IsQ0FBQ3ptQyxFQUFFLENBQUNtcEIsaUJBQWlCZ3hDLDBCQUEwQixFQUFFLElBQUksQ0FBQzBQLGlDQUFpQyxFQUFFN3BFLEVBQUUsQ0FBQ21wQixpQkFBaUJpeEMsc0JBQXNCLEVBQUUsSUFBSSxDQUFDMFAsNkJBQTZCLEVBQUU5cEUsRUFBRSxDQUFDbXBCLGlCQUFpQjR4QyxVQUFVLEVBQUUsSUFBSSxDQUFDZ1AsaUJBQWlCLEVBQUUvcEUsRUFBRSxDQUFDbXBCLGlCQUFpQjZ4QyxZQUFZLEVBQUUsSUFBSSxDQUFDZ1AsbUJBQW1CLEVBQUVocUUsRUFBRSxDQUFDbXBCLGlCQUFpQnVmLG1CQUFtQixFQUFFLElBQUksQ0FBQ2dELHFCQUFxQixFQUFFMXJDLEVBQUUsQ0FBQ21wQixpQkFBaUJtN0IscUJBQXFCLEVBQUUsSUFBSSxDQUFDM1ksdUJBQXVCLEVBQUUzckMsRUFBRSxDQUFDbXBCLGlCQUFpQjB4Qyx3QkFBd0IsRUFBRSxJQUFJLENBQUN1UCwrQkFBK0IsRUFBRXBxRSxFQUFFLENBQUNtcEIsaUJBQWlCKzRDLGlCQUFpQixFQUFFLElBQUksQ0FBQ21JLG1CQUFtQixFQUFFcnFFLEVBQUUsQ0FBQ21wQixpQkFBaUJvNUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDb0UsVUFBVSxFQUFFM21FLEVBQUUsQ0FBQ21wQixpQkFBaUJteEMsNkJBQTZCLEVBQUUsSUFBSSxDQUFDZ1Esb0NBQW9DO0lBQzd1QjtJQUNBckUsaUJBQWlCO1FBQ2YsSUFBSWpyRjtRQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQzJzRCxNQUFNLE1BQU0sUUFBUTNzRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtK0MsS0FBSztRQUNoRSxjQUFjLEdBQ2QsSUFBSSxDQUFDd08sTUFBTSxHQUFHbDJEO1FBQ2QsdUVBQXVFO1FBQ3ZFLGlCQUFpQjtRQUNqQixJQUFJLENBQUNxK0MsWUFBWSxDQUFDczBDLEtBQUs7UUFDdkIsSUFBSSxDQUFDOEIsaUJBQWlCO0lBQ3hCO0lBQ0F3RSxhQUFhbjRDLFVBQVUsRUFBRTc4QixNQUFNLEVBQUU4SCxRQUFRLEVBQUU7UUFDekMsMENBQTBDO1FBQzFDLDhFQUE4RTtRQUM5RSw4RUFBOEU7UUFDOUUsMEJBQTBCO1FBQzFCLHdGQUF3RjtRQUN4RixJQUFJLElBQUksQ0FBQzFKLEtBQUssS0FBS28wQyxnQkFBZ0JvOUIsVUFBVSxJQUFJLElBQUksQ0FBQ3h4RSxLQUFLLEtBQUtvMEMsZ0JBQWdCZ2YsWUFBWSxFQUFFO1lBQzVGLE1BQU1xa0IscUJBQXFCO2dCQUN6QixJQUFJLENBQUNiLFlBQVksQ0FBQ240QyxZQUFZNzhCLFFBQVE4SDtnQkFDdENvakM7WUFDRjtZQUNBLE1BQU1BLFVBQVU7Z0JBQ2QsSUFBSSxDQUFDaGdDLEdBQUcsQ0FBQ3NvQixVQUFVMitDLFdBQVcsRUFBRTBEO2dCQUNoQyxJQUFJLENBQUMzcUUsR0FBRyxDQUFDc29CLFVBQVVpZixTQUFTLEVBQUVvakM7Z0JBQzlCLElBQUksQ0FBQzNxRSxHQUFHLENBQUNzb0IsVUFBVXUzQixZQUFZLEVBQUU3ZjtZQUNuQztZQUNBLElBQUksQ0FBQ3hpQyxJQUFJLENBQUM4cUIsVUFBVTIrQyxXQUFXLEVBQUUwRDtZQUNqQyxJQUFJLENBQUNudEUsSUFBSSxDQUFDOHFCLFVBQVVpZixTQUFTLEVBQUVvakM7WUFDL0IsSUFBSSxDQUFDbnRFLElBQUksQ0FBQzhxQixVQUFVdTNCLFlBQVksRUFBRTdmO1lBQ2xDO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQzlzQyxLQUFLLEtBQUtvMEMsZ0JBQWdCdVksWUFBWSxFQUFFO1lBQy9DLElBQUksQ0FBQ3B3RSxHQUFHLENBQUMydEIsSUFBSSxDQUFDLG1EQUFtRCxJQUFJLENBQUN3MUIsVUFBVTtZQUNoRjtRQUNGO1FBQ0EsTUFBTTNjLFFBQVE4akIsZUFBZWpsQyxPQUFPa1AsRUFBRTtRQUN0QyxNQUFNaWtDLGdCQUFnQmh5QixLQUFLLENBQUMsRUFBRTtRQUM5QixJQUFJaEosV0FBV2dKLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLElBQUl2UixVQUFVaXRCLFdBQVczdEIsRUFBRTtRQUMzQixnSEFBZ0g7UUFDaEgscUVBQXFFO1FBQ3JFLElBQUlpSixZQUFZQSxTQUFTdDRCLFVBQVUsQ0FBQyxPQUFPK3ZCLFVBQVV1STtRQUNyRCxJQUFJZzdCLGtCQUFrQixJQUFJLENBQUNwQyxnQkFBZ0IsQ0FBQ3YwQyxHQUFHLEVBQUU7WUFDL0MsSUFBSSxDQUFDN2hCLEdBQUcsQ0FBQzJ0QixJQUFJLENBQUMsMkRBQTJELElBQUksQ0FBQ3cxQixVQUFVO1lBQ3hGO1FBQ0Y7UUFDQSxNQUFNbVQsY0FBYyxJQUFJLENBQUM3VyxZQUFZLENBQUM1Z0QsR0FBRyxDQUFDMjVEO1FBQzFDLElBQUksQ0FBQ2xDLGFBQWE7WUFDaEIsSUFBSSxDQUFDdDJELEdBQUcsQ0FBQzZzQixLQUFLLENBQUMsb0VBQW9FN2lCLE1BQU0sQ0FBQ3d1RCxnQkFBZ0IsSUFBSSxDQUFDclYsVUFBVTtZQUN6SDtRQUNGO1FBQ0EsSUFBSTgvQjtRQUNKLElBQUksSUFBSSxDQUFDaDZFLE9BQU8sQ0FBQ280RCxjQUFjLEVBQUU7WUFDL0IsSUFBSSxPQUFPLElBQUksQ0FBQ3A0RCxPQUFPLENBQUNvNEQsY0FBYyxLQUFLLFVBQVU7Z0JBQ25ENGhCLHlCQUF5QixJQUFJLENBQUNoNkUsT0FBTyxDQUFDbzRELGNBQWM7WUFDdEQsT0FBTztnQkFDTDRoQix5QkFBeUIsQ0FBQztZQUM1QjtRQUNGO1FBQ0Ezc0IsWUFBWXczQix1QkFBdUIsQ0FBQzVyQyxZQUFZanRCLFNBQVM1UCxRQUFROEgsVUFBVTgxRDtJQUM3RTtJQUNBaFQsbUJBQW1CO1FBQ2pCLElBQUlrckIsbUJBQW1CcDZGLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzNGLElBQUlnM0MsU0FBU2gzQyxVQUFVVSxNQUFNLEdBQUcsSUFBSVYsU0FBUyxDQUFDLEVBQUUsR0FBR0s7UUFDbkQsSUFBSXVKO1FBQ0osSUFBSSxDQUFDd3NGLHdCQUF3QjtRQUM3QixJQUFJLElBQUksQ0FBQzF6RSxLQUFLLEtBQUtvMEMsZ0JBQWdCdVksWUFBWSxFQUFFO1lBQy9DO1FBQ0Y7UUFDQSxJQUFJLENBQUM4RixTQUFTLEdBQUc5MEU7UUFDakIsSUFBSTtZQUNGLElBQUksQ0FBQ3ErQyxZQUFZLENBQUN0aEQsT0FBTyxDQUFDNGIsQ0FBQUE7Z0JBQ3hCQSxFQUFFNkosTUFBTSxDQUFDemxCLE9BQU8sQ0FBQ3c1RCxDQUFBQTtvQkFDZjU5QyxFQUFFeTBFLGNBQWMsQ0FBQzcyQixJQUFJblksUUFBUTtnQkFDL0I7WUFDRjtZQUNBLElBQUksQ0FBQzRXLGdCQUFnQixDQUFDeHlDLE1BQU0sQ0FBQ3psQixPQUFPLENBQUN3NUQsQ0FBQUE7Z0JBQ25DLElBQUlodEQsSUFBSThVO2dCQUNSLElBQUlrNEMsSUFBSWpqQyxLQUFLLEVBQUU7b0JBQ2IsSUFBSSxDQUFDMGhDLGdCQUFnQixDQUFDbzRCLGNBQWMsQ0FBQzcyQixJQUFJampDLEtBQUssRUFBRXltRTtnQkFDbEQ7Z0JBQ0EsSUFBSUEsa0JBQWtCO29CQUNuQnh3RixDQUFBQSxLQUFLZ3RELElBQUlqakMsS0FBSyxNQUFNLFFBQVEvcEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZzZDLE1BQU07b0JBQzlEbGxDLENBQUFBLEtBQUtrNEMsSUFBSWpqQyxLQUFLLE1BQU0sUUFBUWpWLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2daLElBQUk7Z0JBQy9EO1lBQ0Y7WUFDQSxJQUFJLENBQUMyOUIsZ0JBQWdCLENBQUM3bEMsR0FBRyxDQUFDdW9CLGlCQUFpQmd4QywwQkFBMEIsRUFBRSxJQUFJLENBQUMwUCxpQ0FBaUMsRUFBRWpwRSxHQUFHLENBQUN1b0IsaUJBQWlCaXhDLHNCQUFzQixFQUFFLElBQUksQ0FBQzBQLDZCQUE2QixFQUFFbHBFLEdBQUcsQ0FBQ3VvQixpQkFBaUI0eEMsVUFBVSxFQUFFLElBQUksQ0FBQ2dQLGlCQUFpQixFQUFFbnBFLEdBQUcsQ0FBQ3VvQixpQkFBaUI2eEMsWUFBWSxFQUFFLElBQUksQ0FBQ2dQLG1CQUFtQixFQUFFcHBFLEdBQUcsQ0FBQ3VvQixpQkFBaUJ1ZixtQkFBbUIsRUFBRSxJQUFJLENBQUNnRCxxQkFBcUIsRUFBRTlxQyxHQUFHLENBQUN1b0IsaUJBQWlCbTdCLHFCQUFxQixFQUFFLElBQUksQ0FBQzNZLHVCQUF1QixFQUFFL3FDLEdBQUcsQ0FBQ3VvQixpQkFBaUIweEMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDdVAsK0JBQStCLEVBQUV4cEUsR0FBRyxDQUFDdW9CLGlCQUFpQis0QyxpQkFBaUIsRUFBRSxJQUFJLENBQUNtSSxtQkFBbUIsRUFBRXpwRSxHQUFHLENBQUN1b0IsaUJBQWlCbzVDLG1CQUFtQixFQUFFLElBQUksQ0FBQ29FLFVBQVUsRUFBRS9sRSxHQUFHLENBQUN1b0IsaUJBQWlCbXhDLDZCQUE2QixFQUFFLElBQUksQ0FBQ2dRLG9DQUFvQztZQUNydkIsSUFBSSxDQUFDN2pDLGdCQUFnQixDQUFDeHlDLE1BQU0sQ0FBQ213RSxLQUFLO1lBQ2xDLElBQUksQ0FBQzM5QixnQkFBZ0IsQ0FBQzJ5QixXQUFXLENBQUNnTCxLQUFLO1lBQ3ZDLElBQUksQ0FBQzM5QixnQkFBZ0IsQ0FBQzB5QixXQUFXLENBQUNpTCxLQUFLO1lBQ3ZDLElBQUksQ0FBQ3QwQyxZQUFZLENBQUNzMEMsS0FBSztZQUN2QixJQUFJLENBQUNXLGNBQWMsR0FBRyxFQUFFO1lBQ3hCLElBQUksSUFBSSxDQUFDN2tDLFlBQVksSUFBSSxPQUFPLElBQUksQ0FBQzVtRCxPQUFPLENBQUM2aEUsY0FBYyxLQUFLLFdBQVc7Z0JBQ3pFLElBQUksQ0FBQ2piLFlBQVksQ0FBQy9HLEtBQUs7Z0JBQ3ZCLElBQUksQ0FBQytHLFlBQVksR0FBR3p1RDtZQUN0QjtZQUNBLElBQUlza0QsU0FBUztnQkFDWHhtRCxPQUFPdXlCLG1CQUFtQixDQUFDLGdCQUFnQixJQUFJLENBQUN5a0UsV0FBVztnQkFDM0RoM0YsT0FBT3V5QixtQkFBbUIsQ0FBQyxZQUFZLElBQUksQ0FBQ3lrRSxXQUFXO2dCQUN2RGgzRixPQUFPdXlCLG1CQUFtQixDQUFDLFVBQVUsSUFBSSxDQUFDeWtFLFdBQVc7Z0JBQ3BEdnJGLENBQUFBLEtBQUt2SyxVQUFVaTFCLFlBQVksTUFBTSxRQUFRMXFCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhtQixtQkFBbUIsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDMGtFLGtCQUFrQjtZQUNuSTtRQUNGLFNBQVU7WUFDUixJQUFJLENBQUNuQix5QkFBeUIsQ0FBQ245QixnQkFBZ0J1WSxZQUFZO1lBQzNELElBQUksQ0FBQzFoRCxJQUFJLENBQUNtcUIsVUFBVXUzQixZQUFZLEVBQUVyNEI7UUFDcEM7SUFDRjtJQUNBcS9DLDhCQUE4QnYxRSxHQUFHLEVBQUV5MEMsV0FBVyxFQUFFO1FBQzlDLHdCQUF3QjtRQUN4QixJQUFJLENBQUM3VyxZQUFZLENBQUMxc0IsTUFBTSxDQUFDbFI7UUFDekIsSUFBSSxDQUFDeTBDLGFBQWE7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQ3FoQyxhQUFhLENBQUM1a0UsTUFBTSxDQUFDdWpDLFlBQVk5eUMsUUFBUTtRQUM5Qzh5QyxZQUFZMXlDLE1BQU0sQ0FBQ3psQixPQUFPLENBQUNtNkQsQ0FBQUE7WUFDekJoQyxZQUFZazRCLGNBQWMsQ0FBQ2wyQixZQUFZOVksUUFBUSxFQUFFO1FBQ25EO1FBQ0EsSUFBSSxDQUFDOXdCLElBQUksQ0FBQ21xQixVQUFVdWlELHVCQUF1QixFQUFFOWtDO0lBQy9DO0lBQ0F3L0Isc0JBQXNCO1FBQ3BCLElBQUluckYsSUFBSThVO1FBQ1IsT0FBTzhMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxPQUFPLElBQUksQ0FBQ3RpQixPQUFPLENBQUM2aEUsY0FBYyxLQUFLLGFBQWEsSUFBSSxDQUFDN2hFLE9BQU8sQ0FBQzZoRSxjQUFjLENBQUNqYixZQUFZLEVBQUU7Z0JBQ2hHLHVFQUF1RTtnQkFDdkUsSUFBSSxDQUFDQSxZQUFZLEdBQUcsSUFBSSxDQUFDNW1ELE9BQU8sQ0FBQzZoRSxjQUFjLENBQUNqYixZQUFZO1lBQzlELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ0EsWUFBWSxJQUFJLElBQUksQ0FBQ0EsWUFBWSxDQUFDcHNDLEtBQUssS0FBSyxVQUFVO2dCQUNyRSw2REFBNkQ7Z0JBQzdELHNHQUFzRztnQkFDdEcsSUFBSSxDQUFDb3NDLFlBQVksR0FBRyxDQUFDbGxELEtBQUtzOUMsb0JBQW1CLE1BQU8sUUFBUXQ5QyxPQUFPLEtBQUssSUFBSUEsS0FBS3ZKO1lBQ25GO1lBQ0EsSUFBSSxJQUFJLENBQUN5dUQsWUFBWSxJQUFJLElBQUksQ0FBQ0EsWUFBWSxDQUFDcHNDLEtBQUssS0FBSyxhQUFhO2dCQUNoRSx1RUFBdUU7Z0JBQ3ZFLDZHQUE2RztnQkFDN0csSUFBSTtvQkFDRixNQUFNLElBQUksQ0FBQ29zQyxZQUFZLENBQUMweUIsTUFBTTtnQkFDaEMsRUFBRSxPQUFPbmtGLEdBQUc7b0JBQ1YsSUFBSSxDQUFDNEIsR0FBRyxDQUFDMnRCLElBQUksQ0FBQyxrQ0FBa0NwdkIsT0FBT2dLLE1BQU0sQ0FBQ2hLLE9BQU9nSyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzQ2QyxVQUFVLEdBQUc7d0JBQ2hHdDJCLE9BQU96dUI7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksSUFBSSxDQUFDNkssT0FBTyxDQUFDNmhFLGNBQWMsRUFBRTtnQkFDL0IsSUFBSSxDQUFDcnJCLFlBQVksQ0FBQ3RoRCxPQUFPLENBQUNtNEQsQ0FBQUEsY0FBZUEsWUFBWStqQixlQUFlLENBQUMsSUFBSSxDQUFDeHFCLFlBQVk7WUFDeEY7WUFDQSxJQUFJLENBQUN1RyxnQkFBZ0IsQ0FBQ2lrQixlQUFlLENBQUMsSUFBSSxDQUFDeHFCLFlBQVk7WUFDdkQsTUFBTXdyQyxzQkFBc0IsQ0FBQyxDQUFDNTdFLEtBQUssSUFBSSxDQUFDb3dDLFlBQVksTUFBTSxRQUFRcHdDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dFLEtBQUssTUFBTTtZQUN6RyxJQUFJNDNFLHdCQUF3QixJQUFJLENBQUN0QyxnQkFBZ0IsRUFBRTtnQkFDakQsSUFBSSxDQUFDcEUsWUFBWSxHQUFHMEc7Z0JBQ3BCLElBQUksQ0FBQzNzRSxJQUFJLENBQUNtcUIsVUFBVW1nRCwwQkFBMEIsRUFBRXFDO1lBQ2xEO1FBQ0Y7SUFDRjtJQUNBQyxrQkFBa0IvbUUsRUFBRSxFQUFFM3ZCLElBQUksRUFBRTtRQUMxQixJQUFJK0Y7UUFDSixJQUFJMnJEO1FBQ0osSUFBSTF4RCxNQUFNO1lBQ1IweEQsY0FBYysyQixrQkFBa0JDLG1CQUFtQixDQUFDLElBQUksQ0FBQ2gyQixNQUFNLENBQUNpYSxNQUFNLEVBQUUzc0U7UUFDMUUsT0FBTztZQUNMMHhELGNBQWMsSUFBSSsyQixrQkFBa0IsSUFBSSxDQUFDLzFCLE1BQU0sQ0FBQ2lhLE1BQU0sRUFBRWg5QyxJQUFJLElBQUluekIsV0FBV0EsV0FBVztnQkFDcEYwaEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO2dCQUN0QzVoRCxZQUFZLElBQUksQ0FBQzBILE9BQU8sQ0FBQzFILFVBQVU7WUFDckM7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDMEgsT0FBTyxDQUFDNmhFLGNBQWMsRUFBRTtZQUMvQnhVLFlBQVkrakIsZUFBZSxDQUFDLElBQUksQ0FBQ3hxQixZQUFZO1FBQy9DO1FBQ0EsSUFBSSxDQUFDbGxELEtBQUssSUFBSSxDQUFDMUIsT0FBTyxDQUFDaTRFLFdBQVcsTUFBTSxRQUFRdjJFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NzQixRQUFRLEVBQUU7WUFDcEZxL0IsWUFBWXE0QixjQUFjLENBQUMsSUFBSSxDQUFDMWxGLE9BQU8sQ0FBQ2k0RSxXQUFXLEVBQUV6K0MsS0FBSyxDQUFDcmtDLENBQUFBLElBQUssSUFBSSxDQUFDNEIsR0FBRyxDQUFDMnRCLElBQUksQ0FBQywrQkFBK0IzakIsTUFBTSxDQUFDNUwsRUFBRTZMLE9BQU8sR0FBRyxJQUFJLENBQUNrNUMsVUFBVTtRQUNqSjtRQUNBLE9BQU9tVDtJQUNUO0lBQ0F3aEMsdUJBQXVCdmpFLEVBQUUsRUFBRTN2QixJQUFJLEVBQUU7UUFDL0IsSUFBSSxJQUFJLENBQUM2NkMsWUFBWSxDQUFDeGdDLEdBQUcsQ0FBQ3NWLEtBQUs7WUFDN0IsT0FBTyxJQUFJLENBQUNrckIsWUFBWSxDQUFDNWdELEdBQUcsQ0FBQzAxQjtRQUMvQjtRQUNBLE1BQU0raEMsY0FBYyxJQUFJLENBQUNnbEMsaUJBQWlCLENBQUMvbUUsSUFBSTN2QjtRQUMvQyxJQUFJLENBQUM2NkMsWUFBWSxDQUFDbnVDLEdBQUcsQ0FBQ2lqQixJQUFJK2hDO1FBQzFCLElBQUksQ0FBQ3FoQyxhQUFhLENBQUNybUYsR0FBRyxDQUFDMU0sS0FBSzRlLFFBQVEsRUFBRTVlLEtBQUtpZCxHQUFHO1FBQzlDLDJHQUEyRztRQUMzRyw2RkFBNkY7UUFDN0YsSUFBSSxDQUFDcTJFLGlCQUFpQixDQUFDci9DLFVBQVU0K0Msb0JBQW9CLEVBQUVuaEM7UUFDdkQsc0JBQXNCO1FBQ3RCLDZFQUE2RTtRQUM3RSx5Q0FBeUM7UUFDekNBLFlBQVkzbUMsRUFBRSxDQUFDbXBCLGlCQUFpQjRlLGNBQWMsRUFBRTZqQyxDQUFBQTtZQUM5QyxJQUFJLENBQUNyRCxpQkFBaUIsQ0FBQ3IvQyxVQUFVNmUsY0FBYyxFQUFFNmpDLGtCQUFrQmpsQztRQUNyRSxHQUFHM21DLEVBQUUsQ0FBQ21wQixpQkFBaUJtZixlQUFlLEVBQUUsQ0FBQ3ZqQyxPQUFPNGpDO1lBQzlDLDBCQUEwQjtZQUMxQixJQUFJNWpDLE1BQU1wZCxJQUFJLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQzBDLEtBQUssRUFBRTtnQkFDbkMzeEIsTUFBTS9FLEVBQUUsQ0FBQ3FwQixXQUFXc0wsb0JBQW9CLEVBQUUsSUFBSSxDQUFDdXlDLDBCQUEwQjtnQkFDekVuaUUsTUFBTS9FLEVBQUUsQ0FBQ3FwQixXQUFXd0wsbUJBQW1CLEVBQUUsSUFBSSxDQUFDc3lDLHlCQUF5QjtZQUN6RSxPQUFPLElBQUlwaUUsTUFBTXBkLElBQUksS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLEVBQUU7Z0JBQzFDbHZCLE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV3lMLG1CQUFtQixFQUFFLElBQUksQ0FBQ3d5Qyx5QkFBeUI7Z0JBQ3ZFdmlFLE1BQU0vRSxFQUFFLENBQUNxcEIsV0FBV3VMLG9CQUFvQixFQUFFLElBQUksQ0FBQ3l5QywwQkFBMEI7WUFDM0U7WUFDQSxJQUFJLENBQUN0b0UsSUFBSSxDQUFDbXFCLFVBQVVvZixlQUFlLEVBQUV2akMsT0FBTzRqQyxhQUFhaEM7UUFDM0QsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCNDFDLGdCQUFnQixFQUFFcDJCLENBQUFBO1lBQ3ZDLElBQUksQ0FBQzVwQyxJQUFJLENBQUNtcUIsVUFBVTYxQyxnQkFBZ0IsRUFBRXAyQixhQUFhaEM7UUFDckQsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCaWYsaUJBQWlCLEVBQUUsQ0FBQ3JqQyxPQUFPNGpDO1lBQ2hELElBQUksQ0FBQzVwQyxJQUFJLENBQUNtcUIsVUFBVWtmLGlCQUFpQixFQUFFcmpDLE9BQU80akMsYUFBYWhDO1FBQzdELEdBQUczbUMsRUFBRSxDQUFDbXBCLGlCQUFpQjgwQyx1QkFBdUIsRUFBRS9yRSxDQUFBQTtZQUM5QyxJQUFJLENBQUM2TSxJQUFJLENBQUNtcUIsVUFBVSswQyx1QkFBdUIsRUFBRS9yRSxLQUFLeTBDO1FBQ3BELEdBQUczbUMsRUFBRSxDQUFDbXBCLGlCQUFpQjR4QyxVQUFVLEVBQUUveUIsQ0FBQUE7WUFDakMsSUFBSSxDQUFDdWdDLGlCQUFpQixDQUFDci9DLFVBQVU2eEMsVUFBVSxFQUFFL3lCLEtBQUtyQjtRQUNwRCxHQUFHM21DLEVBQUUsQ0FBQ21wQixpQkFBaUI2eEMsWUFBWSxFQUFFaHpCLENBQUFBO1lBQ25DLElBQUksQ0FBQ3VnQyxpQkFBaUIsQ0FBQ3IvQyxVQUFVOHhDLFlBQVksRUFBRWh6QixLQUFLckI7UUFDdEQsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCZ3hDLDBCQUEwQixFQUFFM25FLENBQUFBO1lBQ2pELElBQUksQ0FBQysxRSxpQkFBaUIsQ0FBQ3IvQyxVQUFVaXhDLDBCQUEwQixFQUFFM25FLFVBQVVtMEM7UUFDekUsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCaXhDLHNCQUFzQixFQUFFaG9GLENBQUFBO1lBQzdDLElBQUksQ0FBQ20yRixpQkFBaUIsQ0FBQ3IvQyxVQUFVa3hDLHNCQUFzQixFQUFFaG9GLE1BQU11MEQ7UUFDakUsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCMHhDLHdCQUF3QixFQUFFbGxFLENBQUFBO1lBQy9DLElBQUksQ0FBQzR5RSxpQkFBaUIsQ0FBQ3IvQyxVQUFVMnhDLHdCQUF3QixFQUFFbGxFLFNBQVNneEM7UUFDdEUsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCbXhDLDZCQUE2QixFQUFFRCxDQUFBQTtZQUNwRCxJQUFJLENBQUNrTyxpQkFBaUIsQ0FBQ3IvQyxVQUFVb3hDLDZCQUE2QixFQUFFRCxpQkFBaUIxekI7UUFDbkYsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCNDBDLDhCQUE4QixFQUFFLENBQUMvMUIsS0FBSzNmO1lBQzNELElBQUksQ0FBQ2tnRCxpQkFBaUIsQ0FBQ3IvQyxVQUFVNjBDLDhCQUE4QixFQUFFLzFCLEtBQUszZixRQUFRc2U7UUFDaEYsR0FBRzNtQyxFQUFFLENBQUNtcEIsaUJBQWlCODBDLHVCQUF1QixFQUFFLENBQUNwdUMsVUFBVTN5QjtZQUN6RCxJQUFJLENBQUM2QixJQUFJLENBQUNtcUIsVUFBVSswQyx1QkFBdUIsRUFBRXB1QyxVQUFVOFcsYUFBYXpwQztRQUN0RSxHQUFHOEMsRUFBRSxDQUFDbXBCLGlCQUFpQjIwQyxrQ0FBa0MsRUFBRSxDQUFDOTFCLEtBQUszZjtZQUMvRCxJQUFJLENBQUNrZ0QsaUJBQWlCLENBQUNyL0MsVUFBVTQwQyxrQ0FBa0MsRUFBRTkxQixLQUFLM2YsUUFBUXNlO1FBQ3BGO1FBQ0EsMERBQTBEO1FBQzFELElBQUkxeEQsTUFBTTtZQUNSMHhELFlBQVlteEIsVUFBVSxDQUFDN2lGO1FBQ3pCO1FBQ0EsT0FBTzB4RDtJQUNUO0lBQ0FnSixnQkFBZ0I7UUFDZCxNQUFNb1ksZUFBZXI1RSxNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUNvSSxZQUFZLENBQUNuNEMsTUFBTSxJQUFJMHNCLE1BQU0sQ0FBQyxDQUFDdXZDLEtBQUtqTjtZQUN2RWlOLElBQUlwN0QsSUFBSSxJQUFJbXVELFlBQVk5OUIsU0FBUyxLQUFLLG9HQUFvRztZQUMxSSxPQUFPK3FDO1FBQ1QsR0FBRyxFQUFFO1FBQ0wsTUFBTW9VLGNBQWMsSUFBSSxDQUFDdmhCLGdCQUFnQixDQUFDNTlCLFNBQVMsSUFBSSxtR0FBbUc7UUFDMUosSUFBSSxDQUFDOCtCLE1BQU0sQ0FBQ2dJLGFBQWEsQ0FBQ29ZLGNBQWNDO0lBQzFDO0lBQ0E7OztHQUdDLEdBQ0QyaUIsc0JBQXNCO1FBQ3BCLEtBQUssTUFBTXZnRixLQUFLLElBQUksQ0FBQzBsQyxZQUFZLENBQUNuNEMsTUFBTSxHQUFJO1lBQzFDLEtBQUssTUFBTXF3RCxPQUFPNTlDLEVBQUVndkUsV0FBVyxDQUFDemhGLE1BQU0sR0FBSTtnQkFDeEMsSUFBSXF3RCxJQUFJMnZCLFlBQVksSUFBSTN2QixlQUFlcXpCLHdCQUF3QjtvQkFDN0RyekIsSUFBSXd6QixlQUFlO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBaUwsOEJBQThCO1FBQzVCLElBQUksQ0FBQ2Usd0JBQXdCO1FBQzdCLElBQUlxRSxzQkFBc0I7UUFDMUIsSUFBSSxDQUFDQywyQkFBMkIsR0FBR3RoRCxlQUFlQyxXQUFXLENBQUM7WUFDNUQsSUFDQSxnQ0FBZ0M7WUFDaEMsQ0FBQyxJQUFJLENBQUNrZCxNQUFNLElBQ1osNENBQTRDO1lBQzVDLElBQUksQ0FBQ0EsTUFBTSxDQUFDNlcsUUFBUSxJQUNwQiw2Q0FBNkM7WUFDN0MsQ0FBQyxJQUFJLENBQUM3VyxNQUFNLENBQUMrZixlQUFlLElBQUk7Z0JBQzlCbWtCO2dCQUNBLElBQUksQ0FBQ3g3RixHQUFHLENBQUMydEIsSUFBSSxDQUFDLHNDQUFzQ3B2QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztvQkFDcEd1NEMsYUFBYUY7b0JBQ2Jsa0MsUUFBUTt3QkFDTnFrQyxRQUFRLElBQUksQ0FBQ3JrQyxNQUFNLENBQUM2VyxRQUFRO3dCQUM1Qnl0QixxQkFBcUIsSUFBSSxDQUFDdGtDLE1BQU0sQ0FBQytmLGVBQWU7b0JBQ2xEO2dCQUNGO2dCQUNBLElBQUlta0IsdUJBQXVCLEdBQUc7b0JBQzVCLElBQUksQ0FBQzVGLGNBQWM7b0JBQ25CLElBQUksQ0FBQzNsQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNobkUsT0FBTyxDQUFDMGhFLHlCQUF5QixFQUFFbnBELGlCQUFpQnE2RSxjQUFjO2dCQUMvRjtZQUNGLE9BQU87Z0JBQ0xMLHNCQUFzQjtZQUN4QjtRQUNGLEdBQUdqSDtJQUNMO0lBQ0E0QywyQkFBMkI7UUFDekIsSUFBSSxJQUFJLENBQUNzRSwyQkFBMkIsRUFBRTtZQUNwQ3RoRCxlQUFlRSxhQUFhLENBQUMsSUFBSSxDQUFDb2hELDJCQUEyQjtRQUMvRDtJQUNGO0lBQ0F6RywwQkFBMEJ2eEUsS0FBSyxFQUFFO1FBQy9CLElBQUlBLFVBQVUsSUFBSSxDQUFDQSxLQUFLLEVBQUU7WUFDeEIsWUFBWTtZQUNaLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2lMLElBQUksQ0FBQ21xQixVQUFVK2Usc0JBQXNCLEVBQUUsSUFBSSxDQUFDbjBDLEtBQUs7UUFDdEQsT0FBTztJQUNUO0lBQ0F5MEUsa0JBQWtCaitELEtBQUssRUFBRTtRQUN2QixJQUFJLElBQUksQ0FBQ3hXLEtBQUssS0FBS28wQyxnQkFBZ0JDLFNBQVMsRUFBRTtZQUM1QyxJQUFLLElBQUl2MEIsT0FBT3hpQyxVQUFVVSxNQUFNLEVBQUUyckIsT0FBTyxJQUFJL3VCLE1BQU1rbEMsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUMsT0FBTyxHQUFHQSxPQUFPRCxNQUFNQyxPQUFRO2dCQUMxR3BXLElBQUksQ0FBQ29XLE9BQU8sRUFBRSxHQUFHemlDLFNBQVMsQ0FBQ3lpQyxLQUFLO1lBQ2xDO1lBQ0EsT0FBTyxJQUFJLENBQUM5VSxJQUFJLENBQUN1TCxVQUFVN007UUFDN0I7UUFDQSxPQUFPO0lBQ1Q7SUFDQTs7OztHQUlDLEdBQ0QwdUUscUJBQXFCN3lGLE9BQU8sRUFBRTtRQUM1QixJQUFJMEIsSUFBSThVO1FBQ1IsT0FBTzhMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTXdsRSxpQkFBaUJ4eUYsT0FBT2dLLE1BQU0sQ0FBQztnQkFDbkM2dEIsT0FBTztnQkFDUEUsT0FBTztnQkFDUHlsRSxlQUFlO1lBQ2pCLEdBQUc5eUYsUUFBUWdmLE9BQU87WUFDbEIsTUFBTSt6RSxxQkFBcUJ6OUYsT0FBT2dLLE1BQU0sQ0FBQztnQkFDdkNrbkIsT0FBTztnQkFDUDJHLE9BQU87Z0JBQ1BFLE9BQU87Z0JBQ1AybEUsY0FBYztvQkFBQztvQkFBTTtvQkFBSztpQkFBSTtZQUNoQyxHQUFHaHpGLFFBQVF3MkMsWUFBWTtZQUN2QixJQUFJLENBQUN3d0IsZ0JBQWdCO1lBQ3JCLElBQUksQ0FBQ21wQixRQUFRLEdBQUcsSUFBSXozRSxPQUFPO2dCQUN6QkUsS0FBSztnQkFDTDlmLE1BQU07Z0JBQ04rZixjQUFjO2dCQUNkQyxpQkFBaUI7Z0JBQ2pCQyxjQUFjcFIsV0FBVzdHLEtBQUssQ0FBQyxJQUFJb1csT0FBT1csT0FBTztnQkFDakRxQixVQUFVO2dCQUNWQyxpQkFBaUI7Z0JBQ2pCQyxlQUFlO2dCQUNmSixjQUFjO2dCQUNkQyxlQUFlLEVBQUU7Z0JBQ2pCSSxpQkFBaUI7WUFDbkI7WUFDQSxJQUFJLENBQUM4ekMsZ0JBQWdCLENBQUNxeEIsVUFBVSxDQUFDLElBQUlsa0UsZ0JBQWdCO2dCQUNuREMsVUFBVTtnQkFDVnpoQixNQUFNO1lBQ1I7WUFDQSxJQUFJLENBQUNpMEYsMkJBQTJCO1lBQ2hDLElBQUksQ0FBQ3RuRSxJQUFJLENBQUNtcUIsVUFBVXNmLGVBQWU7WUFDbkMsSUFBSSxDQUFDenBDLElBQUksQ0FBQ21xQixVQUFVaWYsU0FBUztZQUM3QixJQUFJLENBQUNrOUIseUJBQXlCLENBQUNuOUIsZ0JBQWdCQyxTQUFTO1lBQ3hELElBQUlpNUIsZUFBZXo2RCxLQUFLLEVBQUU7Z0JBQ3hCLE1BQU00bEUsU0FBUyxJQUFJclUsc0JBQXNCNWxDLE1BQU0wQixJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJMy9CLFVBQVU7b0JBQ3ZFdEgsUUFBUXdFLFlBQVl3bEMsTUFBTTtvQkFDMUI5a0MsS0FBS3RULEtBQUtDLEtBQUssQ0FBQ0QsS0FBSytjLE1BQU0sS0FBSyxPQUFPN2MsUUFBUTtvQkFDL0N2RixNQUFNZ1ksVUFBVXVELEtBQUs7b0JBQ3JCMWlCLE1BQU07Z0JBQ1IsSUFBSSxJQUFJODRFLGdCQUFnQmtXLGVBQWVnTCxhQUFhLEdBQUcsQ0FBQyxNQUFNNzhGLE9BQU9rQixTQUFTLENBQUNpMUIsWUFBWSxDQUFDOEMsWUFBWSxDQUFDO29CQUN2RzdCLE9BQU87Z0JBQ1QsRUFBQyxFQUFHaUMsY0FBYyxFQUFFLENBQUMsRUFBRSxHQUFHdTFCLDRCQUE0QixNQUFPLEVBQUNuakQsS0FBS3F4RixtQkFBbUJDLFlBQVksQ0FBQyxFQUFFLE1BQU0sUUFBUXR4RixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLEtBQUssTUFBTSxPQUFPdkosV0FBVyxPQUFPO29CQUM5S0csWUFBWSxJQUFJLENBQUMwSCxPQUFPLENBQUMxSCxVQUFVO29CQUNuQ3VoRCxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7Z0JBQ3hDLElBQUk7b0JBQ0Y1aEQsWUFBWSxJQUFJLENBQUMwSCxPQUFPLENBQUMxSCxVQUFVO29CQUNuQ3VoRCxpQkFBaUIsSUFBTSxJQUFJLENBQUNLLFVBQVU7Z0JBQ3hDO2dCQUNBLGFBQWE7Z0JBQ2IsSUFBSSxDQUFDaVQsZ0JBQWdCLENBQUNxMEIsbUJBQW1CLENBQUN5UjtnQkFDMUMsSUFBSSxDQUFDOWxDLGdCQUFnQixDQUFDMW5DLElBQUksQ0FBQ29xQixpQkFBaUJ1ZixtQkFBbUIsRUFBRTZqQztZQUNuRTtZQUNBLElBQUluTCxlQUFlMzZELEtBQUssRUFBRTtnQkFDeEIsTUFBTStsRSxXQUFXLElBQUl0VSxzQkFBc0I1bEMsTUFBTTBCLElBQUksQ0FBQzBDLEtBQUssRUFBRSxJQUFJcGlDLFVBQVU7b0JBQ3pFdEgsUUFBUXdFLFlBQVkwbEMsVUFBVTtvQkFDOUJobEMsS0FBS3RULEtBQUtDLEtBQUssQ0FBQ0QsS0FBSytjLE1BQU0sS0FBSyxPQUFPN2MsUUFBUTtvQkFDL0N2RixNQUFNZ1ksVUFBVXVELEtBQUs7Z0JBQ3ZCLElBQUksSUFBSW0xRCxnQkFBZ0JtWCxlQUFlZ0wsYUFBYSxHQUFHLENBQUMsTUFBTTM3RixVQUFVaTFCLFlBQVksQ0FBQzhDLFlBQVksQ0FBQztvQkFDaEcvQixPQUFPO2dCQUNULEVBQUMsRUFBR2tDLGNBQWMsRUFBRSxDQUFDLEVBQUUsR0FBR3UyQiw0QkFBNEJ6dEQsV0FBVyxPQUFPLElBQUksQ0FBQ3l1RCxZQUFZLEVBQUU7b0JBQ3pGdHVELFlBQVksSUFBSSxDQUFDMEgsT0FBTyxDQUFDMUgsVUFBVTtvQkFDbkN1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO2dCQUN4QyxJQUFJO29CQUNGNWhELFlBQVksSUFBSSxDQUFDMEgsT0FBTyxDQUFDMUgsVUFBVTtvQkFDbkN1aEQsaUJBQWlCLElBQU0sSUFBSSxDQUFDSyxVQUFVO2dCQUN4QztnQkFDQSxhQUFhO2dCQUNiLElBQUksQ0FBQ2lULGdCQUFnQixDQUFDcTBCLG1CQUFtQixDQUFDMFI7Z0JBQzFDLElBQUksQ0FBQy9sQyxnQkFBZ0IsQ0FBQzFuQyxJQUFJLENBQUNvcUIsaUJBQWlCdWYsbUJBQW1CLEVBQUU4akM7WUFDbkU7WUFDQSxJQUFLLElBQUkzNkYsSUFBSSxHQUFHQSxJQUFJdzZGLG1CQUFtQnZzRSxLQUFLLEdBQUcsR0FBR2p1QixLQUFLLEVBQUc7Z0JBQ3hELElBQUlvRCxPQUFPLElBQUkyZSxnQkFBZ0I7b0JBQzdCMUIsS0FBS3RULEtBQUtDLEtBQUssQ0FBQ0QsS0FBSytjLE1BQU0sS0FBSyxPQUFPN2MsUUFBUTtvQkFDL0MrVSxVQUFVLGFBQWF4WixNQUFNLENBQUN4STtvQkFDOUJpaUIsT0FBT0Msc0JBQXNCNDhCLE1BQU07b0JBQ25DMThCLFFBQVEsRUFBRTtvQkFDVkMsVUFBVWpULFdBQVc3RyxLQUFLLENBQUNvVyxLQUFLUSxHQUFHO2dCQUNyQztnQkFDQSxNQUFNNUcsSUFBSSxJQUFJLENBQUMrOUUsc0JBQXNCLENBQUNsekYsS0FBSzRlLFFBQVEsRUFBRTVlO2dCQUNyRCxJQUFJbzNGLG1CQUFtQjFsRSxLQUFLLEVBQUU7b0JBQzVCLE1BQU04bEUsYUFBYXR1Qyw0QkFBNEIsTUFBTyxFQUFDcnVDLEtBQUt1OEUsbUJBQW1CQyxZQUFZLENBQUN6NkYsSUFBSXc2RixtQkFBbUJDLFlBQVksQ0FBQ3g2RixNQUFNLENBQUMsTUFBTSxRQUFRZ2UsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxLQUFLLE9BQU87b0JBQzFMLE1BQU0rbkUsYUFBYSxJQUFJdmpFLFVBQVU7d0JBQy9CdEgsUUFBUXdFLFlBQVl3bEMsTUFBTTt3QkFDMUI5a0MsS0FBS3RULEtBQUtDLEtBQUssQ0FBQ0QsS0FBSytjLE1BQU0sS0FBSyxPQUFPN2MsUUFBUTt3QkFDL0N2RixNQUFNZ1ksVUFBVXVELEtBQUs7b0JBQ3ZCO29CQUNBMUssRUFBRSt6RSx1QkFBdUIsQ0FBQ3NPLFlBQVk1VSxXQUFXM2xFLEdBQUcsRUFBRSxJQUFJMlgsWUFBWTt3QkFBQzRpRTtxQkFBVztvQkFDbEZ4M0YsS0FBS2dmLE1BQU0sR0FBRzsyQkFBSWhmLEtBQUtnZixNQUFNO3dCQUFFNGpFO3FCQUFXO2dCQUM1QztnQkFDQSxJQUFJd1UsbUJBQW1CNWxFLEtBQUssRUFBRTtvQkFDNUIsTUFBTXU0QixhQUFhRTtvQkFDbkIsTUFBTTA0QixhQUFhLElBQUl0akUsVUFBVTt3QkFDL0J0SCxRQUFRd0UsWUFBWTBsQyxVQUFVO3dCQUM5QmhsQyxLQUFLdFQsS0FBS0MsS0FBSyxDQUFDRCxLQUFLK2MsTUFBTSxLQUFLLE9BQU83YyxRQUFRO3dCQUMvQ3ZGLE1BQU1nWSxVQUFVdUQsS0FBSztvQkFDdkI7b0JBQ0ExSyxFQUFFK3pFLHVCQUF1QixDQUFDbi9CLFlBQVk0NEIsV0FBVzFsRSxHQUFHLEVBQUUsSUFBSTJYLFlBQVk7d0JBQUNtMUI7cUJBQVc7b0JBQ2xGL3BELEtBQUtnZixNQUFNLEdBQUc7MkJBQUloZixLQUFLZ2YsTUFBTTt3QkFBRTJqRTtxQkFBVztnQkFDNUM7Z0JBQ0F4dEUsRUFBRTB0RSxVQUFVLENBQUM3aUY7WUFDZjtRQUNGO0lBQ0Y7SUFDQSxtQkFBbUI7SUFDbkI4cEIsS0FBS3VMLEtBQUssRUFBRTtRQUNWLElBQUssSUFBSW9pRSxRQUFRdDdGLFVBQVVVLE1BQU0sRUFBRTJyQixPQUFPLElBQUkvdUIsTUFBTWcrRixRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7WUFDakhsdkUsSUFBSSxDQUFDa3ZFLFFBQVEsRUFBRSxHQUFHdjdGLFNBQVMsQ0FBQ3U3RixNQUFNO1FBQ3BDO1FBQ0Esd0NBQXdDO1FBQ3hDLElBQUlyaUUsVUFBVTRlLFVBQVVzL0MscUJBQXFCLEVBQUU7WUFDN0MseUZBQXlGO1lBQ3pGLE1BQU1vRSxnQkFBZ0JDLFFBQVFwdkUsTUFBTXJvQixNQUFNLENBQUMwQixDQUFBQSxNQUFPQSxRQUFRckY7WUFDMUQsSUFBSSxDQUFDcEIsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLGNBQWNxSSxNQUFNLENBQUNpd0IsUUFBUTE3QixPQUFPZ0ssTUFBTSxDQUFDaEssT0FBT2dLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDNDZDLFVBQVUsR0FBRztnQkFDNUZscEI7Z0JBQ0E3TSxNQUFNbXZFO1lBQ1I7UUFDRjtRQUNBLE9BQU8sS0FBSyxDQUFDN3RFLEtBQUt1TCxVQUFVN007SUFDOUI7QUFDRjtBQUNBLFNBQVNvdkUsUUFBUXB2RSxJQUFJO0lBQ25CLE9BQU9BLEtBQUtqb0IsR0FBRyxDQUFDc0IsQ0FBQUE7UUFDZCxJQUFJLENBQUNBLEtBQUs7WUFDUjtRQUNGO1FBQ0EsSUFBSXBJLE1BQU1DLE9BQU8sQ0FBQ21JLE1BQU07WUFDdEIsT0FBTysxRixRQUFRLzFGO1FBQ2pCO1FBQ0EsSUFBSSxPQUFPQSxRQUFRLFVBQVU7WUFDM0IsT0FBTyxnQkFBZ0JBLE9BQU9BLElBQUkwOEMsVUFBVTtRQUM5QztRQUNBLE9BQU8xOEM7SUFDVDtBQUNGO0FBRUEsSUFBSWcyRjtBQUNILFVBQVVBLFdBQVc7SUFDcEJBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDMUNBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDMUNBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDMUNBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDM0MsR0FBR0EsZUFBZ0JBLENBQUFBLGNBQWMsQ0FBQztBQUNsQyxNQUFNQyxnQkFBZ0JockUsY0FBYzdELFlBQVk7SUFDOUM1aUIsWUFBWSs1QixHQUFHLEVBQUVtM0IsS0FBSyxDQUFFO1FBQ3RCLElBQUlsekQsVUFBVWxJLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsS0FBSztRQUNMLElBQUksQ0FBQ2kzQyxNQUFNLEdBQUd5a0QsWUFBWUUsSUFBSTtRQUM5QixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUM3M0QsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ20zQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDcDZELElBQUksR0FBRyxJQUFJLENBQUNrSixXQUFXLENBQUNsSixJQUFJO1FBQ2pDLElBQUksQ0FBQ28wRCxJQUFJLEdBQUcsSUFBSXYwQyxLQUFLM1ksUUFBUTZtRixXQUFXO1FBQ3hDLElBQUksQ0FBQ3J6QixjQUFjLEdBQUd4ekQsUUFBUXd6RCxjQUFjO1FBQzVDLElBQUl4ekQsUUFBUTR6RixnQkFBZ0IsRUFBRTtZQUM1QixJQUFJLENBQUNBLGdCQUFnQixHQUFHNXpGLFFBQVE0ekYsZ0JBQWdCO1FBQ2xEO0lBQ0Y7SUFDQW5qQyxJQUFJb2pDLFVBQVUsRUFBRTtRQUNkLE9BQU92eEUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxJQUFJLElBQUksQ0FBQ3lzQixNQUFNLEtBQUt5a0QsWUFBWUUsSUFBSSxFQUFFO2dCQUNwQyxNQUFNejJGLE1BQU07WUFDZDtZQUNBLElBQUksQ0FBQzYyRixTQUFTLENBQUNOLFlBQVl6aUMsT0FBTztZQUNsQyxJQUFJO2dCQUNGLE1BQU0sSUFBSSxDQUFDZ2pDLE9BQU87WUFDcEIsRUFBRSxPQUFPbnVFLEtBQUs7Z0JBQ1osSUFBSUEsZUFBZTNvQixPQUFPO29CQUN4QixJQUFJLElBQUksQ0FBQzIyRixnQkFBZ0IsRUFBRTt3QkFDekIsSUFBSSxDQUFDSSxhQUFhLENBQUNwdUUsSUFBSTVrQixPQUFPO29CQUNoQyxPQUFPO3dCQUNMLElBQUksQ0FBQ2l6RixXQUFXLENBQUNydUUsSUFBSTVrQixPQUFPO29CQUM5QjtnQkFDRjtZQUNGO1lBQ0EsTUFBTSxJQUFJLENBQUNrbUUsVUFBVTtZQUNyQix1Q0FBdUM7WUFDdkMsTUFBTSxJQUFJcmtELFFBQVFELENBQUFBLFVBQVcwdEIsV0FBVzF0QixTQUFTO1lBQ2pELGFBQWE7WUFDYixJQUFJLElBQUksQ0FBQ21zQixNQUFNLEtBQUt5a0QsWUFBWVUsT0FBTyxFQUFFO2dCQUN2QyxJQUFJLENBQUNKLFNBQVMsQ0FBQyxJQUFJLENBQUNLLFNBQVMsS0FBS1gsWUFBWVksT0FBTyxHQUFHWixZQUFZNXdCLE1BQU07WUFDNUU7WUFDQSxJQUFJaXhCLFlBQVk7Z0JBQ2RBO1lBQ0Y7WUFDQSxPQUFPLElBQUksQ0FBQzVrQixPQUFPO1FBQ3JCO0lBQ0Y7SUFDQWtsQixZQUFZO1FBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQ1IsSUFBSSxDQUFDOWxFLElBQUksQ0FBQ3VpQixDQUFBQSxJQUFLQSxFQUFFLzNDLEtBQUssS0FBSztJQUMxQztJQUNBbW5ELFVBQVU7UUFDUixPQUFPbDlCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxJQUFJLENBQUM0cUMsSUFBSSxDQUFDMXlDLEtBQUssS0FBS28wQyxnQkFBZ0JDLFNBQVMsRUFBRTtnQkFDakQsT0FBTyxJQUFJLENBQUMzQixJQUFJO1lBQ2xCO1lBQ0EsTUFBTSxJQUFJLENBQUNBLElBQUksQ0FBQzFOLE9BQU8sQ0FBQyxJQUFJLENBQUN6akIsR0FBRyxFQUFFLElBQUksQ0FBQ20zQixLQUFLO1lBQzVDLE9BQU8sSUFBSSxDQUFDaEcsSUFBSTtRQUNsQjtJQUNGO0lBQ0FnYSxhQUFhO1FBQ1gsT0FBTzVrRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLElBQUksSUFBSSxDQUFDNHFDLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQzF5QyxLQUFLLEtBQUtvMEMsZ0JBQWdCdVksWUFBWSxFQUFFO2dCQUNqRSxNQUFNLElBQUksQ0FBQ2phLElBQUksQ0FBQ2dhLFVBQVU7Z0JBQzFCLDRCQUE0QjtnQkFDNUIsTUFBTSxJQUFJcmtELFFBQVFELENBQUFBLFVBQVcwdEIsV0FBVzF0QixTQUFTO1lBQ25EO1FBQ0Y7SUFDRjtJQUNBbFksT0FBTztRQUNMLElBQUksQ0FBQ29wRixTQUFTLENBQUNOLFlBQVlVLE9BQU87SUFDcEM7SUFDQUcsY0FBY3J6RixPQUFPLEVBQUU7UUFDckIsSUFBSSxDQUFDMnlGLElBQUksQ0FBQ3owRixJQUFJLENBQUM7WUFDYjdHLE9BQU87WUFDUDJJO1FBQ0Y7UUFDQSxJQUFJLENBQUN5a0IsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDd3BELE9BQU87SUFDbEM7SUFDQStrQixjQUFjaHpGLE9BQU8sRUFBRTtRQUNyQixJQUFJLENBQUMyeUYsSUFBSSxDQUFDejBGLElBQUksQ0FBQztZQUNiN0csT0FBTztZQUNQMkk7UUFDRjtRQUNBLElBQUksQ0FBQ3lrQixJQUFJLENBQUMsVUFBVSxJQUFJLENBQUN3cEQsT0FBTztJQUNsQztJQUNBZ2xCLFlBQVlqekYsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQzJ5RixJQUFJLENBQUN6MEYsSUFBSSxDQUFDO1lBQ2I3RyxPQUFPO1lBQ1AySTtRQUNGO1FBQ0EsSUFBSSxDQUFDeWtCLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQ3dwRCxPQUFPO0lBQ2xDO0lBQ0E2a0IsVUFBVS9rRCxNQUFNLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDdHBCLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQ3dwRCxPQUFPO0lBQ2xDO0lBQ0EsSUFBSTVnQixTQUFTO1FBQ1gsSUFBSTNzRDtRQUNKLE9BQU8sQ0FBQ0EsS0FBSyxJQUFJLENBQUN3ckQsSUFBSSxNQUFNLFFBQVF4ckQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMnNELE1BQU07SUFDeEU7SUFDQTRnQixVQUFVO1FBQ1IsT0FBTztZQUNMMGtCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2Y3NkYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZmkyQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQjFaLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1FBQy9CO0lBQ0Y7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU2kvRCxrQkFBa0J0MEYsT0FBTztJQUNoQyxJQUFJMEIsSUFBSThVO0lBQ1IsT0FBTzhMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDckMsOEJBQThCO1FBQzlCdGlCLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVVBLFVBQVUsQ0FBQztRQUM3RDBCLENBQUFBLEtBQUsxQixRQUFRbXRCLEtBQUssTUFBTSxRQUFRenJCLE9BQU8sS0FBSyxJQUFJQSxLQUFLMUIsUUFBUW10QixLQUFLLEdBQUc7UUFDckUzVyxDQUFBQSxLQUFLeFcsUUFBUXF0QixLQUFLLE1BQU0sUUFBUTdXLE9BQU8sS0FBSyxJQUFJQSxLQUFLeFcsUUFBUXF0QixLQUFLLEdBQUc7UUFDdEUsTUFBTW9oQixPQUFPNFAsb0JBQW9CcitDLFNBQVNzK0MsZUFBZUM7UUFDekQsTUFBTXR4QixjQUFjMHhCLHNCQUFzQmxRO1FBQzFDLHFGQUFxRjtRQUNyRiw2RUFBNkU7UUFDN0UsTUFBTThsRCxlQUFlcDlGLFVBQVVpMUIsWUFBWSxDQUFDOEMsWUFBWSxDQUFDakM7UUFDekQsSUFBSWp0QixRQUFRbXRCLEtBQUssRUFBRTtZQUNqQms3QixjQUFjSyxtQkFBbUIsQ0FBQ3JnRCxHQUFHLENBQUMsY0FBY2tzRjtZQUNwREEsYUFBYS82RCxLQUFLLENBQUMsSUFBTTZ1QixjQUFjSyxtQkFBbUIsQ0FBQzUrQixNQUFNLENBQUM7UUFDcEU7UUFDQSxJQUFJOXBCLFFBQVFxdEIsS0FBSyxFQUFFO1lBQ2pCZzdCLGNBQWNLLG1CQUFtQixDQUFDcmdELEdBQUcsQ0FBQyxjQUFja3NGO1lBQ3BEQSxhQUFhLzZELEtBQUssQ0FBQyxJQUFNNnVCLGNBQWNLLG1CQUFtQixDQUFDNStCLE1BQU0sQ0FBQztRQUNwRTtRQUNBLE1BQU0xTixTQUFTLE1BQU1tNEU7UUFDckIsT0FBT240RSxPQUFPbVQsU0FBUyxHQUFHcnpCLEdBQUcsQ0FBQ20rQyxDQUFBQTtZQUM1QixNQUFNNnVDLFVBQVU3dUMsaUJBQWlCaHNDLElBQUksS0FBSztZQUMxQzY2RSxVQUFVbHBGLFFBQVFtdEIsS0FBSyxHQUFHbnRCLFFBQVFxdEIsS0FBSztZQUN2QyxJQUFJODdEO1lBQ0osTUFBTUMsWUFBWUYsVUFBVWo4RCxZQUFZRSxLQUFLLEdBQUdGLFlBQVlJLEtBQUs7WUFDakUsSUFBSSxPQUFPKzdELGNBQWMsV0FBVztnQkFDbENELG1CQUFtQkM7WUFDckI7WUFDQSxrR0FBa0c7WUFDbEcscUlBQXFJO1lBQ3JJLElBQUlELGtCQUFrQjtnQkFDcEJBLGlCQUFpQm43RCxRQUFRLEdBQUdxc0IsaUJBQWlCampCLFdBQVcsR0FBR3BKLFFBQVE7WUFDckUsT0FBTztnQkFDTG03RCxtQkFBbUI7b0JBQ2pCbjdELFVBQVVxc0IsaUJBQWlCampCLFdBQVcsR0FBR3BKLFFBQVE7Z0JBQ25EO1lBQ0Y7WUFDQSxNQUFNdkMsUUFBUWttRCx1QkFBdUJ0M0Isa0JBQWtCOHVDO1lBQ3ZELElBQUkxOUQsTUFBTXBkLElBQUksS0FBSzJxQyxNQUFNMEIsSUFBSSxDQUFDQyxLQUFLLEVBQUU7Z0JBQ25DbHZCLE1BQU0vWCxNQUFNLEdBQUdzbEMsTUFBTWdCLE1BQU0sQ0FBQ3lELE1BQU07WUFDcEMsT0FBTyxJQUFJaHlCLE1BQU1wZCxJQUFJLEtBQUsycUMsTUFBTTBCLElBQUksQ0FBQzBDLEtBQUssRUFBRTtnQkFDMUMzeEIsTUFBTS9YLE1BQU0sR0FBR3NsQyxNQUFNZ0IsTUFBTSxDQUFDMkQsVUFBVTtZQUN4QztZQUNBbHlCLE1BQU1peEIsV0FBVyxHQUFHdGdDO1lBQ3BCLE9BQU9xUDtRQUNUO0lBQ0Y7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVMrb0Usc0JBQXNCeDBGLE9BQU87SUFDcEMsT0FBT3NpQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ3JDLE1BQU0zSCxTQUFTLE1BQU0yNUUsa0JBQWtCO1lBQ3JDbm5FLE9BQU87WUFDUEUsT0FBT3J0QjtRQUNUO1FBQ0EsT0FBTzJhLE1BQU0sQ0FBQyxFQUFFO0lBQ2xCO0FBQ0Y7QUFDQSxTQUFTODVFLHNCQUFzQnowRixPQUFPO0lBQ3BDLE9BQU9zaUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxNQUFNM0gsU0FBUyxNQUFNMjVFLGtCQUFrQjtZQUNyQ25uRSxPQUFPbnRCO1lBQ1BxdEIsT0FBTztRQUNUO1FBQ0EsT0FBTzFTLE1BQU0sQ0FBQyxFQUFFO0lBQ2xCO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUys1RSx3QkFBd0IxMEYsT0FBTztJQUN0QyxPQUFPc2lCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDckMsSUFBSXRpQixZQUFZN0gsV0FBVztZQUN6QjZILFVBQVUsQ0FBQztRQUNiO1FBQ0EsSUFBSUEsUUFBUXV4QyxVQUFVLEtBQUtwNUMsYUFBYSxDQUFDeXFELGNBQWM7WUFDckQ1aUQsUUFBUXV4QyxVQUFVLEdBQUcyQixtQkFBbUJPLFVBQVUsQ0FBQ2xDLFVBQVU7UUFDL0Q7UUFDQSxJQUFJcDZDLFVBQVVpMUIsWUFBWSxDQUFDd0QsZUFBZSxLQUFLejNCLFdBQVc7WUFDeEQsTUFBTSxJQUFJNjJDLHVCQUF1QjtRQUNuQztRQUNBLE1BQU0vaEIsY0FBYyt5Qix5Q0FBeUNoZ0Q7UUFDN0QsTUFBTW9jLFNBQVMsTUFBTWpsQixVQUFVaTFCLFlBQVksQ0FBQ3dELGVBQWUsQ0FBQzNDO1FBQzVELE1BQU10UyxTQUFTeUIsT0FBT2tULGNBQWM7UUFDcEMsSUFBSTNVLE9BQU9uaUIsTUFBTSxLQUFLLEdBQUc7WUFDdkIsTUFBTSxJQUFJeTJDLGtCQUFrQjtRQUM5QjtRQUNBLE1BQU1vNkMsY0FBYyxJQUFJelgsZ0JBQWdCajNELE1BQU0sQ0FBQyxFQUFFLEVBQUV4aUIsV0FBVztRQUM5RGt4RixZQUFZMzFFLE1BQU0sR0FBR3NsQyxNQUFNZ0IsTUFBTSxDQUFDNkQsV0FBVztRQUM3QyxNQUFNNndCLGNBQWM7WUFBQzJhO1NBQVk7UUFDakMsSUFBSWp0RSxPQUFPaVQsY0FBYyxHQUFHNzJCLE1BQU0sR0FBRyxHQUFHO1lBQ3RDLE1BQU0rd0YsY0FBYyxJQUFJNVksZ0JBQWdCdjBELE9BQU9pVCxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQUVsM0IsV0FBVztZQUMvRW94RixZQUFZNzFFLE1BQU0sR0FBR3NsQyxNQUFNZ0IsTUFBTSxDQUFDK0QsZ0JBQWdCO1lBQ2xEMndCLFlBQVl4dkUsSUFBSSxDQUFDcXFGO1FBQ25CO1FBQ0EsT0FBTzdhO0lBQ1Q7QUFDRjtBQUVBLE1BQU1pbUIsMEJBQTBCbEI7SUFDOUIsSUFBSXArRCxjQUFjO1FBQ2hCLE9BQU87SUFDVDtJQUNBMCtELFVBQVU7UUFDUixJQUFJcnlGO1FBQ0osT0FBTzRnQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU00cUMsT0FBTyxNQUFNLElBQUksQ0FBQzFOLE9BQU87WUFDL0IsTUFBTS96QixRQUFRLE1BQU1ncEU7WUFDcEJ2bkMsS0FBS0MsZ0JBQWdCLENBQUN1N0IsWUFBWSxDQUFDajlEO1lBQ25DLG9DQUFvQztZQUNwQyxNQUFNLElBQUk1SSxRQUFRRCxDQUFBQSxVQUFXMHRCLFdBQVcxdEIsU0FBUztZQUNqRCx3Q0FBd0M7WUFDeEMsTUFBTXdJLFFBQVEsTUFBTSxDQUFDMXBCLEtBQUsrcEIsTUFBTXVHLE1BQU0sTUFBTSxRQUFRdHdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR294QixRQUFRO1lBQ3hGLElBQUksQ0FBQzFILE9BQU87Z0JBQ1YsTUFBTSxJQUFJbnVCLE1BQU07WUFDbEI7WUFDQSxJQUFJMjNGLGFBQWE7WUFDakJ4cEUsTUFBTWwyQixPQUFPLENBQUN5K0IsQ0FBQUE7Z0JBQ1osSUFBSUEsS0FBSzF6QixJQUFJLEtBQUssa0JBQWtCMHpCLEtBQUtraEUsU0FBUyxLQUFLLFNBQVM7b0JBQzlERCxhQUFhamhFLEtBQUsyOUMsV0FBVztnQkFDL0I7WUFDRjtZQUNBLElBQUlzakIsZUFBZSxHQUFHO2dCQUNwQixNQUFNLElBQUkzM0YsTUFBTTtZQUNsQjtZQUNBLElBQUksQ0FBQ28zRixhQUFhLENBQUMsYUFBYXR6RixNQUFNLENBQUM2ekYsWUFBWTtRQUNyRDtJQUNGO0FBQ0Y7QUFFQSxNQUFNRSwwQkFBMEJyQjtJQUM5QixJQUFJcCtELGNBQWM7UUFDaEIsT0FBTztJQUNUO0lBQ0EwK0QsVUFBVTtRQUNSLElBQUlyeUY7UUFDSixPQUFPNGdCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsTUFBTTRxQyxPQUFPLE1BQU0sSUFBSSxDQUFDMU4sT0FBTztZQUMvQixNQUFNL3pCLFFBQVEsTUFBTStvRTtZQUNwQnRuQyxLQUFLQyxnQkFBZ0IsQ0FBQ3U3QixZQUFZLENBQUNqOUQ7WUFDbkMsb0NBQW9DO1lBQ3BDLE1BQU0sSUFBSTVJLFFBQVFELENBQUFBLFVBQVcwdEIsV0FBVzF0QixTQUFTO1lBQ2pELHdDQUF3QztZQUN4QyxNQUFNd0ksUUFBUSxNQUFNLENBQUMxcEIsS0FBSytwQixNQUFNdUcsTUFBTSxNQUFNLFFBQVF0d0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb3hCLFFBQVE7WUFDeEYsSUFBSSxDQUFDMUgsT0FBTztnQkFDVixNQUFNLElBQUludUIsTUFBTTtZQUNsQjtZQUNBLElBQUkyM0YsYUFBYTtZQUNqQnhwRSxNQUFNbDJCLE9BQU8sQ0FBQ3krQixDQUFBQTtnQkFDWixJQUFJQSxLQUFLMXpCLElBQUksS0FBSyxrQkFBa0IwekIsS0FBS2toRSxTQUFTLEtBQUssU0FBUztvQkFDOURELGFBQWFqaEUsS0FBSzI5QyxXQUFXO2dCQUMvQjtZQUNGO1lBQ0EsSUFBSXNqQixlQUFlLEdBQUc7Z0JBQ3BCLE1BQU0sSUFBSTMzRixNQUFNO1lBQ2xCO1lBQ0EsSUFBSSxDQUFDbzNGLGFBQWEsQ0FBQyxhQUFhdHpGLE1BQU0sQ0FBQzZ6RixZQUFZO1FBQ3JEO0lBQ0Y7QUFDRjtBQUVBLE1BQU1HLHVCQUF1QnRCO0lBQzNCLElBQUlwK0QsY0FBYztRQUNoQixPQUFPO0lBQ1Q7SUFDQTArRCxVQUFVO1FBQ1IsSUFBSXJ5RjtRQUNKLE9BQU80Z0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNNHFDLE9BQU8sTUFBTSxJQUFJLENBQUMxTixPQUFPO1lBQy9CLElBQUl3MUMsd0JBQXdCO1lBQzVCLElBQUlDLGNBQWM7WUFDbEIsSUFBSUM7WUFDSixNQUFNeHRCLG1CQUFtQixJQUFJN2tELFFBQVFELENBQUFBO2dCQUNuQzB0QixXQUFXMXRCLFNBQVM7Z0JBQ3BCc3lFLG9CQUFvQnR5RTtZQUN0QjtZQUNBc3FDLEtBQUt4bUMsRUFBRSxDQUFDa3BCLFVBQVVnK0IsWUFBWSxFQUFFO2dCQUM5Qm9uQix3QkFBd0I7WUFDMUIsR0FBR3R1RSxFQUFFLENBQUNrcEIsVUFBVTIrQyxXQUFXLEVBQUU7Z0JBQzNCMEcsY0FBYztnQkFDZEMsa0JBQWtCO1lBQ3BCO1lBQ0N4ekYsQ0FBQUEsS0FBS3dyRCxLQUFLbUIsTUFBTSxDQUFDaWEsTUFBTSxDQUFDdlUsRUFBRSxNQUFNLFFBQVFyeUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbStDLEtBQUs7WUFDMUUsTUFBTStTLFVBQVUxRixLQUFLbUIsTUFBTSxDQUFDaWEsTUFBTSxDQUFDMVYsT0FBTztZQUMxQyxJQUFJQSxTQUFTO2dCQUNYQSxRQUFRO1lBQ1Y7WUFDQSxNQUFNOFU7WUFDTixJQUFJLENBQUNzdEIsdUJBQXVCO2dCQUMxQixNQUFNLElBQUkvM0YsTUFBTTtZQUNsQixPQUFPLElBQUksQ0FBQ2c0RixlQUFlL25DLEtBQUsxeUMsS0FBSyxLQUFLbzBDLGdCQUFnQkMsU0FBUyxFQUFFO2dCQUNuRSxJQUFJLENBQUNtbEMsYUFBYSxDQUFDO2dCQUNuQixNQUFNLElBQUkvMkYsTUFBTTtZQUNsQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1rNEYsa0JBQWtCMUI7SUFDdEIsSUFBSXArRCxjQUFjO1FBQ2hCLE9BQU87SUFDVDtJQUNBMCtELFVBQVU7UUFDUixJQUFJcnlGLElBQUk4VTtRQUNSLE9BQU84TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE1BQU1veUQsZUFBZSxJQUFJbGpCO1lBQ3pCLE1BQU00akMsVUFBVSxNQUFNMWdCLGFBQWFuc0UsSUFBSSxDQUFDLElBQUksQ0FBQ3d6QixHQUFHLEVBQUUsSUFBSSxDQUFDbTNCLEtBQUssRUFBRTtnQkFDNURnRixlQUFlO2dCQUNmNkosWUFBWTtnQkFDWnFKLGFBQWE7Z0JBQ2J2WCxrQkFBa0I7WUFDcEI7WUFDQSxJQUFJd2hDLFNBQVM7WUFDYixJQUFJQyxVQUFVO1lBQ2QsSUFBSUMsVUFBVTtZQUNkLEtBQUssSUFBSWhxQixhQUFhNnBCLFFBQVF6NUQsVUFBVSxDQUFFO2dCQUN4QyxLQUFLLElBQUlJLE9BQU93dkMsVUFBVXp2QyxJQUFJLENBQUU7b0JBQzlCLElBQUlDLElBQUk5L0IsVUFBVSxDQUFDLFVBQVU7d0JBQzNCcTVGLFVBQVU7d0JBQ1ZDLFVBQVU7b0JBQ1osT0FBTyxJQUFJeDVELElBQUk5L0IsVUFBVSxDQUFDLFdBQVc7d0JBQ25DcTVGLFVBQVU7d0JBQ1ZDLFVBQVU7d0JBQ1ZGLFNBQVM7b0JBQ1g7b0JBQ0EsSUFBSXQ1RCxJQUFJOS9CLFVBQVUsQ0FBQyxVQUFVO3dCQUMzQnM1RixVQUFVO29CQUNaO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJLENBQUNBLFNBQVM7Z0JBQ1osSUFBSSxDQUFDdkIsYUFBYSxDQUFDO1lBQ3JCLE9BQU8sSUFBSXNCLFdBQVcsQ0FBQ0QsUUFBUTtnQkFDN0IsSUFBSSxDQUFDckIsYUFBYSxDQUFDO1lBQ3JCO1lBQ0EsTUFBTXRmLGFBQWE3MEIsS0FBSztZQUN4QixJQUFJLENBQUMsQ0FBQ3JwQyxLQUFLLENBQUM5VSxLQUFLLElBQUksQ0FBQzh4RCxjQUFjLE1BQU0sUUFBUTl4RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd5OUQsU0FBUyxNQUFNLFFBQVEzb0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbWxCLFVBQVUsS0FBSzI1RCxTQUFTO2dCQUN2SixNQUFNLElBQUksQ0FBQ3BvQyxJQUFJLENBQUMxTixPQUFPLENBQUMsSUFBSSxDQUFDempCLEdBQUcsRUFBRSxJQUFJLENBQUNtM0IsS0FBSyxFQUFFO29CQUM1Q2lNLFdBQVc7d0JBQ1R1TSxvQkFBb0I7b0JBQ3RCO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxJQUFJLENBQUNzb0IsYUFBYSxDQUFDO2dCQUNuQixJQUFJLENBQUN0cEYsSUFBSTtnQkFDVCxNQUFNLElBQUltWSxRQUFRRCxDQUFBQSxVQUFXMHRCLFdBQVcxdEIsU0FBUztZQUNuRDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU00eUUsb0JBQW9CL0I7SUFDeEIsSUFBSXArRCxjQUFjO1FBQ2hCLE9BQU87SUFDVDtJQUNBMCtELFVBQVU7UUFDUixPQUFPenhFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSW16RSxTQUFTO1lBQ2IsSUFBSUMsYUFBYTtZQUNqQixJQUFJLENBQUN4b0MsSUFBSSxDQUFDeG1DLEVBQUUsQ0FBQ2twQixVQUFVc2YsZUFBZSxFQUFFO2dCQUN0QyxNQUFNeW1DLGNBQWMsSUFBSSxDQUFDem9DLElBQUksQ0FBQ21CLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQzNWLFNBQVM7Z0JBQ3JELElBQUksQ0FBQ3pGLElBQUksQ0FBQ21CLE1BQU0sQ0FBQ2lhLE1BQU0sQ0FBQzNWLFNBQVMsR0FBRyxDQUFDc0UsSUFBSWhwRDtvQkFDdkMsSUFBSWdwRCxHQUFHOTdCLFNBQVMsRUFBRTt3QkFDaEIsTUFBTUEsWUFBWSxJQUFJM0UsZ0JBQWdCeWdDO3dCQUN0QyxJQUFJNkIsTUFBTSxHQUFHLzNELE1BQU0sQ0FBQ282QixVQUFVdmQsUUFBUSxFQUFFLEtBQUs3YyxNQUFNLENBQUNvNkIsVUFBVTVjLE9BQU8sRUFBRSxLQUFLeGQsTUFBTSxDQUFDbzZCLFVBQVUrQyxJQUFJLEVBQUUsS0FBS245QixNQUFNLENBQUNvNkIsVUFBVWw3QixJQUFJO3dCQUM3SCxJQUFJazdCLFVBQVU1YyxPQUFPLEVBQUU7NEJBQ3JCLElBQUlxM0UsWUFBWXo2RCxVQUFVNWMsT0FBTyxHQUFHO2dDQUNsQ3U2QyxPQUFPOzRCQUNULE9BQU87Z0NBQ0wsSUFBSTM5QixVQUFVdmQsUUFBUSxLQUFLLFNBQVN1ZCxVQUFVa0QsT0FBTyxLQUFLLFdBQVc7b0NBQ25FbzNELFNBQVM7b0NBQ1QzOEIsT0FBTztnQ0FDVCxPQUFPLElBQUkzOUIsVUFBVXZkLFFBQVEsS0FBSyxPQUFPO29DQUN2QzgzRSxhQUFhO2dDQUNmOzRCQUNGO3dCQUNGO3dCQUNBLElBQUksQ0FBQ3JCLGFBQWEsQ0FBQ3Y3QjtvQkFDckI7b0JBQ0EsSUFBSTY4QixhQUFhO3dCQUNmQSxZQUFZMStCLElBQUlocEQ7b0JBQ2xCO2dCQUNGO2dCQUNBLElBQUksSUFBSSxDQUFDaS9DLElBQUksQ0FBQ21CLE1BQU0sQ0FBQythLFNBQVMsRUFBRTtvQkFDOUIsSUFBSSxDQUFDbGMsSUFBSSxDQUFDbUIsTUFBTSxDQUFDK2EsU0FBUyxDQUFDbkcsVUFBVSxDQUFDNUYsbUJBQW1CLEdBQUd4USxDQUFBQTt3QkFDMUQsSUFBSUEsY0FBY2dwQyxnQ0FBZ0M7NEJBQ2hELElBQUksQ0FBQzdCLGFBQWEsQ0FBQyw2QkFBNkJqekYsTUFBTSxDQUFDOHJELEdBQUdpcEMsU0FBUyxFQUFFLEtBQUsvMEYsTUFBTSxDQUFDOHJELEdBQUdrcEMsU0FBUyxFQUFFLEtBQUtoMUYsTUFBTSxDQUFDOHJELEdBQUc5d0IsR0FBRzt3QkFDbkg7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUk7Z0JBQ0YsTUFBTSxJQUFJLENBQUN5akIsT0FBTztnQkFDbEI5akQsY0FBY0MsSUFBSSxDQUFDO1lBQ3JCLEVBQUUsT0FBT2lxQixLQUFLO2dCQUNaLElBQUksQ0FBQ291RSxhQUFhLENBQUM7Z0JBQ25CLE1BQU1wdUU7WUFDUjtZQUNBLElBQUksQ0FBQzZ2RSxRQUFRO2dCQUNYLElBQUksQ0FBQ3pCLGFBQWEsQ0FBQztZQUNyQjtZQUNBLElBQUksQ0FBQzBCLFlBQVk7Z0JBQ2YsSUFBSSxDQUFDMUIsYUFBYSxDQUFDO1lBQ3JCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBUzRCLFlBQVlyM0UsT0FBTztJQUMxQixNQUFNZ2YsUUFBUWhmLFFBQVFqTyxLQUFLLENBQUM7SUFDNUIsSUFBSWl0QixNQUFNL2tDLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLElBQUkra0MsS0FBSyxDQUFDLEVBQUUsS0FBSyxNQUFNO1lBQ3JCLE9BQU87UUFDVCxPQUFPLElBQUlBLEtBQUssQ0FBQyxFQUFFLEtBQUssU0FBU0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPO1lBQ25ELE9BQU87UUFDVCxPQUFPLElBQUlBLEtBQUssQ0FBQyxFQUFFLEtBQUssT0FBTztZQUM3QixNQUFNeTRELFNBQVNwbUYsU0FBUzJ0QixLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ2xDLElBQUl5NEQsVUFBVSxNQUFNQSxVQUFVLElBQUk7Z0JBQ2hDLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxNQUFNQyx1QkFBdUJ4QztJQUMzQixJQUFJcCtELGNBQWM7UUFDaEIsT0FBTztJQUNUO0lBQ0EwK0QsVUFBVTtRQUNSLElBQUlyeUYsSUFBSThVLElBQUlDO1FBQ1osT0FBTzZMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsSUFBSSxJQUFJLENBQUN5WixHQUFHLENBQUM5L0IsVUFBVSxDQUFDLFVBQVUsSUFBSSxDQUFDOC9CLEdBQUcsQ0FBQzkvQixVQUFVLENBQUMsVUFBVTtnQkFDOUQsSUFBSSxDQUFDKzNGLGFBQWEsQ0FBQztZQUNyQjtZQUNBLElBQUl0ZixlQUFlLElBQUlsakI7WUFDdkIsTUFBTTRqQyxVQUFVLE1BQU0xZ0IsYUFBYW5zRSxJQUFJLENBQUMsSUFBSSxDQUFDd3pCLEdBQUcsRUFBRSxJQUFJLENBQUNtM0IsS0FBSyxFQUFFO2dCQUM1RGdGLGVBQWU7Z0JBQ2Y2SixZQUFZO2dCQUNacUosYUFBYTtnQkFDYnZYLGtCQUFrQjtZQUNwQjtZQUNBLElBQUksQ0FBQ3dnQyxhQUFhLENBQUMsZ0NBQWdDdHpGLE1BQU0sQ0FBQ3EwRixRQUFRci9DLGFBQWEsRUFBRTtZQUNqRixJQUFJLENBQUMsQ0FBQ3IwQyxLQUFLMHpGLFFBQVE3SSxVQUFVLE1BQU0sUUFBUTdxRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrYixPQUFPLE1BQU1DLG1CQUFtQnc0RSxLQUFLLElBQUssRUFBQzEvRSxLQUFLNCtFLFFBQVE3SSxVQUFVLE1BQU0sUUFBUS8xRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzRSxNQUFNLEdBQUc7Z0JBQzFMLElBQUksQ0FBQ3U1RSxhQUFhLENBQUMsa0JBQWtCdHpGLE1BQU0sQ0FBQyxDQUFDMFYsS0FBSzIrRSxRQUFRN0ksVUFBVSxNQUFNLFFBQVE5MUUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcUUsTUFBTTtZQUN0SDtZQUNBLE1BQU00NUQsYUFBYTcwQixLQUFLO1FBQzFCO0lBQ0Y7QUFDRjtBQUVBLE1BQU1zMkMsd0JBQXdCMXRFLGNBQWM3RCxZQUFZO0lBQ3RENWlCLFlBQVkrNUIsR0FBRyxFQUFFbTNCLEtBQUssQ0FBRTtRQUN0QixLQUFLO1FBQ0wsSUFBSSxDQUFDa2pDLFlBQVksR0FBRyxJQUFJenNFO1FBQ3hCLElBQUksQ0FBQ29TLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNtM0IsS0FBSyxHQUFHQTtJQUNmO0lBQ0FtakMsaUJBQWlCO1FBQ2YsTUFBTUMsU0FBUyxJQUFJLENBQUNGLFlBQVksQ0FBQ3JzRSxJQUFJO1FBQ3JDLElBQUksQ0FBQ3FzRSxZQUFZLENBQUMvdEYsR0FBRyxDQUFDaXVGLFFBQVE7WUFDNUIzQyxNQUFNLEVBQUU7WUFDUjVrRCxRQUFReWtELFlBQVlFLElBQUk7WUFDeEI1NkYsTUFBTTtZQUNOdThCLGFBQWE7UUFDZjtRQUNBLE9BQU9paEU7SUFDVDtJQUNBQyxZQUFZQyxPQUFPLEVBQUU3NkYsSUFBSSxFQUFFO1FBQ3pCLElBQUksQ0FBQ3k2RixZQUFZLENBQUMvdEYsR0FBRyxDQUFDbXVGLFNBQVM3NkY7UUFDL0IsSUFBSSxDQUFDOHBCLElBQUksQ0FBQyxlQUFlK3dFLFNBQVM3NkY7SUFDcEM7SUFDQXc0RixZQUFZO1FBQ1YsT0FBTy8rRixNQUFNZzVDLElBQUksQ0FBQyxJQUFJLENBQUNnb0QsWUFBWSxDQUFDLzNGLE1BQU0sSUFBSTJWLEtBQUssQ0FBQ3RCLENBQUFBLElBQUtBLEVBQUVxOEIsTUFBTSxLQUFLeWtELFlBQVk1d0IsTUFBTTtJQUMxRjtJQUNBNnpCLGFBQWE7UUFDWCxPQUFPcmhHLE1BQU1nNUMsSUFBSSxDQUFDLElBQUksQ0FBQ2dvRCxZQUFZLENBQUMvM0YsTUFBTTtJQUM1QztJQUNBcTRGLGtCQUFrQkMsS0FBSyxFQUFFO1FBQ3ZCLE9BQU9yMEUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxNQUFNazBFLFVBQVUsSUFBSSxDQUFDSCxjQUFjO1lBQ25DLE1BQU1qL0YsT0FBTyxJQUFJdS9GLE1BQU0sSUFBSSxDQUFDNTZELEdBQUcsRUFBRSxJQUFJLENBQUNtM0IsS0FBSztZQUMzQyxNQUFNMGpDLGVBQWVqN0YsQ0FBQUE7Z0JBQ25CLElBQUksQ0FBQzQ2RixXQUFXLENBQUNDLFNBQVM3NkY7WUFDNUI7WUFDQXZFLEtBQUtzdkIsRUFBRSxDQUFDLFVBQVVrd0U7WUFDbEIsTUFBTS94RixTQUFTLE1BQU16TixLQUFLcTVELEdBQUc7WUFDN0JyNUQsS0FBS2t3QixHQUFHLENBQUMsVUFBVXN2RTtZQUNuQixPQUFPL3hGO1FBQ1Q7SUFDRjtJQUNBZ3lGLGlCQUFpQjtRQUNmLE9BQU92MEUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxPQUFPLElBQUksQ0FBQ28wRSxpQkFBaUIsQ0FBQ1Q7UUFDaEM7SUFDRjtJQUNBYSxjQUFjO1FBQ1osT0FBT3gwRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE9BQU8sSUFBSSxDQUFDbzBFLGlCQUFpQixDQUFDbEI7UUFDaEM7SUFDRjtJQUNBdUIsWUFBWTtRQUNWLE9BQU96MEUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxPQUFPLElBQUksQ0FBQ28wRSxpQkFBaUIsQ0FBQ3ZCO1FBQ2hDO0lBQ0Y7SUFDQTZCLGlCQUFpQjtRQUNmLE9BQU8xMEUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNyQyxPQUFPLElBQUksQ0FBQ28wRSxpQkFBaUIsQ0FBQzNCO1FBQ2hDO0lBQ0Y7SUFDQWtDLG9CQUFvQjtRQUNsQixPQUFPMzBFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDckMsT0FBTyxJQUFJLENBQUNvMEUsaUJBQWlCLENBQUMvQjtRQUNoQztJQUNGO0lBQ0F1QyxvQkFBb0I7UUFDbEIsT0FBTzUwRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3JDLE9BQU8sSUFBSSxDQUFDbzBFLGlCQUFpQixDQUFDNUI7UUFDaEM7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNxQyx5QkFBeUIxTyxVQUFVO0lBQzFDLElBQUl6b0YsVUFBVWxJLFVBQVVVLE1BQU0sR0FBRyxLQUFLVixTQUFTLENBQUMsRUFBRSxLQUFLSyxZQUFZTCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7SUFDbkYsSUFBSTRKO0lBQ0osTUFBTStwQixRQUFRZzlELHNCQUFzQnAvQixhQUFhby9CLFdBQVdwdUMsZ0JBQWdCLEdBQUdvdUM7SUFDL0UsTUFBTTJPLGdCQUFnQjNyRSxNQUFNMkwsV0FBVztJQUN2QyxJQUFJdnlCLFNBQVM7UUFDWDBvQixZQUFZLENBQUM3ckIsS0FBSzFCLFFBQVFxM0YsaUJBQWlCLE1BQU0sUUFBUTMxRixPQUFPLEtBQUssSUFBSUEsS0FBSztRQUM5RTQxRixZQUFZO0lBQ2Q7SUFDQSxnREFBZ0Q7SUFDaEQsSUFBSSxnQkFBZ0JGLGVBQWU7UUFDakMsTUFBTUcsZ0JBQWdCSCxjQUFjN3BFLFVBQVU7UUFDOUM3eEIsY0FBY2hELEtBQUssQ0FBQyxpQkFBaUI7WUFDbkM2K0Y7UUFDRjtRQUNBLElBQUlBLGlCQUFpQixPQUFPQSxrQkFBa0IsWUFBWUMsa0JBQWtCRCxnQkFBZ0I7WUFDMUYxeUYsU0FBUztnQkFDUDBvQixZQUFZZ3FFO2dCQUNaRCxZQUFZO1lBQ2Q7UUFDRjtJQUNGO0lBQ0EsNkZBQTZGO0lBQzdGLElBQUk7UUFBQztRQUFPO0tBQVMsQ0FBQ3ZwRSxRQUFRLENBQUNscEIsT0FBT3l5RixVQUFVLEdBQUc7UUFDakQ1N0YsY0FBY2hELEtBQUssQ0FBQyw4Q0FBOENxSSxNQUFNLENBQUMwcUIsTUFBTXFDLEtBQUssRUFBRTtRQUN0RixNQUFNMnBFLHNCQUFzQkMsMEJBQTBCanNFLE1BQU1xQyxLQUFLO1FBQ2pFLElBQUkycEUsd0JBQXdCdC9GLFdBQVc7WUFDckMwTSxTQUFTNHlGO1FBQ1g7SUFDRjtJQUNBLE9BQU81eUY7QUFDVDtBQUNBLE1BQU04eUYsb0JBQW9CLElBQUlodUUsSUFBSTtJQUFDO1FBQUM7UUFBc0I7WUFDeEQ0RCxZQUFZO1lBQ1orcEUsWUFBWTtRQUNkO0tBQUU7Q0FBQztBQUNILE1BQU1NLDJCQUEyQixJQUFJanVFLElBQUk7SUFBQztRQUFDO1FBQVU7WUFDbkQ0RCxZQUFZO1lBQ1orcEUsWUFBWTtRQUNkO0tBQUU7SUFBRTtRQUFDO1FBQVE7WUFDWC9wRSxZQUFZO1lBQ1orcEUsWUFBWTtRQUNkO0tBQUU7Q0FBQztBQUNIOzs7O0NBSUMsR0FDRCxTQUFTSSwwQkFBMEJHLFdBQVc7SUFDNUMsSUFBSW4yRjtJQUNKLE1BQU1vc0IsUUFBUStwRSxZQUFZOWtGLElBQUksR0FBRy9GLFdBQVc7SUFDNUMsNEVBQTRFO0lBQzVFLElBQUk4Z0IsVUFBVSxJQUFJO1FBQ2hCLE9BQU8zMUI7SUFDVDtJQUNBLG1EQUFtRDtJQUNuRCxJQUFJdy9GLGtCQUFrQjNoRixHQUFHLENBQUM4WCxRQUFRO1FBQ2hDLE9BQU82cEUsa0JBQWtCL2hHLEdBQUcsQ0FBQ2s0QjtJQUMvQjtJQUNBLHFEQUFxRDtJQUNyRCxPQUFPLENBQUNwc0IsS0FBS3RNLE1BQU1nNUMsSUFBSSxDQUFDd3BELHlCQUF5Qi83RixPQUFPLElBQUltUyxJQUFJLENBQUNqUyxDQUFBQTtRQUMvRCxJQUFJLENBQUMrN0YsUUFBUSxHQUFHLzdGO1FBQ2hCLE9BQU8reEIsTUFBTUMsUUFBUSxDQUFDK3BFO0lBQ3hCLEVBQUMsTUFBTyxRQUFRcDJGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUU7QUFDaEQ7QUFDQSxTQUFTODFGLGtCQUFrQnBuRixJQUFJO0lBQzdCLE1BQU0ybkYsZ0JBQWdCO1FBQUM7UUFBUTtRQUFlO1FBQVE7S0FBUTtJQUM5RCxPQUFPM25GLFNBQVNqWSxhQUFhNC9GLGNBQWNocUUsUUFBUSxDQUFDM2Q7QUFDdEQ7QUFFbzhDLENBQ3A4QywrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNraHViYi8uLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzPzI2ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG5cdG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XG5cdFx0XHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGxvZ2xldmVsID0ge2V4cG9ydHM6IHt9fTtcblxuLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG5cbiAgICBpZiAobW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG4gIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlICYmIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gaSA8IGxldmVsID8gbm9vcCA6IHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIGRlZmF1bHRMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgIHNlbGYubGV2ZWxzID0ge1xuICAgICAgICBcIlRSQUNFXCI6IDAsXG4gICAgICAgIFwiREVCVUdcIjogMSxcbiAgICAgICAgXCJJTkZPXCI6IDIsXG4gICAgICAgIFwiV0FSTlwiOiAzLFxuICAgICAgICBcIkVSUk9SXCI6IDQsXG4gICAgICAgIFwiU0lMRU5UXCI6IDVcbiAgICAgIH07XG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIH07XG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICB9XG4gICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIobmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgfSk7XG59KShsb2dsZXZlbCk7XG52YXIgbG9nbGV2ZWxFeHBvcnRzID0gbG9nbGV2ZWwuZXhwb3J0cztcblxudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcInRyYWNlXCJdID0gMF0gPSBcInRyYWNlXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZGVidWdcIl0gPSAxXSA9IFwiZGVidWdcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJpbmZvXCJdID0gMl0gPSBcImluZm9cIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ3YXJuXCJdID0gM10gPSBcIndhcm5cIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJlcnJvclwiXSA9IDRdID0gXCJlcnJvclwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcInNpbGVudFwiXSA9IDVdID0gXCJzaWxlbnRcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG52YXIgTG9nZ2VyTmFtZXM7XG4oZnVuY3Rpb24gKExvZ2dlck5hbWVzKSB7XG4gIExvZ2dlck5hbWVzW1wiRGVmYXVsdFwiXSA9IFwibGl2ZWtpdFwiO1xuICBMb2dnZXJOYW1lc1tcIlJvb21cIl0gPSBcImxpdmVraXQtcm9vbVwiO1xuICBMb2dnZXJOYW1lc1tcIlBhcnRpY2lwYW50XCJdID0gXCJsaXZla2l0LXBhcnRpY2lwYW50XCI7XG4gIExvZ2dlck5hbWVzW1wiVHJhY2tcIl0gPSBcImxpdmVraXQtdHJhY2tcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQdWJsaWNhdGlvblwiXSA9IFwibGl2ZWtpdC10cmFjay1wdWJsaWNhdGlvblwiO1xuICBMb2dnZXJOYW1lc1tcIkVuZ2luZVwiXSA9IFwibGl2ZWtpdC1lbmdpbmVcIjtcbiAgTG9nZ2VyTmFtZXNbXCJTaWduYWxcIl0gPSBcImxpdmVraXQtc2lnbmFsXCI7XG4gIExvZ2dlck5hbWVzW1wiUENNYW5hZ2VyXCJdID0gXCJsaXZla2l0LXBjLW1hbmFnZXJcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQQ1RyYW5zcG9ydFwiXSA9IFwibGl2ZWtpdC1wYy10cmFuc3BvcnRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJFMkVFXCJdID0gXCJsay1lMmVlXCI7XG59KShMb2dnZXJOYW1lcyB8fCAoTG9nZ2VyTmFtZXMgPSB7fSkpO1xubGV0IGxpdmVraXRMb2dnZXIgPSBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsaXZla2l0Jyk7XG5saXZla2l0TG9nZ2VyLnNldERlZmF1bHRMZXZlbChMb2dMZXZlbC5pbmZvKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIobmFtZSk7XG4gIGxvZ2dlci5zZXREZWZhdWx0TGV2ZWwobGl2ZWtpdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gIGlmIChsb2dnZXJOYW1lKSB7XG4gICAgbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihsb2dnZXJOYW1lKS5zZXRMZXZlbChsZXZlbCk7XG4gIH1cbiAgZm9yIChjb25zdCBsb2dnZXIgb2YgT2JqZWN0LmVudHJpZXMobG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcnMoKSkuZmlsdGVyKF9yZWYgPT4ge1xuICAgIGxldCBbbG9nck5hbWVdID0gX3JlZjtcbiAgICByZXR1cm4gbG9nck5hbWUuc3RhcnRzV2l0aCgnbGl2ZWtpdCcpO1xuICB9KS5tYXAoX3JlZjIgPT4ge1xuICAgIGxldCBbLCBsb2dyXSA9IF9yZWYyO1xuICAgIHJldHVybiBsb2dyO1xuICB9KSkge1xuICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG4gIH1cbn1cbi8qKlxuICogdXNlIHRoaXMgdG8gaG9vayBpbnRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uIHRvIGFsbG93IHNlbmRpbmcgaW50ZXJuYWwgbGl2ZWtpdCBsb2dzIHRvIHRoaXJkIHBhcnR5IHNlcnZpY2VzXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxuICovXG5mdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG4gIGxldCBsb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGxpdmVraXRMb2dnZXI7XG4gIGNvbnN0IG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuICBsb2dnZXIubWV0aG9kRmFjdG9yeSA9IChtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgY29uc3QgbG9nTGV2ZWwgPSBMb2dMZXZlbFttZXRob2ROYW1lXTtcbiAgICBjb25zdCBuZWVkTG9nID0gbG9nTGV2ZWwgPj0gY29uZmlnTGV2ZWwgJiYgbG9nTGV2ZWwgPCBMb2dMZXZlbC5zaWxlbnQ7XG4gICAgcmV0dXJuIChtc2csIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtlbHNlIHJhd01ldGhvZChtc2cpO1xuICAgICAgaWYgKG5lZWRMb2cpIHtcbiAgICAgICAgZXh0ZW5zaW9uKGxvZ0xldmVsLCBtc2csIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGxvZ2dlci5zZXRMZXZlbChsb2dnZXIuZ2V0TGV2ZWwoKSk7IC8vIEJlIHN1cmUgdG8gY2FsbCBzZXRMZXZlbCBtZXRob2QgaW4gb3JkZXIgdG8gYXBwbHkgcGx1Z2luXG59XG5sb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsay1lMmVlJyk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LFxuICBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsXG4gIFVJTlQzMl9NQVggPSAweGZmZmZmZmZmLFxuICBJTlQzMl9NQVggPSAweDdmZmZmZmZmLFxuICBJTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHVuc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IFVJTlQzMl9NQVggfHwgYXJnIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgcHJvdG9idWYgZmxvYXQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEZsb2F0MzIoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKSByZXR1cm47XG4gIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jb25zdCBlbnVtVHlwZVN5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi9lbnVtLXR5cGVcIik7XG4vKipcbiAqIEdldCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIGZyb20gYSBnZW5lcmF0ZWQgZW51bS5cbiAqIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgZ2VuZXJhdGVkXG4gKiBlbnVtLCBpdCByYWlzZXMgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCB0ID0gZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF07XG4gIGFzc2VydCh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICByZXR1cm4gdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxufVxuLyoqXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gb24gYSBnZW5lcmF0ZWQgZW51bS5cbiAqL1xuZnVuY3Rpb24gc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF0gPSBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcy5tYXAodiA9PiAoe1xuICAgIG5vOiB2Lm5vLFxuICAgIG5hbWU6IHYubmFtZSxcbiAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub11cbiAgfSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEVudW1UeXBlIHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5fb3B0KSB7XG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbnVtYmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5vcm1hbFZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gY29uc3QgdmFsdWU6IEVudW1WYWx1ZUluZm8gPSB7Li4udiwgb3B0aW9uczogdi5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3R9O1xuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgIG5vcm1hbFZhbHVlcy5wdXNoKG4pO1xuICAgIG5hbWVzW3ZhbHVlLm5hbWVdID0gbjtcbiAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlTmFtZSxcbiAgICB2YWx1ZXM6IG5vcm1hbFZhbHVlcyxcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgIC8vIG9wdGlvbnM6IG9wdD8ub3B0aW9ucyA/PyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGZpbmROYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcbiAgICB9LFxuICAgIGZpbmROdW1iZXIobm8pIHtcbiAgICAgIHJldHVybiBudW1iZXJzW25vXTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbnVtIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnVtKHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgZW51bU9iamVjdFtuLmxvY2FsTmFtZV0gPSBuLm5vO1xuICAgIGVudW1PYmplY3Rbbi5ub10gPSBuLmxvY2FsTmFtZTtcbiAgfVxuICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzKTtcbiAgcmV0dXJuIGVudW1PYmplY3Q7XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpIHtcbiAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7XG4gICAgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lXG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBNZXNzYWdlIGlzIHRoZSBiYXNlIGNsYXNzIG9mIGV2ZXJ5IG1lc3NhZ2UsIGdlbmVyYXRlZCwgb3IgY3JlYXRlZCBhdFxuICogcnVudGltZS5cbiAqXG4gKiBJdCBpcyBfbm90XyBzYWZlIHRvIGV4dGVuZCB0aGlzIGNsYXNzLiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBtZXNzYWdlIGF0XG4gKiBydW4gdGltZSwgdXNlIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoKS5cbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmVxdWFscyh0aGlzLmdldFR5cGUoKSwgdGhpcywgb3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICpcbiAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgKiBleGlzdGluZyBrZXlzLlxuICAgKlxuICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgKiBuZXcgZGF0YS5cbiAgICovXG4gIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodGhpcywgb3B0LnJlYWRlckZhY3RvcnkoYnl0ZXMpLCBieXRlcy5ieXRlTGVuZ3RoLCBvcHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAqL1xuICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbixcbiAgICAgIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBcIi5jb25jYXQodGhpcy5nZXRUeXBlKCkudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cbiAgICovXG4gIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICB3cml0ZXIgPSBvcHQud3JpdGVyRmFjdG9yeSgpO1xuICAgIGJpbi53cml0ZU1lc3NhZ2UodGhpcywgd3JpdGVyLCBvcHQpO1xuICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cbiAgICovXG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAganNvbiA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIHRvSnNvblN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldHR5U3BhY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZm9yIHNlcmlhbGl6YXRpb24gYmVoYXZpb3IuIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW4gY2FsbGluZ1xuICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHNlcmlhbGl6ZSBnb29nbGUucHJvdG9idWYuQW55IHdpdGggYSBwYWNrZWRcbiAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgKiB1bnBhY2tlZCwgYW5kIHRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgdHlwZSByZWdpc3RyeSB0byBsb29rIHVwIHRoZVxuICAgKiBtZXNzYWdlIHR5cGUuICBBcyBhIHJlc3VsdCwgYXR0ZW1wdGluZyB0byBzZXJpYWxpemUgYSBtZXNzYWdlIHdpdGggdGhpc1xuICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHByb3RlY3RlZCBiZWNhdXNlIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gaW52b2tlIGl0XG4gICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICogc3RyaW5naWZpZWQgSlNPTi4gIEFsdGVybmF0aXZlbHksIGlmIGFjdHVhbCBKU09OIGlzIGRlc2lyZWQsIHlvdSBzaG91bGRcbiAgICogdXNlIHRvSnNvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIE1lc3NhZ2VUeXBlIG9mIHRoaXMgbWVzc2FnZSAtIGEgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50c1xuICAgKiB0aGUgcHJvdG9idWYgbWVzc2FnZSBkZWNsYXJhdGlvbiBhbmQgcHJvdmlkZXMgbWV0YWRhdGEgZm9yIHJlZmxlY3Rpb24tXG4gICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIHR5cGUgdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNZXNzYWdlVHlwZShydW50aW1lLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBsb2NhbE5hbWUgPSAoX2EgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlTmFtZS5zdWJzdHJpbmcodHlwZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gIGNvbnN0IHR5cGUgPSB7XG4gICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBydW50aW1lLnV0aWwuaW5pdEZpZWxkcyh0aGlzKTtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gIH1bbG9jYWxOYW1lXTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcbiAgT2JqZWN0LmFzc2lnbih0eXBlLCB7XG4gICAgcnVudGltZSxcbiAgICB0eXBlTmFtZSxcbiAgICBmaWVsZHM6IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoZmllbGRzKSxcbiAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIGpzb24sIGJpbiwgdXRpbCkge1xuICByZXR1cm4ge1xuICAgIHN5bnRheCxcbiAgICBqc29uLFxuICAgIGJpbixcbiAgICB1dGlsLFxuICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICB9LFxuICAgIG1ha2VFbnVtLFxuICAgIG1ha2VFbnVtVHlwZSxcbiAgICBnZXRFbnVtVHlwZVxuICB9O1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBTY2FsYXIgdmFsdWUgdHlwZXMuIFRoaXMgaXMgYSBzdWJzZXQgb2YgZmllbGQgdHlwZXMgZGVjbGFyZWQgYnkgcHJvdG9idWZcbiAqIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgVGhlIHR5cGVzIEdST1VQIGFuZCBNRVNTQUdFXG4gKiBhcmUgb21pdHRlZCwgYnV0IHRoZSBudW1lcmljYWwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKi9cbnZhciBTY2FsYXJUeXBlO1xuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XG4gIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9ycy5cbiAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGTE9BVFwiXSA9IDJdID0gXCJGTE9BVFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDY0XCJdID0gM10gPSBcIklOVDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXG4gIC8vIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbGlrZWx5LlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRklYRUQzMlwiXSA9IDddID0gXCJGSVhFRDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XG4gIC8vIFRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcbiAgLy8gdHJlYXQgZ3JvdXAgZmllbGRzIGFzIHVua25vd24gZmllbGRzLlxuICAvLyBUWVBFX0dST1VQID0gMTAsXG4gIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIE5ldyBpbiB2ZXJzaW9uIDIuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAvLyBUWVBFX0VOVU0gPSAxNCxcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UMzJcIl0gPSAxN10gPSBcIlNJTlQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbnZhciBMb25nVHlwZTtcbihmdW5jdGlvbiAoTG9uZ1R5cGUpIHtcbiAgLyoqXG4gICAqIFVzZSBKYXZhU2NyaXB0IEJpZ0ludC5cbiAgICovXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgU3RyaW5nLlxuICAgKlxuICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19TVFJJTkddYC5cbiAgICovXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gIH1cbiAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xuICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gIH1cbiAgZm9yIChsZXQgc2hpZnQgPSAzOyBzaGlmdCA8PSAzMTsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3BsaXRCaXRzID0gbG8gPj4+IDI4ICYgMHgwZiB8IChoaSAmIDB4MDcpIDw8IDQ7XG4gIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XG4gIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGJ5dGVzLnB1c2goaGkgPj4+IDMxICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xuICBpZiAobWludXMpIHtcbiAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gIH1cbiAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAvLyBkaWdpdHMgdG8gYmluYXJ5LiBUaGlzIGlzIHNhZmUgdG8gZG8gd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoIGJlY2F1c2VcbiAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gIGNvbnN0IGJhc2UgPSAxZTY7XG4gIGxldCBsb3dCaXRzID0gMDtcbiAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xuICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cbiAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArIChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbiAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XG4gICAgfVxuICB9XG4gIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICBhZGQxZTZkaWdpdCgtMTIsIC02KTtcbiAgYWRkMWU2ZGlnaXQoLTYpO1xuICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgLy8gYSBtYW51YWwgdHdvJ3MgY29tcGxlbWVudCBjb252ZXJzaW9uIGJlZm9yZSB0aGUgZGVjaW1hbCBjb252ZXJzaW9uLlxuICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAoe1xuICAgIGxvLFxuICAgIGhpXG4gIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xuICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXG4gIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cbiAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xuICB9XG4gIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgY29uc3QgbG93ID0gbG8gJiAweEZGRkZGRjtcbiAgY29uc3QgbWlkID0gKGxvID4+PiAyNCB8IGhpIDw8IDgpICYgMHhGRkZGRkY7XG4gIGNvbnN0IGhpZ2ggPSBoaSA+PiAxNiAmIDB4RkZGRjtcbiAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgbGV0IGRpZ2l0QSA9IGxvdyArIG1pZCAqIDY3NzcyMTYgKyBoaWdoICogNjcxMDY1NjtcbiAgbGV0IGRpZ2l0QiA9IG1pZCArIGhpZ2ggKiA4MTQ3NDk3O1xuICBsZXQgZGlnaXRDID0gaGlnaCAqIDI7XG4gIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgIGRpZ2l0QSAlPSBiYXNlO1xuICB9XG4gIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgIGRpZ2l0QiAlPSBiYXNlO1xuICB9XG4gIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxuICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcbn1cbmZ1bmN0aW9uIHRvVW5zaWduZWQobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvID4+PiAwLFxuICAgIGhpOiBoaSA+Pj4gMFxuICB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgcmV0dXJuIHtcbiAgICBsbzogbG8gfCAwLFxuICAgIGhpOiBoaSB8IDBcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gIGlmIChsb3dCaXRzKSB7XG4gICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBsb3dCaXRzIGlzIDAsIHRoZW4gYml0d2lzZS1ub3QgaXMgMHhGRkZGRkZGRixcbiAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICBoaWdoQml0cyArPSAxO1xuICB9XG4gIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gZGlnaXQxZTcgPT4ge1xuICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMTI3IHwgMTI4KTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICB9XG4gICAgYnl0ZXMucHVzaCgxKTtcbiAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHgwZikgPDwgMjg7XG4gIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKSBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGlmICgoYiAmIDB4ODApICE9IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgLy8gbm90ZSB0aGF0IFNhZmFyaSAxNCBpbXBsZW1lbnRzIEJpZ0ludCwgYnV0IG5vdCB0aGUgRGF0YVZpZXcgbWV0aG9kc1xuICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwcm9jZXNzLmVudiAhPSBcIm9iamVjdFwiIHx8IHByb2Nlc3MuZW52LkJVRl9CSUdJTlRfRElTQUJMRSAhPT0gXCIxXCIpO1xuICBpZiAob2spIHtcbiAgICBjb25zdCBNSU4gPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSxcbiAgICAgIE1BWCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIiksXG4gICAgICBVTUlOID0gQmlnSW50KFwiMFwiKSxcbiAgICAgIFVNQVggPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGJpID4gTUFYIHx8IGJpIDwgTUlOKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgfSxcbiAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBpZiAoYmkgPiBVTUFYIHx8IGJpIDwgVU1JTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmk7XG4gICAgICB9LFxuICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMucGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnVQYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkdi5nZXRCaWdVaW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdCBhc3NlcnRJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgcmV0dXJuIHtcbiAgICB6ZXJvOiBcIjBcIixcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdUVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuICAgIGRlYyhsbywgaGkpIHtcbiAgICAgIHJldHVybiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfSxcbiAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgcHJvdG9JbnQ2NCA9IG1ha2VJbnQ2NFN1cHBvcnQoKTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbnZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAvKipcbiAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICpcbiAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xuICAgIC8qKlxuICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAqL1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmJ1ZiA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTsgLy8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlcy5zZXQodGhpcy5jaHVua3NbaV0sIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHJldHVybiBieXRlcztcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXG4gICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgKlxuICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxuICAgKi9cbiAgZm9yaygpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgY2h1bmtzOiB0aGlzLmNodW5rcyxcbiAgICAgIGJ1ZjogdGhpcy5idWZcbiAgICB9KTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICovXG4gIGpvaW4oKSB7XG4gICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLmZpbmlzaCgpO1xuICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgaWYgKCFwcmV2KSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XG4gICAgdGhpcy5idWYgPSBwcmV2LmJ1ZjtcbiAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGVzIGEgdGFnIChmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZSkuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgKlxuICAgKiBHZW5lcmF0ZWQgY29kZSBzaG91bGQgY29tcHV0ZSB0aGUgdGFnIGFoZWFkIG9mIHRpbWUgYW5kIGNhbGwgYHVpbnQzMigpYC5cbiAgICovXG4gIHRhZyhmaWVsZE5vLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgKi9cbiAgcmF3KGNodW5rKSB7XG4gICAgaWYgKHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpO1xuICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMiwgaW5saW5lZCBmb3Igc3BlZWRcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlICYgMHg3ZiB8IDB4ODApO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICB9XG4gICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGludDMyYCB2YWx1ZSwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIGludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2wodmFsdWUpIHtcbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAqL1xuICBieXRlcyh2YWx1ZSkge1xuICAgIHRoaXMudWludDMyKHZhbHVlLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgKi9cbiAgc3RyaW5nKHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZmxvYXQodmFsdWUpIHtcbiAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldFVpbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLFxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxuICAgICAgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpLFxuICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgc2lnbiA9IHRjLmhpID4+IDMxLFxuICAgICAgbG8gPSB0Yy5sbyA8PCAxIF4gc2lnbixcbiAgICAgIGhpID0gKHRjLmhpIDw8IDEgfCB0Yy5sbyA+Pj4gMzEpIF4gc2lnbjtcbiAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGB1aW50NjRgIHZhbHVlLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgdWludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cbiAgICovXG4gIHRhZygpIHtcbiAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSxcbiAgICAgIGZpZWxkTm8gPSB0YWcgPj4+IDMsXG4gICAgICB3aXJlVHlwZSA9IHRhZyAmIDc7XG4gICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xuICB9XG4gIC8qKlxuICAgKiBTa2lwIG9uZSBlbGVtZW50IG9uIHRoZSB3aXJlIGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cbiAgICogU3VwcG9ydHMgV2lyZVR5cGUuU3RhcnRHcm91cCBzaW5jZSB2Mi4wLjAtYWxwaGEuMjMuXG4gICAqL1xuICBza2lwKHdpcmVUeXBlKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDB4ODApIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0MzI6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAvLyBGcm9tIGRlc2NyaXB0b3IucHJvdG86IEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCwgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuXG4gICAgICAgIC8vIEJ1dCB3ZSBtdXN0IHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgYW5kIHRyZWF0IGFzIHVua25vd24uXG4gICAgICAgIGxldCB0O1xuICAgICAgICB3aGlsZSAoKHQgPSB0aGlzLnRhZygpWzFdKSAhPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICB0aGlzLnNraXAodCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqL1xuICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIoKSB7XG4gICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgIHJldHVybiB6emUgPj4+IDEgXiAtKHp6ZSAmIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIGludDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHVpbnQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQ2NCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICBsbyA9IChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHM7XG4gICAgaGkgPSBoaSA+Pj4gMSBeIHM7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2woKSB7XG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGZsb2F0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDY0KCh0aGlzLnBvcyArPSA4KSAtIDgsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGJ5dGVzYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKCkge1xuICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLFxuICAgICAgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UgfHwgIXR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuKHtcbiAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjogU2NhbGFyVHlwZS5GTE9BVCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDY0LFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDMyLFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQzMixcbiAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjogU2NhbGFyVHlwZS5TVFJJTkcsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogU2NhbGFyVHlwZS5CWVRFU1xufSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgIHJldHVybiBhID09IGI7XG4gIH1cbiAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUsIGZvbGxvd2luZ1xuICogcHJvdG8zIHNlbWFudGljcy5cbiAqL1xuZnVuY3Rpb24gc2NhbGFyRGVmYXVsdFZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPT0gMCA/IHByb3RvSW50NjQuemVybyA6IFwiMFwiO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIDAuMDtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlIGZvciBwcm90bzMgc2VtYW50aWNzXG4gKlxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICovXG5mdW5jdGlvbiBzY2FsYXJUeXBlSW5mbyh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBpc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gIGxldCB3aXJlVHlwZSA9IFdpcmVUeXBlLlZhcmludDtcbiAgbGV0IGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUubGVuZ3RoO1xuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCBtZXRob2QgPSBTY2FsYXJUeXBlW3R5cGVdLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBbd2lyZVR5cGUsIG1ldGhvZCwgaXNVbmRlZmluZWQgfHwgaXNJbnRyaW5zaWNEZWZhdWx0XTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBuby1jYXNlLWRlY2xhcmF0aW9ucywgcHJlZmVyLWNvbnN0ICovXG5jb25zdCB1bmtub3duRmllbGRzU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL3Vua25vd24tZmllbGRzXCIpO1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIGJpbmFyeSBkYXRhLlxuY29uc3QgcmVhZERlZmF1bHRzID0ge1xuICByZWFkVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgcmVhZGVyRmFjdG9yeTogYnl0ZXMgPT4gbmV3IEJpbmFyeVJlYWRlcihieXRlcylcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcbiAgd3JpdGVVbmtub3duRmllbGRzOiB0cnVlLFxuICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKClcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMkMShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMkMShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtYWtlUmVhZE9wdGlvbnM6IG1ha2VSZWFkT3B0aW9ucyQxLFxuICAgIG1ha2VXcml0ZU9wdGlvbnM6IG1ha2VXcml0ZU9wdGlvbnMkMSxcbiAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfSxcbiAgICBkaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICB9LFxuICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICBpZiAoYykge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xuICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSkge1xuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcbiAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgfVxuICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHtcbiAgICAgICAgbm8sXG4gICAgICAgIHdpcmVUeXBlLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKSxcbiAgICAgICAgICBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsXG4gICAgICAgICAgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCxcbiAgICAgICAgICBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgICAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXIkMTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5MID4gMCkge1xuICAgICAgICAgICAgICByZWFkID0gcmVhZFNjYWxhckxUU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgbGV0IGUgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xuICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkKHJlYWRlciwgc2NhbGFyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0ucHVzaChyZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vLyBSZWFkIGEgbWVzc2FnZSwgYXZvaWRpbmcgTWVzc2FnZVR5cGUuZnJvbUJpbmFyeSgpIHRvIHJlLXVzZSB0aGVcbi8vIEJpbmFyeVJlYWRPcHRpb25zIGFuZCB0aGUgSUJpbmFyeVJlYWRlci5cbmZ1bmN0aW9uIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSxcbiAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICBsZXQga2V5LCB2YWw7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgbGV0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAga2V5ID0gcmVhZFNjYWxhciQxKHJlYWRlciwgZmllbGQuSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIkMShyZWFkZXIsIGZpZWxkLlYuVCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgdmFsID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleVJhdyA9IHNjYWxhckRlZmF1bHRWYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xuICAgIGtleSA9IGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MID8ga2V5UmF3LnRvU3RyaW5nKCkgOiBrZXlSYXc7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9IFwibnVtYmVyXCIpIHtcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB2YWwgPSBzY2FsYXJEZWZhdWx0VmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgdmFsID0gbmV3IGZpZWxkLlYuVCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgY29uc3QgdiA9IHJlYWRTY2FsYXIkMShyZWFkZXIsIHR5cGUpO1xuICByZXR1cm4gdHlwZW9mIHYgPT0gXCJiaWdpbnRcIiA/IHYudG9TdHJpbmcoKSA6IHY7XG59XG4vLyBEb2VzIG5vdCB1c2Ugc2NhbGFyVHlwZUluZm8oKSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHJlYWRlciwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gcmVhZGVyLmRvdWJsZSgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5pbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbHVlKSB7XG4gIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gIHdyaXRlci5mb3JrKCk7XG4gIC8vIGphdmFzY3JpcHQgb25seSBhbGxvd3MgbnVtYmVyIG9yIHN0cmluZyBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgLy8gd2UgY29udmVydCBmcm9tIG91ciByZXByZXNlbnRhdGlvbiB0byB0aGUgcHJvdG9idWYgdHlwZVxuICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIHdlIGRlbGliZXJhdGVseSBoYW5kbGUganVzdCB0aGUgc3BlY2lhbCBjYXNlcyBmb3IgbWFwIGtleXNcbiAgc3dpdGNoIChmaWVsZC5LKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICBhc3NlcnQoa2V5ID09IFwidHJ1ZVwiIHx8IGtleSA9PSBcImZhbHNlXCIpO1xuICAgICAga2V5VmFsdWUgPSBrZXkgPT0gXCJ0cnVlXCI7XG4gICAgICBicmVhaztcbiAgfVxuICAvLyB3cml0ZSBrZXksIGV4cGVjdGluZyBrZXkgZmllbGQgbnVtYmVyID0gMVxuICB3cml0ZVNjYWxhciQxKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUsIHRydWUpO1xuICAvLyB3cml0ZSB2YWx1ZSwgZXhwZWN0aW5nIHZhbHVlIGZpZWxkIG51bWJlciA9IDJcbiAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICB3cml0ZVNjYWxhciQxKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIFNjYWxhclR5cGUuSU5UMzIsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlYuVCwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cbmZ1bmN0aW9uIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKTtcbiAgICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kLCBpc0ludHJpbnNpY0RlZmF1bHRdID0gc2NhbGFyVHlwZUluZm8odHlwZSwgdmFsdWUpO1xuICBpZiAoIWlzSW50cmluc2ljRGVmYXVsdCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIHdyaXRlci50YWcoZmllbGRObywgd2lyZVR5cGUpW21ldGhvZF0odmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMsIHByZWZlci1jb25zdCwgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXRQcm90bzMoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VCaW5hcnlGb3JtYXRDb21tb24oKSksIHtcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgbGV0IHZhbHVlLFxuICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBvdXIgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3IgcmVndWxhciBmaWVsZFxuICAgICAgICAgIHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQsXG4gICAgICAgICAgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICBpZiAob25lb2YuY2FzZSAhPT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZmllbGQgaXMgbm90IHNlbGVjdGVkLCBza2lwXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gb25lb2YudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBtZXNzYWdlW2xvY2FsTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCwgZmllbGQubm8sIGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlQsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBwcmVmZXItY29uc3QgKi9cbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxubGV0IGVuY1RhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuc3BsaXQoXCJcIik7XG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyICpjb2RlKiB0byBieXRlIGJlY2F1c2UgbG9va3VwIGJ5IG51bWJlciBpcyBmYXN0XG5sZXQgZGVjVGFibGUgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgZW5jVGFibGUubGVuZ3RoOyBpKyspIGRlY1RhYmxlW2VuY1RhYmxlW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbi8vIHN1cHBvcnQgYmFzZTY0dXJsIHZhcmlhbnRzXG5kZWNUYWJsZVtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIrXCIpO1xuZGVjVGFibGVbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiL1wiKTtcbmNvbnN0IHByb3RvQmFzZTY0ID0ge1xuICAvKipcbiAgICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICAgKlxuICAgKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICAgKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAgICogLSBkb2VzIG5vdCByZXF1aXJlIHBhZGRpbmdcbiAgICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gICAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAgICogICBcIl9cIiBpbnN0ZWFkIG9mIFwiL1wiLFxuICAgKiAgIG5vIHBhZGRpbmdcbiAgICovXG4gIGRlYyhiYXNlNjRTdHIpIHtcbiAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgbGV0IGVzID0gYmFzZTY0U3RyLmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09IFwiPVwiKSBlcyAtPSAyO2Vsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpIGVzIC09IDE7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLFxuICAgICAgYnl0ZVBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgICBncm91cFBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgIGIsXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcbiAgICAgIHAgPSAwOyAvLyBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBkZWNUYWJsZVtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV07XG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAvLyByZXNldCBzdGF0ZSB3aGVuIHBhZGRpbmcgZm91bmRcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gcCA8PCAyIHwgKGIgJiA0OCkgPj4gNDtcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAxNSkgPDwgNCB8IChiICYgNjApID4+IDI7XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMykgPDwgNiB8IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbiAgfSxcbiAgLyoqXG4gICAqIEVuY29kZSBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICAgKi9cbiAgZW5jKGJ5dGVzKSB7XG4gICAgbGV0IGJhc2U2NCA9IFwiXCIsXG4gICAgICBncm91cFBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgIGIsXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcbiAgICAgIHAgPSAwOyAvLyBjYXJyeSBvdmVyIGZyb20gcHJldmlvdXMgYnl0ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBieXRlc1tpXTtcbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiID4+IDJdO1xuICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDRdO1xuICAgICAgICAgIHAgPSAoYiAmIDE1KSA8PCAyO1xuICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA2XTtcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBvdXRwdXQgcGFkZGluZ1xuICAgIGlmIChncm91cFBvcykge1xuICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgaWYgKGdyb3VwUG9zID09IDEpIGJhc2U2NCArPSBcIj1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfVxufTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBKU09OLlxuY29uc3QganNvblJlYWREZWZhdWx0cyA9IHtcbiAgaWdub3JlVW5rbm93bkZpZWxkczogZmFsc2Vcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIHRvIEpTT04uXG5jb25zdCBqc29uV3JpdGVEZWZhdWx0cyA9IHtcbiAgZW1pdERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICBwcmV0dHlTcGFjZXM6IDBcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvblJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDoganNvblJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXRDb21tb24obWFrZVdyaXRlRmllbGQpIHtcbiAgY29uc3Qgd3JpdGVGaWVsZCA9IG1ha2VXcml0ZUZpZWxkKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpO1xuICByZXR1cm4ge1xuICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICBtYWtlV3JpdGVPcHRpb25zLFxuICAgIHJlYWRNZXNzYWdlKHR5cGUsIGpzb24sIG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgICAgIGlmIChqc29uID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShqc29uKSB8fCB0eXBlb2YganNvbiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvbikpKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgY29uc3Qgb25lb2ZTZWVuID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtqc29uS2V5LCBqc29uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24pKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZEpzb25OYW1lKGpzb25LZXkpO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNlZW4gPSBvbmVvZlNlZW5bZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IG11bHRpcGxlIGtleXMgZm9yIG9uZW9mIFxcXCJcIikuY29uY2F0KGZpZWxkLm9uZW9mLm5hbWUsIFwiXFxcIiBwcmVzZW50OiBcXFwiXCIpLmNvbmNhdChzZWVuLCBcIlxcXCIsIFxcXCJcIikuY29uY2F0KGpzb25LZXksIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ganNvbktleTtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgIGNhc2U6IGxvY2FsTmFtZVxuICAgICAgICAgIH07XG4gICAgICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChqc29uSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25JdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIFwibWFwXCIgaXMgaW52YWxpZCBmb3IgcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5ULmZyb21Kc29uKGpzb25JdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvbkl0ZW0sIGZpZWxkLkwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25JdGVtKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkgfHwgdHlwZW9mIGpzb25WYWx1ZSAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25WYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQuZnJvbUpzb24oanNvbk1hcFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0TWFwW3JlYWRTY2FsYXIoZmllbGQuSywgZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wgPyBqc29uTWFwS2V5ID09IFwidHJ1ZVwiID8gdHJ1ZSA6IGpzb25NYXBLZXkgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiBqc29uTWFwS2V5IDoganNvbk1hcEtleSwgTG9uZ1R5cGUuQklHSU5UKS50b1N0cmluZygpXSA9IHZhbDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvblZhbHVlKSk7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBudWxsIGlzIGludmFsaWQgZm9yIG9uZW9mIGZpZWxkIFxcXCJcIikuY29uY2F0KGpzb25LZXksIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBlbnVtVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkU2NhbGFyKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgbGV0IGZpZWxkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgIGxldCBqc29uVmFsdWU7XG4gICAgICAgICAgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgY29uc3Qgb25lb2YgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG9uZW9mLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZCA9IG1lbWJlci5maW5kRmllbGQob25lb2YuY2FzZSk7XG4gICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgIHRocm93IFwib25lb2YgY2FzZSBub3QgZm91bmQ6IFwiICsgb25lb2YuY2FzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZmllbGQsIG9uZW9mLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmllbGQgPSBtZW1iZXI7XG4gICAgICAgICAgICBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBmaWVsZCA/IFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBKU09OXCIpIDogXCJjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIHRvIEpTT05cIik7XG4gICAgICAgIGNvbnN0IHIgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IFwiOiBcIi5jb25jYXQocikgOiBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIHJlYWRTY2FsYXIsXG4gICAgd3JpdGVTY2FsYXIsXG4gICAgZGVidWc6IGRlYnVnSnNvblZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBkZWJ1Z0pzb25WYWx1ZShqc29uKSB7XG4gIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShqc29uKSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGpzb24ubGVuZ3RoID4gMTAwID8gXCJzdHJpbmdcIiA6IFwiXFxcIlwiLmNvbmNhdChqc29uLnNwbGl0KCdcIicpLmpvaW4oJ1xcXFxcIicpLCBcIlxcXCJcIik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XG4gIH1cbn1cbi8vIE1heSB0aHJvdyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIG1lc3NhZ2UgaXMgbm9uLWJsYW5rLCBpdCBzaG91bGQgYmUgc2hvd24uXG4vLyBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIHByb3ZpZGUgY29udGV4dC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgLy8gZXZlcnkgdmFsaWQgY2FzZSBpbiB0aGUgc3dpdGNoIGJlbG93IHJldHVybnMsIGFuZCBldmVyeSBmYWxsXG4gIC8vIHRocm91Z2ggaXMgcmVnYXJkZWQgYXMgYSBmYWlsdXJlLlxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gMC4wO1xuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gMDtcbiAgICAgIGxldCBpbnQzMjtcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKSBpbnQzMiA9IGpzb247ZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICByZXR1cm4gaW50MzI7XG4gICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICBjb25zdCBsb25nID0gcHJvdG9JbnQ2NC5wYXJzZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBsb25nVHlwZSA/IGxvbmcudG9TdHJpbmcoKSA6IGxvbmc7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICBjb25zdCB1TG9uZyA9IHByb3RvSW50NjQudVBhcnNlKGpzb24pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xuICAgIC8vIGJvb2w6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICBpZiAoanNvbiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIikgYnJlYWs7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEEgc3RyaW5nIG11c3QgYWx3YXlzIGNvbnRhaW4gVVRGLTggZW5jb2RlZCBvciA3LWJpdCBBU0NJSS5cbiAgICAgIC8vIFdlIHZhbGlkYXRlIHdpdGggZW5jb2RlVVJJQ29tcG9uZW50LCB3aGljaCBhcHBlYXJzIHRvIGJlIHRoZSBmYXN0ZXN0IHdpZGVseSBhdmFpbGFibGUgb3B0aW9uLlxuICAgICAgdHJ5IHtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGlmIChqc29uID09PSBudWxsIHx8IGpzb24gPT09IFwiXCIpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZGVjKGpzb24pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgaWYgKHZhbHVlIHx8IGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5ubztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0LCBlbnVtQXNJbnRlZ2VyKSB7XG4gIHZhciBfYTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSAwICYmICFlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGVudW1Bc0ludGVnZXIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB2YWwgPSB0eXBlLmZpbmROdW1iZXIodmFsdWUpO1xuICByZXR1cm4gKF9hID0gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlOyAvLyBpZiB3ZSBkb24ndCBrbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSByZXR1cm4gXCJOYU5cIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgLy8gc3RyaW5nOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAvLyBib29sOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIik7XG4gICAgICByZXR1cm4gdmFsdWUgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgLy8gV2UgdXNlIGltcGxpY2l0IGNvbnZlcnNpb24gd2l0aCBgdmFsdWUgIT0gMGAgdG8gY2F0Y2ggYm90aCAwbiBhbmQgXCIwXCJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiBlbWl0SW50cmluc2ljRGVmYXVsdCB8fCB2YWx1ZSAhPSAwID8gdmFsdWUudG9TdHJpbmcoMTApIDogdW5kZWZpbmVkO1xuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICByZXR1cm4gZW1pdEludHJpbnNpY0RlZmF1bHQgfHwgdmFsdWUuYnl0ZUxlbmd0aCA+IDAgPyBwcm90b0Jhc2U2NC5lbmModmFsdWUpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdFByb3RvMygpIHtcbiAgcmV0dXJuIG1ha2VKc29uRm9ybWF0Q29tbW9uKCh3cml0ZUVudW0sIHdyaXRlU2NhbGFyKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlU2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNvbnN0IGVudW1UeXBlID0gZmllbGQuVi5UO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICBhc3NlcnQoZW50cnlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbnRyeVZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDAgPyBqc29uT2JqIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cmFwRmllbGQoZmllbGQuVCwgdmFsdWVbaV0pLnRvSnNvbihvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQgfHwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcywgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpLnRvSnNvbihvcHRpb25zKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VVdGlsQ29tbW9uKCkge1xuICByZXR1cm4ge1xuICAgIHNldEVudW1UeXBlLFxuICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHRhcmdldC5nZXRUeXBlKCk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsXG4gICAgICAgICAgdCA9IHRhcmdldCxcbiAgICAgICAgICBzID0gc291cmNlO1xuICAgICAgICBpZiAoc1tsb2NhbE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xuICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09IFwibWVzc2FnZVwiICYmICEodmFsIGluc3RhbmNlb2Ygc291cmNlRmllbGQuVCkpIHtcbiAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJiBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgICAgY2FzZTogc2ssXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIGNvcHkgPSBtZW1iZXIucmVwZWF0ZWQgPyBjb3B5Lm1hcCh0b1U4QXJyKSA6IHRvVThBcnIoY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKHZhbCA9PiB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc1tsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAobXQuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICBtdC50eXBlTmFtZSA9PT0gXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsIGluc3RhbmNlb2YgbXQgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeShtID0+IHtcbiAgICAgICAgY29uc3QgdmEgPSBhW20ubG9jYWxOYW1lXTtcbiAgICAgICAgY29uc3QgdmIgPSBiW20ubG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhtLlQsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCBhLCB2YltpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBlYXRlZCBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQobS5raW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHModmEsIHZiKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMobS5ULCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcyA9IG0uZmluZEZpZWxkKHZhLmNhc2UpO1xuICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgICAgc3dpdGNoIChzLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5ULmVxdWFscyh2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMocy5ULCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25lb2YgY2Fubm90IGNvbnRhaW4gXCIuY29uY2F0KHMua2luZCkpO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSxcbiAgICAgICAgdGFyZ2V0ID0gbmV3IHR5cGUoKSxcbiAgICAgICAgYW55ID0gdGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKGNsb25lU2luZ3VsYXJGaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZVNpbmd1bGFyRmllbGQodik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgIGNvbnN0IGYgPSBtZW1iZXIuZmluZEZpZWxkKHNvdXJjZS5jYXNlKTtcbiAgICAgICAgICBjb3B5ID0gZiA/IHtcbiAgICAgICAgICAgIGNhc2U6IHNvdXJjZS5jYXNlLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UudmFsdWUpXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgIGMuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gYztcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vLyBjb252ZXJ0cyBhbnkgQXJyYXlMaWtlPG51bWJlcj4gdG8gVWludDhBcnJheSBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiB0b1U4QXJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dCA6IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBub3JtYWxpemVyKSB7XG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICB9XG4gIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xuICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgfVxuICBmaW5kKGZpZWxkTm8pIHtcbiAgICBpZiAoIXRoaXMubnVtYmVycykge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIHRbZi5ub10gPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5udW1iZXJzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgfVxuICBsaXN0KCkge1xuICAgIGlmICghdGhpcy5hbGwpIHtcbiAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGw7XG4gIH1cbiAgYnlOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcbiAgfVxuICBieU1lbWJlcigpIHtcbiAgICBpZiAoIXRoaXMubWVtYmVycykge1xuICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICBjb25zdCBhID0gdGhpcy5tZW1iZXJzO1xuICAgICAgbGV0IG87XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xuICAgICAgICAgICAgbyA9IGYub25lb2Y7XG4gICAgICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEZpZWxkIG5hbWVzIC0gaW5jbHVkaW5nIG9uZW9mcyAtIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJDYW1lbENhc2UuIEZvclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxuICogd2l0aCBhbiB1bmRlcnNjb3JlLiBGb3IgbWV0aG9kcywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtYWRlIGxvd2VyY2FzZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgaW5PbmVvZikge1xuICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgaWYgKGluT25lb2YpIHtcbiAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgcmV0dXJuIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIG5hbWUgZm9yIGEgcHJvdG9idWYgZmllbGQsIGV4YWN0bHkgbGlrZSBwcm90b2MgZG9lcy5cbiAqL1xuY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICBjb25zdCBiID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjpcbiAgICAgIGNhc2UgXCIxXCI6XG4gICAgICBjYXNlIFwiMlwiOlxuICAgICAgY2FzZSBcIjNcIjpcbiAgICAgIGNhc2UgXCI0XCI6XG4gICAgICBjYXNlIFwiNVwiOlxuICAgICAgY2FzZSBcIjZcIjpcbiAgICAgIGNhc2UgXCI3XCI6XG4gICAgICBjYXNlIFwiOFwiOlxuICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgYyA9IGMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkT2JqZWN0UHJvcGVydGllcyA9IG5ldyBTZXQoW1xuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxuXCJjb25zdHJ1Y3RvclwiLCBcInRvU3RyaW5nXCIsIFwidG9KU09OXCIsIFwidmFsdWVPZlwiXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZVxuXCJnZXRUeXBlXCIsIFwiY2xvbmVcIiwgXCJlcXVhbHNcIiwgXCJmcm9tQmluYXJ5XCIsIFwiZnJvbUpzb25cIiwgXCJmcm9tSnNvblN0cmluZ1wiLCBcInRvQmluYXJ5XCIsIFwidG9Kc29uXCIsIFwidG9Kc29uU3RyaW5nXCIsXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZSBmb3IgdGhlIGZ1dHVyZVxuXCJ0b09iamVjdFwiXSk7XG5jb25zdCBmYWxsYmFjayA9IG5hbWUgPT4gXCJcIi5jb25jYXQobmFtZSwgXCIkXCIpO1xuLyoqXG4gKiBXaWxsIHdyYXAgbmFtZXMgdGhhdCBhcmUgT2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9yIG5hbWVzIHJlc2VydmVkXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cbiAqL1xuY29uc3Qgc2FmZU1lc3NhZ2VQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jbGFzcyBJbnRlcm5hbE9uZW9mSW5mbyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLmtpbmQgPSBcIm9uZW9mXCI7XG4gICAgdGhpcy5yZXBlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgdGhpcy5vcHQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gIH1cbiAgYWRkRmllbGQoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMyBzeW50YXguXG4gKi9cbmNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgbWFrZUpzb25Gb3JtYXRQcm90bzMoKSwgbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7XG4gIG5ld0ZpZWxkTGlzdChmaWVsZHMpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsRmllbGRMaXN0KGZpZWxkcywgbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyk7XG4gIH0sXG4gIGluaXRGaWVsZHModGFyZ2V0KSB7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGFyZ2V0LmdldFR5cGUoKS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgaWYgKG1lbWJlci5vcHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcbiAgICAgICAgdCA9IHRhcmdldDtcbiAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgdFtuYW1lXSA9IHtcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgdFtuYW1lXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICB0W25hbWVdID0gc2NhbGFyRGVmYXVsdFZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59KSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyhmaWVsZEluZm9zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgbztcbiAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZEluZm9zKCkgOiBmaWVsZEluZm9zKSB7XG4gICAgY29uc3QgZiA9IGZpZWxkO1xuICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xuICAgIH1cbiAgICAvLyBGcm9tIHRoZSBwcm90bzMgbGFuZ3VhZ2UgZ3VpZGU6XG4gICAgLy8gPiBJbiBwcm90bzMsIHJlcGVhdGVkIGZpZWxkcyBvZiBzY2FsYXIgbnVtZXJpYyB0eXBlcyBhcmUgcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyBpbmNvbXBsZXRlIC0gYWNjb3JkaW5nIHRvIHRoZSBjb25mb3JtYW5jZSB0ZXN0cywgQk9PTFxuICAgIC8vIGFuZCBFTlVNIGFyZSBwYWNrZWQgYnkgZGVmYXVsdCBhcyB3ZWxsLiBUaGlzIG1lYW5zIG9ubHkgU1RSSU5HIGFuZCBCWVRFU1xuICAgIC8vIGFyZSBub3QgcGFja2VkIGJ5IGRlZmF1bHQsIHdoaWNoIG1ha2VzIHNlbnNlIGJlY2F1c2UgdGhleSBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICBmLnBhY2tlZCA9IChfZCA9IGZpZWxkLnBhY2tlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmllbGQua2luZCA9PSBcImVudW1cIiB8fCBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkc7XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xuICAgICAgfVxuICAgICAgZi5vbmVvZiA9IG87XG4gICAgICBvLmFkZEZpZWxkKGYpO1xuICAgIH1cbiAgICByLnB1c2goZik7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXG4gICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAqIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQucGFyc2UobXMgLyAxMDAwKTtcbiAgICB0aGlzLm5hbm9zID0gMDtcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGxldCB6ID0gXCJaXCI7XG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICB9XG4gIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gIH1cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlY29uZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG4vLyBDb3B5cmlnaHQgMjAyMyBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkF1ZGlvQ29kZWNcbiAqL1xudmFyIEF1ZGlvQ29kZWM7XG4oZnVuY3Rpb24gKEF1ZGlvQ29kZWMpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBERUZBVUxUX0FDID0gMDtcbiAgICovXG4gIEF1ZGlvQ29kZWNbQXVkaW9Db2RlY1tcIkRFRkFVTFRfQUNcIl0gPSAwXSA9IFwiREVGQVVMVF9BQ1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9QVVMgPSAxO1xuICAgKi9cbiAgQXVkaW9Db2RlY1tBdWRpb0NvZGVjW1wiT1BVU1wiXSA9IDFdID0gXCJPUFVTXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUFDID0gMjtcbiAgICovXG4gIEF1ZGlvQ29kZWNbQXVkaW9Db2RlY1tcIkFBQ1wiXSA9IDJdID0gXCJBQUNcIjtcbn0pKEF1ZGlvQ29kZWMgfHwgKEF1ZGlvQ29kZWMgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9Db2RlYylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEF1ZGlvQ29kZWMsIFwibGl2ZWtpdC5BdWRpb0NvZGVjXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRFRkFVTFRfQUNcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJPUFVTXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQUFDXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5WaWRlb0NvZGVjXG4gKi9cbnZhciBWaWRlb0NvZGVjO1xuKGZ1bmN0aW9uIChWaWRlb0NvZGVjKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREVGQVVMVF9WQyA9IDA7XG4gICAqL1xuICBWaWRlb0NvZGVjW1ZpZGVvQ29kZWNbXCJERUZBVUxUX1ZDXCJdID0gMF0gPSBcIkRFRkFVTFRfVkNcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBIMjY0X0JBU0VMSU5FID0gMTtcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkgyNjRfQkFTRUxJTkVcIl0gPSAxXSA9IFwiSDI2NF9CQVNFTElORVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfTUFJTiA9IDI7XG4gICAqL1xuICBWaWRlb0NvZGVjW1ZpZGVvQ29kZWNbXCJIMjY0X01BSU5cIl0gPSAyXSA9IFwiSDI2NF9NQUlOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSDI2NF9ISUdIID0gMztcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkgyNjRfSElHSFwiXSA9IDNdID0gXCJIMjY0X0hJR0hcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBWUDggPSA0O1xuICAgKi9cbiAgVmlkZW9Db2RlY1tWaWRlb0NvZGVjW1wiVlA4XCJdID0gNF0gPSBcIlZQOFwiO1xufSkoVmlkZW9Db2RlYyB8fCAoVmlkZW9Db2RlYyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb0NvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVmlkZW9Db2RlYywgXCJsaXZla2l0LlZpZGVvQ29kZWNcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9WQ1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkgyNjRfQkFTRUxJTkVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJIMjY0X01BSU5cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJIMjY0X0hJR0hcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJWUDhcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkltYWdlQ29kZWNcbiAqL1xudmFyIEltYWdlQ29kZWM7XG4oZnVuY3Rpb24gKEltYWdlQ29kZWMpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBJQ19ERUZBVUxUID0gMDtcbiAgICovXG4gIEltYWdlQ29kZWNbSW1hZ2VDb2RlY1tcIklDX0RFRkFVTFRcIl0gPSAwXSA9IFwiSUNfREVGQVVMVFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IElDX0pQRUcgPSAxO1xuICAgKi9cbiAgSW1hZ2VDb2RlY1tJbWFnZUNvZGVjW1wiSUNfSlBFR1wiXSA9IDFdID0gXCJJQ19KUEVHXCI7XG59KShJbWFnZUNvZGVjIHx8IChJbWFnZUNvZGVjID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEltYWdlQ29kZWMpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShJbWFnZUNvZGVjLCBcImxpdmVraXQuSW1hZ2VDb2RlY1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJJQ19ERUZBVUxUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSUNfSlBFR1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVHJhY2tUeXBlXG4gKi9cbnZhciBUcmFja1R5cGU7XG4oZnVuY3Rpb24gKFRyYWNrVHlwZSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFVRElPID0gMDtcbiAgICovXG4gIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJBVURJT1wiXSA9IDBdID0gXCJBVURJT1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFZJREVPID0gMTtcbiAgICovXG4gIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJWSURFT1wiXSA9IDFdID0gXCJWSURFT1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERBVEEgPSAyO1xuICAgKi9cbiAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIkRBVEFcIl0gPSAyXSA9IFwiREFUQVwiO1xufSkoVHJhY2tUeXBlIHx8IChUcmFja1R5cGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVHJhY2tUeXBlLCBcImxpdmVraXQuVHJhY2tUeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFVRElPXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVklERU9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEQVRBXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5UcmFja1NvdXJjZVxuICovXG52YXIgVHJhY2tTb3VyY2U7XG4oZnVuY3Rpb24gKFRyYWNrU291cmNlKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVU5LTk9XTiA9IDA7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENBTUVSQSA9IDE7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIkNBTUVSQVwiXSA9IDFdID0gXCJDQU1FUkFcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNSUNST1BIT05FID0gMjtcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiTUlDUk9QSE9ORVwiXSA9IDJdID0gXCJNSUNST1BIT05FXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0NSRUVOX1NIQVJFID0gMztcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiU0NSRUVOX1NIQVJFXCJdID0gM10gPSBcIlNDUkVFTl9TSEFSRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNDUkVFTl9TSEFSRV9BVURJTyA9IDQ7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIlNDUkVFTl9TSEFSRV9BVURJT1wiXSA9IDRdID0gXCJTQ1JFRU5fU0hBUkVfQVVESU9cIjtcbn0pKFRyYWNrU291cmNlIHx8IChUcmFja1NvdXJjZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFRyYWNrU291cmNlLCBcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNBTUVSQVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk1JQ1JPUEhPTkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlZpZGVvUXVhbGl0eVxuICovXG52YXIgVmlkZW9RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1cgPSAwO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkxPV1wiXSA9IDBdID0gXCJMT1dcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNRURJVU0gPSAxO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1FRElVTVwiXSA9IDFdID0gXCJNRURJVU1cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBISUdIID0gMjtcbiAgICovXG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJISUdIXCJdID0gMl0gPSBcIkhJR0hcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBPRkYgPSAzO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk9GRlwiXSA9IDNdID0gXCJPRkZcIjtcbn0pKFZpZGVvUXVhbGl0eSB8fCAoVmlkZW9RdWFsaXR5ID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFZpZGVvUXVhbGl0eSwgXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJMT1dcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJNRURJVU1cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJISUdIXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiT0ZGXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVxuICovXG52YXIgQ29ubmVjdGlvblF1YWxpdHkkMTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQT09SID0gMDtcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiUE9PUlwiXSA9IDBdID0gXCJQT09SXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogR09PRCA9IDE7XG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkdPT0RcIl0gPSAxXSA9IFwiR09PRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVYQ0VMTEVOVCA9IDI7XG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkVYQ0VMTEVOVFwiXSA9IDJdID0gXCJFWENFTExFTlRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1NUID0gMztcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiTE9TVFwiXSA9IDNdID0gXCJMT1NUXCI7XG59KShDb25uZWN0aW9uUXVhbGl0eSQxIHx8IChDb25uZWN0aW9uUXVhbGl0eSQxID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkkMSwgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBPT1JcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHT09EXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRVhDRUxMRU5UXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTE9TVFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZ1xuICovXG52YXIgQ2xpZW50Q29uZmlnU2V0dGluZztcbihmdW5jdGlvbiAoQ2xpZW50Q29uZmlnU2V0dGluZykge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOU0VUID0gMDtcbiAgICovXG4gIENsaWVudENvbmZpZ1NldHRpbmdbQ2xpZW50Q29uZmlnU2V0dGluZ1tcIlVOU0VUXCJdID0gMF0gPSBcIlVOU0VUXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRElTQUJMRUQgPSAxO1xuICAgKi9cbiAgQ2xpZW50Q29uZmlnU2V0dGluZ1tDbGllbnRDb25maWdTZXR0aW5nW1wiRElTQUJMRURcIl0gPSAxXSA9IFwiRElTQUJMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBFTkFCTEVEID0gMjtcbiAgICovXG4gIENsaWVudENvbmZpZ1NldHRpbmdbQ2xpZW50Q29uZmlnU2V0dGluZ1tcIkVOQUJMRURcIl0gPSAyXSA9IFwiRU5BQkxFRFwiO1xufSkoQ2xpZW50Q29uZmlnU2V0dGluZyB8fCAoQ2xpZW50Q29uZmlnU2V0dGluZyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZywgXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5TRVRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJESVNBQkxFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVOQUJMRURcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cbiAqL1xudmFyIERpc2Nvbm5lY3RSZWFzb247XG4oZnVuY3Rpb24gKERpc2Nvbm5lY3RSZWFzb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOX1JFQVNPTiA9IDA7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJVTktOT1dOX1JFQVNPTlwiXSA9IDBdID0gXCJVTktOT1dOX1JFQVNPTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENMSUVOVF9JTklUSUFURUQgPSAxO1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiQ0xJRU5UX0lOSVRJQVRFRFwiXSA9IDFdID0gXCJDTElFTlRfSU5JVElBVEVEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRFVQTElDQVRFX0lERU5USVRZID0gMjtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIkRVUExJQ0FURV9JREVOVElUWVwiXSA9IDJdID0gXCJEVVBMSUNBVEVfSURFTlRJVFlcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRVJWRVJfU0hVVERPV04gPSAzO1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiU0VSVkVSX1NIVVRET1dOXCJdID0gM10gPSBcIlNFUlZFUl9TSFVURE9XTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBBUlRJQ0lQQU5UX1JFTU9WRUQgPSA0O1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiUEFSVElDSVBBTlRfUkVNT1ZFRFwiXSA9IDRdID0gXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUk9PTV9ERUxFVEVEID0gNTtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIlJPT01fREVMRVRFRFwiXSA9IDVdID0gXCJST09NX0RFTEVURURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTVEFURV9NSVNNQVRDSCA9IDY7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJTVEFURV9NSVNNQVRDSFwiXSA9IDZdID0gXCJTVEFURV9NSVNNQVRDSFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEpPSU5fRkFJTFVSRSA9IDc7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJKT0lOX0ZBSUxVUkVcIl0gPSA3XSA9IFwiSk9JTl9GQUlMVVJFXCI7XG59KShEaXNjb25uZWN0UmVhc29uIHx8IChEaXNjb25uZWN0UmVhc29uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uLCBcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlJlY29ubmVjdFJlYXNvblxuICovXG52YXIgUmVjb25uZWN0UmVhc29uO1xuKGZ1bmN0aW9uIChSZWNvbm5lY3RSZWFzb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9VTktOT1dOID0gMDtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9VTktOT1dOXCJdID0gMF0gPSBcIlJSX1VOS05PV05cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TSUdOQUxfRElTQ09OTkVDVEVEID0gMTtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIlJSX1NJR05BTF9ESVNDT05ORUNURURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9QVUJMSVNIRVJfRkFJTEVEID0gMjtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCJdID0gMl0gPSBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TVUJTQ1JJQkVSX0ZBSUxFRCA9IDM7XG4gICAqL1xuICBSZWNvbm5lY3RSZWFzb25bUmVjb25uZWN0UmVhc29uW1wiUlJfU1VCU0NSSUJFUl9GQUlMRURcIl0gPSAzXSA9IFwiUlJfU1VCU0NSSUJFUl9GQUlMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TV0lUQ0hfQ0FORElEQVRFID0gNDtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9TV0lUQ0hfQ0FORElEQVRFXCJdID0gNF0gPSBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIjtcbn0pKFJlY29ubmVjdFJlYXNvbiB8fCAoUmVjb25uZWN0UmVhc29uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbiwgXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSUl9VTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXG4gKi9cbnZhciBTdWJzY3JpcHRpb25FcnJvcjtcbihmdW5jdGlvbiAoU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRV9VTktOT1dOID0gMDtcbiAgICovXG4gIFN1YnNjcmlwdGlvbkVycm9yW1N1YnNjcmlwdGlvbkVycm9yW1wiU0VfVU5LTk9XTlwiXSA9IDBdID0gXCJTRV9VTktOT1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfQ09ERUNfVU5TVVBQT1JURUQgPSAxO1xuICAgKi9cbiAgU3Vic2NyaXB0aW9uRXJyb3JbU3Vic2NyaXB0aW9uRXJyb3JbXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiXSA9IDFdID0gXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFX1RSQUNLX05PVEZPVU5EID0gMjtcbiAgICovXG4gIFN1YnNjcmlwdGlvbkVycm9yW1N1YnNjcmlwdGlvbkVycm9yW1wiU0VfVFJBQ0tfTk9URk9VTkRcIl0gPSAyXSA9IFwiU0VfVFJBQ0tfTk9URk9VTkRcIjtcbn0pKFN1YnNjcmlwdGlvbkVycm9yIHx8IChTdWJzY3JpcHRpb25FcnJvciA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvcilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yLCBcImxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU0VfVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU0VfVFJBQ0tfTk9URk9VTkRcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21cbiAqL1xubGV0IFJvb20kMSA9IGNsYXNzIFJvb20gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBlbXB0eV90aW1lb3V0ID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmVtcHR5VGltZW91dCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbWF4X3BhcnRpY2lwYW50cyA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5tYXhQYXJ0aWNpcGFudHMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgY3JlYXRpb25fdGltZSA9IDU7XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGlvblRpbWUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHVybl9wYXNzd29yZCA9IDY7XG4gICAgICovXG4gICAgdGhpcy50dXJuUGFzc3dvcmQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBlbmFibGVkX2NvZGVjcyA9IDc7XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkQ29kZWNzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSA4O1xuICAgICAqL1xuICAgIHRoaXMubWV0YWRhdGEgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG51bV9wYXJ0aWNpcGFudHMgPSA5O1xuICAgICAqL1xuICAgIHRoaXMubnVtUGFydGljaXBhbnRzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBudW1fcHVibGlzaGVycyA9IDExO1xuICAgICAqL1xuICAgIHRoaXMubnVtUHVibGlzaGVycyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFjdGl2ZV9yZWNvcmRpbmcgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb20oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJvb20sIGEsIGIpO1xuICB9XG59O1xuUm9vbSQxLnJ1bnRpbWUgPSBwcm90bzM7XG5Sb29tJDEudHlwZU5hbWUgPSBcImxpdmVraXQuUm9vbVwiO1xuUm9vbSQxLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZW1wdHlfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInR1cm5fcGFzc3dvcmRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJlbmFibGVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibnVtX3B1Ymxpc2hlcnNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImFjdGl2ZV9yZWNvcmRpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db2RlY1xuICovXG5jbGFzcyBDb2RlYyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLm1pbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGZtdHBfbGluZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5mbXRwTGluZSA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvZGVjKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29kZWMsIGEsIGIpO1xuICB9XG59XG5Db2RlYy5ydW50aW1lID0gcHJvdG8zO1xuQ29kZWMudHlwZU5hbWUgPSBcImxpdmVraXQuQ29kZWNcIjtcbkNvZGVjLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZm10cF9saW5lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QbGF5b3V0RGVsYXlcbiAqL1xuY2xhc3MgUGxheW91dERlbGF5IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBlbmFibGVkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtaW4gPSAyO1xuICAgICAqL1xuICAgIHRoaXMubWluID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtYXggPSAzO1xuICAgICAqL1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQbGF5b3V0RGVsYXksIGEsIGIpO1xuICB9XG59XG5QbGF5b3V0RGVsYXkucnVudGltZSA9IHByb3RvMztcblBsYXlvdXREZWxheS50eXBlTmFtZSA9IFwibGl2ZWtpdC5QbGF5b3V0RGVsYXlcIjtcblBsYXlvdXREZWxheS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZW5hYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibWF4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50UGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBzdWJzY3JpYmUgdG8gb3RoZXIgdHJhY2tzIGluIHRoZSByb29tXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3N1YnNjcmliZSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jYW5TdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIG5ldyB0cmFja3MgdG8gcm9vbVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9wdWJsaXNoID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmNhblB1Ymxpc2ggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIGRhdGFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fcHVibGlzaF9kYXRhID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmNhblB1Ymxpc2hEYXRhID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogc291cmNlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIGJlIHB1Ymxpc2hlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlRyYWNrU291cmNlIGNhbl9wdWJsaXNoX3NvdXJjZXMgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuY2FuUHVibGlzaFNvdXJjZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCBpdCdzIGhpZGRlbiB0byBvdGhlcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBoaWRkZW4gPSA3O1xuICAgICAqL1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGl0J3MgYSByZWNvcmRlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHJlY29yZGVyID0gODtcbiAgICAgKi9cbiAgICB0aGlzLnJlY29yZGVyID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIHRoYXQgcGFydGljaXBhbnQgY2FuIHVwZGF0ZSBvd24gbWV0YWRhdGFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fdXBkYXRlX21ldGFkYXRhID0gMTA7XG4gICAgICovXG4gICAgdGhpcy5jYW5VcGRhdGVNZXRhZGF0YSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyB0aGF0IHBhcnRpY2lwYW50IGlzIGFuIGFnZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWdlbnQgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLmFnZW50ID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRQZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRQZXJtaXNzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudFBlcm1pc3Npb24udHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXCI7XG5QYXJ0aWNpcGFudFBlcm1pc3Npb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hfZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9zb3VyY2VzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJoaWRkZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicmVjb3JkZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImNhbl91cGRhdGVfbWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcImFnZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRJbmZvXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50SW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBpZGVudGl0eSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5pZGVudGl0eSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZSBzdGF0ZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lOSU5HO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja0luZm8gdHJhY2tzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLm1ldGFkYXRhID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiB0aW1lc3RhbXAgd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgcm9vbSwgaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBqb2luZWRfYXQgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuam9pbmVkQXQgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDk7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB2ZXJzaW9uID0gMTA7XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIHRoZSBwYXJ0aWNpcGFudCBoYXMgYW4gYWN0aXZlIHB1Ymxpc2hlciBjb25uZWN0aW9uXG4gICAgICogYW5kIGNhbiBwdWJsaXNoIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBpc19wdWJsaXNoZXIgPSAxMztcbiAgICAgKi9cbiAgICB0aGlzLmlzUHVibGlzaGVyID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRJbmZvLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudEluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvXCI7XG5QYXJ0aWNpcGFudEluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImpvaW5lZF9hdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFBlcm1pc3Npb25cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJpc19wdWJsaXNoZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcbiAqL1xudmFyIFBhcnRpY2lwYW50SW5mb19TdGF0ZTtcbihmdW5jdGlvbiAoUGFydGljaXBhbnRJbmZvX1N0YXRlKSB7XG4gIC8qKlxuICAgKiB3ZWJzb2NrZXQnIGNvbm5lY3RlZCwgYnV0IG5vdCBvZmZlcmVkIHlldFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTklORyA9IDA7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiSk9JTklOR1wiXSA9IDBdID0gXCJKT0lOSU5HXCI7XG4gIC8qKlxuICAgKiBzZXJ2ZXIgcmVjZWl2ZWQgY2xpZW50IG9mZmVyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lORUQgPSAxO1xuICAgKi9cbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkpPSU5FRFwiXSA9IDFdID0gXCJKT0lORURcIjtcbiAgLyoqXG4gICAqIElDRSBjb25uZWN0aXZpdHkgZXN0YWJsaXNoZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFDVElWRSA9IDI7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiQUNUSVZFXCJdID0gMl0gPSBcIkFDVElWRVwiO1xuICAvKipcbiAgICogV1MgZGlzY29ubmVjdGVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBESVNDT05ORUNURUQgPSAzO1xuICAgKi9cbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkRJU0NPTk5FQ1RFRFwiXSA9IDNdID0gXCJESVNDT05ORUNURURcIjtcbn0pKFBhcnRpY2lwYW50SW5mb19TdGF0ZSB8fCAoUGFydGljaXBhbnRJbmZvX1N0YXRlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSwgXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJKT0lOSU5HXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSk9JTkVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQUNUSVZFXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiRElTQ09OTkVDVEVEXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5FbmNyeXB0aW9uXG4gKi9cbmNsYXNzIEVuY3J5cHRpb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRW5jcnlwdGlvbiwgYSwgYik7XG4gIH1cbn1cbkVuY3J5cHRpb24ucnVudGltZSA9IHByb3RvMztcbkVuY3J5cHRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuRW5jcnlwdGlvblwiO1xuRW5jcnlwdGlvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW10pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkVuY3J5cHRpb24uVHlwZVxuICovXG52YXIgRW5jcnlwdGlvbl9UeXBlO1xuKGZ1bmN0aW9uIChFbmNyeXB0aW9uX1R5cGUpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOT05FID0gMDtcbiAgICovXG4gIEVuY3J5cHRpb25fVHlwZVtFbmNyeXB0aW9uX1R5cGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHQ00gPSAxO1xuICAgKi9cbiAgRW5jcnlwdGlvbl9UeXBlW0VuY3J5cHRpb25fVHlwZVtcIkdDTVwiXSA9IDFdID0gXCJHQ01cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDVVNUT00gPSAyO1xuICAgKi9cbiAgRW5jcnlwdGlvbl9UeXBlW0VuY3J5cHRpb25fVHlwZVtcIkNVU1RPTVwiXSA9IDJdID0gXCJDVVNUT01cIjtcbn0pKEVuY3J5cHRpb25fVHlwZSB8fCAoRW5jcnlwdGlvbl9UeXBlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSwgXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJOT05FXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiR0NNXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQ1VTVE9NXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cbiAqL1xuY2xhc3MgU2ltdWxjYXN0Q29kZWNJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWVfdHlwZSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5taW1lVHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWlkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm1pZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpbXVsY2FzdENvZGVjSW5mbywgYSwgYik7XG4gIH1cbn1cblNpbXVsY2FzdENvZGVjSW5mby5ydW50aW1lID0gcHJvdG8zO1xuU2ltdWxjYXN0Q29kZWNJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiO1xuU2ltdWxjYXN0Q29kZWNJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tJbmZvXG4gKi9cbmNsYXNzIFRyYWNrSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tUeXBlIHR5cGUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFRyYWNrVHlwZS5BVURJTztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMztcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5tdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHdpZHRoIG9mIHZpZGVvICh1bnNldCBmb3IgYXVkaW8pXG4gICAgICogY2xpZW50cyBtYXkgcmVjZWl2ZSBhIGxvd2VyIHJlc29sdXRpb24gdmVyc2lvbiB3aXRoIHNpbXVsY2FzdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA1O1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIGhlaWdodCBvZiB2aWRlbyAodW5zZXQgZm9yIGF1ZGlvKVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0cmFjayBpcyBzaW11bGNhc3RlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHNpbXVsY2FzdCA9IDc7XG4gICAgICovXG4gICAgdGhpcy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIERUWCAoRGlzY29udGludW91cyBUcmFuc21pc3Npb24pIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfZHR4ID0gODtcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVEdHggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBzb3VyY2Ugb2YgbWVkaWFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1NvdXJjZSBzb3VyY2UgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIG1pbWUgdHlwZSBvZiBjb2RlY1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWltZV90eXBlID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5taW1lVHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWlkID0gMTI7XG4gICAgICovXG4gICAgdGhpcy5taWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm8gY29kZWNzID0gMTM7XG4gICAgICovXG4gICAgdGhpcy5jb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3RlcmVvID0gMTQ7XG4gICAgICovXG4gICAgdGhpcy5zdGVyZW8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIFJFRCAoUmVkdW5kYW50IEVuY29kaW5nKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX3JlZCA9IDE1O1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZVJlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGUgZW5jcnlwdGlvbiA9IDE2O1xuICAgICAqL1xuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHN0cmVhbSA9IDE3O1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja0luZm8sIGEsIGIpO1xuICB9XG59XG5UcmFja0luZm8ucnVudGltZSA9IHByb3RvMztcblRyYWNrSW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja0luZm9cIjtcblRyYWNrSW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJzaW11bGNhc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwibWlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWNJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgYXZhaWxhYmxlIHNwYXRpYWwgbGF5ZXJzXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WaWRlb0xheWVyXG4gKi9cbmNsYXNzIFZpZGVvTGF5ZXIgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogZm9yIHRyYWNrcyB3aXRoIGEgc2luZ2xlIGxheWVyLCB0aGlzIHNob3VsZCBiZSBISUdIXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSAyO1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIHRhcmdldCBiaXRyYXRlIGluIGJpdCBwZXIgc2Vjb25kIChicHMpLCBzZXJ2ZXIgd2lsbCBtZWFzdXJlIGFjdHVhbFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgYml0cmF0ZSA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5iaXRyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBzc3JjID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLnNzcmMgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFZpZGVvTGF5ZXIsIGEsIGIpO1xuICB9XG59XG5WaWRlb0xheWVyLnJ1bnRpbWUgPSBwcm90bzM7XG5WaWRlb0xheWVyLnR5cGVOYW1lID0gXCJsaXZla2l0LlZpZGVvTGF5ZXJcIjtcblZpZGVvTGF5ZXIuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJiaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInNzcmNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbi8qKlxuICogbmV3IERhdGFQYWNrZXQgQVBJXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhUGFja2V0XG4gKi9cbmNsYXNzIERhdGFQYWNrZXQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRhdGFQYWNrZXQuS2luZCBraW5kID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmtpbmQgPSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuRGF0YVBhY2tldC52YWx1ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhUGFja2V0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YVBhY2tldCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFQYWNrZXQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKERhdGFQYWNrZXQsIGEsIGIpO1xuICB9XG59XG5EYXRhUGFja2V0LnJ1bnRpbWUgPSBwcm90bzM7XG5EYXRhUGFja2V0LnR5cGVOYW1lID0gXCJsaXZla2l0LkRhdGFQYWNrZXRcIjtcbkRhdGFQYWNrZXQuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImtpbmRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhUGFja2V0X0tpbmQpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVzZXJQYWNrZXQsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3BlYWtlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRhdGFQYWNrZXQuS2luZFxuICovXG52YXIgRGF0YVBhY2tldF9LaW5kO1xuKGZ1bmN0aW9uIChEYXRhUGFja2V0X0tpbmQpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSRUxJQUJMRSA9IDA7XG4gICAqL1xuICBEYXRhUGFja2V0X0tpbmRbRGF0YVBhY2tldF9LaW5kW1wiUkVMSUFCTEVcIl0gPSAwXSA9IFwiUkVMSUFCTEVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1NTWSA9IDE7XG4gICAqL1xuICBEYXRhUGFja2V0X0tpbmRbRGF0YVBhY2tldF9LaW5kW1wiTE9TU1lcIl0gPSAxXSA9IFwiTE9TU1lcIjtcbn0pKERhdGFQYWNrZXRfS2luZCB8fCAoRGF0YVBhY2tldF9LaW5kID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZCwgXCJsaXZla2l0LkRhdGFQYWNrZXQuS2luZFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSRUxJQUJMRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkxPU1NZXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXG4gKi9cbmNsYXNzIEFjdGl2ZVNwZWFrZXJVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNwZWFrZXJJbmZvIHNwZWFrZXJzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNwZWFrZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVNwZWFrZXJVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVTcGVha2VyVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWN0aXZlU3BlYWtlclVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQWN0aXZlU3BlYWtlclVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cbkFjdGl2ZVNwZWFrZXJVcGRhdGUucnVudGltZSA9IHByb3RvMztcbkFjdGl2ZVNwZWFrZXJVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiO1xuQWN0aXZlU3BlYWtlclVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNwZWFrZXJJbmZvXG4gKi9cbmNsYXNzIFNwZWFrZXJJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIGF1ZGlvIGxldmVsLCAwLTEuMCwgMSBpcyBsb3VkZXN0XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGZsb2F0IGxldmVsID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmxldmVsID0gMDtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHNwZWFrZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFjdGl2ZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlckluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2VySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTcGVha2VySW5mbywgYSwgYik7XG4gIH1cbn1cblNwZWFrZXJJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TcGVha2VySW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5TcGVha2VySW5mb1wiO1xuU3BlYWtlckluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxldmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDIgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3RpdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Vc2VyUGFja2V0XG4gKi9cbmNsYXNzIFVzZXJQYWNrZXQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogcGFydGljaXBhbnQgSUQgb2YgdXNlciB0aGF0IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfaWRlbnRpdHkgPSA1O1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogdXNlciBkZWZpbmVkIHBheWxvYWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYnl0ZXMgcGF5bG9hZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5wYXlsb2FkID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgLyoqXG4gICAgICogdGhlIElEIG9mIHRoZSBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZSAoc2VudCB0byBhbGwgYnkgZGVmYXVsdClcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGRlc3RpbmF0aW9uX3NpZHMgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZGVzdGluYXRpb25TaWRzID0gW107XG4gICAgLyoqXG4gICAgICogaWRlbnRpdGllcyBvZiBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZSAoc2VudCB0byBhbGwgYnkgZGVmYXVsdClcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGRlc3RpbmF0aW9uX2lkZW50aXRpZXMgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuZGVzdGluYXRpb25JZGVudGl0aWVzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVzZXJQYWNrZXQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVc2VyUGFja2V0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXNlclBhY2tldCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXNlclBhY2tldCwgYSwgYik7XG4gIH1cbn1cblVzZXJQYWNrZXQucnVudGltZSA9IHByb3RvMztcblVzZXJQYWNrZXQudHlwZU5hbWUgPSBcImxpdmVraXQuVXNlclBhY2tldFwiO1xuVXNlclBhY2tldC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25fc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRvcGljXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIG9wdDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50VHJhY2tzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHBhcnRpY2lwYW50IElEIG9mIHBhcnRpY2lwYW50IHRvIHdob20gdGhlIHRyYWNrcyBiZWxvbmdcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZHMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRUcmFja3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFRyYWNrcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VHJhY2tzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudFRyYWNrcywgYSwgYik7XG4gIH1cbn1cblBhcnRpY2lwYW50VHJhY2tzLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudFRyYWNrcy50eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiO1xuUGFydGljaXBhbnRUcmFja3MuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgc2VydmVyXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TZXJ2ZXJJbmZvXG4gKi9cbmNsYXNzIFNlcnZlckluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvbiBlZGl0aW9uID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmVkaXRpb24gPSBTZXJ2ZXJJbmZvX0VkaXRpb24uU3RhbmRhcmQ7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdmVyc2lvbiA9IDI7XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHByb3RvY29sID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnByb3RvY29sID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSA0O1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBub2RlX2lkID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVJZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24uIHNlbnQgb25seSBpZiBzZXJ2ZXIgaXMgaW4gZGV2ZWxvcG1lbnQgbW9kZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZGVidWdfaW5mbyA9IDY7XG4gICAgICovXG4gICAgdGhpcy5kZWJ1Z0luZm8gPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2VydmVySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNlcnZlckluZm8sIGEsIGIpO1xuICB9XG59XG5TZXJ2ZXJJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TZXJ2ZXJJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNlcnZlckluZm9cIjtcblNlcnZlckluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImVkaXRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24pXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibm9kZV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRlYnVnX2luZm9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblxuICovXG52YXIgU2VydmVySW5mb19FZGl0aW9uO1xuKGZ1bmN0aW9uIChTZXJ2ZXJJbmZvX0VkaXRpb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTdGFuZGFyZCA9IDA7XG4gICAqL1xuICBTZXJ2ZXJJbmZvX0VkaXRpb25bU2VydmVySW5mb19FZGl0aW9uW1wiU3RhbmRhcmRcIl0gPSAwXSA9IFwiU3RhbmRhcmRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDbG91ZCA9IDE7XG4gICAqL1xuICBTZXJ2ZXJJbmZvX0VkaXRpb25bU2VydmVySW5mb19FZGl0aW9uW1wiQ2xvdWRcIl0gPSAxXSA9IFwiQ2xvdWRcIjtcbn0pKFNlcnZlckluZm9fRWRpdGlvbiB8fCAoU2VydmVySW5mb19FZGl0aW9uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbiwgXCJsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJTdGFuZGFyZFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNsb3VkXCJcbn1dKTtcbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgY2xpZW50XG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5DbGllbnRJbmZvXG4gKi9cbmNsYXNzIENsaWVudEluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudEluZm8uU0RLIHNkayA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zZGsgPSBDbGllbnRJbmZvX1NESy5VTktOT1dOO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwcm90b2NvbCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5wcm90b2NvbCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgb3MgPSA0O1xuICAgICAqL1xuICAgIHRoaXMub3MgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG9zX3ZlcnNpb24gPSA1O1xuICAgICAqL1xuICAgIHRoaXMub3NWZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBkZXZpY2VfbW9kZWwgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuZGV2aWNlTW9kZWwgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGJyb3dzZXIgPSA3O1xuICAgICAqL1xuICAgIHRoaXMuYnJvd3NlciA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYnJvd3Nlcl92ZXJzaW9uID0gODtcbiAgICAgKi9cbiAgICB0aGlzLmJyb3dzZXJWZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBhZGRyZXNzID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLmFkZHJlc3MgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIHdpZmksIHdpcmVkLCBjZWxsdWxhciwgdnBuLCBlbXB0eSBpZiBub3Qga25vd25cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5ldHdvcmsgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLm5ldHdvcmsgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50SW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENsaWVudEluZm8sIGEsIGIpO1xuICB9XG59XG5DbGllbnRJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5DbGllbnRJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LkNsaWVudEluZm9cIjtcbkNsaWVudEluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNka1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwib3NfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRldmljZV9tb2RlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImJyb3dzZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJhZGRyZXNzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIm5ldHdvcmtcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNsaWVudEluZm8uU0RLXG4gKi9cbnZhciBDbGllbnRJbmZvX1NESztcbihmdW5jdGlvbiAoQ2xpZW50SW5mb19TREspIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOID0gMDtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSlMgPSAxO1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJKU1wiXSA9IDFdID0gXCJKU1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNXSUZUID0gMjtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiU1dJRlRcIl0gPSAyXSA9IFwiU1dJRlRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBTkRST0lEID0gMztcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiQU5EUk9JRFwiXSA9IDNdID0gXCJBTkRST0lEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRkxVVFRFUiA9IDQ7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkZMVVRURVJcIl0gPSA0XSA9IFwiRkxVVFRFUlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEdPID0gNTtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiR09cIl0gPSA1XSA9IFwiR09cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTklUWSA9IDY7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIlVOSVRZXCJdID0gNl0gPSBcIlVOSVRZXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUkVBQ1RfTkFUSVZFID0gNztcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiUkVBQ1RfTkFUSVZFXCJdID0gN10gPSBcIlJFQUNUX05BVElWRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJVU1QgPSA4O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJSVVNUXCJdID0gOF0gPSBcIlJVU1RcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQWVRIT04gPSA5O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJQWVRIT05cIl0gPSA5XSA9IFwiUFlUSE9OXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ1BQID0gMTA7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkNQUFwiXSA9IDEwXSA9IFwiQ1BQXCI7XG59KShDbGllbnRJbmZvX1NESyB8fCAoQ2xpZW50SW5mb19TREsgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESywgXCJsaXZla2l0LkNsaWVudEluZm8uU0RLXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNXSUZUXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiQU5EUk9JRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkZMVVRURVJcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJHT1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlVOSVRZXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiUlVTVFwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIlBZVEhPTlwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJDUFBcIlxufV0pO1xuLyoqXG4gKiBzZXJ2ZXIgcHJvdmlkZWQgY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cbiAqL1xuY2xhc3MgQ2xpZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyByZXN1bWVfY29ubmVjdGlvbiA9IDM7XG4gICAgICovXG4gICAgdGhpcy5yZXN1bWVDb25uZWN0aW9uID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyBmb3JjZV9yZWxheSA9IDU7XG4gICAgICovXG4gICAgdGhpcy5mb3JjZVJlbGF5ID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDbGllbnRDb25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuQ2xpZW50Q29uZmlndXJhdGlvbi5ydW50aW1lID0gcHJvdG8zO1xuQ2xpZW50Q29uZmlndXJhdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uXCI7XG5DbGllbnRDb25maWd1cmF0aW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ2aWRlb1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNjcmVlblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGlzYWJsZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEaXNhYmxlZENvZGVjc1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJmb3JjZV9yZWxheVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXG4gKi9cbmNsYXNzIFZpZGVvQ29uZmlndXJhdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyBoYXJkd2FyZV9lbmNvZGVyID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmhhcmR3YXJlRW5jb2RlciA9IENsaWVudENvbmZpZ1NldHRpbmcuVU5TRVQ7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVmlkZW9Db25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuVmlkZW9Db25maWd1cmF0aW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5WaWRlb0NvbmZpZ3VyYXRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCI7XG5WaWRlb0NvbmZpZ3VyYXRpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImhhcmR3YXJlX2VuY29kZXJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkRpc2FibGVkQ29kZWNzXG4gKi9cbmNsYXNzIERpc2FibGVkQ29kZWNzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGRpc2FibGVkIGZvciBib3RoIHB1Ymxpc2ggYW5kIHN1YnNjcmliZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIGNvZGVjcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBvbmx5IGRpc2FibGUgZm9yIHB1Ymxpc2hcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBwdWJsaXNoID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnB1Ymxpc2ggPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGlzYWJsZWRDb2RlY3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENvZGVjcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ29kZWNzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEaXNhYmxlZENvZGVjcywgYSwgYik7XG4gIH1cbn1cbkRpc2FibGVkQ29kZWNzLnJ1bnRpbWUgPSBwcm90bzM7XG5EaXNhYmxlZENvZGVjcy50eXBlTmFtZSA9IFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiO1xuRGlzYWJsZWRDb2RlY3MuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInB1Ymxpc2hcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUERyaWZ0XG4gKi9cbmNsYXNzIFJUUERyaWZ0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBzdGFydF90aW1lc3RhbXAgPSA0O1xuICAgICAqL1xuICAgIHRoaXMuc3RhcnRUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgZW5kX3RpbWVzdGFtcCA9IDU7XG4gICAgICovXG4gICAgdGhpcy5lbmRUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgcnRwX2Nsb2NrX3RpY2tzID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLnJ0cENsb2NrVGlja3MgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBkcmlmdF9zYW1wbGVzID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmRyaWZ0U2FtcGxlcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBkcmlmdF9tcyA9IDg7XG4gICAgICovXG4gICAgdGhpcy5kcmlmdE1zID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBjbG9ja19yYXRlID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrUmF0ZSA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUERyaWZ0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQRHJpZnQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBEcmlmdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUlRQRHJpZnQsIGEsIGIpO1xuICB9XG59XG5SVFBEcmlmdC5ydW50aW1lID0gcHJvdG8zO1xuUlRQRHJpZnQudHlwZU5hbWUgPSBcImxpdmVraXQuUlRQRHJpZnRcIjtcblJUUERyaWZ0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkdXJhdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInN0YXJ0X3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImVuZF90aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJydHBfY2xvY2tfdGlja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkcmlmdF9zYW1wbGVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJkcmlmdF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNsb2NrX3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUFN0YXRzXG4gKi9cbmNsYXNzIFJUUFN0YXRzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldHMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9yYXRlID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldFJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGhlYWRlcl9ieXRlcyA9IDM5O1xuICAgICAqL1xuICAgIHRoaXMuaGVhZGVyQnl0ZXMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgYml0cmF0ZSA9IDc7XG4gICAgICovXG4gICAgdGhpcy5iaXRyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX2xvc3QgPSA4O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c0xvc3QgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9sb3NzX3JhdGUgPSA5O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0TG9zc1JhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgcGFja2V0X2xvc3NfcGVyY2VudGFnZSA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0TG9zc1BlcmNlbnRhZ2UgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfZHVwbGljYXRlID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRzRHVwbGljYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBwYWNrZXRfZHVwbGljYXRlX3JhdGUgPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldER1cGxpY2F0ZVJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzX2R1cGxpY2F0ZSA9IDEzO1xuICAgICAqL1xuICAgIHRoaXMuYnl0ZXNEdXBsaWNhdGUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzX2R1cGxpY2F0ZSA9IDQwO1xuICAgICAqL1xuICAgIHRoaXMuaGVhZGVyQnl0ZXNEdXBsaWNhdGUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgYml0cmF0ZV9kdXBsaWNhdGUgPSAxNDtcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGVEdXBsaWNhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfcGFkZGluZyA9IDE1O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c1BhZGRpbmcgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9wYWRkaW5nX3JhdGUgPSAxNjtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldFBhZGRpbmdSYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBieXRlc19wYWRkaW5nID0gMTc7XG4gICAgICovXG4gICAgdGhpcy5ieXRlc1BhZGRpbmcgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzX3BhZGRpbmcgPSA0MTtcbiAgICAgKi9cbiAgICB0aGlzLmhlYWRlckJ5dGVzUGFkZGluZyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlX3BhZGRpbmcgPSAxODtcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGVQYWRkaW5nID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX291dF9vZl9vcmRlciA9IDE5O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c091dE9mT3JkZXIgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGZyYW1lcyA9IDIwO1xuICAgICAqL1xuICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBmcmFtZV9yYXRlID0gMjE7XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGppdHRlcl9jdXJyZW50ID0gMjI7XG4gICAgICovXG4gICAgdGhpcy5qaXR0ZXJDdXJyZW50ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBqaXR0ZXJfbWF4ID0gMjM7XG4gICAgICovXG4gICAgdGhpcy5qaXR0ZXJNYXggPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbWFwPGludDMyLCB1aW50MzI+IGdhcF9oaXN0b2dyYW0gPSAyNDtcbiAgICAgKi9cbiAgICB0aGlzLmdhcEhpc3RvZ3JhbSA9IHt9O1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tzID0gMjU7XG4gICAgICovXG4gICAgdGhpcy5uYWNrcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19hY2tzID0gMzc7XG4gICAgICovXG4gICAgdGhpcy5uYWNrQWNrcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19taXNzZXMgPSAyNjtcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tNaXNzZXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tfcmVwZWF0ZWQgPSAzODtcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tSZXBlYXRlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGxpcyA9IDI3O1xuICAgICAqL1xuICAgIHRoaXMucGxpcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZmlycyA9IDI5O1xuICAgICAqL1xuICAgIHRoaXMuZmlycyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcnR0X2N1cnJlbnQgPSAzMTtcbiAgICAgKi9cbiAgICB0aGlzLnJ0dEN1cnJlbnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHJ0dF9tYXggPSAzMjtcbiAgICAgKi9cbiAgICB0aGlzLnJ0dE1heCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIga2V5X2ZyYW1lcyA9IDMzO1xuICAgICAqL1xuICAgIHRoaXMua2V5RnJhbWVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBsYXllcl9sb2NrX3BsaXMgPSAzNTtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVyTG9ja1BsaXMgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBTdGF0cygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUFN0YXRzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQU3RhdHMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJUUFN0YXRzLCBhLCBiKTtcbiAgfVxufVxuUlRQU3RhdHMucnVudGltZSA9IHByb3RvMztcblJUUFN0YXRzLnR5cGVOYW1lID0gXCJsaXZla2l0LlJUUFN0YXRzXCI7XG5SVFBTdGF0cy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVuZF90aW1lXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZHVyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYWNrZXRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInBhY2tldF9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiYnl0ZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMzksXG4gIG5hbWU6IFwiaGVhZGVyX2J5dGVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYml0cmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInBhY2tldHNfbG9zdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJwYWNrZXRfbG9zc19yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInBhY2tldF9sb3NzX3BlcmNlbnRhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwYWNrZXRzX2R1cGxpY2F0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwicGFja2V0X2R1cGxpY2F0ZV9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImJ5dGVzX2R1cGxpY2F0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA0MCxcbiAgbmFtZTogXCJoZWFkZXJfYnl0ZXNfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImJpdHJhdGVfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInBhY2tldHNfcGFkZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicGFja2V0X3BhZGRpbmdfcmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJieXRlc19wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDQxLFxuICBuYW1lOiBcImhlYWRlcl9ieXRlc19wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcImJpdHJhdGVfcGFkZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJwYWNrZXRzX291dF9vZl9vcmRlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwiZnJhbWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyMSxcbiAgbmFtZTogXCJmcmFtZV9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDIyLFxuICBuYW1lOiBcImppdHRlcl9jdXJyZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDIzLFxuICBuYW1lOiBcImppdHRlcl9tYXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMjQsXG4gIG5hbWU6IFwiZ2FwX2hpc3RvZ3JhbVwiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gIH1cbn0sIHtcbiAgbm86IDI1LFxuICBuYW1lOiBcIm5hY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzNyxcbiAgbmFtZTogXCJuYWNrX2Fja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDI2LFxuICBuYW1lOiBcIm5hY2tfbWlzc2VzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzOCxcbiAgbmFtZTogXCJuYWNrX3JlcGVhdGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyNyxcbiAgbmFtZTogXCJwbGlzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyOCxcbiAgbmFtZTogXCJsYXN0X3BsaVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAyOSxcbiAgbmFtZTogXCJmaXJzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzMCxcbiAgbmFtZTogXCJsYXN0X2ZpclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzMSxcbiAgbmFtZTogXCJydHRfY3VycmVudFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzIsXG4gIG5hbWU6IFwicnR0X21heFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzMsXG4gIG5hbWU6IFwia2V5X2ZyYW1lc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzQsXG4gIG5hbWU6IFwibGFzdF9rZXlfZnJhbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMzUsXG4gIG5hbWU6IFwibGF5ZXJfbG9ja19wbGlzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzNixcbiAgbmFtZTogXCJsYXN0X2xheWVyX2xvY2tfcGxpXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDQ0LFxuICBuYW1lOiBcInBhY2tldF9kcmlmdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUlRQRHJpZnRcbn0sIHtcbiAgbm86IDQ1LFxuICBuYW1lOiBcInJlcG9ydF9kcmlmdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUlRQRHJpZnRcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UaW1lZFZlcnNpb25cbiAqL1xuY2xhc3MgVGltZWRWZXJzaW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdW5peF9taWNybyA9IDE7XG4gICAgICovXG4gICAgdGhpcy51bml4TWljcm8gPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiB0aWNrcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZWRWZXJzaW9uLCBhLCBiKTtcbiAgfVxufVxuVGltZWRWZXJzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5UaW1lZFZlcnNpb24udHlwZU5hbWUgPSBcImxpdmVraXQuVGltZWRWZXJzaW9uXCI7XG5UaW1lZFZlcnNpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVuaXhfbWljcm9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG5jb25zdCBtYXhSZXRyeURlbGF5ID0gNzAwMDtcbmNvbnN0IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TID0gWzAsIDMwMCwgMiAqIDIgKiAzMDAsIDMgKiAzICogMzAwLCA0ICogNCAqIDMwMCwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheV07XG5jbGFzcyBEZWZhdWx0UmVjb25uZWN0UG9saWN5IHtcbiAgY29uc3RydWN0b3IocmV0cnlEZWxheXMpIHtcbiAgICB0aGlzLl9yZXRyeURlbGF5cyA9IHJldHJ5RGVsYXlzICE9PSB1bmRlZmluZWQgPyBbLi4ucmV0cnlEZWxheXNdIDogREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVM7XG4gIH1cbiAgbmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50ID49IHRoaXMuX3JldHJ5RGVsYXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IHRoaXMuX3JldHJ5RGVsYXlzW2NvbnRleHQucmV0cnlDb3VudF07XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA8PSAxKSByZXR1cm4gcmV0cnlEZWxheTtcbiAgICByZXR1cm4gcmV0cnlEZWxheSArIE1hdGgucmFuZG9tKCkgKiAxMDAwO1xuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBldmVudHMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsO1xudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbicgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xufTtcbnZhciBSZWZsZWN0T3duS2V5cztcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbmV2ZW50cy5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuZXZlbnRzLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG59O1xuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGZpcmVkOiBmYWxzZSxcbiAgICB3cmFwRm46IHVuZGVmaW5lZCxcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwb3NpdGlvbiA9IC0xO1xuICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KCk7ZWxzZSB7XG4gICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG52YXIgZXZlbnRzRXhwb3J0cyA9IGV2ZW50cy5leHBvcnRzO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5sZXQgbG9nRGlzYWJsZWRfID0gdHJ1ZTtcbmxldCBkZXByZWNhdGlvbldhcm5pbmdzXyA9IHRydWU7XG5cbi8qKlxuICogRXh0cmFjdCBicm93c2VyIHZlcnNpb24gb3V0IG9mIHRoZSBwcm92aWRlZCB1c2VyIGFnZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHVhc3RyaW5nIHVzZXJBZ2VudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGV4cHIgUmVndWxhciBleHByZXNzaW9uIHVzZWQgYXMgbWF0Y2ggY3JpdGVyaWEuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBicm93c2VyIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgIGNiLmhhbmRsZUV2ZW50KG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBicm93c2VyOiBudWxsLFxuICAgIHZlcnNpb246IG51bGxcbiAgfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvclxuICB9ID0gd2luZG93O1xuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgIC8vIEZpcmVmb3guXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgd2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXG4gICAgLy8gVmVyc2lvbiBtYXRjaGVzIENocm9tZS9XZWJSVEMgdmVyc2lvbi5cbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKTtcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBzb21ldGhpbmcgeW91IHdhbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIGNvbnN0IHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtcbiAgICAgIFtrZXldOiB2YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG59XG5cbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cbmZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5mdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICBjb25zdCBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICBjb25zdCB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJiB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xuICAgIHJlc3VsdC5mb3JFYWNoKHN0YXRzID0+IHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5jb25zdCBsb2dnaW5nID0gbG9nO1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gdHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7XG4gICAgICAgIGlkZWFsOiBjW2tleV1cbiAgICAgIH07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24gKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lID09PSAnZGV2aWNlSWQnID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbiAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcgPyBmYWNlIDoge1xuICAgICAgICBpZGVhbDogZmFjZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcbiAgICAgIGlmIChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykgJiYgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmICFnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcykpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2Zyb250J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBtYXRjaGVzIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gZm9yIGJhY2sgKHR5cGljYWwpLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgICAgICAgICAgbGV0IGRldiA9IGRldmljZXMuZmluZChkID0+IG1hdGNoZXMuc29tZShtYXRjaCA9PiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcbiAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXYpIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge1xuICAgICAgICAgICAgICAgIGV4YWN0OiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBpZGVhbDogZGV2LmRldmljZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGMgPT4ge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XG5cbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgLy8gY29uc3RyYWludHMuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEkMSh3aW5kb3csIGdldFNvdXJjZUlkKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldFNvdXJjZUlkIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aFxuICAvLyB0aGUgc291cmNlSWQgb2YgdGhlIHNjcmVlbi93aW5kb3cvdGFiIHRvIGJlIHNoYXJlZC5cbiAgaWYgKHR5cGVvZiBnZXRTb3VyY2VJZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ3NoaW1HZXREaXNwbGF5TWVkaWE6IGdldFNvdXJjZUlkIGFyZ3VtZW50IGlzIG5vdCAnICsgJ2EgZnVuY3Rpb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID0gZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUlkKGNvbnN0cmFpbnRzKS50aGVuKHNvdXJjZUlkID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoU3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiYgY29uc3RyYWludHMudmlkZW8ud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHRTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5oZWlnaHQ7XG4gICAgICBjb25zdCBmcmFtZVJhdGVTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5mcmFtZVJhdGU7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2U6ICdkZXNrdG9wJyxcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICBtYXhGcmFtZVJhdGU6IGZyYW1lUmF0ZVNwZWNpZmllZCB8fCAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAod2lkdGhTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heFdpZHRoID0gd2lkdGhTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U3BlY2lmaWVkKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhIZWlnaHQgPSBoZWlnaHRTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cbmZ1bmN0aW9uIHNoaW1PblRyYWNrJDEod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9vbnRyYWNrcG9seSkge1xuICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IGUgPT4ge1xuICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRlLnRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0ge1xuICAgICAgICAgICAgICAgIHRyYWNrOiB0ZS50cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2tcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZXZlbiBpZiBSVENSdHBUcmFuc2NlaXZlciBpcyBpbiB3aW5kb3csIGl0IGlzIG9ubHkgdXNlZCBhbmRcbiAgICAvLyBlbWl0dGVkIGluIHVuaWZpZWQtcGxhbi4gVW5mb3J0dW5hdGVseSB0aGlzIG1lYW5zIHdlIG5lZWRcbiAgICAvLyB0byB1bmNvbmRpdGlvbmFsbHkgd3JhcCB0aGUgZXZlbnQuXG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGlmICghZS50cmFuc2NlaXZlcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICByZWNlaXZlcjogZS5yZWNlaXZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24gKHBjLCB0cmFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIGdldCBkdG1mKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgICAgfSxcbiAgICAgICAgX3BjOiBwY1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYXVnbWVudCBhZGRUcmFjayB3aGVuIGdldFNlbmRlcnMgaXMgbm90IGF2YWlsYWJsZS5cbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kZXJzLnNsaWNlKCk7IC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLlxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgc2VuZGVyID0gc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKTtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgIC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1HZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG5cbiAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGZ1bmN0aW9uIHRoZW4gd2UgYXJlIGluIHRoZSBvbGQgc3R5bGUgc3RhdHMgc28ganVzdFxuICAgIC8vIHBhc3MgYmFjayB0aGUgb3JpZ2luYWwgZ2V0U3RhdHMgZm9ybWF0IHRvIGF2b2lkIGJyZWFraW5nIG9sZCB1c2Vycy5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBzcGVjLXN0eWxlIGdldFN0YXRzIGlzIHN1cHBvcnRlZCwgcmV0dXJuIHRob3NlIHdoZW4gY2FsbGVkIHdpdGhcbiAgICAvLyBlaXRoZXIgbm8gYXJndW1lbnRzIG9yIHRoZSBzZWxlY3RvciBhcmd1bWVudCBpcyBudWxsLlxuICAgIGlmIChvcmlnR2V0U3RhdHMubGVuZ3RoID09PSAwICYmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW10pO1xuICAgIH1cbiAgICBjb25zdCBmaXhDaHJvbWVTdGF0c18gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICBjb25zdCByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICByZXBvcnRzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgICAgICAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICAgICAgICAgIH1bcmVwb3J0LnR5cGVdIHx8IHJlcG9ydC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgfTtcblxuICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICBjb25zdCBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5rZXlzKHN0YXRzKS5tYXAoa2V5ID0+IFtrZXksIHN0YXRzW2tleV1dKSk7XG4gICAgfTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBvblN1Y2MobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXywgc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICAvLyBwcm9taXNlLXN1cHBvcnRcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfSwgcmVqZWN0XSk7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PlxuICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAqICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGlkZW50aWZ5IHRoZSBSVENSdHBTZW5kZXIuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSkpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXG4gIGNvbnN0IG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGV0IHNlbmRlcjtcbiAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgIGxldCBlcnI7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHMgPT4ge1xuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2gociA9PiB7XG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIgfHwgc2VuZGVyICYmIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLm1hcChzdHJlYW1JZCA9PiB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRlcjtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbHRlcihuZXdTZW5kZXIgPT4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTEpO1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW1dLmNvbmNhdChuZXdTZW5kZXJzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBpZiAoc2VuZGVyKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxuICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY1KSB7XG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xuICB9XG5cbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxuICBjb25zdCBvcmlnR2V0TG9jYWxTdHJlYW1zID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFt0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gfHwgc3RyZWFtXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCAhPT0gMSB8fCAhc3RyZWFtc1swXS5nZXRUcmFja3MoKS5maW5kKHQgPT4gdCA9PT0gdHJhY2spKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBhZGFwdGVyLmpzIGFkZFRyYWNrIHBvbHlmaWxsIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgJyArICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICBpZiAob2xkU3RyZWFtKSB7XG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgIC8vIE5vdGU6IHdlIHJlbHkgb24gdGhlIGhpZ2gtbGV2ZWwgYWRkVHJhY2svZHRtZiBzaGltIHRvXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY29uc3QgaXNMZWdhY3lDYWxsID0gYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcbiAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGRlc2NyaXB0aW9uID0+IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG4gIGNvbnN0IG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxuXG4gIGNvbnN0IG9yaWdMb2NhbERlc2NyaXB0aW9uID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBvcmlnTG9jYWxEZXNjcmlwdGlvbi5nZXQuYXBwbHkodGhpcyk7XG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgIC8vIHNpbmNlIHdlIHNoaW0gUlRQU2VuZGVyLiBTbyB3ZSBjaGVjayBpZiBzZW5kZXIuX3BjIGlzIHNldC5cbiAgICBpZiAoIXNlbmRlci5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xuICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICBsZXQgc3RyZWFtO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goc3RyZWFtaWQgPT4ge1xuICAgICAgY29uc3QgaGFzVHJhY2sgPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKS5maW5kKHRyYWNrID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgLy8gdGFrZXMgY2FyZSBvZiBhbnkgc2hpbW1lZCBfc2VuZGVycy5cbiAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBzYW1lIG9kZCBjaHJvbWUgYmVoYXZpb3VyIGFzIGFib3ZlLlxuICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICAgIFttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gZml4IE9OTiBpbiBwbGFuLWIgbW9kZS5cbmZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBlID0+IHtcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgcGMuZ2V0Q29uZmlndXJhdGlvbiAmJiBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxudmFyIGNocm9tZVNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Zml4TmVnb3RpYXRpb25OZWVkZWQ6IGZpeE5lZ290aWF0aW9uTmVlZGVkLFxuXHRzaGltQWRkVHJhY2tSZW1vdmVUcmFjazogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2ssXG5cdHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZTogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlLFxuXHRzaGltR2V0RGlzcGxheU1lZGlhOiBzaGltR2V0RGlzcGxheU1lZGlhJDEsXG5cdHNoaW1HZXRTZW5kZXJzV2l0aER0bWY6IHNoaW1HZXRTZW5kZXJzV2l0aER0bWYsXG5cdHNoaW1HZXRTdGF0czogc2hpbUdldFN0YXRzLFxuXHRzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDIsXG5cdHNoaW1NZWRpYVN0cmVhbTogc2hpbU1lZGlhU3RyZWFtLFxuXHRzaGltT25UcmFjazogc2hpbU9uVHJhY2skMSxcblx0c2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24kMSxcblx0c2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHM6IHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBkZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAoIShjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbykpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7XG4gICAgICAgIG1lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8ubWVkaWFTb3VyY2UgPSBwcmVmZXJyZWRNZWRpYVNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gIH07XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1xuICAgICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtb2Rlcm5TdGF0c1R5cGVzID0ge1xuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXG4gICAgb3V0Ym91bmRydHA6ICdvdXRib3VuZC1ydHAnLFxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gIH07XG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSkudGhlbihzdGF0cyA9PiB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXG4gICAgICAgICAgc3RhdHMuZm9yRWFjaCgoc3RhdCwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuICB9XG4gIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgPyB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKSA6IFByb21pc2UucmVzb2x2ZShuZXcgTWFwKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgfTtcbiAgfVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgZGVwcmVjYXRlZCgncmVtb3ZlU3RyZWFtJywgJ3JlbW92ZVRyYWNrJyk7XG4gICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KSB7XG4gIC8vIHJlbmFtZSBEYXRhQ2hhbm5lbCB0byBSVENEYXRhQ2hhbm5lbCAobmF0aXZlIGZpeCBpbiBGRjYwKTpcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE3Mzg1MVxuICBpZiAod2luZG93LkRhdGFDaGFubmVsICYmICF3aW5kb3cuUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB3aW5kb3cuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuRGF0YUNoYW5uZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9IGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIC8vIFdlYklETCBpbnB1dCBjb2VyY2lvbiBhbmQgdmFsaWRhdGlvblxuICAgICAgbGV0IHNlbmRFbmNvZGluZ3MgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnNlbmRFbmNvZGluZ3M7XG4gICAgICBpZiAoc2VuZEVuY29kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNlbmRFbmNvZGluZ3MgPSBbLi4uc2VuZEVuY29kaW5nc107XG4gICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBzZW5kRW5jb2RpbmdzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICBzZW5kRW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmdQYXJhbSA9PiB7XG4gICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gb3JpZ0FkZFRyYW5zY2VpdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxuICAgICAgICAvLyBhc3luY2hyb25vdXMgd2F5IGFuZCBzYXZlIHRoZSBwcm9taXNlIHJlZmVyZW5jZSBpbiBhIGdsb2JhbCBvYmplY3QuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gdWdseSBoYWNrLCBidXQgYXQgdGhlIHNhbWUgdGltZSBpcyB3YXkgbW9yZSByb2J1c3QgdGhhblxuICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcbiAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYWZ0ZXIgdGhlIGNyZWF0ZW9mZmVyIHdlIGFyZSBub3QgMTAwJSBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIHBhcmFtcyB3ZXJlIGFzeW5jaHJvbm91c2x5IGFwcGxpZWQgc28gd2UgbWlnaHQgbWlzcyB0aGVcbiAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZW5kZXJcbiAgICAgICAgfSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiYgT2JqZWN0LmtleXMocGFyYW1zLmVuY29kaW5nc1swXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRQYXJhbWV0ZXJzID0gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycztcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBmaXJlZm94U2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRzaGltQWRkVHJhbnNjZWl2ZXI6IHNoaW1BZGRUcmFuc2NlaXZlcixcblx0c2hpbUNyZWF0ZUFuc3dlcjogc2hpbUNyZWF0ZUFuc3dlcixcblx0c2hpbUNyZWF0ZU9mZmVyOiBzaGltQ3JlYXRlT2ZmZXIsXG5cdHNoaW1HZXREaXNwbGF5TWVkaWE6IHNoaW1HZXREaXNwbGF5TWVkaWEsXG5cdHNoaW1HZXRQYXJhbWV0ZXJzOiBzaGltR2V0UGFyYW1ldGVycyxcblx0c2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSQxLFxuXHRzaGltT25UcmFjazogc2hpbU9uVHJhY2ssXG5cdHNoaW1QZWVyQ29ubmVjdGlvbjogc2hpbVBlZXJDb25uZWN0aW9uLFxuXHRzaGltUlRDRGF0YUNoYW5uZWw6IHNoaW1SVENEYXRhQ2hhbm5lbCxcblx0c2hpbVJlY2VpdmVyR2V0U3RhdHM6IHNoaW1SZWNlaXZlckdldFN0YXRzLFxuXHRzaGltUmVtb3ZlU3RyZWFtOiBzaGltUmVtb3ZlU3RyZWFtLFxuXHRzaGltU2VuZGVyR2V0U3RhdHM6IHNoaW1TZW5kZXJHZXRTdGF0c1xufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldExvY2FsU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RyZWFtcztcbiAgICB9O1xuICB9XG4gIGlmICghKCdhZGRTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgY29uc3QgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLCBzdHJlYW0pKTtcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0UmVtb3RlU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XG4gICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGUgPT4ge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIGNvbnN0IHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgY29uc3Qgc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIGNvbnN0IGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gYWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIFtjYW5kaWRhdGVdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xufVxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBjb25zdHJhaW50cyA9PiB7XG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcbiAgICB9O1xuICB9XG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihjYiwgZXJyY2IpO1xuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMsIHtcbiAgICAgIHZpZGVvOiBjb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xuICAgICAgICAgIGRlcHJlY2F0ZWQoJ1JUQ0ljZVNlcnZlci51cmwnLCAnUlRDSWNlU2VydmVyLnVybHMnKTtcbiAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xuICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICBkZWxldGUgc2VydmVyLnVybDtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICBpZiAoJ2dlbmVyYXRlQ2VydGlmaWNhdGUnIGluIE9yaWdQZWVyQ29ubmVjdGlvbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gT3JpZ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIEFkZCBldmVudC50cmFuc2NlaXZlciBtZW1iZXIgb3ZlciBkZXByZWNhdGVkIGV2ZW50LnJlY2VpdmVyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcbiAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJiAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJiAhdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BdWRpb0NvbnRleHQod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCB3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xufVxuXG52YXIgc2FmYXJpU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRzaGltQXVkaW9Db250ZXh0OiBzaGltQXVkaW9Db250ZXh0LFxuXHRzaGltQ2FsbGJhY2tzQVBJOiBzaGltQ2FsbGJhY2tzQVBJLFxuXHRzaGltQ29uc3RyYWludHM6IHNoaW1Db25zdHJhaW50cyxcblx0c2hpbUNyZWF0ZU9mZmVyTGVnYWN5OiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3ksXG5cdHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEsXG5cdHNoaW1Mb2NhbFN0cmVhbXNBUEk6IHNoaW1Mb2NhbFN0cmVhbXNBUEksXG5cdHNoaW1SVENJY2VTZXJ2ZXJVcmxzOiBzaGltUlRDSWNlU2VydmVyVXJscyxcblx0c2hpbVJlbW90ZVN0cmVhbXNBUEk6IHNoaW1SZW1vdGVTdHJlYW1zQVBJLFxuXHRzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyOiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyXG59KTtcblxudmFyIHNkcCQxID0ge2V4cG9ydHM6IHt9fTtcblxuLyogZXNsaW50LWVudiBub2RlICovXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIC8vIFNEUCBoZWxwZXJzLlxuICBjb25zdCBTRFBVdGlscyA9IHt9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuICAvLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gIH07XG5cbiAgLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG4gIFNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAvLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuICBTRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgfTtcbiAgLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG4gIFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbicpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG4gIFNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gICAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXG4gIFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucztcbiAgfTtcblxuICAvLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuICBTRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChibG9iLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMCk7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuICAvLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44LjhcbiAgLy8gcnBvcnQgNTU5OTZcIlxuICAvLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cbiAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGxldCBwYXJ0cztcbiAgICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICAgIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgIH1cbiAgICBjb25zdCBjYW5kaWRhdGUgPSB7XG4gICAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICAgIGNvbXBvbmVudDoge1xuICAgICAgICAxOiAncnRwJyxcbiAgICAgICAgMjogJ3J0Y3AnXG4gICAgICB9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgICBpcDogcGFydHNbNF0sXG4gICAgICBhZGRyZXNzOiBwYXJ0c1s0XSxcbiAgICAgIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICAgIHR5cGU6IHBhcnRzWzddXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICAgIGlmIChjYW5kaWRhdGVbcGFydHNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xuICB9O1xuXG4gIC8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4gIC8vIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgYT0gcHJlZml4IVxuICBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICBjb25zdCBzZHAgPSBbXTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gICAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgICBpZiAoY29tcG9uZW50ID09PSAncnRwJykge1xuICAgICAgc2RwLnB1c2goMSk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgICAgc2RwLnB1c2goMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5hZGRyZXNzIHx8IGNhbmRpZGF0ZS5pcCk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuICAgIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgICBzZHAucHVzaCgndHlwJyk7XG4gICAgc2RwLnB1c2godHlwZSk7XG4gICAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiYgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4gIC8vIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG4gIFNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuICBTRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgICB9O1xuICAgIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcbiAgICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICAgIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICAgIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAgIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICAgIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIHJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4gIC8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xuICAgIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gIFNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgICB1cmk6IHBhcnRzWzFdLFxuICAgICAgYXR0cmlidXRlczogcGFydHMuc2xpY2UoMikuam9pbignICcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4gIC8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cbiAgU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbiAoaGVhZGVyRXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICsgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gOiAnJykgKyAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgKGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzID8gJyAnICsgaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgOiAnJykgKyAnXFxyXFxuJztcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBmbXRwIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuICAvLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cbiAgU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgICBsZXQga3Y7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZm10cCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICBTRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBsZXQgbGluZXMgPSAnJztcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICsgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICsgJ1xcclxcbic7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuICBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgICBjb25zdCBwYXJ0cyA9IHtcbiAgICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApXG4gICAgfTtcbiAgICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgICBpZiAoY29sb24gPiAtMSkge1xuICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxLCBjb2xvbik7XG4gICAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG4gIFNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEzKS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKVxuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuICAvLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cbiAgU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICAgIGlmIChtaWQpIHtcbiAgICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG4gIFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbiAgLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG4gIFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1maW5nZXJwcmludDonKTtcbiAgICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvbGU6ICdhdXRvJyxcbiAgICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gICAgfTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIFNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICAgIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNkcDtcbiAgfTtcblxuICAvLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuICBTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgY3J5cHRvU3VpdGU6IHBhcnRzWzFdLFxuICAgICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpXG4gICAgfTtcbiAgfTtcbiAgU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgKyAodHlwZW9mIHBhcmFtZXRlcnMua2V5UGFyYW1zID09PSAnb2JqZWN0JyA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKSA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICsgJ1xcclxcbic7XG4gIH07XG5cbiAgLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxuICBTRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgICBsaWZlVGltZTogcGFydHNbMV0sXG4gICAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9O1xuICBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6JyArIGtleVBhcmFtcy5rZXlTYWx0ICsgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aCA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGggOiAnJyk7XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgYWxsIFNERVMgcGFyYW1ldGVycy5cbiAgU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9Y3J5cHRvOicpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbiAgfTtcblxuICAvLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuICAvLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuICBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtdWZyYWc6JylbMF07XG4gICAgY29uc3QgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS1wd2Q6JylbMF07XG4gICAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxuICAgICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApXG4gICAgfTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgKyAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgICBpZiAocGFyYW1zLmljZUxpdGUpIHtcbiAgICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICBjb2RlY3M6IFtdLFxuICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICAgIHJ0Y3A6IFtdXG4gICAgfTtcbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gICAgZGVzY3JpcHRpb24ucHJvZmlsZSA9IG1saW5lWzJdO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XG4gICAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgICB9KTtcbiAgICBjb25zdCB3aWxkY2FyZFJ0Y3BGYiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjoqICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYiA9PiB7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiYgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuICAvLyBwYXJhbWV0ZXJzLlxuICBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGtpbmQsIGNhcHMpIHtcbiAgICBsZXQgc2RwID0gJyc7XG5cbiAgICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gICAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICAgIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICAgIHNkcCArPSAnICcgKyAoY2Fwcy5wcm9maWxlIHx8ICdVRFAvVExTL1JUUC9TQVZQRicpICsgJyAnO1xuICAgIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gICAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gICAgfSk7XG4gICAgbGV0IG1heHB0aW1lID0gMDtcbiAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgICByZXR1cm4gc2RwO1xuICB9O1xuXG4gIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICAgIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gICAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICAgIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgICBsZXQgc2Vjb25kYXJ5U3NyYztcbiAgICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKS5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XG4gICAgfSk7XG4gICAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgICB9XG4gICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgICBlbmNQYXJhbS5ydHggPSB7XG4gICAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg3KSwgMTApO1xuICAgICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNSksIDEwKSAqIDEwMDAgKiAwLjk1IC0gNTAgKiA0MCAqIDg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xuICB9O1xuXG4gIC8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuICBTRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgICAvLyBTU1JDcy5cbiAgICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xuICAgIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICAgIH1cblxuICAgIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAgIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgICBjb25zdCBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gICAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xuICB9O1xuICBTRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IHNkcCA9ICcnO1xuICAgIGlmIChydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAocnRjcFBhcmFtZXRlcnMubXV4KSB7XG4gICAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAocnRjcFBhcmFtZXRlcnMuc3NyYyAhPT0gdW5kZWZpbmVkICYmIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lKSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuICAvLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuICBTRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgbGV0IHBhcnRzO1xuICAgIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gICAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICB0cmFjazogcGFydHNbMV1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gICAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogcGFydHNbMF0sXG4gICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU0NUUFxuICAvLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbiAgLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcbiAgU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICB9XG4gICAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxuICAgICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICAgIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF0uc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU0NUUFxuICAvLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4gIC8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4gIC8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4gIC8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcbiAgU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWEsIHNjdHApIHtcbiAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJywgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLCAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ107XG4gICAgfVxuICAgIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbiAgLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4gIC8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuICBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG4gIH07XG5cbiAgLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbiAgLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbiAgLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4gIC8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4gIC8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG4gIFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24gKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgICBsZXQgc2Vzc2lvbklkO1xuICAgIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgICBpZiAoc2Vzc0lkKSB7XG4gICAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAgIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICAgIHJldHVybiAndj0wXFxyXFxuJyArICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgKyAncz0tXFxyXFxuJyArICd0PTAgMFxcclxcbic7XG4gIH07XG5cbiAgLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG4gIFNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyaW5nKDIpO1xuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZXNzaW9ucGFydCkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gICAgfVxuICAgIHJldHVybiAnc2VuZHJlY3YnO1xuICB9O1xuICBTRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xuICB9O1xuICBTRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xuICB9O1xuICBTRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpXG4gICAgfTtcbiAgfTtcbiAgU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgICAgYWRkcmVzczogcGFydHNbNV1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cbiAgU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbiAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4gIH1cbn0pKHNkcCQxKTtcbnZhciBzZHBFeHBvcnRzID0gc2RwJDEuZXhwb3J0cztcbnZhciBTRFBVdGlscyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZHBFeHBvcnRzKTtcblxudmFyIHNkcCA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0OiBTRFBVdGlsc1xufSwgW3NkcEV4cG9ydHNdKTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2FuZGlkYXRlLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuYXRpdmVDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUuY2FuZGlkYXRlKTtcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHJlbGF5UHJvdG9jb2wuXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XG4gICAgICAgICAgMDogJ3RscycsXG4gICAgICAgICAgMTogJ3RjcCcsXG4gICAgICAgICAgMjogJ3VkcCdcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNkcFNlbWFudGljc1xuICAgICAgfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICBjb25zdCBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgfVxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gIH07XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MDUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgY29uc3Qgc2RwID0gZGVzYy5zZHAuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAvLyBTYWZhcmkgZW5mb3JjZXMgcmVhZC1vbmx5LW5lc3Mgb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIGZpZWxkcy5cbiAgICAgIGlmICh3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICYmIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzYy5zZHAgPSBzZHA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8vIFN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgLy8gYXMgd2VsbCBhcyBhZGRJY2VDYW5kaWRhdGUoe2NhbmRpZGF0ZTogXCJcIiwgLi4ufSlcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXG4gIC8vIE5vdGU6IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBwb2x5ZmlsbHMgd2hpY2ggY2hhbmdlIHRoZSBzaWduYXR1cmUuXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgaWYgKCFuYXRpdmVBZGRJY2VDYW5kaWRhdGUgfHwgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgLy8gTmF0aXZlIHN1cHBvcnQgZm9yIGlnbm9yaW5nIGV4aXN0cyBmb3IgQ2hyb21lIE03NysuXG4gICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgIC8vIHZlcnNpb24gdGhhdCBhbHNvIGlnbm9yZXMgYWRkSWNlQ2FuZGlkYXRlKG51bGwpLlxuICAgIGlmICgoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScpICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmZ1bmN0aW9uIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBpZiAoIW5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gfHwgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnIHx8IGRlc2MudHlwZSAmJiBkZXNjLnNkcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbWFpbmluZyBzdGVwcyBzaG91bGQgdGVjaG5pY2FsbHkgaGFwcGVuIHdoZW4gU0xEIGNvbWVzIG9mZiB0aGVcbiAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgIC8vIHRoaXMgaXMgdG9vIGRpZmZpY3VsdCB0byBzaGltLiBJbnN0ZWFkLCB0aGlzIHNoaW0gb25seSBjb3ZlcnMgdGhlXG4gICAgLy8gY29tbW9uIGNhc2Ugd2hlcmUgdGhlIG9wZXJhdGlvbnMgY2hhaW4gaXMgZW1wdHkuIFRoaXMgaXMgaW1wZXJmZWN0LCBidXRcbiAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAvLyB3aW5kb3cgdG8gemVybyBvbiBpbXBlcmZlY3QgaW1wbGVtZW50YXRpb25zLCB0aGVyZSdzIHZhbHVlIGluIHRhcHBpbmdcbiAgICAvLyBpbnRvIHRoZSBwZXJmZWN0IG5lZ290aWF0aW9uIHBhdHRlcm4gdGhhdCBzZXZlcmFsIGJyb3dzZXJzIHN1cHBvcnQuXG4gICAgZGVzYyA9IHtcbiAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgIHNkcDogZGVzYy5zZHBcbiAgICB9O1xuICAgIGlmICghZGVzYy50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgY2FzZSAnaGF2ZS1sb2NhbC1vZmZlcic6XG4gICAgICAgIGNhc2UgJ2hhdmUtcmVtb3RlLXByYW5zd2VyJzpcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVzYy5zZHAgfHwgZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBkZXNjLnR5cGUgPT09ICdvZmZlcicgPyB0aGlzLmNyZWF0ZU9mZmVyIDogdGhpcy5jcmVhdGVBbnN3ZXI7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcykudGhlbihkID0+IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2RdKSk7XG4gIH07XG59XG5cbnZhciBjb21tb25TaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQ6IHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQsXG5cdHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eTogc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5LFxuXHRzaGltQ29ubmVjdGlvblN0YXRlOiBzaGltQ29ubmVjdGlvblN0YXRlLFxuXHRzaGltTWF4TWVzc2FnZVNpemU6IHNoaW1NYXhNZXNzYWdlU2l6ZSxcblx0c2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uOiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24sXG5cdHNoaW1SVENJY2VDYW5kaWRhdGU6IHNoaW1SVENJY2VDYW5kaWRhdGUsXG5cdHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sOiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCxcblx0c2hpbVNlbmRUaHJvd1R5cGVFcnJvcjogc2hpbVNlbmRUaHJvd1R5cGVFcnJvclxufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbmZ1bmN0aW9uIGFkYXB0ZXJGYWN0b3J5KCkge1xuICBsZXQge1xuICAgIHdpbmRvd1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBzaGltQ2hyb21lOiB0cnVlLFxuICAgIHNoaW1GaXJlZm94OiB0cnVlLFxuICAgIHNoaW1TYWZhcmk6IHRydWVcbiAgfTtcbiAgLy8gVXRpbHMuXG4gIGNvbnN0IGxvZ2dpbmcgPSBsb2c7XG4gIGNvbnN0IGJyb3dzZXJEZXRhaWxzID0gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IGV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IGRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiBkaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwXG4gIH07XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24kMSB8fCAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltT25UcmFjayQxKHdpbmRvdyk7XG4gICAgICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KTtcbiAgICAgIHNoaW1HZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1PblRyYWNrKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KTtcbiAgICAgIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFBhcmFtZXRlcnMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpO1xuICAgICAgc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIHNoaW1BdWRpb0NvbnRleHQod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuYWRhcHRlckZhY3Rvcnkoe1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogd2luZG93XG59KTtcblxuY29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XG4vLyBIb3cgbWFueSBjb25zZWN1dGl2ZSBmcmFtZXMgY2FuIGZhaWwgZGVjcnlwdGluZyBiZWZvcmUgYSBwYXJ0aWN1bGFyIGtleSBnZXRzIG1hcmtlZCBhcyBpbnZhbGlkXG5jb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmNvbnN0IEUyRUVfRkxBRyA9ICdsa19lMmVlJztcbmNvbnN0IFNBTFQgPSAnTEtGcmFtZUVuY3J5cHRpb25LZXknO1xuY29uc3QgS0VZX1BST1ZJREVSX0RFRkFVTFRTID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0Vcbn07XG5cbnZhciBLZXlQcm92aWRlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlQcm92aWRlckV2ZW50KSB7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJTZXRLZXlcIl0gPSBcInNldEtleVwiO1xuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xufSkoS2V5UHJvdmlkZXJFdmVudCB8fCAoS2V5UHJvdmlkZXJFdmVudCA9IHt9KSk7XG52YXIgS2V5SGFuZGxlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlIYW5kbGVyRXZlbnQpIHtcbiAgS2V5SGFuZGxlckV2ZW50W1wiS2V5UmF0Y2hldGVkXCJdID0gXCJrZXlSYXRjaGV0ZWRcIjtcbn0pKEtleUhhbmRsZXJFdmVudCB8fCAoS2V5SGFuZGxlckV2ZW50ID0ge30pKTtcbnZhciBFbmNyeXB0aW9uRXZlbnQ7XG4oZnVuY3Rpb24gKEVuY3J5cHRpb25FdmVudCkge1xuICBFbmNyeXB0aW9uRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIEVuY3J5cHRpb25FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG59KShFbmNyeXB0aW9uRXZlbnQgfHwgKEVuY3J5cHRpb25FdmVudCA9IHt9KSk7XG52YXIgQ3J5cHRvckV2ZW50O1xuKGZ1bmN0aW9uIChDcnlwdG9yRXZlbnQpIHtcbiAgQ3J5cHRvckV2ZW50W1wiRXJyb3JcIl0gPSBcImNyeXB0b3JFcnJvclwiO1xufSkoQ3J5cHRvckV2ZW50IHx8IChDcnlwdG9yRXZlbnQgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1ZpZGVvRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEtleShrZXlCeXRlcykge1xuICBsZXQgYWxnb3JpdGhtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE1cbiAgfTtcbiAgbGV0IHVzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZW5jcnlwdCc7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleUJ5dGVzLCBhbGdvcml0aG0sIGZhbHNlLCB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcocGFzc3dvcmQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShwYXNzd29yZCksIHtcbiAgICAgIG5hbWU6ICdQQktERjInXG4gICAgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXIpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBjcnlwdG9CdWZmZXIsICdIS0RGJywgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWUsIHNhbHQpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZW5jb2RlZFNhbHQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc2FsdCk7XG4gIHN3aXRjaCAoYWxnb3JpdGhtTmFtZSkge1xuICAgIGNhc2UgJ0hLREYnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpbmZvOiBuZXcgQXJyYXlCdWZmZXIoMTI4KVxuICAgICAgfTtcbiAgICBjYXNlICdQQktERjInOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxnb3JpdGhtIFwiLmNvbmNhdChhbGdvcml0aG1OYW1lLCBcIiBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRcIikpO1xuICB9XG59XG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5mdW5jdGlvbiBkZXJpdmVLZXlzKG1hdGVyaWFsLCBzYWx0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hrZGZQYXJhbXNcbiAgICBjb25zdCBlbmNyeXB0aW9uS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjhcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGVyaWFsLFxuICAgICAgZW5jcnlwdGlvbktleVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRTJFRUtleSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG59XG4vKipcbiAqIFJhdGNoZXRzIGEga2V5LiBTZWVcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuNS4xXG4gKi9cbmZ1bmN0aW9uIHJhdGNoZXQobWF0ZXJpYWwsIHNhbHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlQml0c1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG4gIH0pO1xufVxuZnVuY3Rpb24gbmVlZHNSYnNwVW5lc2NhcGluZyhmcmFtZURhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZURhdGEubGVuZ3RoIC0gMzsgaSsrKSB7XG4gICAgaWYgKGZyYW1lRGF0YVtpXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDJdID09IDMpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmJzcChzdHJlYW0pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOykge1xuICAgIC8vIEJlIGNhcmVmdWwgYWJvdXQgb3Zlci91bmRlcmZsb3cgaGVyZS4gYnl0ZV9sZW5ndGhfIC0gMyBjYW4gdW5kZXJmbG93LCBhbmRcbiAgICAvLyBpICsgMyBjYW4gb3ZlcmZsb3csIGJ1dCBieXRlX2xlbmd0aF8gLSBpIGNhbid0LCBiZWNhdXNlIGkgPCBieXRlX2xlbmd0aF9cbiAgICAvLyBhYm92ZSwgYW5kIHRoYXQgZXhwcmVzc2lvbiB3aWxsIHByb2R1Y2UgdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IGluXG4gICAgLy8gdGhlIHN0cmVhbSBpbmNsdWRpbmcgdGhlIGJ5dGUgYXQgaS5cbiAgICBpZiAobGVuZ3RoIC0gaSA+PSAzICYmICFzdHJlYW1baV0gJiYgIXN0cmVhbVtpICsgMV0gJiYgc3RyZWFtW2kgKyAyXSA9PSAzKSB7XG4gICAgICAvLyBUd28gcmJzcCBieXRlcy5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgLy8gU2tpcCB0aGUgZW11bGF0aW9uIGJ5dGUuXG4gICAgICBpKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNpbmdsZSByYnNwIGJ5dGUuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW4pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV9pbi5sZW5ndGg7ICsraSkge1xuICAgIHZhciBieXRlID0gZGF0YV9pbltpXTtcbiAgICBpZiAoYnl0ZSA8PSBrRW11bGF0aW9uQnl0ZSAmJiBudW1Db25zZWN1dGl2ZVplcm9zID49IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSkge1xuICAgICAgLy8gTmVlZCB0byBlc2NhcGUuXG4gICAgICBkYXRhT3V0LnB1c2goa0VtdWxhdGlvbkJ5dGUpO1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICAgIGRhdGFPdXQucHVzaChieXRlKTtcbiAgICBpZiAoYnl0ZSA9PSAwKSB7XG4gICAgICArK251bUNvbnNlY3V0aXZlWmVyb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBCYXNlS2V5UHJvdmlkZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGNhbGxiYWNrIGJlaW5nIGludm9rZWQgYWZ0ZXIgYSByYXRjaGV0IHJlcXVlc3QgaGFzIGJlZW4gcGVyZm9ybWVkIG9uIGEgcGFydGljaXBhbnRcbiAgICAgKiB0aGF0IHN1cmZhY2VzIHRoZSBuZXcga2V5IG1hdGVyaWFsLlxuICAgICAqIEBwYXJhbSBtYXRlcmlhbFxuICAgICAqIEBwYXJhbSBrZXlJbmRleFxuICAgICAqL1xuICAgIHRoaXMub25LZXlSYXRjaGV0ZWQgPSAobWF0ZXJpYWwsIGtleUluZGV4KSA9PiB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdrZXkgcmF0Y2hldGVkIGV2ZW50IHJlY2VpdmVkJywge1xuICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5rZXlJbmZvTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgS0VZX1BST1ZJREVSX0RFRkFVTFRTKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIGEga2V5IGhhcyBiZWVuIHNldCBmb3IgYSBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKi9cbiAgb25TZXRFbmNyeXB0aW9uS2V5KGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfTtcbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KFwiXCIuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IG51bGwgJiYgcGFydGljaXBhbnRJZGVudGl0eSAhPT0gdm9pZCAwID8gcGFydGljaXBhbnRJZGVudGl0eSA6ICdzaGFyZWQnLCBcIi1cIikuY29uY2F0KGtleUluZGV4ICE9PSBudWxsICYmIGtleUluZGV4ICE9PSB2b2lkIDAgPyBrZXlJbmRleCA6IDApLCBrZXlJbmZvKTtcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8pO1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlJbmZvTWFwLnZhbHVlcygpKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gIH1cbn1cbi8qKlxuICogQSBiYXNpYyBLZXlQcm92aWRlciBpbXBsZW1lbnRhdGlvbiBpbnRlbmRlZCBmb3IgYSBzaW5nbGUgc2hhcmVkXG4gKiBwYXNzcGhyYXNlIGJldHdlZW4gYWxsIHBhcnRpY2lwYW50c1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgc2hhcmVkS2V5OiB0cnVlLFxuICAgICAgLy8gZm9yIGEgc2hhcmVkIGtleSBwcm92aWRlciBmYWlsaW5nIHRvIGRlY3J5cHQgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnRcbiAgICAgIC8vIHNob3VsZCBub3QgbWFyayB0aGUga2V5IGFzIGludmFsaWQsIHNvIHdlIGFjY2VwdCB3cm9uZyBrZXlzIGZvcmV2ZXJcbiAgICAgIC8vIGFuZCB3b24ndCB0cnkgdG8gYXV0by1yYXRjaGV0XG4gICAgICByYXRjaGV0V2luZG93U2l6ZTogMCxcbiAgICAgIGZhaWx1cmVUb2xlcmFuY2U6IC0xXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBzZXRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHlpZWxkIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhrZXkpIDogeWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGtleSk7XG4gICAgICB0aGlzLm9uU2V0RW5jcnlwdGlvbktleShkZXJpdmVkS2V5KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbiwgc3RhdHVzKSB7XG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn1cbmNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufVxuY2xhc3MgVHJhY2tJbnZhbGlkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjAsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgfVxufVxuY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgfVxufVxuY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBwdWJsaXNoIGRhdGEnKTtcbiAgfVxufVxudmFyIE1lZGlhRGV2aWNlRmFpbHVyZTtcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IFwiUGVybWlzc2lvbkRlbmllZFwiO1xuICAvLyBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZVxuICBNZWRpYURldmljZUZhaWx1cmVbXCJOb3RGb3VuZFwiXSA9IFwiTm90Rm91bmRcIjtcbiAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICBNZWRpYURldmljZUZhaWx1cmVbXCJEZXZpY2VJblVzZVwiXSA9IFwiRGV2aWNlSW5Vc2VcIjtcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiT3RoZXJcIl0gPSBcIk90aGVyXCI7XG59KShNZWRpYURldmljZUZhaWx1cmUgfHwgKE1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmICduYW1lJyBpbiBlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnRGV2aWNlc05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuTm90Rm91bmQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLkRldmljZUluVXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5PdGhlcjtcbiAgICB9XG4gIH1cbiAgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUgPSBnZXRGYWlsdXJlO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuXG4vKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgU3RhdGVDaGFuZ2VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuICAgKi9cbiAgUm9vbUV2ZW50W1wiU3RhdGVDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcm9vbVxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cbiAgICogVGhpcyBhbGxvd3MgZm9yIGFwcGxpY2F0aW9ucyB0byBzaG93IFVJIGluZm9ybWluZyB1c2VycyB0aGF0IHRoZXkgbWlnaHQgaGF2ZSB0b1xuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKlxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cbiAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgKlxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUm9vbU1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicm9vbU1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0sIHRvcGljPzogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgKHJlbW90ZSkgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBzdGF0dXMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgYXVkaW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGF1ZGlvIGVsZW1lbnRzLiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogYFJvb20uY2FuUGxheWJhY2tBdWRpb2Agd2lsbCBpbmRpY2F0ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBwZXJtaXR0ZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCB2aWRlbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYSB2aWRlbyBlbGVtZW50LiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogQ2FsbGluZyBgcm9vbS5zdGFydFZpZGVvKClgIGluIGEgdXNlciBnZXN0dXJlIGV2ZW50IGhhbmRsZXIgd2lsbCByZXN1bWUgdGhlIHZpZGVvIHBsYXliYWNrLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcInZpZGVvUGxheWJhY2tDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHdlIGhhdmUgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0cmFjay5cbiAgICogVGhlIGVycm9ycyB0YWtlIHBsYWNlIGluIGdldFVzZXJNZWRpYSgpLlxuICAgKiBVc2UgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUoZXJyb3IpIHRvIGdldCB0aGUgcmVhc29uIG9mIGZhaWx1cmUuXG4gICAqIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0Q2FtZXJhRXJyb3JdXSBhbmQgW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RNaWNyb3Bob25lRXJyb3JdXVxuICAgKiB3aWxsIGluZGljYXRlIGlmIGl0IGhhZCBhbiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgYXVkaW8gb3IgdmlkZW8gdHJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKiBhcmdzOiAoZXJyb3I6IEVycm9yKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC4gQ3VycmVudGx5IG9ubHkgZmlyZWQgb24gTG9jYWxQYXJ0aWNpcGFudC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xuICAvKipcbiAgICogU2lnbmFsIGNvbm5lY3RlZCwgY2FuIHB1Ymxpc2ggdHJhY2tzLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFJlY29yZGluZyBvZiBhIHJvb20gaGFzIHN0YXJ0ZWQvc3RvcHBlZC4gUm9vbS5pc1JlY29yZGluZyB3aWxsIGJlIHVwZGF0ZWQgdG9vLlxuICAgKiBhcmdzOiAoaXNSZWNvcmRpbmc6IGJvb2xlYW4pXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvcmRpbmdTdGF0dXNDaGFuZ2VkXCJdID0gXCJyZWNvcmRpbmdTdGF0dXNDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiRW5jcnlwdGlvbkVycm9yXCJdID0gXCJlbmNyeXB0aW9uRXJyb3JcIjtcbiAgLyoqXG4gICAqIEVtaXRzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGJ1ZmZlciBzdGF0dXMgb2YgYSBkYXRhIGNoYW5uZWwgY2hhbmdlc1xuICAgKiBhcmdzOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWRcIl0gPSBcImRjQnVmZmVyU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJ5IGEgY2FsbCB0byByb29tLnN3aXRjaEFjdGl2ZURldmljZVxuICAgKiBhcmdzOiAoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlRGV2aWNlQ2hhbmdlZFwiXSA9IFwiYWN0aXZlRGV2aWNlQ2hhbmdlZFwiO1xufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAqXG4gICAqIGFyZ3M6IChzcGVha2luZzogYm9vbGVhbilcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJJc1NwZWFraW5nQ2hhbmdlZFwiXSA9IFwiaXNTcGVha2luZ0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkF1ZGlvU3RyZWFtQWNxdWlyZWRcIl0gPSBcImF1ZGlvU3RyZWFtQWNxdWlyZWRcIjtcbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLiBDdXJyZW50bHkgb25seSBmaXJlZCBvbiBMb2NhbFBhcnRpY2lwYW50LlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQQ1RyYWNrQWRkZWRcIl0gPSBcInBjVHJhY2tBZGRlZFwiO1xufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG52YXIgRW5naW5lRXZlbnQ7XG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiTWVkaWFUcmFja0FkZGVkXCJdID0gXCJtZWRpYVRyYWNrQWRkZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJUUFZpZGVvTWFwVXBkYXRlXCJdID0gXCJydHBWaWRlb01hcFVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUm9vbVVwZGF0ZVwiXSA9IFwicm9vbVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVtb3RlTXV0ZVwiXSA9IFwicmVtb3RlTXV0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG59KShFbmdpbmVFdmVudCB8fCAoRW5naW5lRXZlbnQgPSB7fSkpO1xudmFyIFRyYWNrRXZlbnQ7XG4oZnVuY3Rpb24gKFRyYWNrRXZlbnQpIHtcbiAgVHJhY2tFdmVudFtcIk1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcbiAgVHJhY2tFdmVudFtcIk11dGVkXCJdID0gXCJtdXRlZFwiO1xuICBUcmFja0V2ZW50W1wiVW5tdXRlZFwiXSA9IFwidW5tdXRlZFwiO1xuICAvKipcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIlJlc3RhcnRlZFwiXSA9IFwicmVzdGFydGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJFbmRlZFwiXSA9IFwiZW5kZWRcIjtcbiAgVHJhY2tFdmVudFtcIlN1YnNjcmliZWRcIl0gPSBcInN1YnNjcmliZWRcIjtcbiAgVHJhY2tFdmVudFtcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVNldHRpbmdzXCJdID0gXCJ1cGRhdGVTZXR0aW5nc1wiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTdWJzY3JpcHRpb25cIl0gPSBcInVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxBdWRpb1RyYWNrIGluc3RhbmNlc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJhdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaXNpYmlsaXR5Q2hhbmdlZFwiXSA9IFwidmlzaWJpbGl0eUNoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiXSA9IFwidmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwidmlkZW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwidmlkZW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50QXR0YWNoZWRcIl0gPSBcImVsZW1lbnRBdHRhY2hlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50RGV0YWNoZWRcIl0gPSBcImVsZW1lbnREZXRhY2hlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVBhdXNlZFwiXSA9IFwidXBzdHJlYW1QYXVzZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1SZXN1bWVkXCJdID0gXCJ1cHN0cmVhbVJlc3VtZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwic3Vic2NyaXB0aW9uRmFpbGVkXCI7XG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gcihyLCBlLCBuKSB7XG4gIHZhciBpLCB0LCBvO1xuICB2b2lkIDAgPT09IGUgJiYgKGUgPSA1MCksIHZvaWQgMCA9PT0gbiAmJiAobiA9IHt9KTtcbiAgdmFyIGEgPSBudWxsICE9IChpID0gbi5pc0ltbWVkaWF0ZSkgJiYgaSxcbiAgICB1ID0gbnVsbCAhPSAodCA9IG4uY2FsbGJhY2spICYmIHQsXG4gICAgYyA9IG4ubWF4V2FpdCxcbiAgICB2ID0gRGF0ZS5ub3coKSxcbiAgICBsID0gW107XG4gIGZ1bmN0aW9uIGYoKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gYykge1xuICAgICAgdmFyIHIgPSBEYXRlLm5vdygpIC0gdjtcbiAgICAgIGlmIChyICsgZSA+PSBjKSByZXR1cm4gYyAtIHI7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIHZhciBkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgbiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCB0KSB7XG4gICAgICB2YXIgYyA9IGEgJiYgdm9pZCAwID09PSBvO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG8gPSB2b2lkIDAsIHYgPSBEYXRlLm5vdygpLCAhYSkge1xuICAgICAgICAgIHZhciBpID0gci5hcHBseShuLCBlKTtcbiAgICAgICAgICB1ICYmIHUoaSksIGwuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCByLnJlc29sdmUpKGkpO1xuICAgICAgICAgIH0pLCBsID0gW107XG4gICAgICAgIH1cbiAgICAgIH0sIGYoKSksIGMpIHtcbiAgICAgICAgdmFyIGQgPSByLmFwcGx5KG4sIGUpO1xuICAgICAgICByZXR1cm4gdSAmJiB1KGQpLCBpKGQpO1xuICAgICAgfVxuICAgICAgbC5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZTogaSxcbiAgICAgICAgcmVqZWN0OiB0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGQuY2FuY2VsID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAoMCwgZS5yZWplY3QpKHIpO1xuICAgIH0pLCBsID0gW107XG4gIH0sIGQ7XG59XG5cbi8vIHRpbnksIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbGFuY2VkaWtzb24vYm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9wYXJzZXItYnJvd3NlcnMuanNcbi8vIHJlZHVjZWQgdG8gb25seSBkaWZmZXJlbnRpYXRlIENocm9tZShpdW0pIGJhc2VkIGJyb3dzZXJzIC8gRmlyZWZveCAvIFNhZmFyaVxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcbmxldCBicm93c2VyRGV0YWlscztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50KSB7XG4gIGxldCBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCAhPT0gbnVsbCAmJiB1c2VyQWdlbnQgIT09IHZvaWQgMCA/IHVzZXJBZ2VudCA6IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChicm93c2VyRGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdGVzdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gdGVzdC50ZXN0KHVhKTtcbiAgICB9KTtcbiAgICBicm93c2VyRGV0YWlscyA9IGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5kZXNjcmliZSh1YSk7XG4gIH1cbiAgcmV0dXJuIGJyb3dzZXJEZXRhaWxzO1xufVxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW3tcbiAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCB7XG4gIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmNocm9tZXxjaHJvbWl1bXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NyaW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn0sIC8qIFNhZmFyaSAqL1xue1xuICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufV07XG5mdW5jdGlvbiBnZXRNYXRjaChleHAsIHVhKSB7XG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IGlkICYmIG1hdGNoW2lkXSB8fCAnJztcbn1cblxudmFyIHZlcnNpb24kMSA9IFwiMS4xNS4xMFwiO1xuXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gMTE7XG5cbi8qKlxuICogVGltZXJzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcbiAqIHRoYXQgZW5zdXJlIHRoYXQgdGhleSBhcmUgZmlyZWQuIFRoZXNlIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgY3JpdGljYWxcbiAqIHRoYXQgdGhlIHRpbWVyIGZpcmVzIG9uIHRpbWUuXG4gKi9cbmNsYXNzIENyaXRpY2FsVGltZXJzIHt9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZXRJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xufTtcbkNyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dCguLi5hcmd1bWVudHMpO1xufTtcbkNyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGVhckludGVydmFsKC4uLmFyZ3VtZW50cyk7XG59O1xuXG5jbGFzcyBWaWRlb1ByZXNldCB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG1heEJpdHJhdGUsIG1heEZyYW1lcmF0ZSwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5lbmNvZGluZyA9IHtcbiAgICAgIG1heEJpdHJhdGUsXG4gICAgICBtYXhGcmFtZXJhdGUsXG4gICAgICBwcmlvcml0eVxuICAgIH07XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZTogdGhpcy5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufVxuY29uc3QgYmFja3VwQ29kZWNzID0gWyd2cDgnLCAnaDI2NCddO1xuY29uc3QgdmlkZW9Db2RlY3MgPSBbJ3ZwOCcsICdoMjY0JywgJ3ZwOScsICdhdjEnXTtcbmZ1bmN0aW9uIGlzQmFja3VwQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuICEhYmFja3VwQ29kZWNzLmZpbmQoYmFja3VwID0+IGJhY2t1cCA9PT0gY29kZWMpO1xufVxudmFyIEF1ZGlvUHJlc2V0cztcbihmdW5jdGlvbiAoQXVkaW9QcmVzZXRzKSB7XG4gIEF1ZGlvUHJlc2V0cy50ZWxlcGhvbmUgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTIwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLnNwZWVjaCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyMDAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWMgPSB7XG4gICAgbWF4Qml0cmF0ZTogMzIwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljU3RlcmVvID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5ID0ge1xuICAgIG1heEJpdHJhdGU6IDY0MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5U3RlcmVvID0ge1xuICAgIG1heEJpdHJhdGU6IDk2MDAwXG4gIH07XG59KShBdWRpb1ByZXNldHMgfHwgKEF1ZGlvUHJlc2V0cyA9IHt9KSk7XG4vKipcbiAqIFNhbmUgcHJlc2V0cyBmb3IgdmlkZW8gcmVzb2x1dGlvbi9lbmNvZGluZ1xuICovXG5jb25zdCBWaWRlb1ByZXNldHMgPSB7XG4gIGg5MDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgOTAsIDkwMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwMDAwLCAyMCksXG4gIGgyMTY6IG5ldyBWaWRlb1ByZXNldCgzODQsIDIxNiwgMTgwMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDUwMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwMDAwLCAyNSksXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDE3MDAwMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzMDAwMDAwLCAzMCksXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMjU2MCwgMTQ0MCwgNTAwMDAwMCwgMzApLFxuICBoMjE2MDogbmV3IFZpZGVvUHJlc2V0KDM4NDAsIDIxNjAsIDgwMDAwMDAsIDMwKVxufTtcbi8qKlxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0czQzID0ge1xuICBoMTIwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCAxMjAsIDcwMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgyNDAsIDE4MCwgMTI1MDAwLCAyMCksXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg0ODAsIDM2MCwgMzMwMDAwLCAyMCksXG4gIGg0ODA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDQ4MCwgNTAwMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwMDAwLCAyNSksXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDcyMCwgMTMwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE0NDAsIDEwODAsIDIzMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxNDQwLCAzODAwMDAwLCAzMClcbn07XG5jb25zdCBTY3JlZW5TaGFyZVByZXNldHMgPSB7XG4gIGgzNjBmcHMzOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMDAwMCwgMywgJ21lZGl1bScpLFxuICBoMzYwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgODAwMDAwLCA1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTUwMDAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAyMDAwMDAwLCAzMCwgJ21lZGl1bScpLFxuICBoMTA4MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMjUwMDAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDUwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIC8vIG9yaWdpbmFsIHJlc29sdXRpb24sIHdpdGhvdXQgcmVzaXppbmdcbiAgb3JpZ2luYWw6IG5ldyBWaWRlb1ByZXNldCgwLCAwLCA3MDAwMDAwLCAzMCwgJ21lZGl1bScpXG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMyBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlNpZ25hbFRhcmdldFxuICovXG52YXIgU2lnbmFsVGFyZ2V0O1xuKGZ1bmN0aW9uIChTaWduYWxUYXJnZXQpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQVUJMSVNIRVIgPSAwO1xuICAgKi9cbiAgU2lnbmFsVGFyZ2V0W1NpZ25hbFRhcmdldFtcIlBVQkxJU0hFUlwiXSA9IDBdID0gXCJQVUJMSVNIRVJcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTVUJTQ1JJQkVSID0gMTtcbiAgICovXG4gIFNpZ25hbFRhcmdldFtTaWduYWxUYXJnZXRbXCJTVUJTQ1JJQkVSXCJdID0gMV0gPSBcIlNVQlNDUklCRVJcIjtcbn0pKFNpZ25hbFRhcmdldCB8fCAoU2lnbmFsVGFyZ2V0ID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFNpZ25hbFRhcmdldCwgXCJsaXZla2l0LlNpZ25hbFRhcmdldFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJQVUJMSVNIRVJcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTVUJTQ1JJQkVSXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TdHJlYW1TdGF0ZVxuICovXG52YXIgU3RyZWFtU3RhdGU7XG4oZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUNUSVZFID0gMDtcbiAgICovXG4gIFN0cmVhbVN0YXRlW1N0cmVhbVN0YXRlW1wiQUNUSVZFXCJdID0gMF0gPSBcIkFDVElWRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBBVVNFRCA9IDE7XG4gICAqL1xuICBTdHJlYW1TdGF0ZVtTdHJlYW1TdGF0ZVtcIlBBVVNFRFwiXSA9IDFdID0gXCJQQVVTRURcIjtcbn0pKFN0cmVhbVN0YXRlIHx8IChTdHJlYW1TdGF0ZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFN0cmVhbVN0YXRlLCBcImxpdmVraXQuU3RyZWFtU3RhdGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiQUNUSVZFXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUEFVU0VEXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFxuICovXG52YXIgQ2FuZGlkYXRlUHJvdG9jb2w7XG4oZnVuY3Rpb24gKENhbmRpZGF0ZVByb3RvY29sKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVURQID0gMDtcbiAgICovXG4gIENhbmRpZGF0ZVByb3RvY29sW0NhbmRpZGF0ZVByb3RvY29sW1wiVURQXCJdID0gMF0gPSBcIlVEUFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRDUCA9IDE7XG4gICAqL1xuICBDYW5kaWRhdGVQcm90b2NvbFtDYW5kaWRhdGVQcm90b2NvbFtcIlRDUFwiXSA9IDFdID0gXCJUQ1BcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUTFMgPSAyO1xuICAgKi9cbiAgQ2FuZGlkYXRlUHJvdG9jb2xbQ2FuZGlkYXRlUHJvdG9jb2xbXCJUTFNcIl0gPSAyXSA9IFwiVExTXCI7XG59KShDYW5kaWRhdGVQcm90b2NvbCB8fCAoQ2FuZGlkYXRlUHJvdG9jb2wgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbCwgXCJsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVEUFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlRDUFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlRMU1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2lnbmFsUmVxdWVzdFxuICovXG5jbGFzcyBTaWduYWxSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBsaXZla2l0LlNpZ25hbFJlcXVlc3QubWVzc2FnZVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IHtcbiAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2lnbmFsUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblNpZ25hbFJlcXVlc3QucnVudGltZSA9IHByb3RvMztcblNpZ25hbFJlcXVlc3QudHlwZU5hbWUgPSBcImxpdmVraXQuU2lnbmFsUmVxdWVzdFwiO1xuU2lnbmFsUmVxdWVzdC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJpY2tsZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJpY2tsZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJhZGRfdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFkZFRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm11dGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInRyYWNrX3NldHRpbmdcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVRyYWNrU2V0dGluZ3MsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJsZWF2ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTGVhdmVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInVwZGF0ZV9sYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVZpZGVvTGF5ZXJzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInN5bmNfc3RhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN5bmNTdGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzaW11bGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxhdGVTY2VuYXJpbyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJwaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJ1cGRhdGVfbWV0YWRhdGFcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicGluZ19yZXFcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBpbmcsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpZ25hbFJlc3BvbnNlXG4gKi9cbmNsYXNzIFNpZ25hbFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBsaXZla2l0LlNpZ25hbFJlc3BvbnNlLm1lc3NhZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpZ25hbFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuU2lnbmFsUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblNpZ25hbFJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlNpZ25hbFJlc3BvbnNlXCI7XG5TaWduYWxSZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiam9pblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSm9pblJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidHJpY2tsZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJpY2tsZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ1cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHJhY2tfcHVibGlzaGVkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibGVhdmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IExlYXZlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIm11dGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic3BlYWtlcnNfY2hhbmdlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlcnNDaGFuZ2VkLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInJvb21fdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcImNvbm5lY3Rpb25fcXVhbGl0eVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtU3RhdGVVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9xdWFsaXR5X3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25fdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcInJlZnJlc2hfdG9rZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJ0cmFja191bnB1Ymxpc2hlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcInBvbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE5LFxuICBuYW1lOiBcInJlY29ubmVjdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVjb25uZWN0UmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwicG9uZ19yZXNwXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQb25nLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIxLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpbXVsY2FzdENvZGVjXG4gKi9cbmNsYXNzIFNpbXVsY2FzdENvZGVjIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNvZGVjID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNvZGVjID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuY2lkID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlYygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaW11bGNhc3RDb2RlYywgYSwgYik7XG4gIH1cbn1cblNpbXVsY2FzdENvZGVjLnJ1bnRpbWUgPSBwcm90bzM7XG5TaW11bGNhc3RDb2RlYy50eXBlTmFtZSA9IFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY1wiO1xuU2ltdWxjYXN0Q29kZWMuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5BZGRUcmFja1JlcXVlc3RcbiAqL1xuY2xhc3MgQWRkVHJhY2tSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGNsaWVudCBJRCBvZiB0cmFjaywgdG8gbWF0Y2ggaXQgd2hlbiBSVEMgdHJhY2sgaXMgcmVjZWl2ZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrVHlwZSB0eXBlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBUcmFja1R5cGUuQVVESU87XG4gICAgLyoqXG4gICAgICogdG8gYmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBsYXllcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHdpZHRoID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBoZWlnaHQgPSA1O1xuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiB0cnVlIHRvIGFkZCB0cmFjayBhbmQgaW5pdGlhbGl6ZSB0byBtdXRlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG11dGVkID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLm11dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiBEVFggKERpc2NvbnRpbnVvdXMgVHJhbnNtaXNzaW9uKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX2R0eCA9IDc7XG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlRHR4ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrU291cmNlIHNvdXJjZSA9IDg7XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDk7XG4gICAgICovXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU2ltdWxjYXN0Q29kZWMgc2ltdWxjYXN0X2NvZGVjcyA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzID0gW107XG4gICAgLyoqXG4gICAgICogc2VydmVyIElEIG9mIHRyYWNrLCBwdWJsaXNoIG5ldyBjb2RlYyB0byBleGlzdCB0cmFja1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdGVyZW8gPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLnN0ZXJlbyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgUkVEIChSZWR1bmRhbnQgRW5jb2RpbmcpIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfcmVkID0gMTM7XG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlUmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkVuY3J5cHRpb24uVHlwZSBlbmNyeXB0aW9uID0gMTQ7XG4gICAgICovXG4gICAgdGhpcy5lbmNyeXB0aW9uID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgLyoqXG4gICAgICogd2hpY2ggc3RyZWFtIHRoZSB0cmFjayBiZWxvbmdzIHRvLCB1c2VkIHRvIGdyb3VwIHRyYWNrcyB0b2dldGhlci5cbiAgICAgKiBpZiBub3Qgc3BlY2lmaWVkLCBzZXJ2ZXIgd2lsbCBpbmZlciBpdCBmcm9tIHRyYWNrIHNvdXJjZSB0byBidW5kbGUgY2FtZXJhL21pY3JvcGhvbmUsIHNjcmVlbnNoYXJlL2F1ZGlvIHRvZ2V0aGVyXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzdHJlYW0gPSAxNTtcbiAgICAgKi9cbiAgICB0aGlzLnN0cmVhbSA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQWRkVHJhY2tSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuQWRkVHJhY2tSZXF1ZXN0LnJ1bnRpbWUgPSBwcm90bzM7XG5BZGRUcmFja1JlcXVlc3QudHlwZU5hbWUgPSBcImxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XCI7XG5BZGRUcmFja1JlcXVlc3QuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInNpbXVsY2FzdF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsY2FzdENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInN0ZXJlb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJzdHJlYW1cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XG4gKi9cbmNsYXNzIFRyaWNrbGVSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNhbmRpZGF0ZUluaXQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY2FuZGlkYXRlSW5pdCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNpZ25hbFRhcmdldCB0YXJnZXQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJpY2tsZVJlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmlja2xlUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyaWNrbGVSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmlja2xlUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblRyaWNrbGVSZXF1ZXN0LnJ1bnRpbWUgPSBwcm90bzM7XG5Ucmlja2xlUmVxdWVzdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFwiO1xuVHJpY2tsZVJlcXVlc3QuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbmRpZGF0ZUluaXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0YXJnZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFxuICovXG5jbGFzcyBNdXRlVHJhY2tSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5tdXRlZCA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNdXRlVHJhY2tSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE11dGVUcmFja1JlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKE11dGVUcmFja1JlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5NdXRlVHJhY2tSZXF1ZXN0LnJ1bnRpbWUgPSBwcm90bzM7XG5NdXRlVHJhY2tSZXF1ZXN0LnR5cGVOYW1lID0gXCJsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcIjtcbk11dGVUcmFja1JlcXVlc3QuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuSm9pblJlc3BvbnNlXG4gKi9cbmNsYXNzIEpvaW5SZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuUGFydGljaXBhbnRJbmZvIG90aGVyX3BhcnRpY2lwYW50cyA9IDM7XG4gICAgICovXG4gICAgdGhpcy5vdGhlclBhcnRpY2lwYW50cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIGRlcHJlY2F0ZWQuIHVzZSBzZXJ2ZXJfaW5mby52ZXJzaW9uIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZXJ2ZXJfdmVyc2lvbiA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5zZXJ2ZXJWZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuSUNFU2VydmVyIGljZV9zZXJ2ZXJzID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLmljZVNlcnZlcnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiB1c2Ugc3Vic2NyaWJlciBhcyB0aGUgcHJpbWFyeSBQZWVyQ29ubmVjdGlvblxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHN1YnNjcmliZXJfcHJpbWFyeSA9IDY7XG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHdoZW4gdGhlIGN1cnJlbnQgc2VydmVyIGlzbid0IGF2YWlsYWJsZSwgcmV0dXJuIGFsdGVybmF0ZSB1cmwgdG8gcmV0cnkgY29ubmVjdGlvblxuICAgICAqIHdoZW4gdGhpcyBpcyBzZXQsIHRoZSBvdGhlciBmaWVsZHMgd2lsbCBiZSBsYXJnZWx5IGVtcHR5XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBhbHRlcm5hdGl2ZV91cmwgPSA3O1xuICAgICAqL1xuICAgIHRoaXMuYWx0ZXJuYXRpdmVVcmwgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIGRlcHJlY2F0ZWQuIHVzZSBzZXJ2ZXJfaW5mby5yZWdpb24gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNlcnZlcl9yZWdpb24gPSA5O1xuICAgICAqL1xuICAgIHRoaXMuc2VydmVyUmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHBpbmdfdGltZW91dCA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMucGluZ1RpbWVvdXQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcGluZ19pbnRlcnZhbCA9IDExO1xuICAgICAqL1xuICAgIHRoaXMucGluZ0ludGVydmFsID0gMDtcbiAgICAvKipcbiAgICAgKiBTZXJ2ZXItSW5qZWN0ZWQtRnJhbWUgYnl0ZSB0cmFpbGVyLCB1c2VkIHRvIGlkZW50aWZ5IHVuZW5jcnlwdGVkIGZyYW1lcyB3aGVuIGUyZWUgaXMgZW5hYmxlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBieXRlcyBzaWZfdHJhaWxlciA9IDEzO1xuICAgICAqL1xuICAgIHRoaXMuc2lmVHJhaWxlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEpvaW5SZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cbkpvaW5SZXNwb25zZS5ydW50aW1lID0gcHJvdG8zO1xuSm9pblJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LkpvaW5SZXNwb25zZVwiO1xuSm9pblJlc3BvbnNlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tJDFcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mb1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJvdGhlcl9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSUNFU2VydmVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpYmVyX3ByaW1hcnlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic2VydmVyX3JlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJwaW5nX3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwaW5nX2ludGVydmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic2VydmVyX2luZm9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlcnZlckluZm9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInNpZl90cmFpbGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVxuICovXG5jbGFzcyBSZWNvbm5lY3RSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuSUNFU2VydmVyIGljZV9zZXJ2ZXJzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmljZVNlcnZlcnMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVjb25uZWN0UmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvbm5lY3RSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlY29ubmVjdFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSZWNvbm5lY3RSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblJlY29ubmVjdFJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5SZWNvbm5lY3RSZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVwiO1xuUmVjb25uZWN0UmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVxuICovXG5jbGFzcyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jaWQgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcIjtcblRyYWNrUHVibGlzaGVkUmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja0luZm9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcbiAqL1xuY2xhc3MgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5UcmFja1VucHVibGlzaGVkUmVzcG9uc2UudHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXCI7XG5UcmFja1VucHVibGlzaGVkUmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXG4gKi9cbmNsYXNzIFNlc3Npb25EZXNjcmlwdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBcImFuc3dlclwiIHwgXCJvZmZlclwiIHwgXCJwcmFuc3dlclwiIHwgXCJyb2xsYmFja1wiXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0eXBlID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNkcCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5zZHAgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNlc3Npb25EZXNjcmlwdGlvbiwgYSwgYik7XG4gIH1cbn1cblNlc3Npb25EZXNjcmlwdGlvbi5ydW50aW1lID0gcHJvdG8zO1xuU2Vzc2lvbkRlc2NyaXB0aW9uLnR5cGVOYW1lID0gXCJsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblwiO1xuU2Vzc2lvbkRlc2NyaXB0aW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2RwXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVxuICovXG5jbGFzcyBQYXJ0aWNpcGFudFVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuUGFydGljaXBhbnRJbmZvIHBhcnRpY2lwYW50cyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudFVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblBhcnRpY2lwYW50VXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudFVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVwiO1xuUGFydGljaXBhbnRVcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblxuICovXG5jbGFzcyBVcGRhdGVTdWJzY3JpcHRpb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3Vic2NyaWJlID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmliZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrcyBwYXJ0aWNpcGFudF90cmFja3MgPSAzO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja3MgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVTdWJzY3JpcHRpb24sIGEsIGIpO1xuICB9XG59XG5VcGRhdGVTdWJzY3JpcHRpb24ucnVudGltZSA9IHByb3RvMztcblVwZGF0ZVN1YnNjcmlwdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cIjtcblVwZGF0ZVN1YnNjcmlwdGlvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFRyYWNrcyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXG4gKi9cbmNsYXNzIFVwZGF0ZVRyYWNrU2V0dGluZ3MgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiB3aGVuIHRydWUsIHRoZSB0cmFjayBpcyBwbGFjZWQgaW4gYSBwYXVzZWQgc3RhdGUsIHdpdGggbm8gbmV3IGRhdGEgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlZCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2Ygd2lkdGggJiBoZWlnaHRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkxPVztcbiAgICAvKipcbiAgICAgKiBmb3IgdmlkZW8sIHdpZHRoIHRvIHJlY2VpdmVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHdpZHRoID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBmb3IgdmlkZW8sIGhlaWdodCB0byByZWNlaXZlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBoZWlnaHQgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBmcHMgPSA3O1xuICAgICAqL1xuICAgIHRoaXMuZnBzID0gMDtcbiAgICAvKipcbiAgICAgKiBzdWJzY3JpcHRpb24gcHJpb3JpdHkuIDEgYmVpbmcgdGhlIGhpZ2hlc3QgKDAgaXMgdW5zZXQpXG4gICAgICogd2hlbiB1bnNldCwgc2VydmVyIHNpbGwgYXNzaWduIHByaW9yaXR5IGJhc2VkIG9uIHRoZSBvcmRlciBvZiBzdWJzY3JpcHRpb25cbiAgICAgKiBzZXJ2ZXIgd2lsbCB1c2UgcHJpb3JpdHkgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICAgICAqIDEuIHdoZW4gc3Vic2NyaWJlZCB0cmFja3MgZXhjZWVkIHBlci1wYXJ0aWNpcGFudCBzdWJzY3JpcHRpb24gbGltaXQsIHNlcnZlciB3aWxsXG4gICAgICogICAgcGF1c2UgdGhlIGxvd2VzdCBwcmlvcml0eSB0cmFja3NcbiAgICAgKiAyLiB3aGVuIHRoZSBuZXR3b3JrIGlzIGNvbmdlc3RlZCwgc2VydmVyIHdpbGwgYXNzaWduIGF2YWlsYWJsZSBiYW5kd2lkdGggdG9cbiAgICAgKiAgICBoaWdoZXIgcHJpb3JpdHkgdHJhY2tzIGZpcnN0LiBsb3dlc3QgcHJpb3JpdHkgdHJhY2tzIGNhbiBiZSBwYXVzZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHByaW9yaXR5ID0gODtcbiAgICAgKi9cbiAgICB0aGlzLnByaW9yaXR5ID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVUcmFja1NldHRpbmdzLCBhLCBiKTtcbiAgfVxufVxuVXBkYXRlVHJhY2tTZXR0aW5ncy5ydW50aW1lID0gcHJvdG8zO1xuVXBkYXRlVHJhY2tTZXR0aW5ncy50eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXCI7XG5VcGRhdGVUcmFja1NldHRpbmdzLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRpc2FibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJmcHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicHJpb3JpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5MZWF2ZVJlcXVlc3RcbiAqL1xuY2xhc3MgTGVhdmVSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBzZXJ2ZXIgaW5pdGlhdGVzIHRoZSBkaXNjb25uZWN0IGR1ZSB0byBzZXJ2ZXItcmVzdGFydFxuICAgICAqIGluZGljYXRlcyBjbGllbnRzIHNob3VsZCBhdHRlbXB0IGZ1bGwtcmVjb25uZWN0IHNlcXVlbmNlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3JlY29ubmVjdCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jYW5SZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRGlzY29ubmVjdFJlYXNvbiByZWFzb24gPSAyO1xuICAgICAqL1xuICAgIHRoaXMucmVhc29uID0gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhMZWF2ZVJlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5MZWF2ZVJlcXVlc3QucnVudGltZSA9IHByb3RvMztcbkxlYXZlUmVxdWVzdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIjtcbkxlYXZlUmVxdWVzdC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3JlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJyZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxufV0pO1xuLyoqXG4gKiBtZXNzYWdlIHRvIGluZGljYXRlIHB1Ymxpc2hlZCB2aWRlbyB0cmFjayBkaW1lbnNpb25zIGFyZSBjaGFuZ2luZ1xuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcbiAqL1xuY2xhc3MgVXBkYXRlVmlkZW9MYXllcnMgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVWaWRlb0xheWVycygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlVmlkZW9MYXllcnMsIGEsIGIpO1xuICB9XG59XG5VcGRhdGVWaWRlb0xheWVycy5ydW50aW1lID0gcHJvdG8zO1xuVXBkYXRlVmlkZW9MYXllcnMudHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcIjtcblVwZGF0ZVZpZGVvTGF5ZXJzLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVxuICovXG5jbGFzcyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLm1ldGFkYXRhID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEsIGEsIGIpO1xuICB9XG59XG5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLnJ1bnRpbWUgPSBwcm90bzM7XG5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLnR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcIjtcblVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuSUNFU2VydmVyXG4gKi9cbmNsYXNzIElDRVNlcnZlciBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB1cmxzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnVybHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB1c2VybmFtZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy51c2VybmFtZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY3JlZGVudGlhbCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5jcmVkZW50aWFsID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSUNFU2VydmVyKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSUNFU2VydmVyKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSUNFU2VydmVyKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhJQ0VTZXJ2ZXIsIGEsIGIpO1xuICB9XG59XG5JQ0VTZXJ2ZXIucnVudGltZSA9IHByb3RvMztcbklDRVNlcnZlci50eXBlTmFtZSA9IFwibGl2ZWtpdC5JQ0VTZXJ2ZXJcIjtcbklDRVNlcnZlci5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXJsc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1c2VybmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNyZWRlbnRpYWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFxuICovXG5jbGFzcyBTcGVha2Vyc0NoYW5nZWQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNwZWFrZXJJbmZvIHNwZWFrZXJzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNwZWFrZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3BlYWtlcnNDaGFuZ2VkLCBhLCBiKTtcbiAgfVxufVxuU3BlYWtlcnNDaGFuZ2VkLnJ1bnRpbWUgPSBwcm90bzM7XG5TcGVha2Vyc0NoYW5nZWQudHlwZU5hbWUgPSBcImxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXCI7XG5TcGVha2Vyc0NoYW5nZWQuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2VySW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Sb29tVXBkYXRlXG4gKi9cbmNsYXNzIFJvb21VcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb21VcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUm9vbVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblJvb21VcGRhdGUucnVudGltZSA9IHByb3RvMztcblJvb21VcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuUm9vbVVwZGF0ZVwiO1xuUm9vbVVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbSQxXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25RdWFsaXR5SW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eSBxdWFsaXR5ID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdHkgPSBDb25uZWN0aW9uUXVhbGl0eSQxLlBPT1I7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBmbG9hdCBzY29yZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5zY29yZSA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5SW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5SW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5SW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29ubmVjdGlvblF1YWxpdHlJbmZvLCBhLCBiKTtcbiAgfVxufVxuQ29ubmVjdGlvblF1YWxpdHlJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5Db25uZWN0aW9uUXVhbGl0eUluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXCI7XG5Db25uZWN0aW9uUXVhbGl0eUluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSQxKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzY29yZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVxuICovXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIHVwZGF0ZXMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUucnVudGltZSA9IHByb3RvMztcbkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCI7XG5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXBkYXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1xuICovXG5jbGFzcyBTdHJlYW1TdGF0ZUluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdHJlYW1TdGF0ZSBzdGF0ZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IFN0cmVhbVN0YXRlLkFDVElWRTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdHJlYW1TdGF0ZUluZm8sIGEsIGIpO1xuICB9XG59XG5TdHJlYW1TdGF0ZUluZm8ucnVudGltZSA9IHByb3RvMztcblN0cmVhbVN0YXRlSW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cIjtcblN0cmVhbVN0YXRlSW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSlcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVxuICovXG5jbGFzcyBTdHJlYW1TdGF0ZVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3RyZWFtU3RhdGVJbmZvIHN0cmVhbV9zdGF0ZXMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtU3RhdGVzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3RyZWFtU3RhdGVVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5TdHJlYW1TdGF0ZVVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuU3RyZWFtU3RhdGVVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcIjtcblN0cmVhbVN0YXRlVXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdHJlYW1fc3RhdGVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdHJlYW1TdGF0ZUluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcbiAqL1xuY2xhc3MgU3Vic2NyaWJlZFF1YWxpdHkgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBlbmFibGVkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHkoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpYmVkUXVhbGl0eSwgYSwgYik7XG4gIH1cbn1cblN1YnNjcmliZWRRdWFsaXR5LnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpYmVkUXVhbGl0eS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVwiO1xuU3Vic2NyaWJlZFF1YWxpdHkuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVuYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcbiAqL1xuY2xhc3MgU3Vic2NyaWJlZENvZGVjIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNvZGVjID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNvZGVjID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHkgcXVhbGl0aWVzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdGllcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkQ29kZWMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkQ29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkQ29kZWMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmliZWRDb2RlYywgYSwgYik7XG4gIH1cbn1cblN1YnNjcmliZWRDb2RlYy5ydW50aW1lID0gcHJvdG8zO1xuU3Vic2NyaWJlZENvZGVjLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmliZWRDb2RlY1wiO1xuU3Vic2NyaWJlZENvZGVjLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcbiAqL1xuY2xhc3MgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHkgc3Vic2NyaWJlZF9xdWFsaXRpZXMgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuc3Vic2NyaWJlZFF1YWxpdGllcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWMgc3Vic2NyaWJlZF9jb2RlY3MgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUucnVudGltZSA9IHByb3RvMztcblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCI7XG5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9xdWFsaXRpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdWJzY3JpYmVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrUGVybWlzc2lvblxuICovXG5jbGFzcyBUcmFja1Blcm1pc3Npb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogcGVybWlzc2lvbiBjb3VsZCBiZSBncmFudGVkIGVpdGhlciBieSBwYXJ0aWNpcGFudCBzaWQgb3IgaWRlbnRpdHlcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFsbF90cmFja3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuYWxsVHJhY2tzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDM7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9pZGVudGl0eSA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja1Blcm1pc3Npb24sIGEsIGIpO1xuICB9XG59XG5UcmFja1Blcm1pc3Npb24ucnVudGltZSA9IHByb3RvMztcblRyYWNrUGVybWlzc2lvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja1Blcm1pc3Npb25cIjtcblRyYWNrUGVybWlzc2lvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYWxsX3RyYWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblBlcm1pc3Npb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFsbF9wYXJ0aWNpcGFudHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlRyYWNrUGVybWlzc2lvbiB0cmFja19wZXJtaXNzaW9ucyA9IDI7XG4gICAgICovXG4gICAgdGhpcy50cmFja1Blcm1pc3Npb25zID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaXB0aW9uUGVybWlzc2lvbiwgYSwgYik7XG4gIH1cbn1cblN1YnNjcmlwdGlvblBlcm1pc3Npb24ucnVudGltZSA9IHByb3RvMztcblN1YnNjcmlwdGlvblBlcm1pc3Npb24udHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblwiO1xuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19wZXJtaXNzaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQZXJtaXNzaW9uLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcbiAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFsbG93ZWQgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuYWxsb3dlZCA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIGEsIGIpO1xuICB9XG59XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFsbG93ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TeW5jU3RhdGVcbiAqL1xuY2xhc3MgU3luY1N0YXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlIHB1Ymxpc2hfdHJhY2tzID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnB1Ymxpc2hUcmFja3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuRGF0YUNoYW5uZWxJbmZvIGRhdGFfY2hhbm5lbHMgPSA0O1xuICAgICAqL1xuICAgIHRoaXMuZGF0YUNoYW5uZWxzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNTdGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNTdGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNTdGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3luY1N0YXRlLCBhLCBiKTtcbiAgfVxufVxuU3luY1N0YXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5TeW5jU3RhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuU3luY1N0YXRlXCI7XG5TeW5jU3RhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInB1Ymxpc2hfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhQ2hhbm5lbEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cbiAqL1xuY2xhc3MgRGF0YUNoYW5uZWxJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGxhYmVsID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBpZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5pZCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNpZ25hbFRhcmdldCB0YXJnZXQgPSAzO1xuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEYXRhQ2hhbm5lbEluZm8sIGEsIGIpO1xuICB9XG59XG5EYXRhQ2hhbm5lbEluZm8ucnVudGltZSA9IHByb3RvMztcbkRhdGFDaGFubmVsSW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cIjtcbkRhdGFDaGFubmVsSW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFiZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0YXJnZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1xuICovXG5jbGFzcyBTaW11bGF0ZVNjZW5hcmlvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW8uc2NlbmFyaW9cbiAgICAgKi9cbiAgICB0aGlzLnNjZW5hcmlvID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxhdGVTY2VuYXJpbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsYXRlU2NlbmFyaW8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGF0ZVNjZW5hcmlvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaW11bGF0ZVNjZW5hcmlvLCBhLCBiKTtcbiAgfVxufVxuU2ltdWxhdGVTY2VuYXJpby5ydW50aW1lID0gcHJvdG8zO1xuU2ltdWxhdGVTY2VuYXJpby50eXBlTmFtZSA9IFwibGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXCI7XG5TaW11bGF0ZVNjZW5hcmlvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2VyX3VwZGF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibm9kZV9mYWlsdXJlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm1pZ3JhdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfbGVhdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwic3dpdGNoX2NhbmRpZGF0ZV9wcm90b2NvbFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sKSxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpYmVyX2JhbmR3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZV9ub19tZXNzYWdlc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBpbmdcbiAqL1xuY2xhc3MgUGluZyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHRpbWVzdGFtcCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50aW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogcnR0IGluIG1pbGxpc2Vjb25kcyBjYWxjdWxhdGVkIGJ5IGNsaWVudFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBydHQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMucnR0ID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQaW5nKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGluZygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBpbmcoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBpbmcsIGEsIGIpO1xuICB9XG59XG5QaW5nLnJ1bnRpbWUgPSBwcm90bzM7XG5QaW5nLnR5cGVOYW1lID0gXCJsaXZla2l0LlBpbmdcIjtcblBpbmcuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicnR0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBvbmdcbiAqL1xuY2xhc3MgUG9uZyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiB0aW1lc3RhbXAgZmllbGQgb2YgbGFzdCByZWNlaXZlZCBwaW5nIHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgbGFzdF9waW5nX3RpbWVzdGFtcCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5sYXN0UGluZ1RpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHRpbWVzdGFtcCA9IDI7XG4gICAgICovXG4gICAgdGhpcy50aW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvbmcoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb25nKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9uZygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUG9uZywgYSwgYik7XG4gIH1cbn1cblBvbmcucnVudGltZSA9IHByb3RvMztcblBvbmcudHlwZU5hbWUgPSBcImxpdmVraXQuUG9uZ1wiO1xuUG9uZy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFzdF9waW5nX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlZ2lvblNldHRpbmdzXG4gKi9cbmNsYXNzIFJlZ2lvblNldHRpbmdzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5SZWdpb25JbmZvIHJlZ2lvbnMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9ucyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25TZXR0aW5ncygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvblNldHRpbmdzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uU2V0dGluZ3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlZ2lvblNldHRpbmdzLCBhLCBiKTtcbiAgfVxufVxuUmVnaW9uU2V0dGluZ3MucnVudGltZSA9IHByb3RvMztcblJlZ2lvblNldHRpbmdzLnR5cGVOYW1lID0gXCJsaXZla2l0LlJlZ2lvblNldHRpbmdzXCI7XG5SZWdpb25TZXR0aW5ncy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVnaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVnaW9uSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWdpb25JbmZvXG4gKi9cbmNsYXNzIFJlZ2lvbkluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcmVnaW9uID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdXJsID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBkaXN0YW5jZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IHByb3RvSW50NjQuemVybztcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uSW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25JbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSZWdpb25JbmZvLCBhLCBiKTtcbiAgfVxufVxuUmVnaW9uSW5mby5ydW50aW1lID0gcHJvdG8zO1xuUmVnaW9uSW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5SZWdpb25JbmZvXCI7XG5SZWdpb25JbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkaXN0YW5jZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVxuICovXG5jbGFzcyBTdWJzY3JpcHRpb25SZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvciBlcnIgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuZXJyID0gU3Vic2NyaXB0aW9uRXJyb3IuU0VfVU5LTk9XTjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25SZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25SZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblN1YnNjcmlwdGlvblJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpcHRpb25SZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVwiO1xuU3Vic2NyaXB0aW9uUmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVyclwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKVxufV0pO1xuXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG59XG5cbmNvbnN0IEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkgPSA1MDAwO1xuLy8ga2VlcCBvbGQgYXVkaW8gZWxlbWVudHMgd2hlbiBkZXRhY2hlZCwgd2Ugd291bGQgcmUtdXNlIHRoZW0gc2luY2Ugb24gaU9TXG4vLyBTYWZhcmkgdHJhY2tzIHdoaWNoIGF1ZGlvIGVsZW1lbnRzIGhhdmUgYmVlbiBcImJsZXNzZWRcIiBieSB0aGUgdXNlci5cbmNvbnN0IHJlY3ljbGVkRWxlbWVudHMgPSBbXTtcbmNsYXNzIFRyYWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kKSB7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XG4gICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgLy8gZGVsYXkgYXBwIHZpc2liaWxpdHkgdXBkYXRlIGlmIGl0IGdvZXMgdG8gaGlkZGVuXG4gICAgICAvLyB1cGRhdGUgaW1tZWRpYXRlbHkgaWYgaXQgY29tZXMgYmFjayB0byBmb2N1c1xuICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpLCBCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuVHJhY2spO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVRyYWNrO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcykpO1xuICB9XG4gIC8qKiBjdXJyZW50IHJlY2VpdmUgYml0cyBwZXIgc2Vjb25kICovXG4gIGdldCBjdXJyZW50Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdHJhdGU7XG4gIH1cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiB1c2VkIGZvciBrZWVwIG1lZGlhU3RyZWFtJ3MgZmlyc3QgaWQsIHNpbmNlIGl0J3MgaWQgbWlnaHQgY2hhbmdlXG4gICAqIGlmIHdlIGRpc2FibGUvZW5hYmxlIGEgdHJhY2tcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbUlEO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGVsZW1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICBlbGVtZW50VHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwICYmIFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHRoaXMuYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICBpZiAoZS5wYXJlbnRFbGVtZW50ID09PSBudWxsICYmICFlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHBvb2xcbiAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnNwbGljZShyZWN5Y2xlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIGV2ZW4gaWYgd2UgYmVsaWV2ZSBpdCdzIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQsIGl0J3MgcG9zc2libGVcbiAgICAvLyB0aGUgZWxlbWVudCdzIHNyY09iamVjdCB3YXMgc2V0IHRvIHNvbWV0aGluZyBlbHNlIG91dCBvZiBiYW5kLlxuICAgIC8vIHdlJ2xsIHdhbnQgdG8gcmUtYXR0YWNoIGl0IGluIHRoYXQgY2FzZVxuICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgIC8vIGhhbmRsZSBhdXRvIHBsYXliYWNrIGZhaWx1cmVzXG4gICAgY29uc3QgYWxsTWVkaWFTdHJlYW1UcmFja3MgPSBlbGVtZW50LnNyY09iamVjdC5nZXRUcmFja3MoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUodHIgPT4gdHIua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgLy8gbWFudWFsbHkgcGxheSBtZWRpYSB0byBkZXRlY3QgYXV0byBwbGF5YmFjayBzdGF0dXNcbiAgICBlbGVtZW50LnBsYXkoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIC8vIGNvbW1vbmx5IHRyaWdnZXJlZCBieSBhbm90aGVyIGBwbGF5YCByZXF1ZXN0LCBvbmx5IGxvZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJcIi5jb25jYXQoaGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJywgXCIgcGxheWJhY2sgYWJvcnRlZCwgbGlrZWx5IGR1ZSB0byBuZXcgcGxheSByZXF1ZXN0XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImNvdWxkIG5vdCBwbGF5YmFjayBcIi5jb25jYXQoaGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJyksIGUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgYXVkaW8gcGxheWJhY2sgaXNuJ3QgYWxsb3dlZCBtYWtlIHN1cmUgd2Ugc3RpbGwgcGxheSBiYWNrIHRoZSB2aWRlb1xuICAgICAgaWYgKGhhc0F1ZGlvICYmIGVsZW1lbnQgJiYgYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAndmlkZW8nKSAmJiBlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gY2F0Y2ggZm9yIFNhZmFyaSwgZXhjZWVkZWQgb3B0aW9ucyBhdCB0aGlzIHBvaW50IHRvIGF1dG9tYXRpY2FsbHkgcGxheSB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50QXR0YWNoZWQsIGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGV0YWNoZWQgPSBbXTtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsbSA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxtKTtcbiAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xuICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsbSk7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxtKTtcbiAgICAgIH0pO1xuICAgICAgLy8gcmVtb3ZlIGFsbCB0cmFja3NcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgICAgcmV0dXJuIGRldGFjaGVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdG9wTW9uaXRvcigpIHtcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9ySW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUxvZ2dlck9wdGlvbnMobG9nZ2VyT3B0aW9ucykge1xuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpIHtcbiAgICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYikge1xuICAgICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB9XG4gIH1cbiAgcmVjeWNsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHJlLXVzZSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBsZXQgc2hvdWxkQ2FjaGUgPSB0cnVlO1xuICAgICAgZWxlbWVudC5wYXVzZSgpO1xuICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZENhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgIH0pO1xuICB9XG4gIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrLCBlbGVtZW50KSB7XG4gIGxldCBtZWRpYVN0cmVhbTtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIG1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gIH1cbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xuICBsZXQgZXhpc3RpbmdUcmFja3M7XG4gIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICB9IGVsc2Uge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgfVxuICBpZiAoIWV4aXN0aW5nVHJhY2tzLmluY2x1ZGVzKHRyYWNrKSkge1xuICAgIGV4aXN0aW5nVHJhY2tzLmZvckVhY2goZXQgPT4ge1xuICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2soZXQpO1xuICAgIH0pO1xuICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBpZiAoIWlzU2FmYXJpKCkgfHwgIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXG4gICAgLy8gd2Ugd29yayBhcm91bmQgdGhpcyBieSBfbm90XyBzZXR0aW5nIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgb24gc2FmYXJpIGFuZCBpbnN0ZWFkIGNhbGwgYHNldFRpbWVvdXQoKCkgPT4gZWwucGxheSgpLDApYCBmdXJ0aGVyIGRvd25cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgfVxuICAvLyBJbiBjYXNlIHRoZXJlIGFyZSBubyBhdWRpbyB0cmFja3MgcHJlc2VudCBvbiB0aGUgbWVkaWFzdHJlYW0sIHdlIHNldCB0aGUgZWxlbWVudCBhcyBtdXRlZCB0byBlbnN1cmUgYXV0b3BsYXkgd29ya3NcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgfVxuICAvLyBhdm9pZCBmbGlja2VyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCAhPT0gbWVkaWFTdHJlYW0pIHtcbiAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIGlmICgoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgIC8vIEZpcmVmb3ggYWxzbyBoYXMgYSB0aW1pbmcgaXNzdWUgd2hlcmUgdmlkZW8gZG9lc24ndCBhY3R1YWxseSBnZXQgYXR0YWNoZWQgdW5sZXNzXG4gICAgICAvLyBwZXJmb3JtZWQgb3V0LW9mLWJhbmRcbiAgICAgIC8vIFNhZmFyaSAxNSBoYXMgYSBidWcgd2hlcmUgaW4gY2VydGFpbiBsYXlvdXRzLCB2aWRlbyBlbGVtZW50IHJlbmRlcnNcbiAgICAgIC8vIGJsYWNrIHVudGlsIHRoZSBwYWdlIGlzIHJlc2l6ZWQgb3Igb3RoZXIgY2hhbmdlcyB0YWtlIHBsYWNlLlxuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBzcmMgdHJpZ2dlcnMgaXQgdG8gcmVuZGVyLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjkwNTIzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgLy8gU2FmYXJpIDE1IHNvbWV0aW1lcyBmYWlscyB0byBzdGFydCBhIHZpZGVvXG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvdyBpcyBiYWNrZ3JvdW5kZWQgYmVmb3JlIHRoZSBmaXJzdCBmcmFtZSBpcyBkcmF3blxuICAgICAgICAvLyBtYW51YWxseSBjYWxsaW5nIHBsYXkgaGVyZSBzZWVtcyB0byBmaXggdGhhdFxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGFjaFRyYWNrKHRyYWNrLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgaWYgKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2spIHtcbiAgbGV0IEtpbmQ7XG4gIChmdW5jdGlvbiAoS2luZCkge1xuICAgIEtpbmRbXCJBdWRpb1wiXSA9IFwiYXVkaW9cIjtcbiAgICBLaW5kW1wiVmlkZW9cIl0gPSBcInZpZGVvXCI7XG4gICAgS2luZFtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoS2luZCA9IFRyYWNrLktpbmQgfHwgKFRyYWNrLktpbmQgPSB7fSkpO1xuICBsZXQgU291cmNlO1xuICAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICAgIFNvdXJjZVtcIkNhbWVyYVwiXSA9IFwiY2FtZXJhXCI7XG4gICAgU291cmNlW1wiTWljcm9waG9uZVwiXSA9IFwibWljcm9waG9uZVwiO1xuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlXCJdID0gXCJzY3JlZW5fc2hhcmVcIjtcbiAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZUF1ZGlvXCJdID0gXCJzY3JlZW5fc2hhcmVfYXVkaW9cIjtcbiAgICBTb3VyY2VbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKFNvdXJjZSA9IFRyYWNrLlNvdXJjZSB8fCAoVHJhY2suU291cmNlID0ge30pKTtcbiAgbGV0IFN0cmVhbVN0YXRlJDE7XG4gIChmdW5jdGlvbiAoU3RyZWFtU3RhdGUpIHtcbiAgICBTdHJlYW1TdGF0ZVtcIkFjdGl2ZVwiXSA9IFwiYWN0aXZlXCI7XG4gICAgU3RyZWFtU3RhdGVbXCJQYXVzZWRcIl0gPSBcInBhdXNlZFwiO1xuICAgIFN0cmVhbVN0YXRlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShTdHJlYW1TdGF0ZSQxID0gVHJhY2suU3RyZWFtU3RhdGUgfHwgKFRyYWNrLlN0cmVhbVN0YXRlID0ge30pKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kVG9Qcm90byhrKSB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlIEtpbmQuQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XG4gICAgICBjYXNlIEtpbmQuVmlkZW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuVklERU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRSB0aGlzIHdhcyBVTlJFQ09HTklaRUQgYmVmb3JlXG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuREFUQTtcbiAgICB9XG4gIH1cbiAgVHJhY2sua2luZFRvUHJvdG8gPSBraW5kVG9Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQpIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcbiAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBLaW5kLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLmtpbmRGcm9tUHJvdG8gPSBraW5kRnJvbVByb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHNvdXJjZVRvUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuQ0FNRVJBO1xuICAgICAgY2FzZSBTb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc291cmNlVG9Qcm90byA9IHNvdXJjZVRvUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc291cmNlRnJvbVByb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgICByZXR1cm4gU291cmNlLkNhbWVyYTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zb3VyY2VGcm9tUHJvdG8gPSBzb3VyY2VGcm9tUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc3RyZWFtU3RhdGVGcm9tUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5BQ1RJVkU6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLkFjdGl2ZTtcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuUEFVU0VEOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5QYXVzZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byA9IHN0cmVhbVN0YXRlRnJvbVByb3RvO1xufSkoVHJhY2sgfHwgKFRyYWNrID0ge30pKTtcblxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3B0cyA9IChfYSA9IGNsb25lRGVlcChvcHRpb25zKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gIGlmIChvcHRzLmF1ZGlvID09PSB0cnVlKSBvcHRzLmF1ZGlvID0ge307XG4gIGlmIChvcHRzLnZpZGVvID09PSB0cnVlKSBvcHRzLnZpZGVvID0ge307XG4gIC8vIHVzZSBkZWZhdWx0c1xuICBpZiAob3B0cy5hdWRpbykge1xuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG9wdHMuYXVkaW8sIGF1ZGlvRGVmYXVsdHMpO1xuICB9XG4gIGlmIChvcHRzLnZpZGVvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcob3B0cy52aWRlbywgdmlkZW9EZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhtYWluT2JqZWN0LCBvYmplY3RUb01lcmdlKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpIG1haW5PYmplY3Rba2V5XSA9IG9iamVjdFRvTWVyZ2Vba2V5XTtcbiAgfSk7XG4gIHJldHVybiBtYWluT2JqZWN0O1xufVxuZnVuY3Rpb24gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgY29uc3RyYWludHMgPSB7fTtcbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCB2aWRlb09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHZpZGVvT3B0aW9ucztcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMudmlkZW87XG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdyZXNvbHV0aW9uJzpcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gVmlkZW9SZXNvbHV0aW9uIGZpZWxkc1xuICAgICAgICAgICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcodGFyZ2V0LCBzb3VyY2UucmVzb2x1dGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHZpZGVvT3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBvcHRpb25zLnZpZGVvO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgc2lsZW5jZSBvbiBhIGdpdmVuIFtbVHJhY2tdXSBpbnN0YW5jZS5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhY2sgc2VlbXMgdG8gYmUgZW50aXJlbHkgc2lsZW50LlxuICovXG5mdW5jdGlvbiBkZXRlY3RTaWxlbmNlKHRyYWNrKSB7XG4gIGxldCB0aW1lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyMDA7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgY29uc3QgYW5hbHlzZXIgPSBjdHguY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSAyMDQ4O1xuICAgICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XG4gICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgY29uc3Qgc291cmNlID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pKTtcbiAgICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgIHlpZWxkIHNsZWVwKHRpbWVPZmZzZXQpO1xuICAgICAgYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGRhdGFBcnJheSk7XG4gICAgICBjb25zdCBzb21lTm9pc2UgPSBkYXRhQXJyYXkuc29tZShzYW1wbGUgPT4gc2FtcGxlICE9PSAxMjggJiYgc2FtcGxlICE9PSAwKTtcbiAgICAgIGN0eC5jbG9zZSgpO1xuICAgICAgcmV0dXJuICFzb21lTm9pc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROZXdBdWRpb0NvbnRleHQoKSB7XG4gIGNvbnN0IEF1ZGlvQ29udGV4dCA9XG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCk7XG4gIGlmIChBdWRpb0NvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJ1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzb3VyY2VUb0tpbmQoc291cmNlKSB7XG4gIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSB7XG4gICAgcmV0dXJuICdhdWRpb2lucHV0JztcbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBsZXQgdmlkZW9Db25zdHJhaW50cyA9IChfYSA9IG9wdGlvbnMudmlkZW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gIC8vIHRyZWF0IDAgYXMgdW5jYXBwZWRcbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAmJiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggPiAwICYmIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgPiAwKSB7XG4gICAgdmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzID09PSAnYm9vbGVhbicgPyB7fSA6IHZpZGVvQ29uc3RyYWludHM7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICB2aWRlbzogdmlkZW9Db25zdHJhaW50cyxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBkaXNwbGF5IG1lZGlhIGZlYXR1cmVzXG4gICAgY29udHJvbGxlcjogb3B0aW9ucy5jb250cm9sbGVyLFxuICAgIHNlbGZCcm93c2VyU3VyZmFjZTogb3B0aW9ucy5zZWxmQnJvd3NlclN1cmZhY2UsXG4gICAgc3VyZmFjZVN3aXRjaGluZzogb3B0aW9ucy5zdXJmYWNlU3dpdGNoaW5nLFxuICAgIHN5c3RlbUF1ZGlvOiBvcHRpb25zLnN5c3RlbUF1ZGlvXG4gIH07XG59XG5mdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZSkge1xuICBjb25zdCBjb2RlYyA9IG1pbWVUeXBlLnNwbGl0KCcvJylbMV0udG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF2aWRlb0NvZGVjcy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICB0aHJvdyBFcnJvcihcIlZpZGVvIGNvZGVjIG5vdCBzdXBwb3J0ZWQ6IFwiLmNvbmNhdChjb2RlYykpO1xuICB9XG4gIHJldHVybiBjb2RlYztcbn1cbmZ1bmN0aW9uIGdldFRyYWNrUHVibGljYXRpb25JbmZvKHRyYWNrcykge1xuICBjb25zdCBpbmZvcyA9IFtdO1xuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2gobmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uoe1xuICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgIHRyYWNrOiB0cmFjay50cmFja0luZm9cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5mb3M7XG59XG5mdW5jdGlvbiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSB7XG4gIGlmICh0cmFjayBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrU2lkOiB0cmFjay5zaWQsXG4gICAgICB0cmFja1NvdXJjZTogdHJhY2suc291cmNlLFxuICAgICAgdHJhY2tNdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIHRyYWNrRW5hYmxlZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5lbmFibGVkLFxuICAgICAgdHJhY2tLaW5kOiB0cmFjay5raW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tTaWQ6IHRyYWNrLnRyYWNrU2lkLFxuICAgICAgdHJhY2tOYW1lOiB0cmFjay50cmFja05hbWUsXG4gICAgICB0cmFjazogdHJhY2sudHJhY2sgPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrLnRyYWNrKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYWNrRW5hYmxlZDogdHJhY2suaXNFbmFibGVkLFxuICAgICAgdHJhY2tFbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxuICAgICAgdHJhY2tNaW1lVHlwZTogdHJhY2subWltZVR5cGVcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcbmNvbnN0IGRkRXh0ZW5zaW9uVVJJID0gJ2h0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtcnRwLXNwZWMvI2RlcGVuZGVuY3ktZGVzY3JpcHRvci1ydHAtaGVhZGVyLWV4dGVuc2lvbic7XG5mdW5jdGlvbiB1bnBhY2tTdHJlYW1JZChwYWNrZWQpIHtcbiAgY29uc3QgcGFydHMgPSBwYWNrZWQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gW3BhcnRzWzBdLCBwYWNrZWQuc3Vic3RyKHBhcnRzWzBdLmxlbmd0aCArIDEpXTtcbiAgfVxuICByZXR1cm4gW3BhY2tlZCwgJyddO1xufVxuZnVuY3Rpb24gc2xlZXAoZHVyYXRpb24pIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcbiAgcmV0dXJuICdhZGRUcmFuc2NlaXZlcicgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNBZGRUcmFjaygpIHtcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNEeW5hY2FzdCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzQVYxKCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vQVYxJykge1xuICAgICAgICBoYXNBVjEgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0FWMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzVlA5KCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpcmVGb3goKSkge1xuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cbmZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0pIHtcbiAgaWYgKCFkb2N1bWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVsbSkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIH1cbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcbn1cbmNvbnN0IHNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyA9IHtcbiAgQ2hyb21lOiAnMTAwJyxcbiAgU2FmYXJpOiAnMTUnLFxuICBGaXJlZm94OiAnMTAwJ1xufTtcbmZ1bmN0aW9uIHN1cHBvcnRzU2V0Q29kZWNQcmVmZXJlbmNlcyh0cmFuc2NlaXZlcikge1xuICBpZiAoIWlzV2ViKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoJ3NldENvZGVjUHJlZmVyZW5jZXMnIGluIHRyYW5zY2VpdmVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICBpZiAoIShicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgfHwgIWJyb3dzZXIudmVyc2lvbikge1xuICAgIC8vIHZlcnNpb24gaXMgcmVxdWlyZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdiA9IHNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9uc1ticm93c2VyLm5hbWVdO1xuICBpZiAodikge1xuICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCB2KSA+PSAwO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XG59XG5mdW5jdGlvbiBpc0ZpcmVGb3goKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0ZpcmVmb3gnO1xufVxuZnVuY3Rpb24gaXNDaHJvbWl1bUJhc2VkKCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdDaHJvbWUnO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ1NhZmFyaSc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaTE3KCkge1xuICBjb25zdCBiID0gZ2V0QnJvd3NlcigpO1xuICByZXR1cm4gKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgYi52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3LicpO1xufVxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIGlmICghaXNXZWIoKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gL1RhYmxldHxpUGFkfE1vYmlsZXxBbmRyb2lkfEJsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiBpc1dlYigpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAvLyBuYXZpZ2F0b3IucHJvZHVjdCBpcyBkZXByZWNhdGVkIG9uIGJyb3dzZXJzLCBidXQgd2lsbCBiZSBzZXQgYXBwcm9wcmlhdGVseSBmb3IgcmVhY3QtbmF0aXZlLlxuICByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3QgPT0gJ1JlYWN0TmF0aXZlJztcbn1cbmZ1bmN0aW9uIGlzQ2xvdWQoc2VydmVyVXJsKSB7XG4gIHJldHVybiBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LmNsb3VkJykgfHwgc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5ydW4nKTtcbn1cbmZ1bmN0aW9uIGdldExLUmVhY3ROYXRpdmVJbmZvKCkge1xuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWw7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0TmF0aXZlT3MoKSB7XG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gIGlmIChpc1dlYigpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICB9XG4gIHJldHVybiAxO1xufVxuZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxLCB2Mikge1xuICBjb25zdCBwYXJ0czEgPSB2MS5zcGxpdCgnLicpO1xuICBjb25zdCBwYXJ0czIgPSB2Mi5zcGxpdCgnLicpO1xuICBjb25zdCBrID0gTWF0aC5taW4ocGFydHMxLmxlbmd0aCwgcGFydHMyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgY29uc3QgcDEgPSBwYXJzZUludChwYXJ0czFbaV0sIDEwKTtcbiAgICBjb25zdCBwMiA9IHBhcnNlSW50KHBhcnRzMltpXSwgMTApO1xuICAgIGlmIChwMSA+IHAyKSByZXR1cm4gMTtcbiAgICBpZiAocDEgPCBwMikgcmV0dXJuIC0xO1xuICAgIGlmIChpID09PSBrIC0gMSAmJiBwMSA9PT0gcDIpIHJldHVybiAwO1xuICB9XG4gIGlmICh2MSA9PT0gJycgJiYgdjIgIT09ICcnKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHYyID09PSAnJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBwYXJ0czEubGVuZ3RoID09IHBhcnRzMi5sZW5ndGggPyAwIDogcGFydHMxLmxlbmd0aCA8IHBhcnRzMi5sZW5ndGggPyAtMSA6IDE7XG59XG5mdW5jdGlvbiByb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlUmVzaXplKGVudHJ5KTtcbiAgfVxufVxuZnVuY3Rpb24gaW9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgZW50cnkudGFyZ2V0LmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKGVudHJ5KTtcbiAgfVxufVxubGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbmNvbnN0IGdldFJlc2l6ZU9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIXJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihyb0Rpc3BhdGNoQ2FsbGJhY2spO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59O1xubGV0IGludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbmNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIWludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW9EaXNwYXRjaENhbGxiYWNrLCB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgcm9vdE1hcmdpbjogJzBweCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59O1xuZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBpbmZvID0gbmV3IENsaWVudEluZm8oe1xuICAgIHNkazogQ2xpZW50SW5mb19TREsuSlMsXG4gICAgcHJvdG9jb2w6IHByb3RvY29sVmVyc2lvbixcbiAgICB2ZXJzaW9uXG4gIH0pO1xuICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgaW5mby5vcyA9IChfYSA9IGdldFJlYWN0TmF0aXZlT3MoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5sZXQgZW1wdHlWaWRlb1N0cmVhbVRyYWNrO1xuZnVuY3Rpb24gZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5VmlkZW9TdHJlYW1UcmFjaykge1xuICAgIGVtcHR5VmlkZW9TdHJlYW1UcmFjayA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpO1xuICB9XG4gIHJldHVybiBlbXB0eVZpZGVvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpIHtcbiAgbGV0IHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxNjtcbiAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gIGxldCBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgbGV0IHBhaW50Q29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAvLyB0aGUgY2FudmFzIHNpemUgaXMgc2V0IHRvIDE2IGJ5IGRlZmF1bHQsIGJlY2F1c2UgZWxlY3Ryb24gYXBwcyBzZWVtIHRvIGZhaWwgd2l0aCBzbWFsbGVyIHZhbHVlc1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBpZiAocGFpbnRDb250ZW50ICYmIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgNTAsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdncmV5JztcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZHVtbXlTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICBjb25zdCBbZHVtbXlUcmFja10gPSBkdW1teVN0cmVhbS5nZXRUcmFja3MoKTtcbiAgaWYgKCFkdW1teVRyYWNrKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIHZpZGVvIHRyYWNrJyk7XG4gIH1cbiAgZHVtbXlUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcbiAgcmV0dXJuIGR1bW15VHJhY2s7XG59XG5sZXQgZW1wdHlBdWRpb1N0cmVhbVRyYWNrO1xuZnVuY3Rpb24gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbSBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2VicnRjL3dhcm0tdXAtd2l0aC1yZXBsYWNldHJhY2svXG4gICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGNvbnN0IG9zY2lsbGF0b3IgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgIGNvbnN0IGdhaW4gPSBjdHguY3JlYXRlR2FpbigpO1xuICAgIGdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcbiAgICBjb25zdCBkc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgIG9zY2lsbGF0b3IuY29ubmVjdChnYWluKTtcbiAgICBnYWluLmNvbm5lY3QoZHN0KTtcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XG4gICAgW2VtcHR5QXVkaW9TdHJlYW1UcmFja10gPSBkc3Quc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSBhdWRpbyB0cmFjaycpO1xuICAgIH1cbiAgICBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cbmNsYXNzIEZ1dHVyZSB7XG4gIGNvbnN0cnVjdG9yKGZ1dHVyZUJhc2UsIG9uRmluYWxseSkge1xuICAgIHRoaXMub25GaW5hbGx5ID0gb25GaW5hbGx5O1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIGlmIChmdXR1cmVCYXNlKSB7XG4gICAgICAgIHlpZWxkIGZ1dHVyZUJhc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5vbkZpbmFsbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYW5hbHlzZXIgd2ViIGF1ZGlvIG5vZGUgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdHJhY2suXG4gKiBBZGRpdGlvbmFsbHkgcmV0dXJucyBhIGNvbnZlbmllbmNlIG1ldGhvZCBgY2FsY3VsYXRlVm9sdW1lYCB0byBwZXJmb3JtIGluc3RhbnQgdm9sdW1lIHJlYWRpbmdzIG9uIHRoYXQgdHJhY2suXG4gKiBDYWxsIHRoZSByZXR1cm5lZCBgY2xlYW51cGAgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGhlbHBlclxuICovXG5mdW5jdGlvbiBjcmVhdGVBdWRpb0FuYWx5c2VyKHRyYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBjbG9uZVRyYWNrOiBmYWxzZSxcbiAgICBmZnRTaXplOiAyMDQ4LFxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxuICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgIG1heERlY2liZWxzOiAtODBcbiAgfSwgb3B0aW9ucyk7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXVkaW8gQ29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuICB9XG4gIGNvbnN0IHN0cmVhbVRyYWNrID0gb3B0cy5jbG9uZVRyYWNrID8gdHJhY2subWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpIDogdHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgY29uc3QgbWVkaWFTdHJlYW1Tb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFtzdHJlYW1UcmFja10pKTtcbiAgY29uc3QgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgYW5hbHlzZXIubWluRGVjaWJlbHMgPSBvcHRzLm1pbkRlY2liZWxzO1xuICBhbmFseXNlci5tYXhEZWNpYmVscyA9IG9wdHMubWF4RGVjaWJlbHM7XG4gIGFuYWx5c2VyLmZmdFNpemUgPSBvcHRzLmZmdFNpemU7XG4gIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG9wdHMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHRyYWNrIGluIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlVm9sdW1lID0gKCkgPT4ge1xuICAgIGFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSk7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChjb25zdCBhbXBsaXR1ZGUgb2YgZGF0YUFycmF5KSB7XG4gICAgICBzdW0gKz0gTWF0aC5wb3coYW1wbGl0dWRlIC8gMjU1LCAyKTtcbiAgICB9XG4gICAgY29uc3Qgdm9sdW1lID0gTWF0aC5zcXJ0KHN1bSAvIGRhdGFBcnJheS5sZW5ndGgpO1xuICAgIHJldHVybiB2b2x1bWU7XG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgaWYgKG9wdHMuY2xvbmVUcmFjaykge1xuICAgICAgc3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsY3VsYXRlVm9sdW1lLFxuICAgIGFuYWx5c2VyLFxuICAgIGNsZWFudXBcbiAgfTtcbn1cbmNsYXNzIE11dGV4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuX2xvY2tzID0gMDtcbiAgfVxuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja3MgPiAwO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5fbG9ja3MgKz0gMTtcbiAgICBsZXQgdW5sb2NrTmV4dDtcbiAgICBjb25zdCB3aWxsTG9jayA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdW5sb2NrTmV4dCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2xvY2tzIC09IDE7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgY29uc3Qgd2lsbFVubG9jayA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiB1bmxvY2tOZXh0KTtcbiAgICB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHdpbGxMb2NrKTtcbiAgICByZXR1cm4gd2lsbFVubG9jaztcbiAgfVxufVxuZnVuY3Rpb24gaXNWaWRlb0NvZGVjKG1heWJlQ29kZWMpIHtcbiAgcmV0dXJuIHZpZGVvQ29kZWNzLmluY2x1ZGVzKG1heWJlQ29kZWMpO1xufVxuZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50KSkge1xuICAgIHJldHVybiBjb25zdHJhaW50WzBdO1xuICB9XG4gIGlmIChjb25zdHJhaW50LmV4YWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5leGFjdCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5leGFjdDtcbiAgfVxuICBpZiAoY29uc3RyYWludC5pZGVhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuaWRlYWwpKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWw7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCB1bndyYXAgY29uc3RyYWludCcpO1xufVxuZnVuY3Rpb24gdG9XZWJzb2NrZXRVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHRvSHR0cFVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCd3cycpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKHdzKS8sICdodHRwJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuY29uc3QgZGVmYXVsdElkID0gJ2RlZmF1bHQnO1xuY2xhc3MgRGV2aWNlTWFuYWdlciB7XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gbmV3IERldmljZU1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cbiAgZ2V0RGV2aWNlcyhraW5kKSB7XG4gICAgbGV0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICgoKF9hID0gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgPiAwKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2F3YWl0aW5nIGdldFVzZXJNZWRpYSBwcm9taXNlJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGtpbmQpIHtcbiAgICAgICAgICAgIHlpZWxkIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5nZXQoa2luZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC52YWx1ZXMoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdlcnJvciB3YWl0aW5nIGZvciBtZWRpYSBwZXJtaXNzb25zJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICBpZiAocmVxdWVzdFBlcm1pc3Npb25zICYmXG4gICAgICAvLyBmb3Igc2FmYXJpIHdlIG5lZWQgdG8gc2tpcCB0aGlzIGNoZWNrLCBhcyBvdGhlcndpc2UgaXQgd2lsbCByZS1hY3F1aXJlIHVzZXIgbWVkaWEgYW5kIGZhaWwgb24gaU9TIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcbiAgICAgICEoaXNTYWZhcmkoKSAmJiB0aGlzLmhhc0RldmljZUluVXNlKGtpbmQpKSkge1xuICAgICAgICBjb25zdCBpc0R1bW15RGV2aWNlT3JFbXB0eSA9IGRldmljZXMubGVuZ3RoID09PSAwIHx8IGRldmljZXMuc29tZShkZXZpY2UgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vTGFiZWwgPSBkZXZpY2UubGFiZWwgPT09ICcnO1xuICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBraW5kID8gZGV2aWNlLmtpbmQgPT09IGtpbmQgOiB0cnVlO1xuICAgICAgICAgIHJldHVybiBub0xhYmVsICYmIGlzUmVsZXZhbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNEdW1teURldmljZU9yRW1wdHkpIHtcbiAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcbiAgICAgICAgICAgIHZpZGVvOiBraW5kICE9PSAnYXVkaW9pbnB1dCcgJiYga2luZCAhPT0gJ2F1ZGlvb3V0cHV0JyxcbiAgICAgICAgICAgIGF1ZGlvOiBraW5kICE9PSAndmlkZW9pbnB1dCdcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHBlcm1pc3Npb25zVG9BY3F1aXJlKTtcbiAgICAgICAgICBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2luZCkge1xuICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZGV2aWNlID0+IGRldmljZS5raW5kID09PSBraW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH0pO1xuICB9XG4gIG5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VJZDtcbiAgICAgIH1cbiAgICAgIC8vIHJlc29sdmUgYWN0dWFsIGRldmljZSBpZCBpZiBpdCdzICdkZWZhdWx0JzogQ2hyb21lIHJldHVybnMgaXQgd2hlbiBub1xuICAgICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcbiAgICAgIGNvbnN0IGRldmljZSA9IGRldmljZXMuZmluZChkID0+IGQuZ3JvdXBJZCA9PT0gZ3JvdXBJZCAmJiBkLmRldmljZUlkICE9PSBkZWZhdWx0SWQpO1xuICAgICAgcmV0dXJuIGRldmljZSA9PT0gbnVsbCB8fCBkZXZpY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRldmljZS5kZXZpY2VJZDtcbiAgICB9KTtcbiAgfVxuICBoYXNEZXZpY2VJblVzZShraW5kKSB7XG4gICAgcmV0dXJuIGtpbmQgPyBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuaGFzKGtpbmQpIDogRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNpemUgPiAwO1xuICB9XG59XG5EZXZpY2VNYW5hZ2VyLm1lZGlhRGV2aWNlS2luZHMgPSBbJ2F1ZGlvaW5wdXQnLCAnYXVkaW9vdXRwdXQnLCAndmlkZW9pbnB1dCddO1xuRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwID0gbmV3IE1hcCgpO1xuXG5jb25zdCBkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQgPSAxMDAwO1xuY2xhc3MgTG9jYWxUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW50cztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCA9ICgpID0+IHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlcigpLmNhdGNoKCgpID0+IHRoaXMubG9nLmRlYnVnKCd0cmFjayBtdXRlIGJvdW5jZSBnb3QgY2FuY2VsbGVkIGJ5IGFuIHVubXV0ZSBldmVudCcsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciA9IHIoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtKCk7XG4gICAgfSksIDUwMDApO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ3VubXV0ZScpO1xuICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlRW5kZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjaztcbiAgICB0aGlzLm11dGVMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5wYXVzZVVwc3RyZWFtTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMucHJvY2Vzc29yTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhtZWRpYVRyYWNrLCB0cnVlKTtcbiAgICAvLyBhZGRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyLCBjb25zdHJhaW50cyBhcmUgc3luY2VkIHdpdGggTWVkaWFTdHJlYW1UcmFja1xuICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbWVkaWFUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICB9XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmlkO1xuICB9XG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmtpbmQgIT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG4gIGdldCBpc1VzZXJQcm92aWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlZEJ5VXNlcjtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb2Nlc3NlZFRyYWNrKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG4gIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2ssIGZvcmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgLy8gZGV0YWNoXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCduZXctdHJhY2snKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBtZWRpYS4gSW4gdGhpcyBjYXNlIHdlJ2xsIG5lZWQgdG8gc2lnbmFsIHdpdGggcmVtb3RlIHRoYXRcbiAgICAgICAgLy8gdGhlIHRyYWNrIGlzIFwibXV0ZWRcIlxuICAgICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gdG91Y2ggTWVkaWFTdHJlYW1UcmFjay5lbmFibGVkXG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBuZXdUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3NlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIG5ld1RyYWNrICYmIHRoaXMucHJvY2Vzc29yRWxlbWVudCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaFRvRWxlbWVudChuZXdUcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBwcm9jZXNzb3JFbGVtZW50IGl0c2VsZiBzdGF5cyBtdXRlZFxuICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3Nvci5yZXN0YXJ0KHtcbiAgICAgICAgICB0cmFjazogbmV3VHJhY2ssXG4gICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgIGVsZW1lbnQ6IHRoaXMucHJvY2Vzc29yRWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzc2VkVHJhY2sgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbmRlcikge1xuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2socHJvY2Vzc2VkVHJhY2sgIT09IG51bGwgJiYgcHJvY2Vzc2VkVHJhY2sgIT09IHZvaWQgMCA/IHByb2Nlc3NlZFRyYWNrIDogbmV3VHJhY2spO1xuICAgICAgfVxuICAgICAgLy8gaWYgYG5ld1RyYWNrYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdHJhY2ssIHN0b3AgdGhlXG4gICAgICAvLyBvbGRlciB0cmFjayBqdXN0IGJlZm9yZSByZXBsYWNpbmcgaXRcbiAgICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICAvLyBzeW5jIG11dGVkIHN0YXRlIHdpdGggdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG5ld2x5IHByb3ZpZGVkIHRyYWNrXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXG4gICAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yRGltZW5zaW9ucygpIHtcbiAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0O1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZGltZW5zaW9ucyBmb3IgYXVkaW8gdHJhY2tzJyk7XG4gICAgICB9XG4gICAgICBpZiAoKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9zKSA9PT0gJ2lPUycpIHtcbiAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXG4gICAgICAgIC8vIHdoZW4gc2xpZ2h0bHkgZGVsYXlpbmcgdGhlIGNhbGwgdG8gLmdldFNldHRpbmdzKCksIHRoZSBjb3JyZWN0IHJlc29sdXRpb24gaXMgYmVpbmcgcmVwb3J0ZWRcbiAgICAgICAgeWllbGQgc2xlZXAoMTApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0ZWQgPCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gZ2V0IHRyYWNrIGRpbWVuc2lvbnMgYWZ0ZXIgdGltZW91dCcpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldERldmljZUlkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgZ3JvdXBJZFxuICAgICAgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8gPyAnYXVkaW9pbnB1dCcgOiAndmlkZW9pbnB1dCc7XG4gICAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKTtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldFRyYWNrTXV0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXBsYWNlVHJhY2sodHJhY2spIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gcmVwbGFjZSBhbiB1bnB1Ymxpc2hlZCB0cmFjaycpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlcGxhY2UgTWVkaWFTdHJlYW1UcmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sodHJhY2spO1xuICAgICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXG4gICAgICAvLyBvbiB0aGUgcHJldmlvdXMgc3RhdGUgaW4gb3JkZXIgdG8gY2xlYW51cFxuICAgICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIWNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHM7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyB0cmFjayB3aXRoIGNvbnN0cmFpbnRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNvbnN0cmFpbnRzXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICB2aWRlbzogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzO1xuICAgICAgfVxuICAgICAgLy8gdGhlc2Ugc3RlcHMgYXJlIGR1cGxpY2F0ZWQgZnJvbSBzZXRNZWRpYVN0cmVhbVRyYWNrIGJlY2F1c2Ugd2UgbXVzdCBzdG9wXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdHJhY2tzIGJlZm9yZSBuZXcgdHJhY2tzIGNhbiBiZSBhY3F1aXJlZFxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXG4gICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgdHJhY2sgYW5kIGF0dGFjaFxuICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzdHJlYW1Db25zdHJhaW50cyk7XG4gICAgICBjb25zdCBuZXdUcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhuZXdUcmFjayk7XG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgXCIuY29uY2F0KHRoaXMua2luZCwgXCIgdHJhY2sgXCIpLmNvbmNhdChtdXRlZCA/ICdtdXRlZCcgOiAndW5tdXRlZCcpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICB9XG4gIGdldCBuZWVkc1JlQWNxdWlzaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2subXV0ZWQgfHwgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fCB0aGlzLnJlYWNxdWlyZVRyYWNrO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ2aXNpYmlsaXR5IGNoYW5nZWQsIGlzIGluIEJhY2tncm91bmQ6IFwiLmNvbmNhdCh0aGlzLmlzSW5CYWNrZ3JvdW5kKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyBcIi5jb25jYXQodGhpcy5zb3VyY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBwYXVzZXMgcHVibGlzaGluZyB0byB0aGUgc2VydmVyIHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xuICAgKiB0aGUgc2VydmVyLlxuICAgKiB0aGlzIEFQSSBpcyB1bnN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMiBkdWUgdG8gYSBidWdcbiAgICoqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcGF1c2UgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDkxMVxuICAgICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcmVzdW1lIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcbiAgICAgICAgLy8gdGhpcyBvcGVyYXRpb24gaXMgbm9vcCBpZiBtZWRpYXN0cmVhbXRyYWNrIGlzIGFscmVhZHkgYmVpbmcgc2VudFxuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBMb2NhbFRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBTZW5kZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c1JlcG9ydCA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9jZXNzb3Igb24gdGhpcyB0cmFjay5cbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKlxuICAgKiBAcGFyYW0gcHJvY2Vzc29yXG4gICAqIEBwYXJhbSBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSAoX2EgPSB0aGlzLnByb2Nlc3NvckVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5raW5kKTtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyb3IgPT4gdGhpcy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBwbGF5IHByb2Nlc3NvciBlbGVtZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gdGhpcy5wcm9jZXNzb3JFbGVtZW50ICYmIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KSB7XG4gICAgICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIChfYiA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NvcjtcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHRyYWNrIHByb2Nlc3NvclxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdG9wUHJvY2Vzc29yKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHJldHVybjtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgKF9hID0gdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICB5aWVsZCB0aGlzLnByb2Nlc3Nvci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICAgIChfYiA9IHRoaXMucHJvY2Vzc29yRWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZSgpO1xuICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEUyRUVNYW5hZ2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGRhdGEuZXJyb3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0QWNrJzpcbiAgICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xuICAgICAgICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgIT09IGRhdGEuZW5hYmxlZCAmJiBkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkgPT09ICgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBkYXRhLmVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBkYXRhLmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gKF9iID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcImNvdWxkbid0IHNldCBlbmNyeXB0aW9uIHN0YXR1cywgcGFydGljaXBhbnQgbm90IGZvdW5kXCIuY29uY2F0KGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBkYXRhLmVuYWJsZWQsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmF0Y2hldEtleSc6XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLm1hdGVyaWFsLCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25Xb3JrZXJFcnJvciA9IGV2ID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoJ2UyZWUgd29ya2VyIGVuY291bnRlcmVkIGFuIGVycm9yOicsIHtcbiAgICAgICAgZXJyb3I6IGV2LmVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBldi5lcnJvcik7XG4gICAgfTtcbiAgICB0aGlzLmtleVByb3ZpZGVyID0gb3B0aW9ucy5rZXlQcm92aWRlcjtcbiAgICB0aGlzLndvcmtlciA9IG9wdGlvbnMud29ya2VyO1xuICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cChyb29tKSB7XG4gICAgaWYgKCFpc0UyRUVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyk7XG4gICAgfVxuICAgIGxpdmVraXRMb2dnZXIuaW5mbygnc2V0dGluZyB1cCBlMmVlJyk7XG4gICAgaWYgKHJvb20gIT09IHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCB0aGlzLmtleVByb3ZpZGVyKTtcbiAgICAgIC8vIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcignJyk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGtleVByb3ZpZGVyT3B0aW9uczogdGhpcy5rZXlQcm92aWRlci5nZXRPcHRpb25zKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJpbml0aWFsaXppbmcgd29ya2VyXCIsIHtcbiAgICAgICAgICB3b3JrZXI6IHRoaXMud29ya2VyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLm9uV29ya2VyTWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMub25Xb3JrZXJFcnJvcjtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNldCBlMmVlIHRvIFwiLmNvbmNhdChlbmFibGVkLCBcIiBmb3IgcGFydGljaXBhbnQgXCIpLmNvbmNhdChwYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgdGhpcy5wb3N0RW5hYmxlKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdHJhaWxlciB8fCB0cmFpbGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiaWdub3Jpbmcgc2VydmVyIHNlbnQgdHJhaWxlciBhcyBpdCdzIGVtcHR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpO1xuICAgIH1cbiAgfVxuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICBlbmdpbmUub24oRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCA9PiB7XG4gICAgICB0aGlzLnBvc3RSVFBNYXAocnRwTWFwKTtcbiAgICB9KTtcbiAgfVxuICBzZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIGtleVByb3ZpZGVyKSB7XG4gICAgcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIChwdWIsIHBhcnRpY2lwYW50KSA9PiB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQocHViLnRyYWNrSW5mby5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSwgcGFydGljaXBhbnQuaWRlbnRpdHkpKTtcbiAgICByb29tLm9uKFJvb21FdmVudC5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLCBzdGF0ZSA9PiB7XG4gICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgcm9vbS5wYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICAgICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBfLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAncmVtb3ZlVHJhbnNmb3JtJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLm1lZGlhU3RyZWFtSURcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChfYSA9IHRoaXMud29ya2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YiwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2ssIHBhcnRpY2lwYW50LmlkZW50aXR5LCBwdWIudHJhY2tJbmZvKTtcbiAgICB9KS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0ZWQgcm9vbSB0byBiZSBwcmVzZW50IG9uIHNpZ25hbCBjb25uZWN0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlzRTJFRUVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgIGtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xuICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRVNlbmRlcihwdWJsaWNhdGlvbi50cmFjaywgcHVibGljYXRpb24udHJhY2suc2VuZGVyKTtcbiAgICB9KSk7XG4gICAga2V5UHJvdmlkZXIub24oS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8gPT4gdGhpcy5wb3N0S2V5KGtleUluZm8pKS5vbihLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCAocGFydGljaXBhbnRJZCwga2V5SW5kZXgpID0+IHRoaXMucG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSk7XG4gIH1cbiAgcG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCByYXRjaGV0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEtleShfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlJbmRleFxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHNldCBrZXksIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRLZXknLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBpc1B1Ymxpc2hlcjogcGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpLFxuICAgICAgICBrZXksXG4gICAgICAgIGtleUluZGV4XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgY29uc3QgZW5hYmxlTXNnID0ge1xuICAgICAgICBraW5kOiAnZW5hYmxlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYWJsZWQsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZW5hYmxlTXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdmYWlsZWQgdG8gZW5hYmxlIGUyZWUsIHdvcmtlciBpcyBub3QgcmVhZHknKTtcbiAgICB9XG4gIH1cbiAgcG9zdFJUUE1hcChtYXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCBsb2NhbCBwYXJ0aWNpcGFudCBpZGVudGl0eSBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRSVFBNYXAnLFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXAsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHBvc3QgU0lGIHRyYWlsZXIsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRTaWZUcmFpbGVyJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHJhaWxlclxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBzZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcmVtb3RlSWQsIHRyYWNrSW5mbykge1xuICAgIGlmICghdHJhY2sucmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodHJhY2tJbmZvID09PSBudWxsIHx8IHRyYWNrSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tJbmZvLm1pbWVUeXBlKSB8fCB0cmFja0luZm8ubWltZVR5cGUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaW1lVHlwZSBtaXNzaW5nIGZyb20gdHJhY2tJbmZvLCBjYW5ub3Qgc2V0IHVwIEUyRUUgY3J5cHRvcicpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVJlY2VpdmVyKHRyYWNrLnJlY2VpdmVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCByZW1vdGVJZCwgdHJhY2sua2luZCA9PT0gJ3ZpZGVvJyA/IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHRyYWNrSW5mby5taW1lVHlwZSkgOiB1bmRlZmluZWQpO1xuICB9XG4gIHNldHVwRTJFRVNlbmRlcih0cmFjaywgc2VuZGVyKSB7XG4gICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrKSB8fCAhc2VuZGVyKSB7XG4gICAgICBpZiAoIXNlbmRlcikgbGl2ZWtpdExvZ2dlci53YXJuKCdlYXJseSByZXR1cm4gYmVjYXVzZSBzZW5kZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4ge0Bjb2RlIFJUQ1J0cFJlY2VpdmVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZGVjb2Rlci5cbiAgICpcbiAgICovXG4gIGhhbmRsZVJlY2VpdmVyKHJlY2VpdmVyLCB0cmFja0lkLCBwYXJ0aWNpcGFudElkZW50aXR5LCBjb2RlYykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIGNvZGVjXG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoRTJFRV9GTEFHIGluIHJlY2VpdmVyICYmIGNvZGVjKSB7XG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgY29kZWNcbiAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICBraW5kOiAndXBkYXRlQ29kZWMnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgd3JpdGFibGUgPSByZWNlaXZlci53cml0YWJsZVN0cmVhbTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcmVhZGFibGUgPSByZWNlaXZlci5yZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCF3cml0YWJsZSB8fCAhcmVhZGFibGUpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJTdHJlYW1zID0gcmVjZWl2ZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIud3JpdGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgd3JpdGFibGUgPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICAgIHJlYWRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbTogcmVhZGFibGUsXG4gICAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtyZWFkYWJsZSwgd3JpdGFibGVdKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlY2VpdmVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZW5jb2Rlci5cbiAgICpcbiAgICovXG4gIGhhbmRsZVNlbmRlcihzZW5kZXIsIHRyYWNrSWQsIGNvZGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB8fCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignbG9jYWwgaWRlbnRpdHkgbmVlZHMgdG8gYmUga25vd24gaW4gb3JkZXIgdG8gc2V0IHVwIGVuY3J5cHRlZCBzZW5kZXInKTtcbiAgICB9XG4gICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnaW5pdGlhbGl6ZSBzY3JpcHQgdHJhbnNmb3JtJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjXG4gICAgICB9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VuZGVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBzZW5kZXJTdHJlYW1zID0gc2VuZGVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSwgc2VuZGVyU3RyZWFtcy53cml0YWJsZV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VuZGVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICB9XG59XG5cbnZhciBRdWV1ZVRhc2tTdGF0dXM7XG4oZnVuY3Rpb24gKFF1ZXVlVGFza1N0YXR1cykge1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiV0FJVElOR1wiXSA9IDBdID0gXCJXQUlUSU5HXCI7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcbn0pKFF1ZXVlVGFza1N0YXR1cyB8fCAoUXVldWVUYXNrU3RhdHVzID0ge30pKTtcbmNsYXNzIEFzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMubmV4dFRhc2tJbmRleCA9IDA7XG4gIH1cbiAgcnVuKHRhc2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdGFza0luZm8gPSB7XG4gICAgICAgIGlkOiB0aGlzLm5leHRUYXNrSW5kZXgrKyxcbiAgICAgICAgZW5xdWV1ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgc3RhdHVzOiBRdWV1ZVRhc2tTdGF0dXMuV0FJVElOR1xuICAgICAgfTtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSW5mby5pZCwgdGFza0luZm8pO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy50YXNrTXV0ZXgubG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGFza0luZm8uZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5SVU5OSU5HO1xuICAgICAgICByZXR1cm4geWllbGQgdGFzaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLkNPTVBMRVRFRDtcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHRhc2tJbmZvLmlkKTtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7fSkpO1xuICAgIH0pO1xuICB9XG4gIHNuYXBzaG90KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKTtcbiAgfVxufVxuXG5jb25zdCBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyA9IFsnc3luY1N0YXRlJywgJ3RyaWNrbGUnLCAnb2ZmZXInLCAnYW5zd2VyJywgJ3NpbXVsYXRlJywgJ2xlYXZlJ107XG5mdW5jdGlvbiBjYW5QYXNzVGhyb3VnaFF1ZXVlKHJlcSkge1xuICBjb25zdCBjYW5QYXNzID0gcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMuaW5kZXhPZihyZXEuY2FzZSkgPj0gMDtcbiAgbGl2ZWtpdExvZ2dlci50cmFjZSgncmVxdWVzdCBhbGxvd2VkIHRvIGJ5cGFzcyBxdWV1ZTonLCB7XG4gICAgY2FuUGFzcyxcbiAgICByZXFcbiAgfSk7XG4gIHJldHVybiBjYW5QYXNzO1xufVxudmFyIFNpZ25hbENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoU2lnbmFsQ29ubmVjdGlvblN0YXRlKSB7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDFdID0gXCJDT05ORUNURURcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkRJU0NPTk5FQ1RJTkdcIl0gPSAzXSA9IFwiRElTQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVEVEXCJdID0gNF0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xufSkoU2lnbmFsQ29ubmVjdGlvblN0YXRlIHx8IChTaWduYWxDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2lnbmFsQ2xpZW50IHtcbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBnZXQgaXNEaXNjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cbiAgZ2V0IGlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgdXNlSlNPTiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICAvKiogc2lnbmFsIHJ0dCBpbiBtaWxsaXNlY29uZHMgKi9cbiAgICB0aGlzLnJ0dCA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnJlc2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uT2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlNpZ25hbCk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnVzZUpTT04gPSB1c2VKU09OO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICB0aGlzLnF1ZXVlZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICB9XG4gIGpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gZHVyaW5nIGEgZnVsbCByZWNvbm5lY3QsIHdlJ2Qgd2FudCB0byBzdGFydCB0aGUgc2VxdWVuY2UgZXZlbiBpZiBjdXJyZW50bHlcbiAgICAgIC8vIGNvbm5lY3RlZFxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG4gIHJlY29ubmVjdCh1cmwsIHRva2VuLCBzaWQsIHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdhdHRlbXB0ZWQgdG8gcmVjb25uZWN0IHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgYmVpbmcgc2V0LCBpZ25vcmluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xuICAgICAgLy8gY2xlYXIgcGluZyBpbnRlcnZhbCBhbmQgcmVzdGFydCBpdCBvbmNlIHJlY29ubmVjdGVkXG4gICAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7XG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgc2lkLFxuICAgICAgICByZWNvbm5lY3RSZWFzb246IHJlYXNvblxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdHM7XG4gICAgdXJsID0gdG9XZWJzb2NrZXRVcmwodXJsKTtcbiAgICAvLyBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIHVybCArPSAnL3J0Yyc7XG4gICAgY29uc3QgY2xpZW50SW5mbyA9IGdldENsaWVudEluZm8oKTtcbiAgICBjb25zdCBwYXJhbXMgPSBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBjbGllbnRJbmZvLCBvcHRzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkIChzaWduYWwpJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIHRpbWVkIG91dCAoc2lnbmFsKScpKTtcbiAgICAgICAgfSwgb3B0cy53ZWJzb2NrZXRUaW1lb3V0KTtcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdCh1cmwgKyBwYXJhbXMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh1cmwgKyBwYXJhbXMpO1xuICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCBmZXRjaChcImh0dHBcIi5jb25jYXQodXJsLnN1YnN0cmluZygyKSwgXCIvdmFsaWRhdGVcIikuY29uY2F0KHBhcmFtcykpO1xuICAgICAgICAgICAgICBpZiAocmVzcC5zdGF0dXMudG9GaXhlZCgwKS5zdGFydHNXaXRoKCc0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB5aWVsZCByZXNwLnRleHQoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihtc2csIDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8sIHJlc3Auc3RhdHVzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ0ludGVybmFsIGVycm9yJywgMiAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciAqLywgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJywgMSAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXIgZXJyb3JzLCBoYW5kbGVcbiAgICAgICAgICB0aGlzLmhhbmRsZVdTRXJyb3IoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBldiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgIC8vIG5vdCBjb25zaWRlcmVkIGNvbm5lY3RlZCB1bnRpbCBKb2luUmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgICBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShldi5kYXRhKTtcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tSnNvbihqc29uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgcmVzcCA9IFNpZ25hbFJlc3BvbnNlLmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoZXYuZGF0YSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihcImNvdWxkIG5vdCBkZWNvZGUgd2Vic29ja2V0IG1lc3NhZ2U6IFwiLmNvbmNhdCh0eXBlb2YgZXYuZGF0YSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBqb2luIG1lc3NhZ2Ugb25seVxuICAgICAgICAgICAgaWYgKCgoX2EgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYXNlKSA9PT0gJ2pvaW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICAgIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ0ludGVydmFsO1xuICAgICAgICAgICAgICBpZiAodGhpcy5waW5nVGltZW91dER1cmF0aW9uICYmIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGluZyBjb25maWcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcgJiYgcmVzcC5tZXNzYWdlLmNhc2UgIT09ICdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgLy8gaW4gcmVjb25uZWN0aW5nLCBhbnkgbWVzc2FnZSByZWNlaXZlZCBtZWFucyBzaWduYWwgcmVjb25uZWN0ZWRcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKChfYyA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uICYmIHJlc3AubWVzc2FnZS5jYXNlID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdSZWNlaXZlZCBsZWF2ZSByZXF1ZXN0IHdoaWxlIHRyeWluZyB0byAocmUpY29ubmVjdCcsIDQgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCAqLykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0cy5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgLy8gbm9uLXJlY29ubmVjdCBjYXNlLCBzaG91bGQgcmVjZWl2ZSBqb2luIHJlc3BvbnNlIGZpcnN0XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKFwiZGlkIG5vdCByZWNlaXZlIGpvaW4gcmVzcG9uc2UsIGdvdCBcIi5jb25jYXQoKF9kID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FzZSwgXCIgaW5zdGVhZFwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaG91bGRQcm9jZXNzTWVzc2FnZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzcCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBldiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignV2Vic29ja2V0IGdvdCBjbG9zZWQgZHVyaW5nIGEgKHJlKWNvbm5lY3Rpb24gYXR0ZW1wdCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcIndlYnNvY2tldCBjbG9zZWRcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICByZWFzb246IGV2LnJlYXNvbixcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlT25DbG9zZShldi5yZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORztcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy53cy5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgLy8gY2FsbGluZyBgd3MuY2xvc2UoKWAgb25seSBzdGFydHMgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIChDTE9TSU5HIHN0YXRlKSwgcHJlZmVyIHRvIHdhaXQgdW50aWwgc3RhdGUgaXMgYWN0dWFsbHkgQ0xPU0VEXG4gICAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLndzLnJlYWR5U3RhdGUgPCB0aGlzLndzLkNMT1NJTkcpIHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIDI1MG1zIGdyYWNlIHBlcmlvZCBmb3Igd3MgdG8gY2xvc2UgZ3JhY2VmdWxseVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFtjbG9zZVByb21pc2UsIHNsZWVwKDI1MCldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gICAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gaW5pdGlhbCBvZmZlciBhZnRlciBqb2luaW5nXG4gIHNlbmRPZmZlcihvZmZlcikge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIG9mZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBvZmZlclNkcDogb2ZmZXIuc2RwXG4gICAgfSkpO1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ29mZmVyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKVxuICAgIH0pO1xuICB9XG4gIC8vIGFuc3dlciBhIHNlcnZlci1pbml0aWF0ZWQgb2ZmZXJcbiAgc2VuZEFuc3dlcihhbnN3ZXIpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBhbnN3ZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGFuc3dlclNkcDogYW5zd2VyLnNkcFxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYW5zd2VyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcilcbiAgICB9KTtcbiAgfVxuICBzZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy5sb2cudHJhY2UoJ3NlbmRpbmcgaWNlIGNhbmRpZGF0ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgY2FuZGlkYXRlXG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmlja2xlJyxcbiAgICAgIHZhbHVlOiBuZXcgVHJpY2tsZVJlcXVlc3Qoe1xuICAgICAgICBjYW5kaWRhdGVJbml0OiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUpLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbXV0ZScsXG4gICAgICB2YWx1ZTogbmV3IE11dGVUcmFja1JlcXVlc3Qoe1xuICAgICAgICBzaWQ6IHRyYWNrU2lkLFxuICAgICAgICBtdXRlZFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kQWRkVHJhY2socmVxKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2FkZFRyYWNrJyxcbiAgICAgIHZhbHVlOiByZXFcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YSwgbmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVNZXRhZGF0YScsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoe1xuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbmFtZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyYWNrU2V0dGluZycsXG4gICAgICB2YWx1ZTogc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgdmFsdWU6IHN1YlxuICAgIH0pO1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoc3luYykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzeW5jU3RhdGUnLFxuICAgICAgdmFsdWU6IHN5bmNcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVmlkZW9MYXllcnModHJhY2tTaWQsIGxheWVycykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVMYXllcnMnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVWaWRlb0xheWVycyh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBsYXllcnNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50cywgdHJhY2tQZXJtaXNzaW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uJyxcbiAgICAgIHZhbHVlOiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbih7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50cyxcbiAgICAgICAgdHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzaW11bGF0ZScsXG4gICAgICB2YWx1ZTogc2NlbmFyaW9cbiAgICB9KTtcbiAgfVxuICBzZW5kUGluZygpIHtcbiAgICAvKiogc2VuZCBib3RoIG9mIHBpbmcgYW5kIHBpbmdSZXEgZm9yIGNvbXBhdGliaWxpdHkgdG8gb2xkIGFuZCBuZXcgc2VydmVyICovXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdwaW5nJyxcbiAgICAgIHZhbHVlOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgfSksIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3BpbmdSZXEnLFxuICAgICAgdmFsdWU6IG5ldyBQaW5nKHtcbiAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpLFxuICAgICAgICBydHQ6IHByb3RvSW50NjQucGFyc2UodGhpcy5ydHQpXG4gICAgICB9KVxuICAgIH0pXSk7XG4gIH1cbiAgc2VuZExlYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdsZWF2ZScsXG4gICAgICB2YWx1ZTogbmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgIGNhblJlY29ubmVjdDogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICBsZXQgZnJvbVF1ZXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gY2FwdHVyZSBhbGwgcmVxdWVzdHMgd2hpbGUgcmVjb25uZWN0aW5nIGFuZCBwdXQgdGhlbSBpbiBhIHF1ZXVlXG4gICAgICAvLyB1bmxlc3MgdGhlIHJlcXVlc3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBxdWV1ZSwgdGhlbiBkb24ndCBlbnF1ZXVlIGFnYWluXG4gICAgICBjb25zdCBjYW5RdWV1ZSA9ICFmcm9tUXVldWUgJiYgIWNhblBhc3NUaHJvdWdoUXVldWUobWVzc2FnZSk7XG4gICAgICBpZiAoY2FuUXVldWUgJiYgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3RzLnB1c2goKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZFJlcXVlc3QobWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbWFrZSBzdXJlIHByZXZpb3VzbHkgcXVldWVkIHJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGZpcnN0XG4gICAgICBpZiAoIWZyb21RdWV1ZSkge1xuICAgICAgICB5aWVsZCB0aGlzLnJlcXVlc3RRdWV1ZS5mbHVzaCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICB5aWVsZCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLndzIHx8IHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gdGhpcy53cy5PUEVOKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiY2Fubm90IHNlbmQgc2lnbmFsIHJlcXVlc3QgYmVmb3JlIGNvbm5lY3RlZCwgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5jYXNlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gbmV3IFNpZ25hbFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnVzZUpTT04pIHtcbiAgICAgICAgICB0aGlzLndzLnNlbmQocmVxLnRvSnNvblN0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndzLnNlbmQocmVxLnRvQmluYXJ5KCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbXNnID0gcmVzLm1lc3NhZ2U7XG4gICAgaWYgKG1zZyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnN1cHBvcnRlZCBtZXNzYWdlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBpbmdIYW5kbGVkID0gZmFsc2U7XG4gICAgaWYgKG1zZy5jYXNlID09PSAnYW5zd2VyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XG4gICAgICAgIHRoaXMub25BbnN3ZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdvZmZlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyKSB7XG4gICAgICAgIHRoaXMub25PZmZlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBtc2dDYXNlOiBtc2cuY2FzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXBpbmdIYW5kbGVkKSB7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gIH1cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlT25DbG9zZShyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpIHJldHVybjtcbiAgICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkOiBcIi5jb25jYXQocmVhc29uKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgICAgaWYgKG9uQ2xvc2VDYWxsYmFjaykge1xuICAgICAgICBvbkNsb3NlQ2FsbGJhY2socmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVXU0Vycm9yKGV2KSB7XG4gICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgZXJyb3I6IGV2XG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBpbmcgdGltZW91dCBhbmQgc3RhcnRzIGEgbmV3IHRpbWVvdXQuXG4gICAqIENhbGwgdGhpcyBhZnRlciByZWNlaXZpbmcgYSBwb25nIG1lc3NhZ2VcbiAgICovXG4gIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgdGltZW91dCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waW5nVGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcInBpbmcgdGltZW91dCB0cmlnZ2VyZWQuIGxhc3QgcG9uZyByZWNlaXZlZCBhdDogXCIuY29uY2F0KG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKS50b1VUQ1N0cmluZygpKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuaGFuZGxlT25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gICAgfSwgdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBwaW5nIHRpbWVvdXQgKGRvZXMgbm90IHN0YXJ0IGEgbmV3IHRpbWVvdXQpXG4gICAqL1xuICBjbGVhclBpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0KSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0UGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ0ludGVydmFsRHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgaW50ZXJ2YWwgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydCBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc2VuZFBpbmcoKTtcbiAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uICogMTAwMCk7XG4gIH1cbiAgY2xlYXJQaW5nSW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ2NsZWFyaW5nIHBpbmcgaW50ZXJ2YWwnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuY2xlYXJQaW5nVGltZW91dCgpO1xuICAgIGlmICh0aGlzLnBpbmdJbnRlcnZhbCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oc2QpIHtcbiAgY29uc3QgcnNkID0ge1xuICAgIHR5cGU6ICdvZmZlcicsXG4gICAgc2RwOiBzZC5zZHBcbiAgfTtcbiAgc3dpdGNoIChzZC50eXBlKSB7XG4gICAgY2FzZSAnYW5zd2VyJzpcbiAgICBjYXNlICdvZmZlcic6XG4gICAgY2FzZSAncHJhbnN3ZXInOlxuICAgIGNhc2UgJ3JvbGxiYWNrJzpcbiAgICAgIHJzZC50eXBlID0gc2QudHlwZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByc2Q7XG59XG5mdW5jdGlvbiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHJzZCkge1xuICBjb25zdCBzZCA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgIHNkcDogcnNkLnNkcCxcbiAgICB0eXBlOiByc2QudHlwZVxuICB9KTtcbiAgcmV0dXJuIHNkO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgaW5mbywgb3B0cykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xuICAvLyBvcHRzXG4gIGlmIChvcHRzLnJlY29ubmVjdCkge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdCcsICcxJyk7XG4gICAgaWYgKG9wdHMuc2lkKSB7XG4gICAgICBwYXJhbXMuc2V0KCdzaWQnLCBvcHRzLnNpZCk7XG4gICAgfVxuICB9XG4gIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcbiAgLy8gQ2xpZW50SW5mb1xuICBwYXJhbXMuc2V0KCdzZGsnLCBpc1JlYWN0TmF0aXZlKCkgPyAncmVhY3RuYXRpdmUnIDogJ2pzJyk7XG4gIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24pO1xuICBwYXJhbXMuc2V0KCdwcm90b2NvbCcsIGluZm8ucHJvdG9jb2wudG9TdHJpbmcoKSk7XG4gIGlmIChpbmZvLmRldmljZU1vZGVsKSB7XG4gICAgcGFyYW1zLnNldCgnZGV2aWNlX21vZGVsJywgaW5mby5kZXZpY2VNb2RlbCk7XG4gIH1cbiAgaWYgKGluZm8ub3MpIHtcbiAgICBwYXJhbXMuc2V0KCdvcycsIGluZm8ub3MpO1xuICB9XG4gIGlmIChpbmZvLm9zVmVyc2lvbikge1xuICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3Nlcikge1xuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXInLCBpbmZvLmJyb3dzZXIpO1xuICB9XG4gIGlmIChpbmZvLmJyb3dzZXJWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3Nlcl92ZXJzaW9uJywgaW5mby5icm93c2VyVmVyc2lvbik7XG4gIH1cbiAgaWYgKG9wdHMucHVibGlzaE9ubHkgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5zZXQoJ3B1Ymxpc2gnLCBvcHRzLnB1Ymxpc2hPbmx5KTtcbiAgfVxuICBpZiAob3B0cy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgIHBhcmFtcy5zZXQoJ2FkYXB0aXZlX3N0cmVhbScsICcxJyk7XG4gIH1cbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0X3JlYXNvbicsIG9wdHMucmVjb25uZWN0UmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKChfYSA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYXJhbXMuc2V0KCduZXR3b3JrJywgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSk7XG4gIH1cbiAgcmV0dXJuIFwiP1wiLmNvbmNhdChwYXJhbXMudG9TdHJpbmcoKSk7XG59XG5cbnZhciBwYXJzZXIkMSA9IHt9O1xuXG52YXIgZ3JhbW1hciQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdyYW1tYXIkMSA9IGdyYW1tYXIkMi5leHBvcnRzID0ge1xuICB2OiBbe1xuICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICByZWc6IC9eKFxcZCopJC9cbiAgfV0sXG4gIG86IFt7XG4gICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgbmFtZTogJ29yaWdpbicsXG4gICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gIH1dLFxuICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgczogW3tcbiAgICBuYW1lOiAnbmFtZSdcbiAgfV0sXG4gIGk6IFt7XG4gICAgbmFtZTogJ2Rlc2NyaXB0aW9uJ1xuICB9XSxcbiAgdTogW3tcbiAgICBuYW1lOiAndXJpJ1xuICB9XSxcbiAgZTogW3tcbiAgICBuYW1lOiAnZW1haWwnXG4gIH1dLFxuICBwOiBbe1xuICAgIG5hbWU6ICdwaG9uZSdcbiAgfV0sXG4gIHo6IFt7XG4gICAgbmFtZTogJ3RpbWV6b25lcydcbiAgfV0sXG4gIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cbiAgcjogW3tcbiAgICBuYW1lOiAncmVwZWF0cydcbiAgfV0sXG4gIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXG4gIHQ6IFt7XG4gICAgLy8gdD0wIDBcbiAgICBuYW1lOiAndGltaW5nJyxcbiAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXG4gICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgIGZvcm1hdDogJyVkICVkJ1xuICB9XSxcbiAgYzogW3tcbiAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcbiAgICBuYW1lOiAnY29ubmVjdGlvbicsXG4gICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXG4gICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcbiAgfV0sXG4gIGI6IFt7XG4gICAgLy8gYj1BUzo0MDAwXG4gICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcbiAgICBmb3JtYXQ6ICclczolcydcbiAgfV0sXG4gIG06IFt7XG4gICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cbiAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XG4gICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gIH1dLFxuICBhOiBbe1xuICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICBwdXNoOiAncnRwJyxcbiAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLmVuY29kaW5nID8gJ3J0cG1hcDolZCAlcy8lcy8lcycgOiBvLnJhdGUgPyAncnRwbWFwOiVkICVzLyVzJyA6ICdydHBtYXA6JWQgJXMnO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxuICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgcHVzaDogJ2ZtdHAnLFxuICAgIHJlZzogL15mbXRwOihcXGQqKSAoW1xcU3wgXSopLyxcbiAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gIH0sIHtcbiAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICByZWc6IC9eY29udHJvbDooLiopLyxcbiAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XG4gICAgbmFtZTogJ3J0Y3AnLFxuICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5hZGRyZXNzICE9IG51bGwgPyAncnRjcDolZCAlcyBJUCVkICVzJyA6ICdydGNwOiVkJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcbiAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgZm9ybWF0OiAncnRjcC1mYjolcyB0cnItaW50ICVkJ1xuICB9LCB7XG4gICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgIHB1c2g6ICdydGNwRmInLFxuICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndHlwZScsICdzdWJ0eXBlJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uc3VidHlwZSAhPSBudWxsID8gJ3J0Y3AtZmI6JXMgJXMgJXMnIDogJ3J0Y3AtZmI6JXMgJXMnO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XG4gICAgcHVzaDogJ2V4dCcsXG4gICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuICdleHRtYXA6JWQnICsgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArICcgJXMnICsgKG8uY29uZmlnID8gJyAlcycgOiAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1leHRtYXAtYWxsb3ctbWl4ZWRcbiAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXG4gICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xuICB9LCB7XG4gICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICBwdXNoOiAnY3J5cHRvJyxcbiAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLnNlc3Npb25Db25maWcgIT0gbnVsbCA/ICdjcnlwdG86JWQgJXMgJXMgJXMnIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgbmFtZTogJ3NldHVwJyxcbiAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgfSwge1xuICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcbiAgICBuYW1lOiAnY29ubmVjdGlvblR5cGUnLFxuICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcbiAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1taWQ6MVxuICAgIG5hbWU6ICdtaWQnLFxuICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICBmb3JtYXQ6ICdtaWQ6JXMnXG4gIH0sIHtcbiAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgIG5hbWU6ICdtc2lkJyxcbiAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1wdGltZToyMFxuICAgIG5hbWU6ICdwdGltZScsXG4gICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gIH0sIHtcbiAgICAvLyBhPW1heHB0aW1lOjYwXG4gICAgbmFtZTogJ21heHB0aW1lJyxcbiAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcbiAgfSwge1xuICAgIC8vIGE9c2VuZHJlY3ZcbiAgICBuYW1lOiAnZGlyZWN0aW9uJyxcbiAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgfSwge1xuICAgIC8vIGE9aWNlLWxpdGVcbiAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gIH0sIHtcbiAgICAvLyBhPWljZS11ZnJhZzpGN2dJXG4gICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXG4gICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1pY2UtcHdkOng5Y21sL1l6aWNoVjIrWGxoaU11OGdcbiAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgIGZvcm1hdDogJ2ljZS1wd2Q6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcbiAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXG4gIH0sIHtcbiAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB1ZHAgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICBwdXNoOiAnY2FuZGlkYXRlcycsXG4gICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcbiAgICAgIHN0ciArPSBvLnJhZGRyICE9IG51bGwgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgIHN0ciArPSBvLnRjcHR5cGUgIT0gbnVsbCA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuICAgICAgaWYgKG8uZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgfVxuICAgICAgc3RyICs9IG9bJ25ldHdvcmstaWQnXSAhPSBudWxsID8gJyBuZXR3b3JrLWlkICVkJyA6ICcldic7XG4gICAgICBzdHIgKz0gb1snbmV0d29yay1jb3N0J10gIT0gbnVsbCA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgbmFtZTogJ2VuZE9mQ2FuZGlkYXRlcycsXG4gICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXG4gIH0sIHtcbiAgICAvLyBhPXJlbW90ZS1jYW5kaWRhdGVzOjEgMjAzLjAuMTEzLjEgNTQ0MDAgMiAyMDMuMC4xMTMuMSA1NDQwMSAuLi5cbiAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgIGZvcm1hdDogJ3JlbW90ZS1jYW5kaWRhdGVzOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgbmFtZTogJ2ljZU9wdGlvbnMnLFxuICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxuICAgIHB1c2g6ICdzc3JjcycsXG4gICAgcmVnOiAvXnNzcmM6KFxcZCopIChbXFx3Xy1dKikoPzo6KC4qKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RyID0gJ3NzcmM6JWQnO1xuICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICBpZiAoby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICc6JXMnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICBwdXNoOiAnc3NyY0dyb3VwcycsXG4gICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgIG5hbWVzOiBbJ3NlbWFudGljcycsICdzc3JjcyddLFxuICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gIH0sIHtcbiAgICAvLyBhPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXG4gICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gIH0sIHtcbiAgICAvLyBhPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgIHB1c2g6ICdncm91cHMnLFxuICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtbXV4XG4gICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICB9LCB7XG4gICAgLy8gYT1ydGNwLXJzaXplXG4gICAgbmFtZTogJ3J0Y3BSc2l6ZScsXG4gICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgfSwge1xuICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgIHJlZzogL15zY3RwbWFwOihbXFx3Xy9dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLm1heE1lc3NhZ2VTaXplICE9IG51bGwgPyAnc2N0cG1hcDolcyAlcyAlcycgOiAnc2N0cG1hcDolcyAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcbiAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgIHJlZzogL154LWdvb2dsZS1mbGFnOihbXlxcc10qKS8sXG4gICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcbiAgfSwge1xuICAgIC8vIGE9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgcHVzaDogJ3JpZHMnLFxuICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLnBhcmFtcyA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAvLyBhPWltYWdlYXR0cjoqIHNlbmQgW3g9ODAwLHk9NjQwXSByZWN2ICpcbiAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXG4gICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAvLyBhPWltYWdlYXR0cjo5N1xuICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgLy8gc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXVxuICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xuICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICcoPzpbXFxcXHNcXFxcdF0rKHJlY3Z8c2VuZClbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKSk/JyksXG4gICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gJ2ltYWdlYXR0cjolcyAlcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1zaW11bGNhc3Q6c2VuZCAxLDIsMzt+NCx+NSByZWN2IDY7fjcsfjhcbiAgICAvLyBhPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XG4gICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgIC8vIGE9c2ltdWxjYXN0OlxuICAgICdec2ltdWxjYXN0OicgK1xuICAgIC8vIHNlbmQgMSwyLDM7fjQsfjVcbiAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgLy8gZW5kXG4gICAgJyQnKSxcbiAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAvLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zZHAtc2ltdWxjYXN0LTAzXG4gICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgbmFtZTogJ3NpbXVsY2FzdF8wMycsXG4gICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcbiAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgIGZvcm1hdDogJ3NpbXVsY2FzdDogJXMnXG4gIH0sIHtcbiAgICAvLyBhPWZyYW1lcmF0ZToyNVxuICAgIC8vIGE9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgbmFtZTogJ2ZyYW1lcmF0ZScsXG4gICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkM0NTcwXG4gICAgLy8gYT1zb3VyY2UtZmlsdGVyOiBpbmNsIElOIElQNCAyMzkuNS4yLjMxIDEwLjEuMTUuNVxuICAgIG5hbWU6ICdzb3VyY2VGaWx0ZXInLFxuICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgIG5hbWVzOiBbJ2ZpbHRlck1vZGUnLCAnbmV0VHlwZScsICdhZGRyZXNzVHlwZXMnLCAnZGVzdEFkZHJlc3MnLCAnc3JjTGlzdCddLFxuICAgIGZvcm1hdDogJ3NvdXJjZS1maWx0ZXI6ICVzICVzICVzICVzICVzJ1xuICB9LCB7XG4gICAgLy8gYT1idW5kbGUtb25seVxuICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcbiAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgfSwge1xuICAgIC8vIGE9bGFiZWw6MVxuICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgcmVnOiAvXmxhYmVsOiguKykvLFxuICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xuICB9LCB7XG4gICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNVxuICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgcmVnOiAvXnNjdHAtcG9ydDooXFxkKykkLyxcbiAgICBmb3JtYXQ6ICdzY3RwLXBvcnQ6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XG4gICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICByZWc6IC9ebWF4LW1lc3NhZ2Utc2l6ZTooXFxkKykkLyxcbiAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xuICB9LCB7XG4gICAgLy8gUkZDNzI3M1xuICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XG4gICAgcHVzaDogJ3RzUmVmQ2xvY2tzJyxcbiAgICByZWc6IC9edHMtcmVmY2xrOihbXlxccz1dKikoPzo9KFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ2Nsa3NyYycsICdjbGtzcmNFeHQnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gJ3RzLXJlZmNsazolcycgKyAoby5jbGtzcmNFeHQgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIFJGQzcyNzNcbiAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcbiAgICBuYW1lOiAnbWVkaWFDbGsnLFxuICAgIHJlZzogL15tZWRpYWNsazooPzppZD0oXFxTKikpPyAqKFteXFxzPV0qKSg/Oj0oXFxTKikpPyg/OiAqcmF0ZT0oXFxkKylcXC8oXFxkKykpPy8sXG4gICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0ciA9ICdtZWRpYWNsazonO1xuICAgICAgc3RyICs9IG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcyc7XG4gICAgICBzdHIgKz0gby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJyc7XG4gICAgICBzdHIgKz0gby5yYXRlTnVtZXJhdG9yICE9IG51bGwgPyAnIHJhdGU9JXMnIDogJyc7XG4gICAgICBzdHIgKz0gby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJyc7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgbmFtZTogJ2tleXdvcmRzJyxcbiAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcbiAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWNvbnRlbnQ6bWFpblxuICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICByZWc6IC9eY29udGVudDooLispLyxcbiAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xuICB9LFxuICAvLyBCRkNQIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NTgzXG4gIHtcbiAgICAvLyBhPWZsb29yY3RybDpjLXNcbiAgICBuYW1lOiAnYmZjcEZsb29yQ3RybCcsXG4gICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcbiAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWNvbmZpZDoxXG4gICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgIHJlZzogL15jb25maWQ6KFxcZCspLyxcbiAgICBmb3JtYXQ6ICdjb25maWQ6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXVzZXJpZDoxXG4gICAgbmFtZTogJ2JmY3BVc2VySWQnLFxuICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICBmb3JtYXQ6ICd1c2VyaWQ6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWZsb29yaWQ6MVxuICAgIG5hbWU6ICdiZmNwRmxvb3JJZCcsXG4gICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXG4gICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxuICAgIGZvcm1hdDogJ2Zsb29yaWQ6JXMgbXN0cm06JXMnXG4gIH0sIHtcbiAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgIHB1c2g6ICdpbnZhbGlkJyxcbiAgICBuYW1lczogWyd2YWx1ZSddXG4gIH1dXG59O1xuXG4vLyBzZXQgc2Vuc2libGUgZGVmYXVsdHMgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBncmFtbWFyIHdpdGggYm9yaW5nIGRldGFpbHNcbk9iamVjdC5rZXlzKGdyYW1tYXIkMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBvYmpzID0gZ3JhbW1hciQxW2tleV07XG4gIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICBvYmoucmVnID0gLyguKikvO1xuICAgIH1cbiAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBncmFtbWFyRXhwb3J0cyA9IGdyYW1tYXIkMi5leHBvcnRzO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgdmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG4gIH07XG4gIHZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICAgIGxvY2F0aW9uW3Jhd05hbWVdID0gdG9JbnRJZkludChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG1hdGNoW2kgKyAxXSAhPSBudWxsKSB7XG4gICAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xuICAgIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICAgIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcbiAgICB9IGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gICAgfVxuICAgIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID8ge30gOlxuICAgIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgbmVlZHNCbGFuayA/IGxvY2F0aW9uW29iai5uYW1lXSA6IGxvY2F0aW9uOyAvLyBvdGhlcndpc2UsIG5hbWVkIGxvY2F0aW9uIG9yIHJvb3RcblxuICAgIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuICAgIGlmIChvYmoucHVzaCkge1xuICAgICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xuICAgIH1cbiAgfTtcbiAgdmFyIGdyYW1tYXIgPSBncmFtbWFyRXhwb3J0cztcbiAgdmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XG4gICAgdmFyIHNlc3Npb24gPSB7fSxcbiAgICAgIG1lZGlhID0gW10sXG4gICAgICBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxuXG4gICAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICAgIHNkcC5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pLmZpbHRlcih2YWxpZExpbmUpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgIHZhciB0eXBlID0gbFswXTtcbiAgICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgICAgbWVkaWEucHVzaCh7XG4gICAgICAgICAgcnRwOiBbXSxcbiAgICAgICAgICBmbXRwOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGggLSAxXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgICBpZiAob2JqLnJlZy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gICAgcmV0dXJuIHNlc3Npb247XG4gIH07XG4gIHZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gICAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgICB9IGVsc2UgaWYgKHMubGVuZ3RoID09PSAxICYmIGV4cHIubGVuZ3RoID4gMSkge1xuICAgICAgYWNjW3NbMF1dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuICBleHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoLztcXHM/LykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICB9O1xuXG4gIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXG4gIGV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcbiAgZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xuICB9O1xuICBleHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgICBpcDogcGFydHNbaSArIDFdLFxuICAgICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgfTtcbiAgZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGggLSAxKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgICB9KTtcbiAgfTtcbiAgZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgdmFyIHNjaWQsXG4gICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xuICAgICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XG4gICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNjaWQ6IHNjaWQsXG4gICAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSkocGFyc2VyJDEpO1xuXG52YXIgZ3JhbW1hciA9IGdyYW1tYXJFeHBvcnRzO1xuXG4vLyBjdXN0b21pemVkIHV0aWwuZm9ybWF0IC0gZGlzY2FyZHMgZXhjZXNzIGFyZ3VtZW50cyBhbmQgY2FuIHZvaWQgbWlkZGxlIG9uZXNcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xudmFyIGZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXRTdHIpIHtcbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICByZXR1cm4gZm9ybWF0U3RyLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgIGlmIChpID49IGxlbikge1xuICAgICAgcmV0dXJuIHg7IC8vIG1pc3NpbmcgYXJndW1lbnRcbiAgICB9XG4gICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgaSArPSAxO1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJSUnOlxuICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgY2FzZSAnJXMnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgICBjYXNlICclZCc6XG4gICAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgICAgIGNhc2UgJyV2JzpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIC8vIE5COiB3ZSBkaXNjYXJkIGV4Y2VzcyBhcmd1bWVudHMgLSB0aGV5IGFyZSB0eXBpY2FsbHkgdW5kZWZpbmVkIGZyb20gbWFrZUxpbmVcbn07XG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gb2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSA6IG9iai5mb3JtYXQ7XG4gIHZhciBhcmdzID0gW3R5cGUgKyAnPScgKyBzdHJdO1xuICBpZiAob2JqLm5hbWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBuID0gb2JqLm5hbWVzW2ldO1xuICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV1bbl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFsndicsICdvJywgJ3MnLCAnaScsICd1JywgJ2UnLCAncCcsICdjJywgJ2InLCAndCcsICdyJywgJ3onLCAnYSddO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG52YXIgd3JpdGVyJDEgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcbiAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XG4gIHZhciBpbm5lck9yZGVyID0gb3B0cy5pbm5lck9yZGVyIHx8IGRlZmF1bHRJbm5lck9yZGVyO1xuICB2YXIgc2RwID0gW107XG5cbiAgLy8gbG9vcCB0aHJvdWdoIG91dGVyT3JkZXIgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMgb24gc2Vzc2lvblxuICBvdXRlck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKG9iai5uYW1lIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIHNlc3Npb24pKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai5uYW1lIGluIG1MaW5lICYmIG1MaW5lW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5wdXNoIGluIG1MaW5lICYmIG1MaW5lW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgICAgbUxpbmVbb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xufTtcblxudmFyIHBhcnNlciA9IHBhcnNlciQxO1xudmFyIHdyaXRlciA9IHdyaXRlciQxO1xudmFyIHdyaXRlID0gd3JpdGVyO1xudmFyIHBhcnNlID0gcGFyc2VyLnBhcnNlO1xucGFyc2VyLnBhcnNlUGFyYW1zO1xucGFyc2VyLnBhcnNlRm10cENvbmZpZzsgLy8gQWxpYXMgb2YgcGFyc2VQYXJhbXMoKS5cbnBhcnNlci5wYXJzZVBheWxvYWRzO1xucGFyc2VyLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcztcbnBhcnNlci5wYXJzZUltYWdlQXR0cmlidXRlcztcbnBhcnNlci5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3Q7XG5cbi8qIFRoZSBzdmMgY29kZWMgKGF2MS92cDkpIHdvdWxkIHVzZSBhIHZlcnkgbG93IGJpdHJhdGUgYXQgdGhlIGJlZ2luaW5nIGFuZFxuaW5jcmVhc2Ugc2xvd2x5IGJ5IHRoZSBiYW5kd2lkdGggZXN0aW1hdG9yIHVudGlsIGl0IHJlYWNoIHRoZSB0YXJnZXQgYml0cmF0ZS4gVGhlXG5wcm9jZXNzIGNvbW1vbmx5IGNvc3QgbW9yZSB0aGFuIDEwIHNlY29uZHMgY2F1c2Ugc3Vic2NyaWJlciB3aWxsIGdldCBibHVyIHZpZGVvIGF0XG50aGUgZmlyc3QgZmV3IHNlY29uZHMuIFNvIHdlIHVzZSBhIDcwJSBvZiB0YXJnZXQgYml0cmF0ZSBoZXJlIGFzIHRoZSBzdGFydCBiaXRyYXRlIHRvXG5lbGltaW5hdGUgdGhpcyBpc3N1ZS5cbiovXG5jb25zdCBzdGFydEJpdHJhdGVGb3JTVkMgPSAwLjc7XG5jb25zdCBQQ0V2ZW50cyA9IHtcbiAgTmVnb3RpYXRpb25TdGFydGVkOiAnbmVnb3RpYXRpb25TdGFydGVkJyxcbiAgTmVnb3RpYXRpb25Db21wbGV0ZTogJ25lZ290aWF0aW9uQ29tcGxldGUnLFxuICBSVFBWaWRlb1BheWxvYWRUeXBlczogJ3J0cFZpZGVvUGF5bG9hZFR5cGVzJ1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFBDVHJhbnNwb3J0IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgcGMoKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYztcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBsZXQgbWVkaWFDb25zdHJhaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzID0gW107XG4gICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tCaXRyYXRlcyA9IFtdO1xuICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IFtdO1xuICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBbXTtcbiAgICAvLyBkZWJvdW5jZWQgbmVnb3RpYXRlIGludGVyZmFjZVxuICAgIHRoaXMubmVnb3RpYXRlID0gcihvbkVycm9yID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgMTAwKTtcbiAgICB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QQ1RyYW5zcG9ydCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMgPSBtZWRpYUNvbnN0cmFpbnRzO1xuICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICB9XG4gIGNyZWF0ZVBDKCkge1xuICAgIGNvbnN0IHBjID0gaXNDaHJvbWl1bUJhc2VkKCkgP1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2hyb21lIGFsbG93cyBhZGRpdGlvbmFsIG1lZGlhIGNvbnN0cmFpbnRzIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBSVENQZWVyQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZywgdGhpcy5tZWRpYUNvbnN0cmFpbnRzKSA6IG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZyk7XG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWV2LmNhbmRpZGF0ZSkgcmV0dXJuO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYuY2FuZGlkYXRlKTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlZXJyb3IgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9udHJhY2sgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBwYztcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICBnZXQgaXNJQ0VDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjICE9PSBudWxsICYmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKTtcbiAgfVxuICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbihzZCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IG11bmdlZFNEUCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc3RlcmVvTWlkcyxcbiAgICAgICAgICBuYWNrTWlkc1xuICAgICAgICB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IHN0ZXJlb01pZHM7XG4gICAgICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBuYWNrTWlkcztcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoKF9hID0gc2Quc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XG4gICAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtZWRpYS5taWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyA9IGZtdHAuY29uZmlnLnNwbGl0KCc7JykuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaW5jbHVkZXMoJ21heGF2ZXJhZ2ViaXRyYXRlJykpLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjttYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IFwibWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbXVuZ2VkU0RQID0gd3JpdGUoc2RwUGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWRTRFAsIHRydWUpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmVuZWdvdGlhdGUpIHtcbiAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XG4gICAgICAgIGlmIChzZC5zZHApIHtcbiAgICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShzZC5zZHApO1xuICAgICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgbWVkaWEucnRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIElDRScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgICAvLyB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgcGVlciB0byBhY2NlcHQgb3VyIG9mZmVyLCBzbyB3ZSdsbCBqdXN0IHdhaXRcbiAgICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcbiAgICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpICYmIGN1cnJlbnRTRCkge1xuICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxuICAgICAgICAgIHlpZWxkIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGN1cnJlbnRTRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGNyZWF0ZU9mZmVyIHdpdGggY2xvc2VkIHBlZXIgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0aW5nIHRvIG5lZ290aWF0ZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBjb25zdCBvZmZlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEpO1xuICAgICAgICAgIC8vIG11bmcgc2RwIGZvciBjb2RlYyBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcbiAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcbiAgICAgICAgICAgIGlmICghbWVkaWEubXNpZCB8fCAhdHJhY2tici5jaWQgfHwgIW1lZGlhLm1zaWQuaW5jbHVkZXModHJhY2tici5jaWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1zdGFydC1iaXRyYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KE1hdGgucm91bmQodHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1tYXgtYml0cmF0ZScpKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjt4LWdvb2dsZS1tYXgtYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhicik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZtdHBGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogXCJ4LWdvb2dsZS1zdGFydC1iaXRyYXRlPVwiLmNvbmNhdChNYXRoLnJvdW5kKHRyYWNrYnIubWF4YnIgKiBzdGFydEJpdHJhdGVGb3JTVkMpLCBcIjt4LWdvb2dsZS1tYXgtYml0cmF0ZT1cIikuY29uY2F0KHRyYWNrYnIubWF4YnIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAob2ZmZXIsIHdyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBbmRTZXRBbnN3ZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoKF9hID0gYW5zd2VyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgdGhpcy5yZW1vdGVTdGVyZW9NaWRzLCB0aGlzLnJlbW90ZU5hY2tNaWRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChhbnN3ZXIsIHdyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFja0NvZGVjQml0cmF0ZShpbmZvKSB7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzLnB1c2goaW5mbyk7XG4gIH1cbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gIH1cbiAgY2FuUmVtb3ZlVHJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldElDRUNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmljZUNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsaW5nU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldFRyYW5zY2VpdmVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRTZW5kZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VuZGVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uO1xuICB9XG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZURlc2NyaXB0aW9uO1xuICB9XG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gJyc7XG4gICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXAoKTtcbiAgICAgIC8vIGlkIC0+IGNhbmRpZGF0ZSBpcFxuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIHN3aXRjaCAodi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9IHYuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZW1vdGUtY2FuZGlkYXRlJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIFwiXCIuY29uY2F0KHYuYWRkcmVzcywgXCI6XCIpLmNvbmNhdCh2LnBvcnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkSUQgPSAoX2EgPSBjYW5kaWRhdGVQYWlycy5nZXQoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgICBpZiAoc2VsZWN0ZWRJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlcy5nZXQoc2VsZWN0ZWRJRCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWQsIHJlbW90ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAobXVuZ2VkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2RwID0gc2Quc2RwO1xuICAgICAgICBzZC5zZHAgPSBtdW5nZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIG11bmdlZCBcIi5jb25jYXQocmVtb3RlID8gJ3JlbW90ZScgOiAnbG9jYWwnLCBcIiBkZXNjcmlwdGlvblwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcIm5vdCBhYmxlIHRvIHNldCBcIi5jb25jYXQoc2QudHlwZSwgXCIsIGZhbGxpbmcgYmFjayB0byB1bm1vZGlmaWVkIHNkcFwiKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIHNkcDogbXVuZ2VkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHNkLnNkcCA9IG9yaWdpbmFsU2RwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyB0aGlzIGVycm9yIGNhbm5vdCBhbHdheXMgYmUgY2F1Z2h0LlxuICAgICAgICAvLyBJZiB0aGUgbG9jYWwgZGVzY3JpcHRpb24gaGFzIGEgc2V0Q29kZWNQcmVmZXJlbmNlcyBlcnJvciwgdGhpcyBlcnJvciB3aWxsIGJlIHVuY2F1Z2h0XG4gICAgICAgIGxldCBtc2cgPSAndW5rbm93biBlcnJvcic7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtc2cgPSBlLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbXNnID0gZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZHMgPSB7XG4gICAgICAgICAgZXJyb3I6IG1zZyxcbiAgICAgICAgICBzZHA6IHNkLnNkcFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXJlbW90ZSAmJiB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgZmllbGRzLnJlbW90ZVNkcCA9IHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZmllbGRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBzdGVyZW9NaWRzLCBuYWNrTWlkcykge1xuICAvLyBmb3VuZCBvcHVzIGNvZGVjIHRvIGFkZCBuYWNrIGZiXG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIC8vIGFkZCBuYWNrIHJ0Y3BmYiBpZiBub3QgZXhpc3RcbiAgaWYgKG9wdXNQYXlsb2FkID4gMCkge1xuICAgIGlmICghbWVkaWEucnRjcEZiKSB7XG4gICAgICBtZWRpYS5ydGNwRmIgPSBbXTtcbiAgICB9XG4gICAgaWYgKG5hY2tNaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkgJiYgIW1lZGlhLnJ0Y3BGYi5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgcGF5bG9hZDogb3B1c1BheWxvYWQsXG4gICAgICAgIHR5cGU6ICduYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVyZW9NaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkpIHtcbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCdzdGVyZW89MScpKSB7XG4gICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnO3N0ZXJlbz0xJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDKG1lZGlhKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgY29kZWMgPSAoX2IgPSAoX2EgPSBtZWRpYS5ydHBbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlYykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghaXNTVkNDb2RlYyhjb2RlYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1heElEID0gMDtcbiAgY29uc3QgZGRGb3VuZCA9IChfYyA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNvbWUoZXh0ID0+IHtcbiAgICBpZiAoZXh0LnVyaSA9PT0gZGRFeHRlbnNpb25VUkkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXh0LnZhbHVlID4gbWF4SUQpIHtcbiAgICAgIG1heElEID0gZXh0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBpZiAoIWRkRm91bmQpIHtcbiAgICAoX2QgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wdXNoKHtcbiAgICAgIHZhbHVlOiBtYXhJRCArIDEsXG4gICAgICB1cmk6IGRkRXh0ZW5zaW9uVVJJXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIob2ZmZXIpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzdGVyZW9NaWRzID0gW107XG4gIGNvbnN0IG5hY2tNaWRzID0gW107XG4gIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKChfYSA9IG9mZmVyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKChfYSA9IG1lZGlhLnJ0Y3BGYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZmIgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgICBuYWNrTWlkcy5wdXNoKG1lZGlhLm1pZCk7XG4gICAgICB9XG4gICAgICBtZWRpYS5mbXRwLnNvbWUoZm10cCA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKGZtdHAuY29uZmlnLmluY2x1ZGVzKCdzcHJvcC1zdGVyZW89MScpKSB7XG4gICAgICAgICAgICBzdGVyZW9NaWRzLnB1c2gobWVkaWEubWlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGVyZW9NaWRzLFxuICAgIG5hY2tNaWRzXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRWaWRlb0NvZGVjID0gJ3ZwOCc7XG5jb25zdCBwdWJsaXNoRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXVkaW9CaXRyYXRlOiBBdWRpb1ByZXNldHMubXVzaWMubWF4Qml0cmF0ZSxcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcbiAgZHR4OiB0cnVlLFxuICByZWQ6IHRydWUsXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcbiAgc2ltdWxjYXN0OiB0cnVlLFxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcbiAgdmlkZW9Db2RlYzogZGVmYXVsdFZpZGVvQ29kZWMsXG4gIGJhY2t1cENvZGVjOiB0cnVlXG59O1xuY29uc3QgYXVkaW9EZWZhdWx0cyA9IHtcbiAgYXV0b0dhaW5Db250cm9sOiB0cnVlLFxuICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICBub2lzZVN1cHByZXNzaW9uOiB0cnVlXG59O1xuY29uc3QgdmlkZW9EZWZhdWx0cyA9IHtcbiAgcmVzb2x1dGlvbjogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvblxufTtcbmNvbnN0IHJvb21PcHRpb25EZWZhdWx0cyA9IHtcbiAgYWRhcHRpdmVTdHJlYW06IGZhbHNlLFxuICBkeW5hY2FzdDogZmFsc2UsXG4gIHN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2g6IHRydWUsXG4gIHJlY29ubmVjdFBvbGljeTogbmV3IERlZmF1bHRSZWNvbm5lY3RQb2xpY3koKSxcbiAgZGlzY29ubmVjdE9uUGFnZUxlYXZlOiB0cnVlLFxuICBleHBXZWJBdWRpb01peDogZmFsc2Vcbn07XG5jb25zdCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1MDAwLFxuICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxufTtcblxudmFyIFBDVHJhbnNwb3J0U3RhdGU7XG4oZnVuY3Rpb24gKFBDVHJhbnNwb3J0U3RhdGUpIHtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiTkVXXCJdID0gMF0gPSBcIk5FV1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMl0gPSBcIkNPTk5FQ1RFRFwiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJGQUlMRURcIl0gPSAzXSA9IFwiRkFJTEVEXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNMT1NJTkdcIl0gPSA0XSA9IFwiQ0xPU0lOR1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TRURcIl0gPSA1XSA9IFwiQ0xPU0VEXCI7XG59KShQQ1RyYW5zcG9ydFN0YXRlIHx8IChQQ1RyYW5zcG9ydFN0YXRlID0ge30pKTtcbmNsYXNzIFBDVHJhbnNwb3J0TWFuYWdlciB7XG4gIGdldCBuZWVkc1B1Ymxpc2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgbmVlZHNTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJ0Y0NvbmZpZywgc3Vic2NyaWJlclByaW1hcnksIGxvZ2dlck9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlcyA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzLm1hcCh0ciA9PiB0ci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnZmFpbGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVElORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ25ldycpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicGMgc3RhdGUgY2hhbmdlOiBmcm9tIFwiLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3ByZXZpb3VzU3RhdGVdLCBcIiB0byBcIikuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbdGhpcy5zdGF0ZV0pLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAoX2EgPSB0aGlzLm9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuc3RhdGUsIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpLCB0aGlzLnN1YnNjcmliZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QQ01hbmFnZXIpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9ICFzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHN1YnNjcmliZXJQcmltYXJ5O1xuICAgIGNvbnN0IGdvb2dDb25zdHJhaW50cyA9IHtcbiAgICAgIG9wdGlvbmFsOiBbe1xuICAgICAgICBnb29nRHNjcDogdHJ1ZVxuICAgICAgfV1cbiAgICB9O1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgZ29vZ0NvbnN0cmFpbnRzLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICB9O1xuICAgIC8vIGluIHN1YnNjcmliZXIgcHJpbWFyeSBtb2RlLCBzZXJ2ZXIgc2lkZSBvcGVucyBzdWIgZGF0YSBjaGFubmVscy5cbiAgICB0aGlzLnN1YnNjcmliZXIub25EYXRhQ2hhbm5lbCA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uVHJhY2sgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHRoaXMucHVibGlzaGVyLm9uT2ZmZXIgPSBvZmZlciA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uUHVibGlzaGVyT2ZmZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIG9mZmVyKTtcbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcbiAgICB0aGlzLmNvbm5lY3Rpb25Mb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gIH1cbiAgcmVxdWlyZVB1Ymxpc2hlcigpIHtcbiAgICBsZXQgcmVxdWlyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkID0gcmVxdWlyZTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gIH1cbiAgcmVxdWlyZVN1YnNjcmliZXIoKSB7XG4gICAgbGV0IHJlcXVpcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuICBjcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVBbmRTZW5kT2ZmZXIob3B0aW9ucyk7XG4gIH1cbiAgc2V0UHVibGlzaGVyQW5zd2VyKHNkKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucHVibGlzaGVyICYmIHRoaXMucHVibGlzaGVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpICE9PSAnY2xvc2VkJykge1xuICAgICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgICAgZm9yIChjb25zdCBzZW5kZXIgb2YgcHVibGlzaGVyLmdldFNlbmRlcnMoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaGF2ZSByZW1vdmVUcmFjayB5ZXQuXG4gICAgICAgICAgICBpZiAocHVibGlzaGVyLmNhblJlbW92ZVRyYWNrKCkpIHtcbiAgICAgICAgICAgICAgcHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHJlbW92ZVRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5wdWJsaXNoZXIuY2xvc2UoKSwgdGhpcy5zdWJzY3JpYmVyLmNsb3NlKCldKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICB9KTtcbiAgfVxuICB0cmlnZ2VySWNlUmVzdGFydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgICAgLy8gb25seSByZXN0YXJ0IHB1Ymxpc2hlciBpZiBpdCdzIG5lZWRlZFxuICAgICAgaWYgKHRoaXMubmVlZHNQdWJsaXNoZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIoe1xuICAgICAgICAgIGljZVJlc3RhcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCB0aGlzLnN1YnNjcmliZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIG9mZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGUsXG4gICAgICAgIHNkcDogc2Quc2RwLFxuICAgICAgICBzaWduYWxpbmdTdGF0ZTogdGhpcy5zdWJzY3JpYmVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH0pKTtcbiAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICAvLyBhbnN3ZXIgdGhlIG9mZmVyXG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnN1YnNjcmliZXIuY3JlYXRlQW5kU2V0QW5zd2VyKCk7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnLCBpY2VSZXN0YXJ0KSB7XG4gICAgdGhpcy5wdWJsaXNoZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIHRoaXMuc3Vic2NyaWJlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgaWYgKGljZVJlc3RhcnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RlZCcgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKChfYSA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKHRyYW5zcG9ydCA9PiB0aGlzLmVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCh0cmFuc3BvcnQsIGFib3J0Q29udHJvbGxlciwgdGltZW91dCkpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmVnb3RpYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiB0aW1lZCBvdXQnKTtcbiAgICAgICAgfSwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiBhYm9ydGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCwgKCkgPT4ge1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZShlID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhY2sodHJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIGNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHJlcXVpcmVkIHRyYW5zcG9ydCdzIGFkZHJlc3MgaWYgbm8gZXhwbGljaXQgdGFyZ2V0IGlzIHNwZWNpZmllZFxuICAgKi9cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcyh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzWzBdLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgfVxuICBnZXQgcmVxdWlyZWRUcmFuc3BvcnRzKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSBbXTtcbiAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCkge1xuICAgICAgdHJhbnNwb3J0cy5wdXNoKHRoaXMucHVibGlzaGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5zdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHBjVHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZSA9IHBjVHJhbnNwb3J0LmdldENvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IHRyYW5zcG9ydCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJywgMyAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkICovKSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBhYm9ydEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJykpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApOyAvLyBGSVhNRSB3ZSBzaG91bGRuJ3QgcmVseSBvbiBgc2xlZXBgIGluIHRoZSBjb25uZWN0aW9uIHBhdGhzLCBhcyBpdCBpbnZva2VzIGBzZXRUaW1lb3V0YCB3aGljaCBjYW4gYmUgZHJhc3RpY2FsbHkgdGhyb3R0bGVkIGJ5IGJyb3dzZXIgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQnLCAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBsb3NzeURhdGFDaGFubmVsID0gJ19sb3NzeSc7XG5jb25zdCByZWxpYWJsZURhdGFDaGFubmVsID0gJ19yZWxpYWJsZSc7XG5jb25zdCBtaW5SZWNvbm5lY3RXYWl0ID0gMiAqIDEwMDA7XG5jb25zdCBsZWF2ZVJlY29ubmVjdCA9ICdsZWF2ZS1yZWNvbm5lY3QnO1xudmFyIFBDU3RhdGU7XG4oZnVuY3Rpb24gKFBDU3RhdGUpIHtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiTmV3XCJdID0gMF0gPSBcIk5ld1wiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSAxXSA9IFwiQ29ubmVjdGVkXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IDJdID0gXCJEaXNjb25uZWN0ZWRcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gM10gPSBcIlJlY29ubmVjdGluZ1wiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJDbG9zZWRcIl0gPSA0XSA9IFwiQ2xvc2VkXCI7XG59KShQQ1N0YXRlIHx8IChQQ1N0YXRlID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFJUQ0VuZ2luZSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IGlzQ2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ0Y0NvbmZpZyA9IHt9O1xuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGZhbHNlO1xuICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuTmV3O1xuICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVycyA9IHt9O1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSAwO1xuICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgIC8qKiBrZWVwcyB0cmFjayBvZiBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaGFzIGJlZW4gdHJpZWQgKi9cbiAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDA7XG4gICAgLyoqIHNwZWNpZmllcyBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byByZXRyeSAqL1xuICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gMTtcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwgPSBfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNoYW5uZWxcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsLmxhYmVsID09PSBsb3NzeURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJvbiBkYXRhIGNoYW5uZWwgXCIuY29uY2F0KGNoYW5uZWwuaWQsIFwiLCBcIikuY29uY2F0KGNoYW5uZWwubGFiZWwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBjaGFubmVsLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2UgPSBtZXNzYWdlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYiwgX2M7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzcGVjdCBpbmNvbWluZyBkYXRhIG1lc3NhZ2Ugb3JkZXIgYnkgcHJvY2Vzc2luZyBtZXNzYWdlIGV2ZW50cyBvbmUgYWZ0ZXIgdGhlIG90aGVyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmRhdGFQcm9jZXNzTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBkZWNvZGVcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICBidWZmZXIgPSB5aWVsZCBtZXNzYWdlLmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcigndW5zdXBwb3J0ZWQgZGF0YSB0eXBlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRwID0gRGF0YVBhY2tldC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICBpZiAoKChfYiA9IGRwLnZhbHVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FzZSkgPT09ICdzcGVha2VyJykge1xuICAgICAgICAgIC8vIGRpc3BhdGNoIHNwZWFrZXIgdXBkYXRlc1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgZHAudmFsdWUudmFsdWUuc3BlYWtlcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoX2MgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhc2UpID09PSAndXNlcicpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCBkcC52YWx1ZS52YWx1ZSwgZHAua2luZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlRGF0YUVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyAnbG9zc3knIDogJ3JlbGlhYmxlJztcbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVycm9yRXZlbnQgJiYgZXZlbnQuZXJyb3IpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0gPSBldmVudC5lcnJvcjtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQsIFwiOiBcIikuY29uY2F0KGV2ZW50Lm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIlVua25vd24gRGF0YUNoYW5uZWwgZXJyb3Igb24gXCIuY29uY2F0KGNoYW5uZWxLaW5kKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdyA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gRGF0YVBhY2tldF9LaW5kLkxPU1NZIDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFO1xuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoY2hhbm5lbEtpbmQpO1xuICAgIH07XG4gICAgLy8gd2Vic29ja2V0IHJlY29ubmVjdCBiZWhhdmlvci4gaWYgd2Vic29ja2V0IGlzIGludGVycnVwdGVkLCBhbmQgdGhlIFBlZXJDb25uZWN0aW9uXG4gICAgLy8gY29udGludWVzIHRvIHdvcmssIHdlIGNhbiByZWNvbm5lY3QgdG8gd2Vic29ja2V0IHRvIGNvbnRpbnVlIHRoZSBzZXNzaW9uXG4gICAgLy8gYWZ0ZXIgYSBudW1iZXIgb2YgcmV0cmllcywgd2UnbGwgY2xvc2UgYW5kIGdpdmUgdXAgcGVybWFuZW50bHlcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QgPSAoY29ubmVjdGlvbiwgZGlzY29ubmVjdFJlYXNvbikgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLndhcm4oXCJcIi5jb25jYXQoY29ubmVjdGlvbiwgXCIgZGlzY29ubmVjdGVkXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgLy8gb25seSByZXNldCBzdGFydCB0aW1lIG9uIHRoZSBmaXJzdCB0cnlcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXNjb25uZWN0ID0gZHVyYXRpb24gPT4ge1xuICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlY292ZXIgY29ubmVjdGlvbiBhZnRlciBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgXCIgYXR0ZW1wdHMsIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXMuIGdpdmluZyB1cFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0O1xuICAgICAgbGV0IGRlbGF5ID0gdGhpcy5nZXROZXh0UmV0cnlEZWxheSh7XG4gICAgICAgIGVsYXBzZWRNczogZHVyYXRpb24sXG4gICAgICAgIHJldHJ5Q291bnQ6IHRoaXMucmVjb25uZWN0QXR0ZW1wdHNcbiAgICAgIH0pO1xuICAgICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIGRpc2Nvbm5lY3QoZHVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY29ubmVjdGlvbiA9PT0gbGVhdmVSZWNvbm5lY3QpIHtcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJyZWNvbm5lY3RpbmcgaW4gXCIuY29uY2F0KGRlbGF5LCBcIm1zXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLnRva2VuICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gdG9rZW4gbWF5IGhhdmUgYmVlbiByZWZyZXNoZWQsIHdlIGRvIG5vdCB3YW50IHRvIHJlY3JlYXRlIHRoZSByZWdpb25VcmxQcm92aWRlclxuICAgICAgICAvLyBzaW5jZSB0aGUgY3VycmVudCBlbmdpbmUgbWF5IGhhdmUgaW5oZXJpdGVkIGEgcmVnaW9uYWwgdXJsXG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlVG9rZW4odGhpcy50b2tlbik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0ZW1wdFJlY29ubmVjdChkaXNjb25uZWN0UmVhc29uKSwgZGVsYXkpO1xuICAgIH07XG4gICAgdGhpcy53YWl0Rm9yUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25SZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzID0ga2luZCA9PiB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIHN0YXR1cyAhPT0gdGhpcy5kY0J1ZmZlclN0YXR1cy5nZXQoa2luZCkpIHtcbiAgICAgICAgdGhpcy5kY0J1ZmZlclN0YXR1cy5zZXQoa2luZCwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaXNCdWZmZXJTdGF0dXNMb3cgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICBpZiAoZGMpIHtcbiAgICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lID0gKCkgPT4ge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgZW5naW5lIGlzIGN1cnJlbnRseSByZWNvbm5lY3RpbmcsIGF0dGVtcHQgYSByZWNvbm5lY3QgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGJyb3dzZXIgc3RhdGUgaGFzIGNoYW5nZWQgdG8gJ29uTGluZSdcbiAgICAgIGlmICh0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IG9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuRW5naW5lKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgIH07XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KHVuZGVmaW5lZCwgdGhpcy5sb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLmNsaWVudC5zaWduYWxMYXRlbmN5ID0gdGhpcy5vcHRpb25zLmV4cFNpZ25hbExhdGVuY3k7XG4gICAgdGhpcy5yZWNvbm5lY3RQb2xpY3kgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0UG9saWN5O1xuICAgIHRoaXMucmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmRhdGFQcm9jZXNzTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMgPSBuZXcgTWFwKFtbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSwgW0RhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZV1dKTtcbiAgICB0aGlzLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdXBkYXRlcyA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHVwZGF0ZXMpO1xuICAgIHRoaXMuY2xpZW50Lm9uQ29ubmVjdGlvblF1YWxpdHkgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uUm9vbVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gcmVzcCA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3RyZWFtU3RhdGVVcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiAoX2IgPSAoX2EgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lLFxuICAgICAgcm9vbVNpZDogKF9kID0gKF9jID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb29tKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2lkLFxuICAgICAgaWRlbnRpdHk6IChfZiA9IChfZSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5pZGVudGl0eVxuICAgIH07XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuc2lnbmFsT3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IG9wdHMubWF4UmV0cmllcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5jbGllbnQuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlID0gam9pblJlc3BvbnNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgb2ZmZXJcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJQcmltYXJ5KSB7XG4gICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24gPSBqb2luUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIGpvaW5SZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICBpZiAoZS5yZWFzb24gPT09IDEgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlICovKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiQ291bGRuJ3QgY29ubmVjdCB0byBzZXJ2ZXIsIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMuam9pbkF0dGVtcHRzLCBcIiBvZiBcIikuY29uY2F0KHRoaXMubWF4Sm9pbkF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5DbG9zaW5nKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cFBlZXJDb25uZWN0aW9ucygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZGNDbGVhbnVwID0gZGMgPT4ge1xuICAgICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICAgIGRjLmNsb3NlKCk7XG4gICAgICAgIGRjLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zaW5nID0gbnVsbDtcbiAgICAgICAgZGMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGRjLm9ub3BlbiA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDU3ViKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlREMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG4gICAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvc3N5RENTdWIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlREMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cENsaWVudCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlc2V0Q2FsbGJhY2tzKCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkVHJhY2socmVxKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ2EgdHJhY2sgd2l0aCB0aGUgc2FtZSBJRCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHVibGljYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXTtcbiAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInKSk7XG4gICAgICB9LCAxMDAwMCk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSA9IHtcbiAgICAgICAgcmVzb2x2ZTogaW5mbyA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2FuY2VsbGVkIHB1YmxpY2F0aW9uIGJ5IGNhbGxpbmcgdW5wdWJsaXNoJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2VuZGVyIGZyb20gUGVlckNvbm5lY3Rpb24sIHJldHVybmluZyB0cnVlIGlmIGl0IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseVxuICAgKiBhbmQgYSBuZWdvdGlhdGlvbiBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHNlbmRlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlci50cmFjayAmJiB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlamVjdFxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBjTWFuYWdlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHJlbW92ZSB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlTXV0ZVN0YXR1cyh0cmFja1NpZCwgbXV0ZWQpIHtcbiAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XG4gIH1cbiAgZ2V0IGRhdGFTdWJzY3JpYmVyUmVhZHlTdGF0ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmVsaWFibGVEQ1N1YikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGU7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc2V0UmVnaW9uVXJsUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cbiAgY29uZmlndXJlKGpvaW5SZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gYWxyZWFkeSBjb25maWd1cmVkXG4gICAgICBpZiAodGhpcy5wY01hbmFnZXIgJiYgdGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLk5FVykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gKF9hID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkO1xuICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihqb2luUmVzcG9uc2UpO1xuICAgICAgdGhpcy5wY01hbmFnZXIgPSBuZXcgUENUcmFuc3BvcnRNYW5hZ2VyKHJ0Y0NvbmZpZywgam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5LCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlRyYW5zcG9ydHNDcmVhdGVkLCB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIsIHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wY01hbmFnZXIub25QdWJsaXNoZXJPZmZlciA9IG9mZmVyID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc2VuZE9mZmVyKG9mZmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkRhdGFDaGFubmVsID0gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbDtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uU3RhdGVDaGFuZ2UgPSAoY29ubmVjdGlvblN0YXRlLCBwdWJsaXNoZXJTdGF0ZSwgc3Vic2NyaWJlclN0YXRlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJpbWFyeSBQQyBzdGF0ZSBjaGFuZ2VkIFwiLmNvbmNhdChjb25uZWN0aW9uU3RhdGUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSB0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuTmV3O1xuICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XG4gICAgICAgICAgLy8gb24gU2FmYXJpLCBQZWVyQ29ubmVjdGlvbiB3aWxsIHN3aXRjaCB0byAnZGlzY29ubmVjdGVkJyBkdXJpbmcgcmVuZWdvdGlhdGlvblxuICAgICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncGVlcmNvbm5lY3Rpb24gZmFpbGVkJywgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJyA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRCA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgZXYudHJhY2ssIGV2LnN0cmVhbXNbMF0sIGV2LnJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgIH0pO1xuICB9XG4gIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSBzZCA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGVcbiAgICAgIH0pKTtcbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGNhbmRpZGF0ZSBvbiB0cmlja2xlXG4gICAgdGhpcy5jbGllbnQub25Ucmlja2xlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLnRyYWNlKCdnb3QgSUNFIGNhbmRpZGF0ZSBmcm9tIHBlZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNlcnZlciBjcmVhdGVzIGFuIG9mZmVyIGZvciB0aGUgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25PZmZlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcmVzID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IChfYSA9IHJlcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZFxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIm1pc3NpbmcgdHJhY2sgcmVzb2x2ZXIgZm9yIFwiLmNvbmNhdChyZXMuY2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgY2lkOiByZXMuY2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXNvbHZlXG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICByZXNvbHZlKHJlcy50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHJlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uVG9rZW5SZWZyZXNoID0gdG9rZW4gPT4ge1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25SZW1vdGVNdXRlQ2hhbmdlZCA9ICh0cmFja1NpZCwgbXV0ZWQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdzaWduYWwnLCBSZWNvbm5lY3RSZWFzb24uUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxlYXZlID0gbGVhdmUgPT4ge1xuICAgICAgaWYgKGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5jYW5SZWNvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbmV4dCBhdHRlbXB0XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUucmVhc29uKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ2NsaWVudCBsZWF2ZSByZXF1ZXN0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJlYXNvbjogbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvblxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cbiAgbWFrZVJUQ0NvbmZpZ3VyYXRpb24oc2VydmVyUmVzcG9uc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcnRjQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ydGNDb25maWcpO1xuICAgIGlmICgoX2EgPSB0aGlzLnNpZ25hbE9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lMmVlRW5hYmxlZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ0UyRUUgLSBzZXR0aW5nIHVwIHRyYW5zcG9ydHMgd2l0aCBpbnNlcnRhYmxlIHN0cmVhbXMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gIHRoaXMgbWFrZXMgc3VyZSB0aGF0IG5vIGRhdGEgaXMgc2VudCBiZWZvcmUgdGhlIHRyYW5zZm9ybXMgYXJlIHJlYWR5XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBydGNDb25maWcuZW5jb2RlZEluc2VydGFibGVTdHJlYW1zID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIElDRSBzZXJ2ZXJzIGJlZm9yZSBjcmVhdGluZyBQZWVyQ29ubmVjdGlvblxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzICYmICFydGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgcnRjSWNlU2VydmVycyA9IFtdO1xuICAgICAgc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycy5mb3JFYWNoKGljZVNlcnZlciA9PiB7XG4gICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlciA9IHtcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJsc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKSBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIuY3JlZGVudGlhbCkge1xuICAgICAgICAgIHJ0Y0ljZVNlcnZlci5jcmVkZW50aWFsID0gaWNlU2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcnRjSWNlU2VydmVycy5wdXNoKHJ0Y0ljZVNlcnZlcik7XG4gICAgICB9KTtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcbiAgICB9XG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24gJiYgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbi5mb3JjZVJlbGF5ID09PSBDbGllbnRDb25maWdTZXR0aW5nLkVOQUJMRUQpIHtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLnNkcFNlbWFudGljcyA9ICd1bmlmaWVkLXBsYW4nO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuY29udGludWFsR2F0aGVyaW5nUG9saWN5ID0gJ2dhdGhlcl9jb250aW51YWxseSc7XG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbHMoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjbGVhciBvbGQgZGF0YSBjaGFubmVsIGNhbGxiYWNrcyBpZiByZWNyZWF0ZVxuICAgIGlmICh0aGlzLmxvc3N5REMpIHtcbiAgICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XG4gICAgICAvLyB3aWxsIGRyb3Agb2xkZXIgcGFja2V0cyB0aGF0IGFycml2ZVxuICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwXG4gICAgfSk7XG4gICAgdGhpcy5yZWxpYWJsZURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwocmVsaWFibGVEYXRhQ2hhbm5lbCwge1xuICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIGFsc28gaGFuZGxlIG1lc3NhZ2VzIG92ZXIgdGhlIHB1YiBjaGFubmVsLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAvLyBoYW5kbGUgZGF0YWNoYW5uZWwgZXJyb3JzXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIC8vIHNldCB1cCBkYyBidWZmZXIgdGhyZXNob2xkLCBzZXQgdG8gNjRrQiAob3RoZXJ3aXNlIDAgYnkgZGVmYXVsdClcbiAgICB0aGlzLmxvc3N5REMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICB0aGlzLnJlbGlhYmxlREMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICAvLyBoYW5kbGUgYnVmZmVyIGFtb3VudCBsb3cgZXZlbnRzXG4gICAgdGhpcy5sb3NzeURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgfVxuICBzZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwga2luZCwgdmlkZW9Db2RlYykge1xuICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FwID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICBpZiAoIWNhcCkgcmV0dXJuO1xuICAgIHRoaXMubG9nLmRlYnVnKCdnZXQgc2VuZGVyIGNhcGFiaWxpdGllcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgY2FwXG4gICAgfSkpO1xuICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICBjb25zdCBwYXJ0aWFsTWF0Y2hlZCA9IFtdO1xuICAgIGNvbnN0IHVubWF0Y2hlZCA9IFtdO1xuICAgIGNhcC5jb2RlY3MuZm9yRWFjaChjID0+IHtcbiAgICAgIGNvbnN0IGNvZGVjID0gYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGNvZGVjID09PSAnYXVkaW8vb3B1cycpIHtcbiAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaGVzVmlkZW9Db2RlYyA9IGNvZGVjID09PSBcInZpZGVvL1wiLmNvbmNhdCh2aWRlb0NvZGVjKTtcbiAgICAgIGlmICghbWF0Y2hlc1ZpZGVvQ29kZWMpIHtcbiAgICAgICAgdW5tYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGZvciBoMjY0IGNvZGVjcyB0aGF0IGhhdmUgc2RwRm10cExpbmUgYXZhaWxhYmxlLCB1c2Ugb25seSBpZiB0aGVcbiAgICAgIC8vIHByb2ZpbGUtbGV2ZWwtaWQgaXMgNDJlMDFmIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHlcbiAgICAgIGlmICh2aWRlb0NvZGVjID09PSAnaDI2NCcpIHtcbiAgICAgICAgaWYgKGMuc2RwRm10cExpbmUgJiYgYy5zZHBGbXRwTGluZS5pbmNsdWRlcygncHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKSkge1xuICAgICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0aWFsTWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICB9KTtcbiAgICBpZiAoc3VwcG9ydHNTZXRDb2RlY1ByZWZlcmVuY2VzKHRyYW5zY2VpdmVyKSkge1xuICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhtYXRjaGVkLmNvbmNhdChwYXJ0aWFsTWF0Y2hlZCwgdW5tYXRjaGVkKSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0geWllbGQgdGhpcy5jcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0geWllbGQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ0Nhbm5vdCBzdHJlYW0gb24gdGhpcyBkZXZpY2UnKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgIGlmICh0cmFjay5tZWRpYVN0cmVhbSkge1xuICAgICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgIHN0cmVhbXNcbiAgICAgIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgICAgIHRoaXMuc2V0UHJlZmVycmVkQ29kZWModHJhbnNjZWl2ZXIsIHRyYWNrLmtpbmQsIG9wdHMudmlkZW9Db2RlYyk7XG4gICAgICAgIHRyYWNrLmNvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5J1xuICAgICAgfTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICBpZiAoIW9wdHMudmlkZW9Db2RlYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFByZWZlcnJlZENvZGVjKHRyYW5zY2VpdmVyLCB0cmFjay5raW5kLCBvcHRzLnZpZGVvQ29kZWMpO1xuICAgICAgdHJhY2suc2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIob3B0cy52aWRlb0NvZGVjLCB0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVSVENSdHBTZW5kZXIodHJhY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKTtcbiAgICB9KTtcbiAgfVxuICBhdHRlbXB0UmVjb25uZWN0KHJlYXNvbikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZ3VhcmQgZm9yIGF0dGVtcHRpbmcgcmVjb25uZWN0aW9uIG11bHRpcGxlIHRpbWVzIHdoaWxlIG9uZSBhdHRlbXB0IGlzIHN0aWxsIG5vdCBmaW5pc2hlZFxuICAgICAgaWYgKHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2FscmVhZHkgYXR0ZW1wdGluZyByZWNvbm5lY3QsIHJldHVybmluZyBlYXJseScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gdGhpcy5jbGllbnRDb25maWd1cmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdW1lQ29ubmVjdGlvbikgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRElTQUJMRUQgfHxcbiAgICAgIC8vIHNpZ25hbGluZyBzdGF0ZSBjb3VsZCBjaGFuZ2UgdG8gY2xvc2VkIGR1ZSB0byBoYXJkd2FyZSBzbGVlcFxuICAgICAgLy8gdGhvc2UgY29ubmVjdGlvbnMgY2Fubm90IGJlIHJlc3VtZWRcbiAgICAgICgoX2MgPSAoX2IgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmN1cnJlbnRTdGF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogUENUcmFuc3BvcnRTdGF0ZS5ORVcpID09PSBQQ1RyYW5zcG9ydFN0YXRlLk5FVykge1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArPSAxO1xuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5yZWNvdmVyYWJsZSBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgLy8gdW5yZWNvdmVyYWJsZVxuICAgICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIShlIGluc3RhbmNlb2YgU2lnbmFsUmVjb25uZWN0RXJyb3IpKSB7XG4gICAgICAgICAgLy8gY2Fubm90IHJlc3VtZVxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdyZWNvbm5lY3QnLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbyhcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0LCBcIm1zLiBnaXZpbmcgdXBcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXROZXh0UmV0cnlEZWxheShjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29ubmVjdFBvbGljeS5uZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBlcnJvciBpbiB1c2VyIGNvZGUgd2l0aCBwcm92aWRlZCByZWNvbm5lY3QgcG9saWN5LCBzdG9wIHJlY29ubmVjdGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3RhcnRDb25uZWN0aW9uKHJlZ2lvblVybCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwicmVjb25uZWN0aW5nLCBhdHRlbXB0OiBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBDbGllbnQoKTtcbiAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2lnbmFsT3B0cykge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIGNvbm5lY3Rpb24gcmVzdGFydCwgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBwcmVzZW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbiBjYXNlIGEgcmVnaW9uVXJsIGlzIHBhc3NlZCwgdGhlIHJlZ2lvbiBVUkwgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgIGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuam9pbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSAwIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xuICAgICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuICAgICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxuICAgICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0QXR0ZW1wdHMoKTtcbiAgICAgICAgLy8gcmVjb25uZWN0IHN1Y2Nlc3NcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRlZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uVXJsID0geWllbGQgKF9iID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XG4gICAgICAgIGlmIChuZXh0UmVnaW9uVXJsKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbihuZXh0UmVnaW9uVXJsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gbW9yZSByZWdpb25zIHRvIHRyeSAob3Igd2UncmUgbm90IG9uIGNsb3VkKVxuICAgICAgICAgIChfYyA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVDb25uZWN0aW9uKHJlYXNvbikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGFuZCBzdWJzY3JpYmVyIGNvbm5lY3Rpb25zIHVuc2V0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKFwicmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24sIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtaW5nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jbGllbnQucmVjb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnBhcnRpY2lwYW50U2lkLCByZWFzb24pO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xuICAgICAgICAgIHRoaXMucGNNYW5hZ2VyLnVwZGF0ZUNvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvci5tZXNzYWdlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IDQgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCAqLykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgICAvLyAoZm9yIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0Njg4KVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlbGlhYmxlREMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nICYmIHRoaXMucmVsaWFibGVEQy5pZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgICAgLy8gcmVzdW1lIHN1Y2Nlc3NcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWVkKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JQQ1JlY29ubmVjdGVkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBwZWVyIGNvbm5lY3Rpb24gdG8gcmVjb25uZWN0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHNsZWVwKG1pblJlY29ubmVjdFdhaXQpOyAvLyBGSVhNRSBzZXRUaW1lb3V0IGFnYWluIG5vdCBpZGVhbCBmb3IgYSBjb25uZWN0aW9uIGNyaXRpY2FsIHBhdGhcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCBhIGBmYWlsZWRgIHN0YXRlIGhlcmUgZm9yIHRoZSBQQz9cbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sIFwiLmNvbmNhdChlLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IHBhY2tldC50b0JpbmFyeSgpO1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICBkYy5zZW5kKG1zZyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhraW5kKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmQpIHtcbiAgICBsZXQgc3Vic2NyaWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBzdWJzY3JpYmVyID8gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlciA6IHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlcjtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSBzdWJzY3JpYmVyID8gJ1N1YnNjcmliZXInIDogJ1B1Ymxpc2hlcic7XG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24gbm90IHNldFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1YnNjcmliZXIgJiYgIXRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5pc0lDRUNvbm5lY3RlZCAmJiB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkgIT09ICdjaGVja2luZycpIHtcbiAgICAgICAgLy8gc3RhcnQgbmVnb3RpYXRpb25cbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKTtcbiAgICAgIGlmICgodGFyZ2V0Q2hhbm5lbCA9PT0gbnVsbCB8fCB0YXJnZXRDaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDaGFubmVsLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gd2FpdCB1bnRpbCBJQ0UgY29ubmVjdGVkXG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHdoaWxlIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJiAoKF9hID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uLCBzdGF0ZTogXCIpLmNvbmNhdCh0cmFuc3BvcnQuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkpKTtcbiAgICB9KTtcbiAgfVxuICBlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICB2ZXJpZnlUcmFuc3BvcnQoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwcmltYXJ5IGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgc2lnbmFsIGlzIGNvbm5lY3RlZFxuICAgIGlmICghdGhpcy5jbGllbnQud3MgfHwgdGhpcy5jbGllbnQud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIG5lZ290aWF0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gb2JzZXJ2ZSBzaWduYWwgc3RhdGVcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICByZWplY3QobmV3IE5lZ290aWF0aW9uRXJyb3IoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBjTWFuYWdlci5yZXF1aXJlUHVibGlzaGVyKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdlbmdpbmUgZGlzY29ubmVjdGVkIHdoaWxlIG5lZ290aWF0aW9uIHdhcyBvbmdvaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgIHJlamVjdCgnY2Fubm90IG5lZ290aWF0ZSBvbiBjbG9zZWQgZW5naW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgcnRwVHlwZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ0cE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBydHBUeXBlcy5mb3JFYWNoKHJ0cCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IHJ0cC5jb2RlYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGlzVmlkZW9Db2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgICAgcnRwTWFwLnNldChydHAucGF5bG9hZCwgY29kZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIubmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOZWdvdGlhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ25lZ290aWF0aW9uJywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1Yikge1xuICAgIGlmICghc3ViKSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5REM7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlREM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQ1N1YjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N5bmMgc3RhdGUgY2Fubm90IGJlIHNlbnQgd2l0aG91dCBwZWVyIGNvbm5lY3Rpb24gc2V0dXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Fuc3dlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzT2ZmZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XG4gICAgLyogMS4gYXV0b3N1YnNjcmliZSBvbiwgc28gc3Vic2NyaWJlZCB0cmFja3MgPSBhbGwgdHJhY2tzIC0gdW5zdWIgdHJhY2tzLFxuICAgICAgICAgIGluIHRoaXMgY2FzZSwgd2Ugc2VuZCB1bnN1YiB0cmFja3MsIHNvIHNlcnZlciBhZGQgYWxsIHRyYWNrcyB0byB0aGlzXG4gICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxuICAgICAgIDIuIGF1dG9zdWJzY3JpYmUgb2ZmLCB3ZSBzZW5kIHN1YnNjcmliZWQgdHJhY2tzLlxuICAgICovXG4gICAgY29uc3QgYXV0b1N1YnNjcmliZSA9IChfYiA9IChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgaWYgKHRyYWNrLmlzRGVzaXJlZCAhPT0gYXV0b1N1YnNjcmliZSkge1xuICAgICAgICB0cmFja1NpZHMucHVzaCh0cmFjay50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQuc2VuZFN5bmNTdGF0ZShuZXcgU3luY1N0YXRlKHtcbiAgICAgIGFuc3dlcjogcHJldmlvdXNBbnN3ZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c0Fuc3dlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzQW5zd2VyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgb2ZmZXI6IHByZXZpb3VzT2ZmZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c09mZmVyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNPZmZlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIHRyYWNrU2lkcyxcbiAgICAgICAgc3Vic2NyaWJlOiAhYXV0b1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtdXG4gICAgICB9KSxcbiAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcbiAgICAgIGRhdGFDaGFubmVsczogdGhpcy5kYXRhQ2hhbm5lbHNJbmZvKClcbiAgICB9KSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGZhaWxOZXh0KCkge1xuICAgIC8vIGRlYnVnZ2luZyBtZXRob2QgdG8gZmFpbCB0aGUgbmV4dCByZWNvbm5lY3QvcmVzdW1lIGF0dGVtcHRcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gdHJ1ZTtcbiAgfVxuICBkYXRhQ2hhbm5lbHNJbmZvKCkge1xuICAgIGNvbnN0IGluZm9zID0gW107XG4gICAgY29uc3QgZ2V0SW5mbyA9IChkYywgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoKGRjID09PSBudWxsIHx8IGRjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYy5pZCkgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgIGxhYmVsOiBkYy5sYWJlbCxcbiAgICAgICAgICBpZDogZGMuaWQsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICByZXR1cm4gaW5mb3M7XG4gIH1cbiAgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgfVxuICByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbiAgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSAwO1xuICAgIHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUgPSAzMDAwO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICB1cGRhdGVUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBpc0Nsb3VkKCkge1xuICAgIHJldHVybiBpc0Nsb3VkKHRoaXMuc2VydmVyVXJsKTtcbiAgfVxuICBnZXRTZXJ2ZXJVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVXJsO1xuICB9XG4gIGdldE5leHRCZXN0UmVnaW9uVXJsKGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlZ2lvblNldHRpbmdzIHx8IERhdGUubm93KCkgLSB0aGlzLmxhc3RVcGRhdGVBdCA+IHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUpIHtcbiAgICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IHlpZWxkIHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb25zTGVmdCA9IHRoaXMucmVnaW9uU2V0dGluZ3MucmVnaW9ucy5maWx0ZXIocmVnaW9uID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZChhdHRlbXB0ZWQgPT4gYXR0ZW1wdGVkLnVybCA9PT0gcmVnaW9uLnVybCkpO1xuICAgICAgaWYgKHJlZ2lvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dFJlZ2lvbiA9IHJlZ2lvbnNMZWZ0WzBdO1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIm5leHQgcmVnaW9uOiBcIi5jb25jYXQobmV4dFJlZ2lvbi5yZWdpb24pKTtcbiAgICAgICAgcmV0dXJuIG5leHRSZWdpb24udXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRBdHRlbXB0cygpIHtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3NSZXNwb25zZSA9IHlpZWxkIGZldGNoKFwiXCIuY29uY2F0KGdldENsb3VkQ29uZmlnVXJsKHRoaXMuc2VydmVyVXJsKSwgXCIvcmVnaW9uc1wiKSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRoaXMudG9rZW4pXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IHlpZWxkIHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZWdpb25TZXR0aW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8gOiB1bmRlZmluZWQsIHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwucHJvdG9jb2wucmVwbGFjZSgnd3MnLCAnaHR0cCcpLCBcIi8vXCIpLmNvbmNhdChzZXJ2ZXJVcmwuaG9zdCwgXCIvc2V0dGluZ3NcIik7XG59XG5cbmNvbnN0IG1vbml0b3JGcmVxdWVuY3kgPSAyMDAwO1xuZnVuY3Rpb24gY29tcHV0ZUJpdHJhdGUoY3VycmVudFN0YXRzLCBwcmV2U3RhdHMpIHtcbiAgaWYgKCFwcmV2U3RhdHMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgYnl0ZXNOb3c7XG4gIGxldCBieXRlc1ByZXY7XG4gIGlmICgnYnl0ZXNSZWNlaXZlZCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgfSBlbHNlIGlmICgnYnl0ZXNTZW50JyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1NlbnQ7XG4gICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzU2VudDtcbiAgfVxuICBpZiAoYnl0ZXNOb3cgPT09IHVuZGVmaW5lZCB8fCBieXRlc1ByZXYgPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQgfHwgcHJldlN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIChieXRlc05vdyAtIGJ5dGVzUHJldikgKiA4ICogMTAwMCAvIChjdXJyZW50U3RhdHMudGltZXN0YW1wIC0gcHJldlN0YXRzLnRpbWVzdGFtcCk7XG59XG5cbmNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBsZXQgYXVkaW9Db250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLkF1ZGlvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnN0b3BPbk11dGUgPSBmYWxzZTtcbiAgICB0aGlzLm1vbml0b3JTZW5kZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZ2V0IGF1ZGlvIHNlbmRlciBzdGF0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pc011dGVkIHx8IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBkaXNhYmxlZCBzcGVjaWFsIGhhbmRsaW5nIGFzIGl0IHdpbGwgY2F1c2UgQlQgaGVhZHNldHMgdG8gc3dpdGNoIGNvbW11bmljYXRpb24gbW9kZXNcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiB0aGlzLnN0b3BPbk11dGUgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RvcHBpbmcgbWljIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IG1pY3JvcGhvbmUgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHVubXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPSB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09IHVud3JhcENvbnN0cmFpbnQodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQpO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgX3N1cGVyLnJlc3RhcnQuY2FsbCh0aGlzLCBjb25zdHJhaW50cyk7XG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yIFwiLmNvbmNhdChwcm9jZXNzb3IubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuICBnZXRTZW5kZXJTdGF0cygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgYXVkaW9TdGF0cztcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgYXVkaW9TdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBieXRlc1NlbnQ6IHYuYnl0ZXNTZW50LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhdWRpb1N0YXRzO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrRm9yU2lsZW5jZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvU2lsZW5jZURldGVjdGVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFja0lzU2lsZW50O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgc3dpdGNoIChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIHVuZGVmaW5lZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCBsb2dnZXJPcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgdHJhY2sgdHlwZTogXCIuY29uY2F0KG1lZGlhU3RyZWFtVHJhY2sua2luZCkpO1xuICB9XG59XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHMxNjkgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0cyk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHM0MyA9IE9iamVjdC52YWx1ZXMoVmlkZW9QcmVzZXRzNDMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzU2NyZWVuU2hhcmUgPSBPYmplY3QudmFsdWVzKFNjcmVlblNoYXJlUHJlc2V0cyk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5ID0gW1ZpZGVvUHJlc2V0cy5oMTgwLCBWaWRlb1ByZXNldHMuaDM2MF07XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMgPSBbVmlkZW9QcmVzZXRzNDMuaDE4MCwgVmlkZW9QcmVzZXRzNDMuaDM2MF07XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzID0gZnJvbVByZXNldCA9PiB7XG4gIGNvbnN0IGxheWVycyA9IFt7XG4gICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAyLFxuICAgIGZwczogZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcbiAgfV07XG4gIHJldHVybiBsYXllcnMubWFwKHQgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIG5ldyBWaWRlb1ByZXNldChNYXRoLmZsb29yKGZyb21QcmVzZXQud2lkdGggLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksIE1hdGguZmxvb3IoZnJvbVByZXNldC5oZWlnaHQgLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksIE1hdGgubWF4KDE1MDAwMCwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGUgLyAoTWF0aC5wb3codC5zY2FsZVJlc29sdXRpb25Eb3duQnksIDIpICogKCgoX2EgPSBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzApIC8gKChfYiA9IHQuZnBzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAzMCkpKSkpLCB0LmZwcywgZnJvbVByZXNldC5lbmNvZGluZy5wcmlvcml0eSk7XG4gIH0pO1xufTtcbi8vIC8qKlxuLy8gICpcbi8vICAqIEBpbnRlcm5hbFxuLy8gICogQGV4cGVyaW1lbnRhbFxuLy8gICovXG4vLyBjb25zdCBjb21wdXRlRGVmYXVsdE11bHRpQ29kZWNTaW11bGNhc3RFbmNvZGluZ3MgPSAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbi8vICAgLy8gdXNlIHZwOCBhcyBhIGRlZmF1bHRcbi8vICAgY29uc3QgdnA4ID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhmYWxzZSwgd2lkdGgsIGhlaWdodCk7XG4vLyAgIGNvbnN0IHZwOSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuOSB9O1xuLy8gICBjb25zdCBoMjY0ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMS4xIH07XG4vLyAgIGNvbnN0IGF2MSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuNyB9O1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHZwOCxcbi8vICAgICB2cDksXG4vLyAgICAgaDI2NCxcbi8vICAgICBhdjEsXG4vLyAgIH07XG4vLyB9O1xuY29uc3QgdmlkZW9SaWRzID0gWydxJywgJ2gnLCAnZiddO1xuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBjb21wdXRlVmlkZW9FbmNvZGluZ3MoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBsZXQgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0VuY29kaW5nO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVFbmNvZGluZztcbiAgfVxuICBjb25zdCB1c2VTaW11bGNhc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2ltdWxjYXN0O1xuICBjb25zdCBzY2FsYWJpbGl0eU1vZGUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NhbGFiaWxpdHlNb2RlO1xuICBjb25zdCB2aWRlb0NvZGVjID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ29kZWM7XG4gIGlmICghdmlkZW9FbmNvZGluZyAmJiAhdXNlU2ltdWxjYXN0ICYmICFzY2FsYWJpbGl0eU1vZGUgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAvLyB3aGVuIHdlIGFyZW4ndCBzaW11bGNhc3Rpbmcgb3Igc3ZjLCB3aWxsIG5lZWQgdG8gcmV0dXJuIGEgc2luZ2xlIGVuY29kaW5nIHdpdGhvdXRcbiAgICAvLyBjYXBwaW5nIGJhbmR3aWR0aC4gd2UgYWx3YXlzIHJlcXVpcmUgYSBlbmNvZGluZyBmb3IgZHluYWNhc3RcbiAgICByZXR1cm4gW3t9XTtcbiAgfVxuICBpZiAoIXZpZGVvRW5jb2RpbmcpIHtcbiAgICAvLyBmaW5kIHRoZSByaWdodCBlbmNvZGluZyBiYXNlZCBvbiB3aWR0aC9oZWlnaHRcbiAgICB2aWRlb0VuY29kaW5nID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCB2aWRlb0NvZGVjKTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1c2luZyB2aWRlbyBlbmNvZGluZycsIHZpZGVvRW5jb2RpbmcpO1xuICB9XG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFZpZGVvUHJlc2V0KHdpZHRoLCBoZWlnaHQsIHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSwgdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGUsIHZpZGVvRW5jb2RpbmcucHJpb3JpdHkpO1xuICBpZiAoc2NhbGFiaWxpdHlNb2RlICYmIGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwidXNpbmcgc3ZjIHdpdGggc2NhbGFiaWxpdHlNb2RlIFwiLmNvbmNhdChzY2FsYWJpbGl0eU1vZGUpKTtcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2NhbGFiaWxpdHlNb2RlKTtcbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBpZiAoc20uc3BhdGlhbCA+IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogXCIuY29uY2F0KHNjYWxhYmlsaXR5TW9kZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtLnNwYXRpYWw7IGkgKz0gMSkge1xuICAgICAgZW5jb2RpbmdzLnB1c2goe1xuICAgICAgICByaWQ6IHZpZGVvUmlkc1syIC0gaV0sXG4gICAgICAgIG1heEJpdHJhdGU6IHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSAvIE1hdGgucG93KDMsIGkpLFxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUgPSBzY2FsYWJpbGl0eU1vZGU7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnZW5jb2RpbmdzJywgZW5jb2RpbmdzKTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xuICB9XG4gIGlmICghdXNlU2ltdWxjYXN0KSB7XG4gICAgcmV0dXJuIFt2aWRlb0VuY29kaW5nXTtcbiAgfVxuICBsZXQgcHJlc2V0cyA9IFtdO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHByZXNldHMgPSAoX2EgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzZXRzID0gKF9iID0gc29ydFByZXNldHMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCk7XG4gIH1cbiAgbGV0IG1pZFByZXNldDtcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XG4gICAgaWYgKHByZXNldHMubGVuZ3RoID4gMSkge1xuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuICAgIC8vIE5PVEU6XG4gICAgLy8gICAxLiBPcmRlcmluZyBvZiB0aGVzZSBlbmNvZGluZ3MgaXMgaW1wb3J0YW50LiBDaHJvbWUgc2VlbXNcbiAgICAvLyAgICAgIHRvIHVzZSB0aGUgaW5kZXggaW50byBlbmNvZGluZ3MgdG8gZGVjaWRlIHdoaWNoIGxheWVyXG4gICAgLy8gICAgICB0byBkaXNhYmxlIHdoZW4gQ1BVIGNvbnN0cmFpbmVkLlxuICAgIC8vICAgICAgU28gZW5jb2RpbmdzIHNob3VsZCBiZSBvcmRlcmVkIGluIGluY3JlYXNpbmcgc3BhdGlhbFxuICAgIC8vICAgICAgcmVzb2x1dGlvbiBvcmRlci5cbiAgICAvLyAgIDIuIGlvbi1zZnUgdHJhbnNsYXRlcyByaWRzIGludG8gbGF5ZXJzLiBTbywgYWxsIGVuY29kaW5nc1xuICAgIC8vICAgICAgc2hvdWxkIGhhdmUgdGhlIGJhc2UgbGF5ZXIgYHFgIGFuZCB0aGVuIG1vcmUgYWRkZWRcbiAgICAvLyAgICAgIGJhc2VkIG9uIG90aGVyIGNvbmRpdGlvbnMuXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChzaXplID49IDk2MCAmJiBtaWRQcmVzZXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBtaWRQcmVzZXQsIG9yaWdpbmFsXSk7XG4gICAgfVxuICAgIGlmIChzaXplID49IDQ4MCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG9yaWdpbmFsXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbb3JpZ2luYWxdKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcbiAgaWYgKCFvcHRzLmJhY2t1cENvZGVjIHx8IG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUgfHwgb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyA9PT0gb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgLy8gYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmcgaXMgZGlzYWJsZWRcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMpIHtcbiAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3JlcXVlc3RlZCBhIGRpZmZlcmVudCBjb2RlYyB0aGFuIHNwZWNpZmllZCBhcyBiYWNrdXAnLCB7XG4gICAgICBzZXJ2ZXJSZXF1ZXN0ZWQ6IHZpZGVvQ29kZWMsXG4gICAgICBiYWNrdXA6IG9wdHMuYmFja3VwQ29kZWMuY29kZWNcbiAgICB9KTtcbiAgfVxuICBvcHRzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAvLyB1c2UgYmFja3VwIGVuY29kaW5nIHNldHRpbmcgYXMgdmlkZW9FbmNvZGluZyBmb3IgYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmdcbiAgb3B0cy52aWRlb0VuY29kaW5nID0gb3B0cy5iYWNrdXBDb2RlYy5lbmNvZGluZztcbiAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGNvbnN0IHdpZHRoID0gKF9hID0gc2V0dGluZ3Mud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0O1xuICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIG9wdHMpO1xuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIGNvZGVjKSB7XG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IHtcbiAgICBlbmNvZGluZ1xuICB9ID0gcHJlc2V0c1swXTtcbiAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXNldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBwcmVzZXRzW2ldO1xuICAgIGVuY29kaW5nID0gcHJlc2V0LmVuY29kaW5nO1xuICAgIGlmIChwcmVzZXQud2lkdGggPj0gc2l6ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIHByZXNldHMgYXJlIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIG9mIHZwOCBhcyBhIGNvZGVjXG4gIC8vIGZvciBvdGhlciBjb2RlY3Mgd2UgYWRqdXN0IHRoZSBtYXhCaXRyYXRlIGlmIG5vIHNwZWNpZmljIHZpZGVvRW5jb2RpbmcgaGFzIGJlZW4gcHJvdmlkZWRcbiAgLy8gdXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRoZXNlIHdpdGggb25lcyB0aGF0IGFyZSBvcHRpbWl6ZWQgZm9yIHRoZWlyIHVzZSBjYXNlXG4gIC8vIE5PVEU6IFNWQyBjb2RlYyBiaXRyYXRlcyBhcmUgaW5jbHVzaXZlIG9mIGFsbCBzY2FsYWJpbGl0eSBsYXllcnMuIHdoaWxlXG4gIC8vIGJpdHJhdGUgZm9yIG5vbi1TVkMgY29kZWNzIGRvZXMgbm90IGluY2x1ZGUgb3RoZXIgc2ltdWxjYXN0IGxheWVycy5cbiAgaWYgKGNvZGVjKSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnYXYxJzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC43O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZwOSc6XG4gICAgICAgIGVuY29kaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuODU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2Rpbmc7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICByZXR1cm4gcHJlc2V0c1NjcmVlblNoYXJlO1xuICB9XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIHByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIHByZXNldHM0Mztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyhvcmlnaW5hbCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gb3JpZ2luYWw7XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzO1xufVxuLy8gcHJlc2V0cyBzaG91bGQgYmUgb3JkZXJlZCBieSBsb3csIG1lZGl1bSwgaGlnaFxuZnVuY3Rpb24gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgcHJlc2V0cykge1xuICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgcHJlc2V0cy5mb3JFYWNoKChwcmVzZXQsIGlkeCkgPT4ge1xuICAgIGlmIChpZHggPj0gdmlkZW9SaWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcmlkID0gdmlkZW9SaWRzW2lkeF07XG4gICAgY29uc3QgZW5jb2RpbmcgPSB7XG4gICAgICByaWQsXG4gICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IE1hdGgubWF4KDEsIHNpemUgLyBNYXRoLm1pbihwcmVzZXQud2lkdGgsIHByZXNldC5oZWlnaHQpKSxcbiAgICAgIG1heEJpdHJhdGU6IHByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlXG4gICAgfTtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkge1xuICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG4gIC8vIFJOIGlvcyBzaW11bGNhc3QgcmVxdWlyZXMgYWxsIHNhbWUgZnJhbWVyYXRlcy5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSAmJiBnZXRSZWFjdE5hdGl2ZU9zKCkgPT09ICdpb3MnKSB7XG4gICAgbGV0IHRvcEZyYW1lcmF0ZSA9IHVuZGVmaW5lZDtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBub3RpZnlPbmNlID0gdHJ1ZTtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICE9IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICBpZiAobm90aWZ5T25jZSkge1xuICAgICAgICAgIG5vdGlmeU9uY2UgPSBmYWxzZTtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTaW11bGNhc3Qgb24gaU9TIFJlYWN0LU5hdGl2ZSByZXF1aXJlcyBhbGwgZW5jb2RpbmdzIHRvIHNoYXJlIHRoZSBzYW1lIGZyYW1lcmF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2V0dGluZyBmcmFtZXJhdGUgb2YgZW5jb2RpbmcgXFxcIlwiLmNvbmNhdCgoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBcIlxcXCIgdG8gXCIpLmNvbmNhdCh0b3BGcmFtZXJhdGUpKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzb3J0UHJlc2V0cyhwcmVzZXRzKSB7XG4gIGlmICghcHJlc2V0cykgcmV0dXJuO1xuICByZXR1cm4gcHJlc2V0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2Rpbmc6IGFFbmNcbiAgICB9ID0gYTtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYkVuY1xuICAgIH0gPSBiO1xuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHNjYWxhYmlsaXR5TW9kZS5tYXRjaCgvXkwoXFxkKVQoXFxkKShofF9LRVl8X0tFWV9TSElGVCl7MCwxfSQvKTtcbiAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYWJpbGl0eSBtb2RlJyk7XG4gICAgfVxuICAgIHRoaXMuc3BhdGlhbCA9IHBhcnNlSW50KHJlc3VsdHNbMV0pO1xuICAgIHRoaXMudGVtcG9yYWwgPSBwYXJzZUludChyZXN1bHRzWzJdKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAzKSB7XG4gICAgICBzd2l0Y2ggKHJlc3VsdHNbM10pIHtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ19LRVknOlxuICAgICAgICBjYXNlICdfS0VZX1NISUZUJzpcbiAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHJlc3VsdHNbM107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gXCJMXCIuY29uY2F0KHRoaXMuc3BhdGlhbCwgXCJUXCIpLmNvbmNhdCh0aGlzLnRlbXBvcmFsKS5jb25jYXQoKF9hID0gdGhpcy5zdWZmaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgfVxufVxuXG5jb25zdCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyA9IDUwMDA7XG5jbGFzcyBMb2NhbFZpZGVvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXAoc3RhdHMubWFwKHMgPT4gW3MucmlkLCBzXSkpO1xuICAgICAgaWYgKHRoaXMucHJldlN0YXRzKSB7XG4gICAgICAgIGxldCB0b3RhbEJpdHJhdGUgPSAwO1xuICAgICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG4gICAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSB0b3RhbEJpdHJhdGU7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBNdXRleCgpO1xuICB9XG4gIGdldCBpc1NpbXVsY2FzdCgpIHtcbiAgICBpZiAodGhpcy5zZW5kZXIgJiYgdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpLmVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzYXZlIG9yaWdpbmFsIGVuY29kaW5nc1xuICAgIC8vIFRPRE8gOiBtZXJnZSBzaW11bGNhc3QgdHJhY2tzIHN0YXRzXG4gICAgY29uc3QgcGFyYW1zID0gKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5mb3JFYWNoKHRyYWNrSW5mbyA9PiB7XG4gICAgICB0cmFja0luZm8ubWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG4gIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBwYXVzZVVwc3RyZWFtOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucGF1c2VVcHN0cmVhbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgdmFyIF9kO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIucGF1c2VVcHN0cmVhbS5jYWxsKHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICB5aWVsZCAoX2QgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICByZXN1bWVVcHN0cmVhbToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnJlc3VtZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5yZXN1bWVVcHN0cmVhbS5jYWxsKHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICB5aWVsZCAoX2QgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICAgIGVfMiA9IHtcbiAgICAgICAgICBlcnJvcjogZV8yXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5tdXRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBjYW1lcmEgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHVubXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICBzdXBlci5zZXRUcmFja011dGVkKG11dGVkKTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgfVxuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICBjb25zdCB2cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgcmlkOiAoX2EgPSB2LnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdi5pZCxcbiAgICAgICAgICAgIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogdi5yZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQsXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXM6IHYucXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgLy/CoGxvY2F0ZSB0aGUgYXBwcm9wcmlhdGUgcmVtb3RlLWluYm91bmQtcnRwIGl0ZW1cbiAgICAgICAgICBjb25zdCByID0gc3RhdHMuZ2V0KHYucmVtb3RlSWQpO1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2cy5qaXR0ZXIgPSByLmppdHRlcjtcbiAgICAgICAgICAgIHZzLnBhY2tldHNMb3N0ID0gci5wYWNrZXRzTG9zdDtcbiAgICAgICAgICAgIHZzLnJvdW5kVHJpcFRpbWUgPSByLnJvdW5kVHJpcFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW1zLnB1c2godnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9KTtcbiAgfVxuICBzZXRQdWJsaXNoaW5nUXVhbGl0eShtYXhRdWFsaXR5KSB7XG4gICAgY29uc3QgcXVhbGl0aWVzID0gW107XG4gICAgZm9yIChsZXQgcSA9IFZpZGVvUXVhbGl0eS5MT1c7IHEgPD0gVmlkZW9RdWFsaXR5LkhJR0g7IHEgKz0gMSkge1xuICAgICAgcXVhbGl0aWVzLnB1c2gobmV3IFN1YnNjcmliZWRRdWFsaXR5KHtcbiAgICAgICAgcXVhbGl0eTogcSxcbiAgICAgICAgZW5hYmxlZDogcSA8PSBtYXhRdWFsaXR5XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBwdWJsaXNoaW5nIHF1YWxpdHkuIG1heCBxdWFsaXR5IFwiLmNvbmNhdChtYXhRdWFsaXR5KSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKTtcbiAgfVxuICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgLy8gd2hlbiB2aWRlbyBpcyBtdXRlZCwgdW5kZXJseWluZyBtZWRpYSBzdHJlYW0gdHJhY2sgaXMgc3RvcHBlZCBhbmRcbiAgICAgIC8vIHdpbGwgYmUgcmVzdGFydGVkIGxhdGVyXG4gICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNNdXRlZCB8fCB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIHZpZGVvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICBpZiAoc2Muc2VuZGVyKSB7XG4gICAgICAgICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCk7XG4gICAgICAgICAgICB5aWVsZCBzYy5zZW5kZXIucmVwbGFjZVRyYWNrKHNjLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgICAgZV8zID0ge1xuICAgICAgICAgIGVycm9yOiBlXzNfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9lKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgbGV0IHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgc2V0UHJvY2Vzc29yOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuc2V0UHJvY2Vzc29yXG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcbiAgICB2YXIgX2QsIF9lO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuc2V0UHJvY2Vzc29yLmNhbGwodGhpcywgcHJvY2Vzc29yLCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSk7XG4gICAgICBpZiAoKF9kID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgX2cgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2g7IF9oID0geWllbGQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgICB5aWVsZCAoX2UgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV80XzEpIHtcbiAgICAgICAgICBlXzQgPSB7XG4gICAgICAgICAgICBlcnJvcjogZV80XzFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBfZy5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9nKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZFNpbXVsY2FzdFRyYWNrKGNvZGVjLCBlbmNvZGluZ3MpIHtcbiAgICBpZiAodGhpcy5zaW11bGNhc3RDb2RlY3MuaGFzKGNvZGVjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGNvZGVjLCBcIiBhbHJlYWR5IGFkZGVkXCIpKTtcbiAgICB9XG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0ge1xuICAgICAgY29kZWMsXG4gICAgICBtZWRpYVN0cmVhbVRyYWNrOiB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSxcbiAgICAgIHNlbmRlcjogdW5kZWZpbmVkLFxuICAgICAgZW5jb2RpbmdzXG4gICAgfTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5zZXQoY29kZWMsIHNpbXVsY2FzdENvZGVjSW5mbyk7XG4gICAgcmV0dXJuIHNpbXVsY2FzdENvZGVjSW5mbztcbiAgfVxuICBzZXRTaW11bGNhc3RUcmFja1NlbmRlcihjb2RlYywgc2VuZGVyKSB7XG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjKTtcbiAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyID0gc2VuZGVyO1xuICAgIC8vIGJyb3dzZXIgd2lsbCByZWVuYWJsZSBkaXNhYmxlZCBjb2RlYy9sYXllcnMgYWZ0ZXIgbmV3IGNvZGVjIGhhcyBiZWVuIHB1Ymxpc2hlZCxcbiAgICAvLyBzbyByZWZyZXNoIHN1YnNjcmliZWRDb2RlY3MgYWZ0ZXIgcHVibGlzaCBhIG5ldyBjb2RlY1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZENvZGVjcykge1xuICAgICAgICB0aGlzLnNldFB1Ymxpc2hpbmdDb2RlY3ModGhpcy5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgIH1cbiAgICB9LCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGNvZGVjcyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nLCByZXR1cm5zIG5ldyBjb2RlY3MgdGhhdCBoYXZlIG5vdCB5ZXRcbiAgICogYmVlbiBwdWJsaXNoZWRcbiAgICovXG4gIHNldFB1Ymxpc2hpbmdDb2RlY3MoY29kZWNzKSB7XG4gICAgdmFyIF9hLCBjb2RlY3NfMSwgY29kZWNzXzFfMTtcbiAgICB2YXIgX2IsIGVfNSwgX2MsIF9kO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGNvZGVjcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjb2RlY3MsXG4gICAgICAgIGN1cnJlbnRDb2RlYzogdGhpcy5jb2RlY1xuICAgICAgfSkpO1xuICAgICAgLy8gb25seSBlbmFibGUgc2ltdWxjYXN0IGNvZGVjIGZvciBwcmVmZXJlbmNlIGNvZGVjIHNldHRlZFxuICAgICAgaWYgKCF0aGlzLmNvZGVjICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhjb2RlY3NbMF0ucXVhbGl0aWVzKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5zdWJzY3JpYmVkQ29kZWNzID0gY29kZWNzO1xuICAgICAgY29uc3QgbmV3Q29kZWNzID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9hID0gdHJ1ZSwgY29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKGNvZGVjcyk7IGNvZGVjc18xXzEgPSB5aWVsZCBjb2RlY3NfMS5uZXh0KCksIF9iID0gY29kZWNzXzFfMS5kb25lLCAhX2I7IF9hID0gdHJ1ZSkge1xuICAgICAgICAgIF9kID0gY29kZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICBfYSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2Q7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvZGVjIHx8IHRoaXMuY29kZWMgPT09IGNvZGVjLmNvZGVjKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWMucXVhbGl0aWVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mb1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8gfHwgIXNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBxIG9mIGNvZGVjLnF1YWxpdGllcykge1xuICAgICAgICAgICAgICAgIGlmIChxLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0NvZGVjcy5wdXNoKGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyLCBzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzLCBjb2RlYy5xdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jaywgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzVfMSkge1xuICAgICAgICBlXzUgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfNV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2EgJiYgIV9iICYmIChfYyA9IGNvZGVjc18xLnJldHVybikpIHlpZWxkIF9jLmNhbGwoY29kZWNzXzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NvZGVjcztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgbGF5ZXJzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmdcbiAgICovXG4gIHNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHF1YWxpdGllc1xuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnNlbmRlciB8fCAhdGhpcy5lbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcih0aGlzLnNlbmRlciwgdGhpcy5lbmNvZGluZ3MsIHF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIWlzTW9iaWxlKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNlbmRlciwgc2VuZGVyRW5jb2RpbmdzLCBxdWFsaXRpZXMsIHNlbmRlckxvY2ssIGxvZywgbG9nQ29udGV4dCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHNlbmRlckxvY2subG9jaygpO1xuICAgIGxvZy5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgIHNlbmRlcixcbiAgICAgIHF1YWxpdGllcyxcbiAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5jb2RpbmdzXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5ncy5sZW5ndGggIT09IHNlbmRlckVuY29kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgLyogZGlzYWJsZSBjbG9zYWJsZSBzcGF0aWFsIGxheWVyIGFzIGl0IGhhcyB2aWRlbyBibHVyIC8gZnJvemVuIGlzc3VlIHdpdGggY3VycmVudCBzZXJ2ZXIgLyBjbGllbnRcbiAgICAgIDEuIGNocm9tZSAxMTM6IHdoZW4gc3dpdGNoaW5nIHRvIHVwIGxheWVyIHdpdGggc2NhbGFiaWxpdHkgTW9kZSBjaGFuZ2UsIGl0IHdpbGwgZ2VuZXJhdGUgYVxuICAgICAgICAgICAgbG93IHJlc29sdXRpb24gZnJhbWUgYW5kIHJlY292ZXIgdmVyeSBxdWlja2x5LCBidXQgbm90aWNhYmxlXG4gICAgICAyLiBsaXZla2l0IHNmdTogYWRkaXRpb25hbCBwbGkgcmVxdWVzdCBjYXVzZSB2aWRlbyBmcm96ZW4gZm9yIGEgZmV3IGZyYW1lcywgYWxzbyBub3RpY2FibGUgKi9cbiAgICAgIGNvbnN0IGNsb3NhYmxlU3BhdGlhbCA9IGZhbHNlO1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgaWYgKGNsb3NhYmxlU3BhdGlhbCAmJiBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKSA7IGVsc2Uge1xuICAgICAgICAvLyBzaW11bGNhc3QgZHluYWNhc3QgZW5jb2RpbmdzXG4gICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGxldCByaWQgPSAoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgIGlmIChyaWQgPT09ICcnKSB7XG4gICAgICAgICAgICByaWQgPSAncSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKTtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVhbGl0eSA9IHF1YWxpdGllcy5maW5kKHEgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcbiAgICAgICAgICBpZiAoIXN1YnNjcmliZWRRdWFsaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgIT09IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcInNldHRpbmcgbGF5ZXIgXCIuY29uY2F0KHN1YnNjcmliZWRRdWFsaXR5LnF1YWxpdHksIFwiIHRvIFwiKS5jb25jYXQoZW5jb2RpbmcuYWN0aXZlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJyksIGxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgLy8gRmlyZUZveCBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgZW5jb2RpbmcuYWN0aXZlIHRvIGZhbHNlLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSBhIHdvcmthcm91bmQgb2YgbG93ZXJpbmcgaXRzIGJpdHJhdGUgYW5kIHJlc29sdXRpb24gdG8gdGhlIG1pbi5cbiAgICAgICAgICAgIGlmIChpc0ZpcmVGb3goKSkge1xuICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4RnJhbWVSYXRlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDQ7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IDEwO1xuICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIGxvZy5kZWJ1ZyhcInNldHRpbmcgZW5jb2RpbmdzXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlbmNvZGluZ3M6IHBhcmFtcy5lbmNvZGluZ3NcbiAgICAgICAgfSkpO1xuICAgICAgICB5aWVsZCBzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCkge1xuICBzd2l0Y2ggKHJpZCkge1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5NRURJVU07XG4gICAgY2FzZSAncSc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkxPVztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xuICB9XG59XG5mdW5jdGlvbiB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3Mod2lkdGgsIGhlaWdodCwgZW5jb2RpbmdzLCBzdmMpIHtcbiAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcbiAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gW25ldyBWaWRlb0xheWVyKHtcbiAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdILFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBiaXRyYXRlOiAwLFxuICAgICAgc3NyYzogMFxuICAgIH0pXTtcbiAgfVxuICBpZiAoc3ZjKSB7XG4gICAgLy8gc3ZjIGxheWVyc1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBjb25zdCBlbmNvZGluZ1NNID0gZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZTtcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2RpbmdTTSk7XG4gICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcbiAgICAgIGxheWVycy5wdXNoKG5ldyBWaWRlb0xheWVyKHtcbiAgICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0ggLSBpLFxuICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gTWF0aC5wb3coMiwgaSkpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBNYXRoLnBvdygyLCBpKSksXG4gICAgICAgIGJpdHJhdGU6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlID8gTWF0aC5jZWlsKGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gTWF0aC5wb3coMywgaSkpIDogMCxcbiAgICAgICAgc3NyYzogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ3MubWFwKGVuY29kaW5nID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzY2FsZSA9IChfYSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZCgoX2IgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eSxcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBzY2FsZSksXG4gICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBzY2FsZSksXG4gICAgICBiaXRyYXRlOiAoX2MgPSBlbmNvZGluZy5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxuICAgICAgc3NyYzogMFxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgUmVtb3RlVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwga2luZCwgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNdXRlZChtdXRlZCkge1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgIT09IG11dGVkKSB7XG4gICAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbSkge1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIGRldGVybWluZSB3aGVuIHRoZSB0cmFjayBpcyBmaW5pc2hlZFxuICAgIHRoaXMubWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgY29uc3Qgb25SZW1vdmVUcmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50cmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgfVxuICBzdGFydCgpIHtcbiAgICB0aGlzLnN0YXJ0TW9uaXRvcigpO1xuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgIHN1cGVyLmVuYWJsZSgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBSZW1vdGVUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwUmVjZWl2ZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnJlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCF0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm1vbml0b3JSZWNlaXZlcigpLCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlQXVkaW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYXVkaW9Db250ZXh0LCBhdWRpb091dHB1dCwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5BdWRpbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIGZvciBhbGwgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHNcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodm9sdW1lLCAwLCAwLjEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwudm9sdW1lID0gdm9sdW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLl9zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50Vm9sdW1lID0gdm9sdW1lO1xuICB9XG4gIC8qKlxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb2YgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHMgKGxvdWRlc3QpXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQudm9sdW1lID4gaGlnaGVzdFZvbHVtZSkge1xuICAgICAgICBoaWdoZXN0Vm9sdW1lID0gZWxlbWVudC52b2x1bWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZ2hlc3RWb2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxzIHNldFNpbmtJZCBvbiBhbGwgYXR0YWNoZWQgZWxlbWVudHMsIGlmIHN1cHBvcnRlZFxuICAgKiBAcGFyYW0gZGV2aWNlSWQgYXVkaW8gb3V0cHV0IGRldmljZVxuICAgKi9cbiAgc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gZGV2aWNlSWQ7XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLmF0dGFjaGVkRWxlbWVudHMubWFwKGVsbSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIHJldHVybiBlbG0uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBhdHRhY2goZWxlbWVudCkge1xuICAgIGNvbnN0IG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdm9sdW1lIHNldHRpbmcgaXMgYmVpbmcgYXBwbGllZCB0byB0aGUgbmV3bHkgYXR0YWNoZWQgZWxlbWVudFxuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5lbGVtZW50Vm9sdW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQgPSBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgYW55IGF0dGFjaGVkIGVsZW1lbnRzIGFmdGVyIGRldGFjaGluZywgY29ubmVjdCB3ZWJhdWRpbyB0byB0aGUgZmlyc3QgZWxlbWVudCB0aGF0J3MgbGVmdFxuICAgICAgLy8gZGlzY29ubmVjdCB3ZWJhdWRpbyBvdGhlcndpc2VcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXRhY2hlZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHBhcmFtIHtBdWRpb05vZGVbXX0gbm9kZXMgLSBBbiBhcnJheSBvZiBXZWJBdWRpbyBub2Rlcy4gVGhlc2Ugbm9kZXMgc2hvdWxkIG5vdCBiZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciB3aGVuIHBhc3NlZCwgYXMgdGhlIHNkayB3aWxsIHRha2UgY2FyZSBvZiBjb25uZWN0aW5nIHRoZW0gaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheS5cbiAgICovXG4gIHNldFdlYkF1ZGlvUGx1Z2lucyhub2Rlcykge1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RXZWJBdWRpbyhjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxuICAgIHRoaXMuc291cmNlTm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZWxlbWVudC5zcmNPYmplY3QpO1xuICAgIGxldCBsYXN0Tm9kZSA9IHRoaXMuc291cmNlTm9kZTtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxhc3ROb2RlLmNvbm5lY3Qobm9kZSk7XG4gICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5nYWluTm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIGxhc3ROb2RlLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG4gICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xuICAgIH1cbiAgICAvLyB0cnkgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGlmIGl0IGlzbid0IHJ1bm5pbmcgYWxyZWFkeVxuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgIGNvbnRleHQucmVzdW1lKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgIChfYiA9IHRoaXMuc291cmNlTm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgY29uY2VhbGVkU2FtcGxlczogdi5jb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgICBzaWxlbnRDb25jZWFsZWRTYW1wbGVzOiB2LnNpbGVudENvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICBzaWxlbnRDb25jZWFsbWVudEV2ZW50czogdi5zaWxlbnRDb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcbiAgICAgICAgICAgIHRvdGFsU2FtcGxlc0R1cmF0aW9uOiB2LnRvdGFsU2FtcGxlc0R1cmF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBSRUFDVElPTl9ERUxBWSA9IDEwMDtcbmNsYXNzIFJlbW90ZVZpZGVvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjayB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBzaWQsIFRyYWNrLktpbmQuVmlkZW8sIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xuICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUgPSByKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucygpO1xuICAgIH0sIFJFQUNUSU9OX0RFTEFZKTtcbiAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xuICB9XG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgIT09IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogTm90ZTogV2hlbiB1c2luZyBhZGFwdGl2ZVN0cmVhbSwgeW91IG5lZWQgdG8gdXNlIHJlbW90ZVZpZGVvVHJhY2suYXR0YWNoKCkgdG8gYWRkIHRoZSB0cmFjayB0byBhIEhUTUxWaWRlb0VsZW1lbnQsIG90aGVyd2lzZSB5b3VyIHZpZGVvIHRyYWNrcyBtaWdodCBuZXZlciBzdGFydFxuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNdXRlZChtdXRlZCkge1xuICAgIHN1cGVyLnNldE11dGVkKG11dGVkKTtcbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIC8vIGRldGFjaCBvciBhdHRhY2hcbiAgICAgIGlmIChtdXRlZCkge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2goZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIEl0J3MgcG9zc2libGUgYXR0YWNoIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBlbGVtZW50LiBXaGVuIHRoYXQnc1xuICAgIC8vIHRoZSBjYXNlLCB3ZSdkIHdhbnQgdG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZSBlbGVtZW50SW5mb3NcbiAgICBpZiAodGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRJbmZvID0gbmV3IEhUTUxFbGVtZW50SW5mbyhlbGVtZW50KTtcbiAgICAgIHRoaXMub2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE9ic2VydmUgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMgd2hlbiBhZGFwdGl2ZSBzdHJlYW1pbmcuXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9ic2VydmVFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gICAgICB9O1xuICAgICAgZWxlbWVudEluZm8uaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWxlbWVudEluZm9zLnB1c2goZWxlbWVudEluZm8pO1xuICAgICAgZWxlbWVudEluZm8ub2JzZXJ2ZSgpO1xuICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgcmVzaXplIHVwZGF0ZSBjeWNsZVxuICAgICAgLy8gaWYgdGhlIHRhYiBpcyBiYWNrZ3JvdW5kZWQsIHRoZSBpbml0aWFsIHJlc2l6ZSBldmVudCBkb2VzIG5vdCBmaXJlIHVudGlsXG4gICAgICAvLyB0aGUgdGFiIGNvbWVzIGludG8gZm9jdXMgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd2aXNpYmlsaXR5IHJlc2l6ZSBvYnNlcnZlciBub3QgdHJpZ2dlcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0b3Agb2JzZXJ2aW5nIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oZWxlbWVudEluZm8pIHtcbiAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgdGhpcy5sb2cud2Fybignc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvIGlnbm9yZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdG9wRWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICBpbmZvLnN0b3BPYnNlcnZpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvICE9PSBlbGVtZW50SW5mbyk7XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIGxldCBkZXRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc3VwZXIuZGV0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBkZXRhY2hlZEVsZW1lbnRzID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBlIG9mIGRldGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZSk7XG4gICAgfVxuICAgIHJldHVybiBkZXRhY2hlZEVsZW1lbnRzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wcmV2U3RhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNvZGVySW1wbGVtZW50YXRpb247XG4gIH1cbiAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyIHx8ICF0aGlzLnJlY2VpdmVyLmdldFN0YXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XG4gICAgICBsZXQgY29kZWNJRCA9ICcnO1xuICAgICAgbGV0IGNvZGVjcyA9IG5ldyBNYXAoKTtcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICBjb2RlY0lEID0gdi5jb2RlY0lkO1xuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgZnJhbWVzRGVjb2RlZDogdi5mcmFtZXNEZWNvZGVkLFxuICAgICAgICAgICAgZnJhbWVzRHJvcHBlZDogdi5mcmFtZXNEcm9wcGVkLFxuICAgICAgICAgICAgZnJhbWVzUmVjZWl2ZWQ6IHYuZnJhbWVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IHYucGFja2V0c1JlY2VpdmVkLFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBkZWNvZGVySW1wbGVtZW50YXRpb246IHYuZGVjb2RlckltcGxlbWVudGF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcbiAgICAgICAgICBjb2RlY3Muc2V0KHYuaWQsIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNlaXZlclN0YXRzICYmIGNvZGVjSUQgIT09ICcnICYmIGNvZGVjcy5nZXQoY29kZWNJRCkpIHtcbiAgICAgICAgcmVjZWl2ZXJTdGF0cy5taW1lVHlwZSA9IGNvZGVjcy5nZXQoY29kZWNJRCkubWltZVR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgICB9KTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGluZm8pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5lbGVtZW50SW5mb3MucmVkdWNlKChwcmV2LCBpbmZvKSA9PiBNYXRoLm1heChwcmV2LCBpbmZvLnZpc2liaWxpdHlDaGFuZ2VkQXQgfHwgMCksIDApO1xuICAgIGNvbnN0IGJhY2tncm91bmRQYXVzZSA9ICgoX2IgPSAoX2EgPSB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVZpZGVvSW5CYWNrZ3JvdW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICkgPyB0aGlzLmlzSW5CYWNrZ3JvdW5kIDogZmFsc2U7XG4gICAgY29uc3QgaXNQaVBNb2RlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8ucGljdHVyZUluUGljdHVyZSk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8udmlzaWJsZSkgJiYgIWJhY2tncm91bmRQYXVzZSB8fCBpc1BpUE1vZGU7XG4gICAgaWYgKHRoaXMubGFzdFZpc2libGUgPT09IGlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVmlzaWJsZSAmJiBEYXRlLm5vdygpIC0gbGFzdFZpc2liaWxpdHlDaGFuZ2UgPCBSRUFDVElPTl9ERUxBWSkge1xuICAgICAgLy8gZGVsYXkgaGlkZGVuIGV2ZW50c1xuICAgICAgQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCBpc1Zpc2libGUsIHRoaXMpO1xuICB9XG4gIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxEZW5zaXR5KCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHRoaXMuZWxlbWVudEluZm9zKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudFdpZHRoID0gaW5mby53aWR0aCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRIZWlnaHQgPSBpbmZvLmhlaWdodCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50V2lkdGggKyBjdXJyZW50RWxlbWVudEhlaWdodCA+IG1heFdpZHRoICsgbWF4SGVpZ2h0KSB7XG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudEVsZW1lbnRXaWR0aDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudEVsZW1lbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gbWF4V2lkdGggJiYgKChfYiA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBtYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcbiAgfVxuICBnZXRQaXhlbERlbnNpdHkoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBpeGVsRGVuc2l0eTtcbiAgICBpZiAocGl4ZWxEZW5zaXR5ID09PSAnc2NyZWVuJykge1xuICAgICAgcmV0dXJuIGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB9IGVsc2UgaWYgKCFwaXhlbERlbnNpdHkpIHtcbiAgICAgIC8vIHdoZW4gdW5zZXQsIHdlJ2xsIHBpY2sgYSBzYW5lIGRlZmF1bHQgaGVyZS5cbiAgICAgIC8vIGZvciBoaWdoZXIgcGl4ZWwgZGVuc2l0eSBkZXZpY2VzIChtb2JpbGUgcGhvbmVzLCBldGMpLCB3ZSdsbCB1c2UgMlxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGRlZmF1bHRzIHRvIDFcbiAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyA+IDIpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpeGVsRGVuc2l0eTtcbiAgfVxufVxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIHtcbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaVAgfHwgdGhpcy5pc0ludGVyc2VjdGluZztcbiAgfVxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUDtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB2aXNpYmxlKSB7XG4gICAgdGhpcy5vblZpc2liaWxpdHlDaGFuZ2VkID0gZW50cnkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gZW50cnk7XG4gICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25FbnRlclBpUCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuaXNQaVAgPSB0cnVlO1xuICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm9uTGVhdmVQaVAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLmlzUGlQID0gZmFsc2U7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IHZpc2libGUgIT09IG51bGwgJiYgdmlzaWJsZSAhPT0gdm9pZCAwID8gdmlzaWJsZSA6IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gMDtcbiAgfVxuICB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoO1xuICB9XG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIGN1cnJlbnQgdmlzaWJsZSBzdGF0ZSBvbmNlIHdlIHN0YXJ0IHRvIG9ic2VydmVcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNFbGVtZW50SW5WaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuaXNQaVAgPSBkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gdGhpcy5lbGVtZW50O1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVJlc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XG4gICAgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgZ2V0UmVzaXplT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cbiAgc3RvcE9ic2VydmluZygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAoX2IgPSBnZXRSZXNpemVPYnNlcnZlcigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cbn1cbi8vIGRvZXMgbm90IGFjY291bnQgZm9yIG9jY2x1c2lvbiBieSBvdGhlciBlbGVtZW50c1xuZnVuY3Rpb24gaXNFbGVtZW50SW5WaWV3cG9ydChlbCkge1xuICBsZXQgdG9wID0gZWwub2Zmc2V0VG9wO1xuICBsZXQgbGVmdCA9IGVsLm9mZnNldExlZnQ7XG4gIGNvbnN0IHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgY29uc3Qge1xuICAgIGhpZGRlblxuICB9ID0gZWw7XG4gIGNvbnN0IHtcbiAgICBvcGFjaXR5LFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XG4gICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgdG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gIH1cbiAgcmV0dXJuIHRvcCA8IHdpbmRvdy5wYWdlWU9mZnNldCArIHdpbmRvdy5pbm5lckhlaWdodCAmJiBsZWZ0IDwgd2luZG93LnBhZ2VYT2Zmc2V0ICsgd2luZG93LmlubmVyV2lkdGggJiYgdG9wICsgaGVpZ2h0ID4gd2luZG93LnBhZ2VZT2Zmc2V0ICYmIGxlZnQgKyB3aWR0aCA+IHdpbmRvdy5wYWdlWE9mZnNldCAmJiAhaGlkZGVuICYmIChvcGFjaXR5ICE9PSAnJyA/IHBhcnNlRmxvYXQob3BhY2l0eSkgPiAwIDogdHJ1ZSkgJiYgZGlzcGxheSAhPT0gJ25vbmUnO1xufVxuXG5jbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihraW5kLCBpZCwgbmFtZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWV0YWRhdGFNdXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUHVibGljYXRpb24pO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gdGhpcy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMudHJhY2tTaWQgPSBpZDtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICAvLyBmb3J3YXJkIGV2ZW50c1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpKTtcbiAgfVxuICBnZXQgaXNNdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YU11dGVkO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgfVxuICAvKipcbiAgICogYW4gW0F1ZGlvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYW4gYXVkaW8gdHJhY2tcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcbiAgICovXG4gIGdldCB2aWRlb1RyYWNrKCkge1xuICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrIHx8IHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xuICAgIHRoaXMubWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHRcbiAgICAgIH07XG4gICAgICB0aGlzLnNpbXVsY2FzdGVkID0gaW5mby5zaW11bGNhc3Q7XG4gICAgfVxuICAgIHRoaXMuZW5jcnlwdGlvbiA9IGluZm8uZW5jcnlwdGlvbjtcbiAgICB0aGlzLnRyYWNrSW5mbyA9IGluZm87XG4gICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0ZSBwdWJsaWNhdGlvbiBpbmZvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBpbmZvXG4gICAgfSkpO1xuICB9XG59XG4oZnVuY3Rpb24gKFRyYWNrUHVibGljYXRpb24pIHtcbiAgKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25TdGF0dXMpIHtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJEZXNpcmVkXCJdID0gXCJkZXNpcmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG4gIChmdW5jdGlvbiAoUGVybWlzc2lvblN0YXR1cykge1xuICAgIFBlcm1pc3Npb25TdGF0dXNbXCJBbGxvd2VkXCJdID0gXCJhbGxvd2VkXCI7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdF9hbGxvd2VkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyB8fCAoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzID0ge30pKTtcbn0pKFRyYWNrUHVibGljYXRpb24gfHwgKFRyYWNrUHVibGljYXRpb24gPSB7fSkpO1xuXG5jbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZDtcbiAgfVxuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgdHJhY2ssIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgICB0aGlzLnNldFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNNdXRlZCgpIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLmF1ZGlvVHJhY2s7XG4gIH1cbiAgZ2V0IHZpZGVvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIE11dGUgdGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBtdXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tdXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgdW5tdXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm11dGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF1c2VzIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gZnJvbSBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHNpZ25hbHMgXCJtdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGF1c2UgdGhlIHN0cmVhbSB3aXRob3V0IHBhdXNpbmcgdGhlIGxvY2FsIG1lZGlhIHN0cmVhbSB0cmFja1xuICAgKi9cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cbiAgICogYW5kIHNpZ25hbHMgXCJ1bm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzICh1bmxlc3MgdGhlIHRyYWNrIGlzIGV4cGxpY2l0bHkgbXV0ZWQpXG4gICAqL1xuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkdvb2RcIl0gPSBcImdvb2RcIjtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJQb29yXCJdID0gXCJwb29yXCI7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHBhcnRpY2lwYW50IGhhcyB0ZW1wb3JhcmlseSAob3IgcGVybWFuZW50bHkpIGxvc3QgY29ubmVjdGlvbiB0byBMaXZlS2l0LlxuICAgKiBGb3IgcGVybWFuZW50IGRpc2Nvbm5lY3Rpb24gYSBgUGFydGljaXBhbnREaXNjb25uZWN0ZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBhZnRlciBhIHRpbWVvdXRcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiTG9zdFwiXSA9IFwibG9zdFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbn0pKENvbm5lY3Rpb25RdWFsaXR5IHx8IChDb25uZWN0aW9uUXVhbGl0eSA9IHt9KSk7XG5mdW5jdGlvbiBxdWFsaXR5RnJvbVByb3RvKHEpIHtcbiAgc3dpdGNoIChxKSB7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkVYQ0VMTEVOVDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5FeGNlbGxlbnQ7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkdPT0Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuR29vZDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuUE9PUjpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5MT1NUOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkxvc3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICB9XG59XG5jbGFzcyBQYXJ0aWNpcGFudCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSksIHtcbiAgICAgIHBhcnRpY2lwYW50U2lkOiB0aGlzLnNpZCxcbiAgICAgIHBhcnRpY2lwYW50SWQ6IHRoaXMuaWRlbnRpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzLnNpemUgPiAwICYmIEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmV2ZXJ5KHRyID0+IHRyLmlzRW5jcnlwdGVkKTtcbiAgfVxuICBnZXQgaXNBZ2VudCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWdlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogYXVkaW8gbGV2ZWwgYmV0d2VlbiAwLTEuMCwgMSBiZWluZyBsb3VkZXN0LCAwIGJlaW5nIHNvZnRlc3QgKi9cbiAgICB0aGlzLmF1ZGlvTGV2ZWwgPSAwO1xuICAgIC8qKiBpZiBwYXJ0aWNpcGFudCBpcyBjdXJyZW50bHkgc3BlYWtpbmcgKi9cbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMgPT09IG51bGwgfHwgbG9nZ2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QYXJ0aWNpcGFudCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFja3MgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0VHJhY2tzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgc291cmNlIGZpbHRlciwgZm9yIGV4YW1wbGUsIGdldHRpbmdcbiAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxuICAgKiBAcGFyYW0gc291cmNlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUcmFjayhzb3VyY2UpIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja3MpIHtcbiAgICAgIGlmIChwdWIuc291cmNlID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrQnlOYW1lKG5hbWUpIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja3MpIHtcbiAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBjb25uZWN0aW9uUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gIH1cbiAgZ2V0IGlzQ2FtZXJhRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNNaWNyb3Bob25lRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICByZXR1cm4gISgoX2EgPSB0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2suaXNNdXRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XG4gIH1cbiAgZ2V0IGlzU2NyZWVuU2hhcmVFbmFibGVkKCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpO1xuICAgIHJldHVybiAhIXRyYWNrO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb20gKi9cbiAgZ2V0IGpvaW5lZEF0KCkge1xuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0aGlzLnBhcnRpY2lwYW50SW5mby5qb2luZWRBdC50b1N0cmluZygpKSAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIHVwZGF0ZSBjb3VsZCBiZSBhcHBsaWVkIG91dCBvZiBvcmRlciBkdWUgdG8gYXdhaXRcbiAgICAvLyBkdXJpbmcgcmVjb25uZWN0IHNlcXVlbmNlcy4gd2hlbiB0aGF0IGhhcHBlbnMsIGl0J3MgcG9zc2libGUgZm9yIHNlcnZlclxuICAgIC8vIHRvIGhhdmUgc2VudCBtb3JlIHJlY2VudCB2ZXJzaW9uIG9mIHBhcnRpY2lwYW50IGluZm8gd2hpbGUgSlMgaXMgd2FpdGluZ1xuICAgIC8vIHRvIHByb2Nlc3MgdGhlIGV4aXN0aW5nIHBheWxvYWQuXG4gICAgLy8gd2hlbiB0aGUgcGFydGljaXBhbnQgc2lkIHJlbWFpbnMgdGhlIHNhbWUsIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBsYXRlciB2ZXJzaW9uXG4gICAgLy8gb2YgdGhlIHBheWxvYWQsIHRoZXkgY2FuIGJlIHNhZmVseSBza2lwcGVkXG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvICYmIHRoaXMucGFydGljaXBhbnRJbmZvLnNpZCA9PT0gaW5mby5zaWQgJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8udmVyc2lvbiA+IGluZm8udmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlkZW50aXR5ID0gaW5mby5pZGVudGl0eTtcbiAgICB0aGlzLnNpZCA9IGluZm8uc2lkO1xuICAgIHRoaXMuX3NldE5hbWUoaW5mby5uYW1lKTtcbiAgICB0aGlzLl9zZXRNZXRhZGF0YShpbmZvLm1ldGFkYXRhKTtcbiAgICBpZiAoaW5mby5wZXJtaXNzaW9uKSB7XG4gICAgICB0aGlzLnNldFBlcm1pc3Npb25zKGluZm8ucGVybWlzc2lvbik7XG4gICAgfVxuICAgIC8vIHNldCB0aGlzIGxhc3Qgc28gc2V0TWV0YWRhdGEgY2FuIGRldGVjdCBjaGFuZ2VzXG4gICAgdGhpcy5wYXJ0aWNpcGFudEluZm8gPSBpbmZvO1xuICAgIHRoaXMubG9nLnRyYWNlKCd1cGRhdGUgcGFydGljaXBhbnQgaW5mbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgaW5mb1xuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBtZXRhZGF0YSBmcm9tIHNlcnZlclxuICAgKiovXG4gIF9zZXRNZXRhZGF0YShtZCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHByZXZNZXRhZGF0YSk7XG4gICAgfVxuICB9XG4gIF9zZXROYW1lKG5hbWUpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5uYW1lICE9PSBuYW1lO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2gpIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZSAhPT0gKChfYiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5TdWJzY3JpYmUpIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSAoKF9jID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhblB1Ymxpc2hEYXRhKSB8fCBwZXJtaXNzaW9ucy5oaWRkZW4gIT09ICgoX2QgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGlkZGVuKSB8fCBwZXJtaXNzaW9ucy5yZWNvcmRlciAhPT0gKChfZSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWNvcmRlcikgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5QdWJsaXNoU291cmNlc1tpbmRleF0pO1xuICAgIH0pO1xuICAgIHRoaXMucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucztcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0SXNTcGVha2luZyhzcGVha2luZykge1xuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgIGlmIChzcGVha2luZykge1xuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRDb25uZWN0aW9uUXVhbGl0eShxKSB7XG4gICAgY29uc3QgcHJldlF1YWxpdHkgPSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IHF1YWxpdHlGcm9tUHJvdG8ocSk7XG4gICAgaWYgKHByZXZRdWFsaXR5ICE9PSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChjdHgpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGN0eDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzLmZvckVhY2godHJhY2sgPT4gKHRyYWNrLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjayB8fCB0cmFjay50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykgJiYgdHJhY2sudHJhY2suc2V0QXVkaW9Db250ZXh0KGN0eCkpO1xuICB9XG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcbiAgICAvLyBmb3J3YXJkIHB1YmxpY2F0aW9uIGRyaXZlbiBldmVudHNcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50Lk11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBwdWIgPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICBwdWIudHJhY2suc2lkID0gcHVibGljYXRpb24udHJhY2tTaWQ7XG4gICAgfVxuICAgIHRoaXMudHJhY2tzLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXMpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICghcGVybXMucGFydGljaXBhbnRTaWQgJiYgIXBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhY2sgcGVybWlzc2lvbiwgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBvZiBwYXJ0aWNpcGFudElkZW50aXR5IGFuZCBwYXJ0aWNpcGFudFNpZCcpO1xuICB9XG4gIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKHtcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiAoX2EgPSBwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICBwYXJ0aWNpcGFudFNpZDogKF9iID0gcGVybXMucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgIGFsbFRyYWNrczogKF9jID0gcGVybXMuYWxsb3dBbGwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxuICAgIHRyYWNrU2lkczogcGVybXMuYWxsb3dlZFRyYWNrU2lkcyB8fCBbXVxuICB9KTtcbn1cblxuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgYXV0b1N1YnNjcmliZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB2aXNpYmxlID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gdmlzaWJpbGl0eSBcIi5jb25jYXQodGhpcy50cmFja1NpZCwgXCIsIHZpc2libGU9XCIpLmNvbmNhdCh2aXNpYmxlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSA9IGRpbWVuc2lvbnMgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zIFwiLmNvbmNhdChkaW1lbnNpb25zLndpZHRoLCBcInhcIikuY29uY2F0KGRpbWVuc2lvbnMuaGVpZ2h0KSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB0byB0aGlzIHJlbW90ZSB0cmFja1xuICAgKiBAcGFyYW0gc3Vic2NyaWJlZCB0cnVlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBmYWxzZSB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgc2V0U3Vic2NyaWJlZChzdWJzY3JpYmVkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgLy8gcmVzZXQgYWxsb3dlZCBzdGF0dXMgd2hlbiBkZXNpcmVkIHN1YnNjcmlwdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAgLy8gc2VydmVyIHdpbGwgbm90aWZ5IGNsaWVudCB2aWEgc2lnbmFsIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxsb3dlZFxuICAgIGlmIChzdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWIgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrczogW25ldyBQYXJ0aWNpcGFudFRyYWNrcyh7XG4gICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgIHBhcnRpY2lwYW50U2lkOiAnJyxcbiAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF1cbiAgICAgIH0pXVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gIH1cbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlVuc3Vic2NyaWJlZDtcbiAgICB9XG4gICAgaWYgKCFzdXBlci5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5EZXNpcmVkO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuU3Vic2NyaWJlZDtcbiAgfVxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkID8gVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLkFsbG93ZWQgOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuTm90QWxsb3dlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICovXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzU3Vic2NyaWJlZDtcbiAgfVxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xuICB9XG4gIC8qKlxuICAgKiBkaXNhYmxlIHNlcnZlciBmcm9tIHNlbmRpbmcgZG93biBkYXRhIGZvciB0aGlzIHRyYWNrLiB0aGlzIGlzIHVzZWZ1bCB3aGVuXG4gICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cbiAgICogdG8gcmVkdWNlIGJhbmR3aWR0aCByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIGVuYWJsZWRcbiAgICovXG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmRpc2FibGVkID09PSAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVkID0gIWVuYWJsZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogZm9yIHRyYWNrcyB0aGF0IHN1cHBvcnQgc2ltdWxjYXN0aW5nLCBhZGp1c3Qgc3Vic2NyaWJlZCBxdWFsaXR5XG4gICAqXG4gICAqIFRoaXMgaW5kaWNhdGVzIHRoZSBoaWdoZXN0IHF1YWxpdHkgdGhlIGNsaWVudCBjYW4gYWNjZXB0LiBpZiBuZXR3b3JrXG4gICAqIGJhbmR3aWR0aCBkb2VzIG5vdCBhbGxvdywgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgcXVhbGl0eSB0b1xuICAgKiBvcHRpbWl6ZSBmb3IgdW5pbnRlcnJ1cHRlZCB2aWRlb1xuICAgKi9cbiAgc2V0VmlkZW9RdWFsaXR5KHF1YWxpdHkpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID09PSBxdWFsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBzZXRWaWRlb0RpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IGRpbWVuc2lvbnMud2lkdGggJiYgKChfYiA9IHRoaXMudmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gZGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIHNldFZpZGVvRlBTKGZwcykge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlVmlkZW9UcmFjaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnBzID09PSBmcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBnZXQgdmlkZW9RdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBjb25zdCBwcmV2VHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIGlmIChwcmV2VHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmV2VHJhY2spIHtcbiAgICAgIC8vIHVucmVnaXN0ZXIgbGlzdGVuZXJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgcHJldlRyYWNrLmRldGFjaCgpO1xuICAgICAgcHJldlRyYWNrLnN0b3BNb25pdG9yKCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZUcmFjayk7XG4gICAgfVxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnNpZCA9IHRoaXMudHJhY2tTaWQ7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0QWxsb3dlZChhbGxvd2VkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHN1cGVyLnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhTXV0ZWQgPSB0aGlzLm1ldGFkYXRhTXV0ZWQ7XG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gaW5mby5tdXRlZDtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5zZXRNdXRlZChpbmZvLm11dGVkKTtcbiAgICB9IGVsc2UgaWYgKHByZXZNZXRhZGF0YU11dGVkICE9PSBpbmZvLm11dGVkKSB7XG4gICAgICB0aGlzLmVtaXQoaW5mby5tdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQpO1xuICAgIH1cbiAgfVxuICBlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gY3VycmVudFN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBjdXJyZW50U3RhdHVzLCBwcmV2aW91c1N0YXR1cyk7XG4gIH1cbiAgZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzICE9PSBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCB0aGlzLnBlcm1pc3Npb25TdGF0dXMsIHByZXZpb3VzUGVybWlzc2lvblN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIHRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgdGhpcy5sb2cud2FybignYWRhcHRpdmUgc3RyZWFtIGlzIGVuYWJsZWQsIGNhbm5vdCBjaGFuZ2UgdmlkZW8gdHJhY2sgc2V0dGluZ3MnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXNpcmVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjYW5ub3QgdXBkYXRlIHRyYWNrIHNldHRpbmdzIHdoZW4gbm90IHN1YnNjcmliZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2sgJiYgdGhpcy50cmFjay5pc0FkYXB0aXZlU3RyZWFtO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBlbWl0VHJhY2tVcGRhdGUoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncyh7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgZnBzOiB0aGlzLmZwc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50LCBwaSkge1xuICAgIHJldHVybiBuZXcgUmVtb3RlUGFydGljaXBhbnQoc2lnbmFsQ2xpZW50LCBwaS5zaWQsIHBpLmlkZW50aXR5LCBwaS5uYW1lLCBwaS5tZXRhZGF0YSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSB8fCAnJywgbmFtZSwgbWV0YWRhdGEsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKSB7XG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgLy8gcmVnaXN0ZXIgYWN0aW9uIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kIHVwZGF0ZSBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViID0+IHtcbiAgICAgIHN1Yi5wYXJ0aWNpcGFudFRyYWNrcy5mb3JFYWNoKHB0ID0+IHtcbiAgICAgICAgcHQucGFydGljaXBhbnRTaWQgPSB0aGlzLnNpZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHN0YXR1cyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHN0YXR1cyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2sgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBwdWJsaWNhdGlvbi50cmFja1NpZCwgZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldFRyYWNrKHNvdXJjZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2soc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgZ2V0VHJhY2tCeU5hbWUobmFtZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgYXVkaW8gdHJhY2tcbiAgICogYnkgZGVmYXVsdCwgdGhpcyBhZmZlY3RzIHRoZSBtaWNyb3Bob25lIHB1YmxpY2F0aW9uXG4gICAqIGEgZGlmZmVyZW50IHNvdXJjZSBjYW4gYmUgcGFzc2VkIGluIGFzIGEgc2Vjb25kIGFyZ3VtZW50XG4gICAqIGlmIG5vIHRyYWNrIGV4aXN0cyB0aGUgdm9sdW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBtaWNyb3Bob25lIHRyYWNrIGlzIGFkZGVkXG4gICAqL1xuICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgdGhpcy52b2x1bWVNYXAuc2V0KHNvdXJjZSwgdm9sdW1lKTtcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmIChhdWRpb1B1YmxpY2F0aW9uICYmIGF1ZGlvUHVibGljYXRpb24udHJhY2spIHtcbiAgICAgIGF1ZGlvUHVibGljYXRpb24udHJhY2suc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgbWljcm9waG9uZSB0cmFja1xuICAgKi9cbiAgZ2V0Vm9sdW1lKCkge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgcmV0dXJuIGF1ZGlvUHVibGljYXRpb24udHJhY2suZ2V0Vm9sdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZvbHVtZU1hcC5nZXQoc291cmNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQpIHtcbiAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc2lkKTtcbiAgICAvLyBpdCdzIGFsc28gcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBkaWRuJ3QgaG9ub3Igb3VyIG9yaWdpbmFsIHRyYWNrIGlkXG4gICAgLy8gRmlyZUZveCB3b3VsZCB1c2UgaXRzIG93biBsb2NhbCB1dWlkIGluc3RlYWQgb2Ygc2VydmVyIHRyYWNrIGlkXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKCFzaWQuc3RhcnRzV2l0aCgnVFInKSkge1xuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdHlwZVxuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIGlmICghcHVibGljYXRpb24gJiYgbWVkaWFUcmFjay5raW5kID09PSBwLmtpbmQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgcHVibGljYXRpb24gPSBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdoZW4gd2UgY291bGRuJ3QgbG9jYXRlIHRoZSB0cmFjaywgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBtZXRhZGF0YSBoYXNuJ3RcbiAgICAvLyB5ZXQgYXJyaXZlZC4gV2FpdCBhIGJpdCBsb25nZXIgZm9yIGl0IHRvIGFycml2ZSwgb3IgZmlyZSBhbiBlcnJvclxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiBzaWRcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gdW5kZWZpbmVkKSB0cmllc0xlZnQgPSAyMDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQgLSAxKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYVRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCd1bmFibGUgdG8gc3Vic2NyaWJlIGJlY2F1c2UgTWVkaWFTdHJlYW1UcmFjayBpcyBlbmRlZC4gRG8gbm90IGNhbGwgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCknLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNWaWRlbyA9IG1lZGlhVHJhY2sua2luZCA9PT0gJ3ZpZGVvJztcbiAgICBsZXQgdHJhY2s7XG4gICAgaWYgKGlzVmlkZW8pIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZVZpZGVvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZUF1ZGlvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgdGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXVkaW9PdXRwdXQpO1xuICAgIH1cbiAgICAvLyBzZXQgdHJhY2sgaW5mb1xuICAgIHRyYWNrLnNvdXJjZSA9IHB1YmxpY2F0aW9uLnNvdXJjZTtcbiAgICAvLyBrZWVwIHB1YmxpY2F0aW9uJ3MgbXV0ZWQgc3RhdHVzXG4gICAgdHJhY2suaXNNdXRlZCA9IHB1YmxpY2F0aW9uLmlzTXV0ZWQ7XG4gICAgdHJhY2suc2V0TWVkaWFTdHJlYW0obWVkaWFTdHJlYW0pO1xuICAgIHRyYWNrLnN0YXJ0KCk7XG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodHJhY2spO1xuICAgIC8vIHNldCBwYXJ0aWNpcGFudCB2b2x1bWVzIG9uIG5ldyBhdWRpbyB0cmFja3NcbiAgICBpZiAodGhpcy52b2x1bWVNYXAuaGFzKHB1YmxpY2F0aW9uLnNvdXJjZSkgJiYgdHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgaGFzTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXJ0aWNpcGFudEluZm87XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzaWQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3MuZ2V0KHNpZCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxuICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcbiAgICAvLyByZWNvbmNpbGUgdHJhY2sgcHVibGljYXRpb25zLCBwdWJsaXNoIGV2ZW50cyBvbmx5IGlmIG1ldGFkYXRhIGlzIGFscmVhZHkgdGhlcmVcbiAgICAvLyBpLmUuIGNoYW5nZXMgc2luY2UgdGhlIGxvY2FsIHBhcnRpY2lwYW50IGhhcyBqb2luZWRcbiAgICBjb25zdCB2YWxpZFRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBuZXdUcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oa2luZCwgdGksIChfYSA9IHRoaXMuc2lnbmFsQ2xpZW50LmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1N1YnNjcmliZSwge1xuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIGxvZ2dlck5hbWU6IChfYiA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxvZ2dlck5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICBuZXdUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5zb3VyY2UpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiBwdWJsaWNhdGlvbi5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJyZWNlaXZlZCBhIHNlY29uZCB0cmFjayBwdWJsaWNhdGlvbiBmb3IgXCIuY29uY2F0KHRoaXMuaWRlbnRpdHksIFwiIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIikuY29uY2F0KHB1YmxpY2F0aW9uLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgb2xkVHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdUcmFja09mU291cmNlKSxcbiAgICAgICAgICAgIG5ld1RyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICB9XG4gICAgICB2YWxpZFRyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgLy8gZGV0ZWN0IHJlbW92ZWQgdHJhY2tzXG4gICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICBpZiAoIXZhbGlkVHJhY2tzLmhhcyhwdWJsaWNhdGlvbi50cmFja1NpZCkpIHtcbiAgICAgICAgdGhpcy5sb2cudHJhY2UoJ2RldGVjdGVkIHJlbW92ZWQgdHJhY2sgb24gcmVtb3RlIHBhcnRpY2lwYW50LCB1bnB1Ymxpc2hpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGFsd2F5cyBlbWl0IGV2ZW50cyBmb3IgbmV3IHB1YmxpY2F0aW9ucywgUm9vbSB3aWxsIG5vdCBmb3J3YXJkIHRoZW0gdW5sZXNzIGl0J3MgcmVhZHlcbiAgICBuZXdUcmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdW5wdWJsaXNoVHJhY2soc2lkLCBzZW5kVW5wdWJsaXNoKSB7XG4gICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLnRyYWNrcy5nZXQoc2lkKTtcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFsc28gc2VuZCB1bnN1YnNjcmliZSwgaWYgdHJhY2sgaXMgYWN0aXZlbHkgc3Vic2NyaWJlZFxuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNrXG4gICAgfSA9IHB1YmxpY2F0aW9uO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHRyYWNrIGZyb20gbWFwcyBvbmx5IGFmdGVyIHVuc3Vic2NyaWJlZCBoYXMgYmVlbiBmaXJlZFxuICAgIHRoaXMudHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZW5kVW5wdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvT3V0cHV0KG91dHB1dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmF1ZGlvT3V0cHV0ID0gb3V0cHV0O1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwdWIudHJhY2suc2V0U2lua0lkKChfYSA9IG91dHB1dC5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2RlZmF1bHQnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB0aGlzLmxvZy50cmFjZSgncGFydGljaXBhbnQgZXZlbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGV2ZW50LFxuICAgICAgYXJnc1xuICAgIH0pKTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cblxuY2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBlbmdpbmUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmVuZ2luZS5sb2dDb250ZXh0XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSA9IHRydWU7XG4gICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5yZWNvbm5lY3RGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKHRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlLnByb21pc2UuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKGUubWVzc2FnZSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ0dvdCBkaXNjb25uZWN0ZWQgZHVyaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHRyYWNrIHN1YnNjcmlwdGlvbiBwZXJtaXNzaW9ucycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkOiB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyh0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSwgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMubWFwKHAgPT4gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwKSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMub25UcmFja1VubXV0ZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNVcHN0cmVhbVBhdXNlZCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHRoZSBsb2NhbCB0cmFjayBjaGFuZ2VzIGluIG11dGUgc3RhdHVzLCB3ZSdsbCBub3RpZnkgc2VydmVyIGFzIHN1Y2hcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrTXV0ZWQgPSAodHJhY2ssIG11dGVkKSA9PiB7XG4gICAgICBpZiAobXV0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtdXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLnNpZCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IHVwZGF0ZSBtdXRlIHN0YXR1cyBmb3IgdW5wdWJsaXNoZWQgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5naW5lLnVwZGF0ZU11dGVTdGF0dXModHJhY2suc2lkLCBtdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSBwYXVzZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcmVzdW1lZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc011dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgIHZhciBfZCwgX2U7XG4gICAgICBpZiAoISgoX2QgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHluYWNhc3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja3MuZ2V0KHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdyZWNlaXZlZCBzdWJzY3JpYmVkIHF1YWxpdHkgdXBkYXRlIGZvciB1bmtub3duIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHVwZGF0ZS50cmFja1NpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghcHViLnZpZGVvVHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29kZWNzID0geWllbGQgcHViLnZpZGVvVHJhY2suc2V0UHVibGlzaGluZ0NvZGVjcyh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBuZXdDb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMobmV3Q29kZWNzKSwgbmV3Q29kZWNzXzFfMTsgbmV3Q29kZWNzXzFfMSA9IHlpZWxkIG5ld0NvZGVjc18xLm5leHQoKSwgX2EgPSBuZXdDb2RlY3NfMV8xLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICBfYyA9IG5ld0NvZGVjc18xXzEudmFsdWU7XG4gICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSBfYztcbiAgICAgICAgICAgIGlmIChpc0JhY2t1cENvZGVjKGNvZGVjKSkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2ggXCIuY29uY2F0KGNvZGVjLCBcIiBmb3IgXCIpLmNvbmNhdChwdWIudmlkZW9UcmFjay5zaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSkpO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgZV8xID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gbmV3Q29kZWNzXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChuZXdDb2RlY3NfMSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCAoX2UgPSBwdWIudmlkZW9UcmFjaykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNldFB1Ymxpc2hpbmdMYXllcnModXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5wdWJsaXNoZWQgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrcy5nZXQodW5wdWJsaXNoZWQudHJhY2tTaWQpO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdyZWNlaXZlZCB1bnB1Ymxpc2hlZCBldmVudCBmb3IgdW5rbm93biB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2spO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gdHJhY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyBsb2NhbCB0cmFjayBkdWUgdG8gVHJhY2tFbmRlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zID0geWllbGQgbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGVybWlzc2lvbiBxdWVyeSBmb3IgY2FtZXJhIGFuZCBtaWNyb3Bob25lIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihcInVzZXIgaGFzIHJldm9rZWQgYWNjZXNzIHRvIFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGdyYW50ZWQgY2hhbmdlIGFmdGVyIHBlcm1pc3Npb25zIHdlcmUgZGVuaWVkIHRvIHRyeSBhbmQgcmVzdW1lIHRoZW5cbiAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zLnN0YXRlICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRVc2VyTWVkaWEgUGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd0cmFjayBlbmRlZCwgYXR0ZW1wdGluZyB0byB1c2UgYSBkaWZmZXJlbnQgZGV2aWNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcImNvdWxkIG5vdCByZXN0YXJ0IHRyYWNrLCBtdXRpbmcgaW5zdGVhZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgIHRoaXMucm9vbU9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2V0dXBFbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLmFjdGl2ZURldmljZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgbGFzdENhbWVyYUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xuICB9XG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLm1pY3JvcGhvbmVFcnJvcjtcbiAgfVxuICBnZXQgaXNFMkVFRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgZ2V0VHJhY2soc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja0J5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja3MuZ2V0KHRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIHB1Yi5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWIudW5tdXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKS5vbihFbmdpbmVFdmVudC5SZXN1bWluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKS5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBUaGUgY2hhbmdlIGRvZXMgbm90IHRha2UgaW1tZWRpYXRlIGVmZmVjdC5cbiAgICogSWYgc3VjY2Vzc2Z1bCwgYSBgUGFydGljaXBhbnRFdmVudC5NZXRhZGF0YUNoYW5nZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YSwgKF9hID0gdGhpcy5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBUaGUgY2hhbmdlIGRvZXMgbm90IHRha2UgaW1tZWRpYXRlIGVmZmVjdC5cbiAgICogSWYgc3VjY2Vzc2Z1bCwgYSBgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAqL1xuICBzZXROYW1lKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKChfYSA9IHRoaXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHN1cGVyLnNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICBpZiAoY2hhbmdlZCAmJiBwcmV2UGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEUyRUVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRUcmFja0VuYWJsZWQoc291cmNlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXRUcmFja0VuYWJsZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9KSk7XG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB5aWVsZCB0cmFjay51bm11dGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbG9jYWxUcmFja3M7XG4gICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIGR1cGxpY2F0ZSBwdWJsaXNoZWQgc291cmNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvOiAoX2EgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICBhdWRpbzogKF9iID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlU2NyZWVuVHJhY2tzKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3B1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sobG9jYWxUcmFjaykpKTtcbiAgICAgICAgICAgICAgcHVibGlzaFByb21pc2VzLnB1c2godGhpcy5wdWJsaXNoVHJhY2sobG9jYWxUcmFjaywgcHVibGlzaE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IHlpZWxkIFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgICAvLyBmb3Igc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9ucyBpbmNsdWRpbmcgYXVkaW8sIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9uLCBub3QgdGhlIHNjcmVlbiBzaGFyZSBhdWRpbyBvbmVcbiAgICAgICAgICAgIC8vIHJldmlzaXQgaWYgd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgdHJhY2tzIGluc3RlYWQgZm9yIHYyXG4gICAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICAgICAgdHIuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmICEoZSBpbnN0YW5jZW9mIFRyYWNrSW52YWxpZEVycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayAmJiB0cmFjay50cmFjaykge1xuICAgICAgICAvLyBzY3JlZW5zaGFyZSBjYW5ub3QgYmUgbXV0ZWQsIHVucHVibGlzaCBpbnN0ZWFkXG4gICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgIHRyYWNrID0geWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW9UcmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pO1xuICAgICAgICAgIGlmIChzY3JlZW5BdWRpb1RyYWNrICYmIHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGJvdGggY2FtZXJhIGFuZCBtaWNyb3Bob25lIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBkaXNwbGF5aW5nIGEgc2luZ2xlIFBlcm1pc3Npb24gRGlhbG9nIGJveCB0byB0aGUgZW5kIHVzZXIuXG4gICAqL1xuICBlbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHwgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpKSB7XG4gICAgICAgIC8vIG5vLW9wIGl0J3MgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0cmFjayA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjcmVhdGVUcmFja3Mob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdWRpb0NhcHR1cmVEZWZhdWx0cywgKF9iID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuICAgICAgbGV0IHN0cmVhbTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJlYW0uZ2V0VHJhY2tzKCkubWFwKG1lZGlhU3RyZWFtVHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBpc0F1ZGlvID0gbWVkaWFTdHJlYW1UcmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgICBpc0F1ZGlvID8gb3B0aW9ucy5hdWRpbyA6IG9wdGlvbnMudmlkZW87XG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxNygpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgICAvLyBkdWUgdG8gZW5jb2RpbmcgYSBodWdlIHZpZGVvLiBFbmNvZGluZyBzdWNoIGxhcmdlIHN1cmZhY2VzIGlzIHJlYWxseSBleHBlbnNpdmVcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSBTYWZhcmkgMTcgaGFzIGEgYnV0IGFuZCBjYW5ub3QgYmUgY29uc3RyYWluZWQgYnkgZGVmYXVsdFxuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgaWYgKG9wdGlvbnMuY29udGVudEhpbnQpIHtcbiAgICAgICAgc2NyZWVuVmlkZW8ubWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9IG9wdGlvbnMuY29udGVudEhpbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IFtzY3JlZW5WaWRlb107XG4gICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGEgbmV3IHRyYWNrIHRvIHRoZSByb29tXG4gICAqIEBwYXJhbSB0cmFja1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2U7XG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrICYmIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5oYXModHJhY2spKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5nZXQodHJhY2spO1xuICAgICAgfVxuICAgICAgbGV0IGRlZmF1bHRDb25zdHJhaW50cztcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gYWNjZXNzIGNvbnN0cmFpbnRzIGRpcmVjdGx5IGFzIGB0cmFjay5tZWRpYVN0cmVhbVRyYWNrYFxuICAgICAgICAvLyBtaWdodCBiZSBwb2ludGluZyB0byBhIG5vbi1kZXZpY2UgdHJhY2sgKGUuZy4gcHJvY2Vzc2VkIHRyYWNrKSBhbHJlYWR5XG4gICAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IHRyYWNrLmNvbnN0cmFpbnRzO1xuICAgICAgICBsZXQgZGV2aWNlS2luZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoICh0cmFjay5zb3VyY2UpIHtcbiAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgZGV2aWNlS2luZCA9ICdhdWRpb2lucHV0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcbiAgICAgICAgICAgIGRldmljZUtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldmljZUtpbmQgJiYgdGhpcy5hY3RpdmVEZXZpY2VNYXAuaGFzKGRldmljZUtpbmQpKSB7XG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uc3RyYWludHMpLCB7XG4gICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgcmF3IG1lZGlhIHRyYWNrIGludG8gYXVkaW8gb3IgdmlkZW8gdHJhY2tcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XG4gICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIHRoaXMuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIHtcbiAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kIFwiLmNvbmNhdCh0cmFjay5raW5kKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrLnVwZGF0ZUxvZ2dlck9wdGlvbnMoe1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgfVxuICAgICAgLy8gaXMgaXQgYWxyZWFkeSBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbikpKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0ZXJlb0lucHV0ID0gJ2NoYW5uZWxDb3VudCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpICYmXG4gICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCA9PT0gMiB8fCB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCkuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgY29uc3QgaXNTdGVyZW8gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2VTdGVyZW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzU3RlcmVvSW5wdXQ7XG4gICAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcbiAgICAgIGlmIChpc1N0ZXJlbykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZHR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiT3B1cyBEVFggd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbyhcIk9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuXCIpO1xuICAgICAgICB9XG4gICAgICAgIChfYyA9IG9wdGlvbnMuZHR4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBvcHRpb25zLmR0eCA9IGZhbHNlO1xuICAgICAgICAoX2QgPSBvcHRpb25zLnJlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3B0aW9ucy5yZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICAvLyBkaXNhYmxlIHNpbXVsY2FzdCBpZiBlMmVlIGlzIHNldCBvbiBzYWZhcmlcbiAgICAgIGlmIChpc1NhZmFyaSgpICYmIHRoaXMucm9vbU9wdGlvbnMuZTJlZSkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiRW5kLXRvLWVuZCBlbmNyeXB0aW9uIGlzIHNldCB1cCwgc2ltdWxjYXN0IHB1Ymxpc2hpbmcgd2lsbCBiZSBkaXNhYmxlZCBvbiBTYWZhcmlcIiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5zb3VyY2UpIHtcbiAgICAgICAgdHJhY2suc291cmNlID0gb3B0cy5zb3VyY2U7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZSA9IHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLnNldCh0cmFjaywgcHVibGlzaFByb21pc2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX287XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrICYmIHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gdHJhY2suc291cmNlKTtcbiAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwicHVibGlzaGluZyBhIHNlY29uZCB0cmFjayB3aXRoIHRoZSBzYW1lIHNvdXJjZTogXCIuY29uY2F0KHRyYWNrLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiB0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgICB0cmFjay5zdG9wT25NdXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBpc0ZpcmVGb3goKSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxuICAgICAgICAvLyB3ZSBmcmVxdWVudGx5IGdldCBubyBkYXRhIG9uIGxheWVyIDAgd2hlbiBlbmFibGVkXG4gICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ2F2MScgJiYgIXN1cHBvcnRzQVYxKCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ3ZwOScgJiYgIXN1cHBvcnRzVlA5KCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IGRlZmF1bHRWaWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICAgIC8vIGhhbmRsZSB0cmFjayBhY3Rpb25zXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICAvLyBnZXQgbG9jYWwgdHJhY2sgaWQgZm9yIHVzZSBkdXJpbmcgcHVibGlzaGluZ1xuICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgZGlzYWJsZUR0eDogISgoX2EgPSBvcHRzLmR0eCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSksXG4gICAgICAgIGVuY3J5cHRpb246IHRoaXMuZW5jcnlwdGlvblR5cGUsXG4gICAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICAgIGRpc2FibGVSZWQ6IHRoaXMuaXNFMkVFRW5hYmxlZCB8fCAhKChfYiA9IG9wdHMucmVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSxcbiAgICAgICAgc3RyZWFtOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc3RyZWFtXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbXB1dGUgZW5jb2RpbmdzIGFuZCBsYXllcnMgZm9yIHZpZGVvXG4gICAgICBsZXQgZW5jb2RpbmdzO1xuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgbGV0IGRpbXMgPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGltcyA9IHlpZWxkIHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB1c2UgZGVmYXVsdHMsIGl0J3MgcXVpdGUgcGFpbmZ1bCBmb3IgY29uZ2VzdGlvbiBjb250cm9sIHdpdGhvdXQgc2ltdWxjYXN0XG4gICAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXG4gICAgICAgICAgY29uc3QgZGVmYXVsdFJlcyA9IChfZCA9IChfYyA9IHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNvbHV0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBWaWRlb1ByZXNldHMuaDcyMC5yZXNvbHV0aW9uO1xuICAgICAgICAgIGRpbXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZGVmYXVsdFJlcy5oZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZyBmYWlsdXJlXG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgdHJhY2sgZGltZW5zaW9ucywgdXNpbmcgZGVmYXVsdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpLCB7XG4gICAgICAgICAgICBkaW1zXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgc2hvdWxkIGJlIGRlZmluZWQgZm9yIHZpZGVvXG4gICAgICAgIHJlcS53aWR0aCA9IGRpbXMud2lkdGg7XG4gICAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgICAgLy8gZm9yIHN2YyBjb2RlY3MsIGRpc2FibGUgc2ltdWxjYXN0IGFuZCB1c2UgdnA4IGZvciBiYWNrdXAgY29kZWNcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAgIC8vIHZwOSBzdmMgd2l0aCBzY3JlZW5zaGFyZSBoYXMgcHJvYmxlbSB0byBlbmNvZGUsIGFsd2F5cyB1c2UgTDFUMyBoZXJlXG4gICAgICAgICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdmlkZW9Db2RlYyA9PT0gJ3ZwOScpIHtcbiAgICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAoX2UgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ0wzVDNfS0VZJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0ge1xuICAgICAgICAgICAgICBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjICYmIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCBjb2RlY3NcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgICAgIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCByZXF1aXJlcyBkeW5hY2FzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcy5wdXNoKG5ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICAgIGNvZGVjOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgICAgICAgICAgICBjaWQ6ICcnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncywgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICBlbmNvZGluZ3MgPSBbe1xuICAgICAgICAgIG1heEJpdHJhdGU6IChfZyA9IChfZiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBvcHRzLmF1ZGlvQml0cmF0ZSxcbiAgICAgICAgICBwcmlvcml0eTogKF9qID0gKF9oID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnByaW9yaXR5KSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAnaGlnaCcsXG4gICAgICAgICAgbmV0d29ya1ByaW9yaXR5OiAoX2wgPSAoX2sgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2sucHJpb3JpdHkpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6ICdoaWdoJ1xuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGkgPSB5aWVsZCB0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpO1xuICAgICAgLy8gc2VydmVyIG1pZ2h0IG5vdCBzdXBwb3J0IHRoZSBjb2RlYyB0aGUgY2xpZW50IGhhcyByZXF1ZXN0ZWQsIGluIHRoYXQgY2FzZSwgZmFsbGJhY2tcbiAgICAgIC8vIHRvIGEgc3VwcG9ydGVkIGNvZGVjXG4gICAgICBsZXQgcHJpbWFyeUNvZGVjTWltZTtcbiAgICAgIHRpLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByaW1hcnlDb2RlY01pbWUgPSBjb2RlYy5taW1lVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xuICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2ZhbGxpbmcgYmFjayB0byBzZXJ2ZXIgc2VsZWN0ZWQgY29kZWMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpLCB7XG4gICAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XG4gICAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2sua2luZCwgdGksIHRyYWNrLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgLy8gc2F2ZSBvcHRpb25zIGZvciB3aGVuIGl0IG5lZWRzIHRvIGJlIHJlcHVibGlzaGVkIGFnYWluXG4gICAgICBwdWJsaWNhdGlvbi5vcHRpb25zID0gb3B0cztcbiAgICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcbiAgICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwY01hbmFnZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hpbmcgXCIuY29uY2F0KHRyYWNrLmtpbmQsIFwiIHdpdGggZW5jb2RpbmdzXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KSk7XG4gICAgICB0cmFjay5zZW5kZXIgPSB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIGlmIChpc0ZpcmVGb3goKSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgLyogUmVmZXIgdG8gUkZDIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU4NyNzZWN0aW9uLTYuMSxcbiAgICAgICAgICAgICBsaXZla2l0LXNlcnZlciB1c2VzIG1heGF2ZXJhZ2ViaXRyYXRlPTUxMDAwMCBpbiB0aGUgYW5zd2VyIHNkcCB0byBwZXJtaXQgY2xpZW50IHRvXG4gICAgICAgICAgICAgcHVibGlzaCBoaWdoIHF1YWxpdHkgYXVkaW8gdHJhY2suIEJ1dCBmaXJlZm94IGFsd2F5cyB1c2VzIHRoaXMgdmFsdWUgYXMgdGhlIGFjdHVhbFxuICAgICAgICAgICAgIGJpdHJhdGVzLCBjYXVzaW5nIHRoZSBhdWRpbyBiaXRyYXRlcyB0byByaXNlIHRvIDUxMEticHMgaW4gYW55IHN0ZXJlbyBjYXNlIHVuZXhwZWN0ZWRseS5cbiAgICAgICAgICAgICBTbyB0aGUgY2xpZW50IG5lZWQgdG8gbW9kaWZ5IG1heGF2ZXJyYWdlYml0cmF0ZXMgaW4gYW5zd2VyIHNkcCB0byB1c2VyIHByb3ZpZGVkIHZhbHVlIHRvXG4gICAgICAgICAgICAgZml4IHRoZSBpc3N1ZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgdHJhY2tUcmFuc2NlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrLnNlbmRlcikge1xuICAgICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tUcmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICBjb2RlYzogJ29wdXMnLFxuICAgICAgICAgICAgICBtYXhicjogKChfbSA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLm1heEJpdHJhdGUpID8gZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwIDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmICgoX28gPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5tYXhCaXRyYXRlKSkge1xuICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgY2lkOiByZXEuY2lkLFxuICAgICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgICAgbWF4YnI6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IodGhpcy5lbmdpbmUuY2xpZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9KTtcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsXG4gICAqIHB1Ymxpc2ggYWRkaXRpb25hbCBjb2RlYyB0byBleGlzdGluZyB0cmFja1xuICAgKi9cbiAgcHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBUT0RPIHJlbW92ZSBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgdHJhY2tzXG4gICAgICBpZiAodGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaXMgaXQgbm90IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBwdWJsaXNoZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBhIHZpZGVvIHRyYWNrJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3ModHJhY2ssIHZpZGVvQ29kZWMsIG9wdHMpO1xuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcImJhY2t1cCBjb2RlYyBoYXMgYmVlbiBkaXNhYmxlZCwgaWdub3JpbmcgcmVxdWVzdCB0byBhZGQgYWRkaXRpb25hbCBjb2RlYyBmb3IgdHJhY2tcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaW11bGNhc3RUcmFjayA9IHRyYWNrLmFkZFNpbXVsY2FzdFRyYWNrKHZpZGVvQ29kZWMsIGVuY29kaW5ncyk7XG4gICAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgICBzaWQ6IHRyYWNrLnNpZCxcbiAgICAgICAgc2ltdWxjYXN0Q29kZWNzOiBbe1xuICAgICAgICAgIGNvZGVjOiBvcHRzLnZpZGVvQ29kZWMsXG4gICAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MocmVxLndpZHRoLCByZXEuaGVpZ2h0LCBlbmNvZGluZ3MpO1xuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hlZCBcIi5jb25jYXQodmlkZW9Db2RlYywgXCIgZm9yIHRyYWNrIFwiKS5jb25jYXQodHJhY2suc2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVuY29kaW5ncyxcbiAgICAgICAgdHJhY2tJbmZvOiB0aVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIHVucHVibGlzaFRyYWNrKHRyYWNrLCBzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBsb29rIHRocm91Z2ggYWxsIHB1Ymxpc2hlZCB0cmFja3MgdG8gZmluZCB0aGUgcmlnaHQgb25lc1xuICAgICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xuICAgICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHB1YmxpY2F0aW9uLnRyYWNrO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0b3BPblVucHVibGlzaCA9IChfYiA9IChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCkge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9XG4gICAgICBsZXQgbmVnb3RpYXRpb25OZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHRyYWNrU2VuZGVyID0gdHJhY2suc2VuZGVyO1xuICAgICAgdHJhY2suc2VuZGVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuZW5naW5lLnBjTWFuYWdlciAmJiB0aGlzLmVuZ2luZS5wY01hbmFnZXIuY3VycmVudFN0YXRlIDwgUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQgJiYgdHJhY2tTZW5kZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNlbmRlciBpcyBub3QgY3VycmVudGx5IHNlbmRpbmcgKGFmdGVyIHJlcGxhY2VUcmFjayhudWxsKSlcbiAgICAgICAgICAgIC8vIHJlbW92ZVRyYWNrIHdvdWxkIGhhdmUgbm8gZWZmZWN0LlxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGVuZCB1cCBzdWNjZXNzZnVsbHkgcmVtb3ZpbmcgdGhlIHRyYWNrLCBtYW51YWxseSBzZXRcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2NlaXZlciB0byBpbmFjdGl2ZVxuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2tTZW5kZXIpIHtcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tTZW5kZXIpKSB7XG4gICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCB0cmFja0luZm9dIG9mIHRyYWNrLnNpbXVsY2FzdENvZGVjcykge1xuICAgICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5yZW1vdmVUcmFjayh0cmFja0luZm8uc2VuZGVyKSkge1xuICAgICAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja0luZm8uc2VuZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5zaW11bGNhc3RDb2RlY3MuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gdW5wdWJsaXNoIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICAgIHRoaXMudHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICAgIHRoaXMuYXVkaW9UcmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICAgIHRoaXMudmlkZW9UcmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFja3ModHJhY2tzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spKSk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIodHJhY2sgPT4gdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIHJlcHVibGlzaEFsbFRyYWNrcyhvcHRpb25zKSB7XG4gICAgbGV0IHJlc3RhcnRUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGxvY2FsUHVicyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHB1Yi5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWIub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFB1YnMucHVzaChwdWIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxvY2FsUHVicy5tYXAocHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICAgIHlpZWxkIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgaWYgKHJlc3RhcnRUcmFja3MgJiYgIXRyYWNrLmlzTXV0ZWQgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spICYmICF0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIC8vIGdlbmVyYWxseSB3ZSBuZWVkIHRvIHJlc3RhcnQgdGhlIHRyYWNrIGJlZm9yZSBwdWJsaXNoaW5nLCBvZnRlbiBhIGZ1bGwgcmVjb25uZWN0XG4gICAgICAgICAgLy8gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgY29tcHV0ZXIgaGFkIGdvbmUgdG8gc2xlZXAuXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zKTtcbiAgICAgIH0pKSk7XG4gICAgfSk7XG4gIH1cbiAgcHVibGlzaERhdGEoZGF0YSwga2luZCkge1xuICAgIGxldCBwdWJsaXNoT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucykgPyBwdWJsaXNoT3B0aW9ucyA6IHB1Ymxpc2hPcHRpb25zID09PSBudWxsIHx8IHB1Ymxpc2hPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaXNoT3B0aW9ucy5kZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uU2lkcyA9IFtdO1xuICAgICAgY29uc3QgdG9waWMgPSAhQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucykgPyBwdWJsaXNoT3B0aW9ucy50b3BpYyA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uLmZvckVhY2godmFsID0+IHtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVtb3RlUGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uU2lkcy5wdXNoKHZhbC5zaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblNpZHMucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3VzZXInLFxuICAgICAgICAgIHZhbHVlOiBuZXcgVXNlclBhY2tldCh7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogdGhpcy5zaWQsXG4gICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgZGVzdGluYXRpb25TaWRzOiBkZXN0aW5hdGlvblNpZHMsXG4gICAgICAgICAgICB0b3BpY1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbCB3aG8gY2FuIHN1YnNjcmliZSB0byBMb2NhbFBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIHBhcnRpY2lwYW50cyBjYW4gc3Vic2NyaWJlLiBUaGlzIGFsbG93cyBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAqIHdobyBpcyBhYmxlIHRvIHN1YnNjcmliZSBhdCBhIHBhcnRpY2lwYW50IGFuZCB0cmFjayBsZXZlbC5cbiAgICpcbiAgICogTm90ZTogaWYgYWNjZXNzIGlzIGdpdmVuIGF0IGEgdHJhY2stbGV2ZWwgKGkuZS4gYm90aCBbYWxsUGFydGljaXBhbnRzQWxsb3dlZF0gYW5kXG4gICAqIFtQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5hbGxUcmFja3NBbGxvd2VkXSBhcmUgZmFsc2UpLCBhbnkgbmV3ZXIgcHVibGlzaGVkIHRyYWNrc1xuICAgKiB3aWxsIG5vdCBncmFudCBwZXJtaXNzaW9ucyB0byBhbnkgcGFydGljaXBhbnRzIGFuZCB3aWxsIHJlcXVpcmUgYSBzdWJzZXF1ZW50XG4gICAqIHBlcm1pc3Npb25zIHVwZGF0ZSB0byBhbGxvdyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIEFsbG93cyBhbGwgcGFydGljaXBhbnRzIHRvIHN1YnNjcmliZSBhbGwgdHJhY2tzLlxuICAgKiAgVGFrZXMgcHJlY2VkZW5jZSBvdmVyIFtbcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXV0gaWYgc2V0IHRvIHRydWUuXG4gICAqICBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHRydWUuXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgRnVsbCBsaXN0IG9mIGluZGl2aWR1YWwgcGVybWlzc2lvbnMgcGVyXG4gICAqICBwYXJ0aWNpcGFudC90cmFjay4gQW55IG9taXR0ZWQgcGFydGljaXBhbnRzIHdpbGwgbm90IHJlY2VpdmUgYW55IHBlcm1pc3Npb25zLlxuICAgKi9cbiAgc2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkKSB7XG4gICAgbGV0IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM7XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkO1xuICAgIGlmICghdGhpcy5lbmdpbmUuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoaW5mby5zaWQgIT09IHRoaXMuc2lkKSB7XG4gICAgICAvLyBkcm9wIHVwZGF0ZXMgdGhhdCBzcGVjaWZ5IGEgd3Jvbmcgc2lkLlxuICAgICAgLy8gdGhlIHNpZCBmb3IgbG9jYWwgcGFydGljaXBhbnQgaXMgb25seSBleHBsaWNpdGx5IHNldCBvbiBqb2luIGFuZCBmdWxsIHJlY29ubmVjdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxuICAgIC8vIHRoZSBzZXJ2ZXIncyBjb3B5XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja3MuZ2V0KHRpLnNpZCk7XG4gICAgICBpZiAocHViKSB7XG4gICAgICAgIGNvbnN0IG11dGVkT25TZXJ2ZXIgPSBwdWIuaXNNdXRlZCB8fCAoKF9iID0gKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpO1xuICAgICAgICBpZiAobXV0ZWRPblNlcnZlciAhPT0gdGkubXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgc2VydmVyIG11dGUgc3RhdGUgYWZ0ZXIgcmVjb25jaWxlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSksIHtcbiAgICAgICAgICAgIG11dGVkT25TZXJ2ZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRNdXRlVHJhY2sodGkuc2lkLCBtdXRlZE9uU2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spIHtcbiAgICBsZXQgcHVibGljYXRpb247XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxvb2tzIG92ZXJseSBjb21wbGljYXRlZCBkdWUgdG8gdGhpcyBvYmplY3QgdHJlZVxuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBpZiAobG9jYWxUcmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCBsb2NhbFRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgaWYgKGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbn1cblxudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmNvbnN0IGNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kgPSAyICogMTAwMDtcbi8qKiBAZGVwcmVjYXRlZCBSb29tU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBbW0Nvbm5lY3Rpb25TdGF0ZV1dICovXG5jb25zdCBSb29tU3RhdGUgPSBDb25uZWN0aW9uU3RhdGU7XG4vKipcbiAqIEluIExpdmVLaXQsIGEgcm9vbSBpcyB0aGUgbG9naWNhbCBncm91cGluZyBmb3IgYSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAqIFBhcnRpY2lwYW50cyBpbiBhIHJvb20gY2FuIHB1Ymxpc2ggdHJhY2tzLCBhbmQgc3Vic2NyaWJlIHRvIG90aGVycycgdHJhY2tzLlxuICpcbiAqIGEgUm9vbSBmaXJlcyBbW1Jvb21FdmVudCB8IFJvb21FdmVudHNdXS5cbiAqXG4gKiBAbm9Jbmhlcml0RG9jXG4gKi9cbmNsYXNzIFJvb20gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJvb20sIHRoZSBwcmltYXJ5IGNvbnN0cnVjdCBmb3IgYSBMaXZlS2l0IHNlc3Npb24uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfYSwgX2I7XG4gICAgc3VwZXIoKTtcbiAgICBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXG4gICAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAvKiogcmVmbGVjdHMgdGhlIHNlbmRlciBlbmNyeXB0aW9uIHN0YXR1cyBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQgKi9cbiAgICB0aGlzLmlzRTJFRUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuY29ubmVjdCA9ICh1cmwsIHRva2VuLCBvcHRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2M7XG4gICAgICAvLyBJbiBjYXNlIGEgZGlzY29ubmVjdCBjYWxsZWQgaGFwcGVuZWQgcmlnaHQgYmVmb3JlIHRoZSBjb25uZWN0IGNhbGwsIG1ha2Ugc3VyZSB0aGUgZGlzY29ubmVjdCBpcyBjb21wbGV0ZWQgZmlyc3QgYnkgYXdhaXRpbmcgaXRzIGxvY2tcbiAgICAgIGNvbnN0IHVubG9ja0Rpc2Nvbm5lY3QgPSB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIHN0YXRlIGlzIHJlY29ubmVjdGluZyBvciBjb25uZWN0ZWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSBcIi5jb25jYXQodGhpcy5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nKTtcbiAgICAgIGlmICgoKF9jID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFNlcnZlclVybCgpLnRvU3RyaW5nKCkpICE9PSB1cmwpIHtcbiAgICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IGZldGNoIHdpdGhvdXQgd2FpdGluZyBmb3IgYSByZXNwb25zZVxuICAgICAgICAvLyBpZiBpbml0aWFsIGNvbm5lY3Rpb24gZmFpbHMsIHRoaXMgd2lsbCBzcGVlZCB1cCBwaWNraW5nIHJlZ2lvbmFsIHVybFxuICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHJ1bnNcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5mZXRjaFJlZ2lvblNldHRpbmdzKCkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdEZuID0gKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfZDtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBsaWNpdCBjcmVhdGlvbiBhcyBsb2NhbCB2YXIgbmVlZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIgd2hlbiBwYXNzaW5nIGl0IHRvIGBhdHRlbXB0Q29ubmVjdGlvbmAgZnVydGhlciBkb3duXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QgPT09IG51bGwgfHwgdW5sb2NrRGlzY29ubmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24ocmVnaW9uVXJsICE9PSBudWxsICYmIHJlZ2lvblVybCAhPT0gdm9pZCAwID8gcmVnaW9uVXJsIDogdXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciAmJiBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uICE9PSAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8gJiYgZS5yZWFzb24gIT09IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8pIHtcbiAgICAgICAgICAgIGxldCBuZXh0VXJsID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5leHRVcmwgPSB5aWVsZCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKChfZCA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2lnbmFsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3IucmVhc29uID09PSAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRVcmwpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbyhcIkluaXRpYWwgY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBDb25uZWN0aW9uRXJyb3I6IFwiLmNvbmNhdChlLm1lc3NhZ2UsIFwiLiBSZXRyeWluZyB3aXRoIGFub3RoZXIgcmVnaW9uOiBcIikuY29uY2F0KG5leHRVcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB5aWVsZCBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCBuZXh0VXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCk7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVnaW9uVXJsID0gdGhpcy5yZWdpb25Vcmw7XG4gICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdFNpZ25hbCA9ICh1cmwsIHRva2VuLCBlbmdpbmUsIGNvbm5lY3RPcHRpb25zLCByb29tT3B0aW9ucywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2UsIF9mLCBfZztcbiAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIGVuZ2luZS5qb2luKHVybCwgdG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogY29ubmVjdE9wdGlvbnMuYXV0b1N1YnNjcmliZSxcbiAgICAgICAgcHVibGlzaE9ubHk6IGNvbm5lY3RPcHRpb25zLnB1Ymxpc2hPbmx5LFxuICAgICAgICBhZGFwdGl2ZVN0cmVhbTogdHlwZW9mIHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0JyA/IHRydWUgOiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSxcbiAgICAgICAgbWF4UmV0cmllczogY29ubmVjdE9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgZTJlZUVuYWJsZWQ6ICEhdGhpcy5lMmVlTWFuYWdlcixcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogY29ubmVjdE9wdGlvbnMud2Vic29ja2V0VGltZW91dFxuICAgICAgfSwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBsZXQgc2VydmVySW5mbyA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvO1xuICAgICAgaWYgKCFzZXJ2ZXJJbmZvKSB7XG4gICAgICAgIHNlcnZlckluZm8gPSB7XG4gICAgICAgICAgdmVyc2lvbjogam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24sXG4gICAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciBcIi5jb25jYXQoT2JqZWN0LmVudHJpZXMoc2VydmVySW5mbykubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgfSkuam9pbignLCAnKSksIHtcbiAgICAgICAgcm9vbTogKF9lID0gam9pblJlc3BvbnNlLnJvb20pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5uYW1lLFxuICAgICAgICByb29tU2lkOiAoX2YgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNpZCxcbiAgICAgICAgaWRlbnRpdHk6IChfZyA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmlkZW50aXR5XG4gICAgICB9KTtcbiAgICAgIGlmICgham9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkU2VydmVyKCd1bmtub3duIHNlcnZlciB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24gPT09ICcwLjE1LjEnICYmIHRoaXMub3B0aW9ucy5keW5hY2FzdCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZGlzYWJsaW5nIGR5bmFjYXN0IGR1ZSB0byBzZXJ2ZXIgdmVyc2lvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIGR5bmFjYXN0IGhhcyBhIGJ1ZyBpbiAwLjE1LjEsIHNvIHdlIGNhbm5vdCB1c2UgaXQgdGhlblxuICAgICAgICByb29tT3B0aW9ucy5keW5hY2FzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpvaW5SZXNwb25zZTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlID0gam9pblJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50O1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCA9IHBpLnNpZDtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9IHBpLmlkZW50aXR5O1xuICAgICAgLy8gcG9wdWxhdGUgcmVtb3RlIHBhcnRpY2lwYW50cywgdGhlc2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIG5ldyBldmVudHNcbiAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKFtwaSwgLi4uam9pblJlc3BvbnNlLm90aGVyUGFydGljaXBhbnRzXSk7XG4gICAgICBpZiAoam9pblJlc3BvbnNlLnJvb20pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKGpvaW5SZXNwb25zZS5yb29tKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSAmJiB0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0U2lmVHJhaWxlcihqb2luUmVzcG9uc2Uuc2lmVHJhaWxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF0dGVtcHRDb25uZWN0aW9uID0gKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9oLCBfajtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ1JlY29ubmVjdGlvbiBhdHRlbXB0IHJlcGxhY2VkIGJ5IG5ldyBjb25uZWN0aW9uIGF0dGVtcHQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2xvc2UgYW5kIHJlY3JlYXRlIHRoZSBleGlzdGluZyBlbmdpbmUgaW4gb3JkZXIgdG8gZ2V0IHJpZCBvZiBhbnkgcG90ZW50aWFsbHkgb25nb2luZyByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGVuZ2luZSBpZiBwcmV2aW91c2x5IGRpc2Nvbm5lY3RlZFxuICAgICAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgICB9XG4gICAgICBpZiAoKF9oID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aGlzLmVuZ2luZS5zZXRSZWdpb25VcmxQcm92aWRlcih0aGlzLnJlZ2lvblVybFByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWNxdWlyZUF1ZGlvQ29udGV4dCgpO1xuICAgICAgdGhpcy5jb25uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyksIG9wdHMpO1xuICAgICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnJ0Y0NvbmZpZyA9IHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5jb25uZWN0U2lnbmFsKHVybCwgdG9rZW4sIHRoaXMuZW5naW5lLCB0aGlzLmNvbm5PcHRpb25zLCB0aGlzLm9wdGlvbnMsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcbiAgICAgICAgLy8gZm9yd2FyZCBtZXRhZGF0YSBjaGFuZ2VkIGZvciB0aGUgbG9jYWwgcGFydGljaXBhbnRcbiAgICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0aW5nRXJyb3IgPSBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBzaWduYWwgY29ubmVjdGlvblwiKTtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IubWVzc2FnZSA9IFwiXCIuY29uY2F0KHJlc3VsdGluZ0Vycm9yLm1lc3NhZ2UsIFwiOiBcIikuY29uY2F0KGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5zdGF0dXMgPSBlcnIuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZXJyb3IgdHJ5aW5nIHRvIGVzdGFibGlzaCBzaWduYWwgY29ubmVjdGlvblwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgcmVzdWx0aW5nRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gYXR0ZW1wdCBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIC8vIGFsc28gaG9vayB1bmxvYWQgZXZlbnRcbiAgICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcbiAgICAgICAgLy8gY2FwdHVyaW5nIGJvdGggJ3BhZ2VoaWRlJyBhbmQgJ2JlZm9yZXVubG9hZCcgdG8gY2FwdHVyZSBicm9hZGVzdCBzZXQgb2YgYnJvd3NlciBiZWhhdmlvcnNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICAoX2ogPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0cyB0aGUgcm9vbSwgZW1pdHMgW1tSb29tRXZlbnQuRGlzY29ubmVjdGVkXV1cbiAgICAgKi9cbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgc3RvcFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2ssIF9sLCBfbSwgX287XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAoX2sgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmFib3J0KCk7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBhYm9ydCBjb250cm9sbGVyIGRpZG4ndCBtYW5hZ2UgdG8gY2FuY2VsIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQsIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIChfbSA9IChfbCA9IHRoaXMuY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnJlamVjdCkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhbGwoX2wsIG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcpKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2VuZCBsZWF2ZVxuICAgICAgICAgIGlmICghKChfbyA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28uY2xpZW50LmlzRGlzY29ubmVjdGVkKSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjbG9zZSBlbmdpbmUgKGFsc28gY2xvc2VzIGNsaWVudClcbiAgICAgICAgICBpZiAodGhpcy5lbmdpbmUpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChzdG9wVHJhY2tzLCBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQpO1xuICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICB0aGlzLmVuZ2luZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uUGFnZUxlYXZlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICAgKiBJbiB0aG9zZSBjYXNlcywgYXVkaW8gd2lsbCBiZSBzaWxlbnQgdW50aWwgYSBjbGljay90YXAgdHJpZ2dlcmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRBdWRpbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5vcyA9PT0gJ2lPUycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlPUyBibG9ja3MgYXVkaW8gZWxlbWVudCBwbGF5YmFjayBpZlxuICAgICAgICAgKiAtIHVzZXIgaXMgbm90IHB1Ymxpc2hpbmcgYXVkaW8gdGhlbXNlbHZlcyBhbmRcbiAgICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBhcyBhIHdvcmthcm91bmQsIHdlIGNyZWF0ZSBhbiBhdWRpbyBlbGVtZW50IHdpdGggYW4gZW1wdHkgdHJhY2ssIHNvIHRoYXRcbiAgICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdWRpb0lkID0gJ2xpdmVraXQtZHVtbXktYXVkaW8tZWwnO1xuICAgICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCk7XG4gICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzcmNPYmplY3QgdG8gbnVsbCBvbiBwYWdlIGhpZGUgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NrIHNjcmVlbiBjb250cm9scyB0byBzaG93IHVwIGZvciBpdFxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcbiAgICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID09PSBudWxsIHx8IGR1bW15QXVkaW9FbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVtbXlBdWRpb0VsLnJlbW92ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZHVtbXlBdWRpb0VsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuYXVkaW9UcmFja3MuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAodC50cmFjaykge1xuICAgICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksIC4uLmVsZW1lbnRzLm1hcChlID0+IHtcbiAgICAgICAgICBlLm11dGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGUucGxheSgpO1xuICAgICAgICB9KV0pO1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0VmlkZW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIHAudmlkZW9UcmFja3MuZm9yRWFjaCh0ciA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IHRyLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHMuaW5jbHVkZXMoZWwpKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKGVsZW1lbnRzLm1hcChlbCA9PiBlbC5wbGF5KCkpKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCgpO1xuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignUmVzdW1pbmcgdmlkZW8gcGxheWJhY2sgZmFpbGVkLCBtYWtlIHN1cmUgeW91IGNhbGwgYHN0YXJ0VmlkZW9gIGRpcmVjdGx5IGluIGEgdXNlciBnZXN0dXJlIGhhbmRsZXInLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVJlc3RhcnRpbmcgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgLy8gYWxzbyB1bndpbmQgZXhpc3RpbmcgcGFydGljaXBhbnRzICYgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uc1xuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocC5zaWQsIHApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZCA9IGpvaW5SZXNwb25zZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXIsIHJlZ2lvbiBcIi5jb25jYXQoam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzID0gW107XG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICAgIHlpZWxkIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlclwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoX3ApIHtcbiAgICAgICAgLy8gcmVjb25uZWN0aW9uIGZhaWxlZCwgaGFuZGxlRGlzY29ubmVjdCBpcyBiZWluZyBpbnZva2VkIGFscmVhZHksIGp1c3QgcmV0dXJuIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgLy8gZW1pdCBwYXJ0aWNpcGFudCBjb25uZWN0ZWQgZXZlbnRzIGFmdGVyIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWRcbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IHBhcnRpY2lwYW50SW5mb3MgPT4ge1xuICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICBpZiAoaW5mby5pZGVudGl0eSA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSBpZGVudGl0eSA8PT4gc2lkIG1hcHBpbmdcbiAgICAgICAgY29uc3Qgc2lkID0gdGhpcy5pZGVudGl0eVRvU2lkLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgaWYgKHNpZCAmJiBzaWQgIT09IGluZm8uc2lkKSB7XG4gICAgICAgICAgLy8gc2lkIGhhZCBjaGFuZ2VkLCBuZWVkIHRvIHJlbW92ZSBwcmV2aW91cyBwYXJ0aWNpcGFudFxuICAgICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoc2lkLCB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KGluZm8uc2lkKTtcbiAgICAgICAgY29uc3QgaXNOZXdQYXJ0aWNpcGFudCA9ICFyZW1vdGVQYXJ0aWNpcGFudDtcbiAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXG4gICAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpbmZvLnNpZCwgcmVtb3RlUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBwYXJ0aWNpcGFudCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5zaWQsIGluZm8pO1xuICAgICAgICAgIGlmICghaXNOZXdQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgLy8ganVzdCB1cGRhdGUsIG5vIGV2ZW50c1xuICAgICAgICAgICAgcmVtb3RlUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gdXBkYXRlcyBhcmUgc2VudCBvbmx5IHdoZW4gdGhlcmUncyBhIGNoYW5nZSB0byBzcGVha2VyIG9yZGVyaW5nXG4gICAgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSA9IHNwZWFrZXJzID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBjb25zdCBzZWVuU2lkcyA9IHt9O1xuICAgICAgc3BlYWtlcnMuZm9yRWFjaChzcGVha2VyID0+IHtcbiAgICAgICAgc2VlblNpZHNbc3BlYWtlci5zaWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgIGFjdGl2ZVNwZWFrZXJzLnB1c2godGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgICAgIHAuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgICAgIGFjdGl2ZVNwZWFrZXJzLnB1c2gocCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VlblNpZHNbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZF0pIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBpZiAoIXNlZW5TaWRzW3Auc2lkXSkge1xuICAgICAgICAgIHAuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgICAgcC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gYWN0aXZlU3BlYWtlcnM7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQsIGFjdGl2ZVNwZWFrZXJzKTtcbiAgICB9O1xuICAgIC8vIHByb2Nlc3MgbGlzdCBvZiBjaGFuZ2VkIHNwZWFrZXJzXG4gICAgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQgPSBzcGVha2VyVXBkYXRlcyA9PiB7XG4gICAgICBjb25zdCBsYXN0U3BlYWtlcnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGxhc3RTcGVha2Vycy5zZXQocC5zaWQsIHApO1xuICAgICAgfSk7XG4gICAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBsZXQgcCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzcGVha2VyLnNpZCk7XG4gICAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG4gICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5zZXQoc3BlYWtlci5zaWQsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgICAgYWN0aXZlU3BlYWtlcnMuc29ydCgoYSwgYikgPT4gYi5hdWRpb0xldmVsIC0gYS5hdWRpb0xldmVsKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IHN0cmVhbVN0YXRlVXBkYXRlID0+IHtcbiAgICAgIHN0cmVhbVN0YXRlVXBkYXRlLnN0cmVhbVN0YXRlcy5mb3JFYWNoKHN0cmVhbVN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3RyZWFtU3RhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24oc3RyZWFtU3RhdGUudHJhY2tTaWQpO1xuICAgICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSA9IFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvKHN0cmVhbVN0YXRlLnN0YXRlKTtcbiAgICAgICAgcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldEFsbG93ZWQodXBkYXRlLmFsbG93ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvciA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnRyYWNrcy5oYXModXBkYXRlLnRyYWNrU2lkKSk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odXBkYXRlLnRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1Yi5zZXRTdWJzY3JpcHRpb25FcnJvcih1cGRhdGUuZXJyKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YVBhY2tldCA9ICh1c2VyUGFja2V0LCBraW5kKSA9PiB7XG4gICAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQodXNlclBhY2tldC5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBwYXJ0aWNpcGFudCwga2luZCwgdXNlclBhY2tldC50b3BpYyk7XG4gICAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XG4gICAgICBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBraW5kKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkID0gZSA9PiB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcGxheWJhY2sgYXVkaW8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0pKTtcbiAgICAgIGlmICghdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCkge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCkge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURldmljZUNoYW5nZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzQ2hhbmdlZCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlID0gcm9vbSA9PiB7XG4gICAgICBjb25zdCBvbGRSb29tID0gdGhpcy5yb29tSW5mbztcbiAgICAgIHRoaXMucm9vbUluZm8gPSByb29tO1xuICAgICAgaWYgKG9sZFJvb20gJiYgb2xkUm9vbS5tZXRhZGF0YSAhPT0gcm9vbS5tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Sb29tTWV0YWRhdGFDaGFuZ2VkLCByb29tLm1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICgob2xkUm9vbSA9PT0gbnVsbCB8fCBvbGRSb29tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRSb29tLmFjdGl2ZVJlY29yZGluZykgIT09IHJvb20uYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJlY29yZGluZ1N0YXR1c0NoYW5nZWQsIHJvb20uYWN0aXZlUmVjb3JkaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgdXBkYXRlLnVwZGF0ZXMuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgaWYgKGluZm8ucGFydGljaXBhbnRTaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaW5mby5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgIHBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgPSBtZXRhZGF0YSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQgPSBuYW1lID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQgPSBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQgPSBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfcTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgaWYgKHB1Yi50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgcHViLnRyYWNrLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCAoX3EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5nZXREZXZpY2VJZCgpO1xuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZChwdWIuc291cmNlKTtcbiAgICAgIGlmIChkZXZpY2VLaW5kICYmIGRldmljZUlkICYmIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IHF1YWxpdHkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IgPSBlID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSBwcmV2UGVybWlzc2lvbnMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNhY2hlZFBhcnRpY2lwYW50U2lkcyA9IFtdO1xuICAgIHRoaXMuaWRlbnRpdHlUb1NpZCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21PcHRpb25EZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5Sb29tKTtcbiAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1ZGlvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyk7XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQgPSBuZXcgTG9jYWxQYXJ0aWNpcGFudCgnJywgJycsIHRoaXMuZW5naW5lLCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCd2aWRlb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xuICAgIH1cbiAgICBpZiAoKF9iID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkKSkuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKFwiQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6IFwiLmNvbmNhdChlLm1lc3NhZ2UpLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgIT09ICcnKSB7XG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdlMmVlIG5vdCBjb25maWd1cmVkLCBwbGVhc2Ugc2V0IGUyZWUgc2V0dGluZ3Mgd2l0aGluIHRoZSByb29tIG9wdGlvbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXR1cEUyRUUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCAoZW5hYmxlZCwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50IGluc3RhbmNlb2YgTG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IgPT4gdGhpcy5lbWl0KFJvb21FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yKSk7XG4gICAgICAoX2EgPSB0aGlzLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0dXAodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiB0aGlzLm5hbWUsXG4gICAgICByb29tU2lkOiB0aGlzLnNpZCxcbiAgICAgIGlkZW50aXR5OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQgKi9cbiAgZ2V0IHNpZCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICAvKiogdXNlciBhc3NpZ25lZCBuYW1lLCBkZXJpdmVkIGZyb20gSldUIHRva2VuICovXG4gIGdldCBuYW1lKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICAvKiogcm9vbSBtZXRhZGF0YSAqL1xuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0YWRhdGE7XG4gIH1cbiAgZ2V0IG51bVBhcnRpY2lwYW50cygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIGdldCBudW1QdWJsaXNoZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1QdWJsaXNoZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIG1heWJlQ3JlYXRlRW5naW5lKCkge1xuICAgIGlmICh0aGlzLmVuZ2luZSAmJiAhdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgUlRDRW5naW5lKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB0aGlzLmhhbmRsZVJvb21VcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQpLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSkub24oRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpLm9uKEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZFBhcnRpY2lwYW50U2lkcyA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMua2V5cygpKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIC8vIG9uY2UgcmVjb25uZWN0ZWQsIGZpZ3VyZSBvdXQgaWYgYW55IHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgZHVyaW5nIHJlY29ubmVjdCBhbmQgZW1pdCBldmVudHMgZm9yIGl0XG4gICAgICBjb25zdCBkaWZmUGFydGljaXBhbnRzID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmlsdGVyKHAgPT4gIXRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzLmluY2x1ZGVzKHAuc2lkKSk7XG4gICAgICBkaWZmUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhcnRpY2lwYW50U2lkcyA9IFtdO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMuc2VuZFN5bmNTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVzdGFydGluZykub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZCkub24oRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCAoc3RhdHVzLCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBnZXRMb2NhbERldmljZXMgYWJzdHJhY3RzIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcy5cbiAgICogSW4gcGFydGljdWxhciwgaXQgaGFuZGxlcyBDaHJvbWUncyB1bmlxdWUgYmVoYXZpb3Igb2YgY3JlYXRpbmcgYGRlZmF1bHRgXG4gICAqIGRldmljZXMuIFdoZW4gZW5jb3VudGVyZWQsIGl0J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBvZiBkZXZpY2VzLlxuICAgKiBUaGUgYWN0dWFsIGRlZmF1bHQgZGV2aWNlIHdpbGwgYmUgcGxhY2VkIGF0IHRvcC5cbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBsb2NhbCBkZXZpY2VzXG4gICAqL1xuICBzdGF0aWMgZ2V0TG9jYWxEZXZpY2VzKGtpbmQpIHtcbiAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyhraW5kLCByZXF1ZXN0UGVybWlzc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogLSBwZXJmb3JtIEROUyByZXNvbHV0aW9uIGFuZCBwcmUtd2FybSB0aGUgRE5TIGNhY2hlXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xuICAgKlxuICAgKiBXaXRoIExpdmVLaXQgQ2xvdWQsIGl0IHdpbGwgYWxzbyBkZXRlcm1pbmUgdGhlIGJlc3QgZWRnZSBkYXRhIGNlbnRlciBmb3JcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIHByZXBhcmVDb25uZWN0aW9uKHVybCwgdG9rZW4pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlQ29ubmVjdGlvbiB0byBcIi5jb25jYXQodXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkgJiYgdG9rZW4pIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5vdCByZXBsYWNlIHRoZSByZWdpb25VcmwgaWYgYW4gYXR0ZW1wdCBoYWQgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgICAgLy8gdG8gYXZvaWQgb3ZlcnJpZGluZyByZWdpb25VcmwgYWZ0ZXIgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGhhZCBzdGFydGVkXG4gICAgICAgICAgaWYgKHJlZ2lvblVybCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHJlZ2lvblVybDtcbiAgICAgICAgICAgIHlpZWxkIGZldGNoKHRvSHR0cFVybChyZWdpb25VcmwpLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJlcGFyZWQgY29ubmVjdGlvbiB0byBcIi5jb25jYXQocmVnaW9uVXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHVybCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHByZXBhcmUgY29ubmVjdGlvbicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmV0cmlldmVzIGEgcGFydGljaXBhbnQgYnkgaWRlbnRpdHlcbiAgICogQHBhcmFtIGlkZW50aXR5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSBpZGVudGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICB9XG4gICAgY29uc3Qgc2lkID0gdGhpcy5pZGVudGl0eVRvU2lkLmdldChpZGVudGl0eSk7XG4gICAgaWYgKHNpZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydGljaXBhbnRzLmdldChzaWQpO1xuICAgIH1cbiAgfVxuICBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xuICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIGZvciB0ZXN0aW5nXG4gICAqL1xuICBzaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvLCBhcmcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiB7fTtcbiAgICAgIGxldCByZXE7XG4gICAgICBzd2l0Y2ggKHNjZW5hcmlvKSB7XG4gICAgICAgIGNhc2UgJ3NpZ25hbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NwZWFrZXInOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzcGVha2VyVXBkYXRlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbm9kZS1mYWlsdXJlJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnbm9kZUZhaWx1cmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZXJ2ZXItbGVhdmUnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzZXJ2ZXJMZWF2ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pZ3JhdGlvbic6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ21pZ3JhdGlvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3VtZS1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZhaWxOZXh0KCk7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZSc6XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZS1uby1tZXNzYWdlcyc6XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZU5vTWVzc2FnZXMnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdWxsLXJlY29ubmVjdCc6XG4gICAgICAgICAgdGhpcy5lbmdpbmUuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGZ1bGwtcmVjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvcmNlLXRjcCc6XG4gICAgICAgIGNhc2UgJ2ZvcmNlLXRscyc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3N3aXRjaENhbmRpZGF0ZVByb3RvY29sJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHNjZW5hcmlvID09PSAnZm9yY2UtdGxzJyA/IDIgOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uTGVhdmUgPSB0aGlzLmVuZ2luZS5jbGllbnQub25MZWF2ZTtcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgICAgIG9uTGVhdmUobmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgICAgICAgICAgY2FuUmVjb25uZWN0OiB0cnVlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlci1iYW5kd2lkdGgnOlxuICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgYXJnICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdWJzY3JpYmVyLWJhbmR3aWR0aCByZXF1aXJlcyBhIG51bWJlciBhcyBhcmd1bWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc3Vic2NyaWJlckJhbmR3aWR0aCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoYXJnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFNpbXVsYXRlU2NlbmFyaW8ocmVxKTtcbiAgICAgICAgeWllbGQgcG9zdEFjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXVkaW8gcGxheWJhY2sgaXMgZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGNhblBsYXliYWNrQXVkaW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9FbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdmlkZW8gcGxheWJhY2sgaXMgZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGNhblBsYXliYWNrVmlkZW8oKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdGl2ZSBhdWRpbyBvdXRwdXQgZGV2aWNlIHVzZWQgaW4gdGhpcyByb29tLlxuICAgKiBAcmV0dXJuIHRoZSBwcmV2aW91c2x5IHN1Y2Nlc3NmdWxseSBzZXQgYXVkaW8gb3V0cHV0IGRldmljZSBJRCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGRlZmF1bHQgZGV2aWNlIGlzIHVzZWQuXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0QWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcpYCBpbnN0ZWFkXG4gICAqL1xuICBnZXRBY3RpdmVBdWRpb091dHB1dERldmljZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gIH1cbiAgZ2V0QWN0aXZlRGV2aWNlKGtpbmQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoa2luZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgKlxuICAgKiBOb3RlOiBzZXR0aW5nIEF1ZGlvT3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2Vycy4gU2VlIFtzZXRTaW5rSWRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcbiAgICogIGBhdWRpb2lucHV0YCBmb3IgbWljcm9waG9uZSB0cmFjayxcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZCwgZGV2aWNlSWQpIHtcbiAgICBsZXQgZXhhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgZGV2aWNlSGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgY29uc3QgZGV2aWNlQ29uc3RyYWludCA9IGV4YWN0ID8ge1xuICAgICAgICBleGFjdDogZGV2aWNlSWRcbiAgICAgIH0gOiBkZXZpY2VJZDtcbiAgICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICBkZXZpY2VIYXNDaGFuZ2VkID0gcHJldkRldmljZUlkICE9PSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0LmF1ZGlvVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREZXZpY2VJZChkZXZpY2VDb25zdHJhaW50KTtcbiAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgZGV2aWNlSGFzQ2hhbmdlZCA9IHByZXZEZXZpY2VJZCAhPT0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0LnZpZGVvVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREZXZpY2VJZChkZXZpY2VDb25zdHJhaW50KTtcbiAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKCkgJiYgIXRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCB8fCB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggJiYgdGhpcy5hdWRpb0NvbnRleHQgJiYgISgnc2V0U2lua0lkJyBpbiB0aGlzLmF1ZGlvQ29udGV4dCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCBzZXRTaW5rSWQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IChfYyA9IHRoaXMub3B0aW9ucykuYXVkaW9PdXRwdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9jLmF1ZGlvT3V0cHV0ID0ge307XG4gICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgIGRldmljZUhhc0NoYW5nZWQgPSBwcmV2RGV2aWNlSWQgIT09IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgKF9iID0gdGhpcy5hdWRpb0NvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChBcnJheS5mcm9tKHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKS5tYXAocCA9PiBwLnNldEF1ZGlvT3V0cHV0KHtcbiAgICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXZpY2VIYXNDaGFuZ2VkICYmIHN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwgZGV2aWNlSWQpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGtpbmQsIGRldmljZUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0pO1xuICB9XG4gIHNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpIHtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQpO1xuICB9XG4gIHJlY3JlYXRlRW5naW5lKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgIC8vIGNsZWFyIG91dCBleGlzdGluZyByZW1vdGUgcGFydGljaXBhbnRzLCBzaW5jZSB0aGV5IG1heSBoYXZlIGF0dGFjaGVkXG4gICAgLy8gdGhlIG9sZCBlbmdpbmVcbiAgICB0aGlzLnBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgfVxuICBvblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhZnRlciBSb29tIGRpc2Nvbm5lY3RlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdW5wYWNrU3RyZWFtSWQoc3RyZWFtLmlkKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudElkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuICAgIGlmIChwYXJ0aWNpcGFudElkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd0cmllZCB0byBjcmVhdGUgUmVtb3RlUGFydGljaXBhbnQgZm9yIGxvY2FsIHBhcnRpY2lwYW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQocGFydGljaXBhbnRJZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudElkKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnRpY2lwYW50LmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHRyYWNrSWQsIHN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpO1xuICB9XG4gIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgbGV0IHNob3VsZFN0b3BUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLnRyYWNrcy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgICAgcC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2tTaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHViLnRyYWNrLCBzaG91bGRTdG9wVHJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU3RvcFRyYWNrcykge1xuICAgICAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldGFjaCgpO1xuICAgICAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrcy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tzLmNsZWFyKCk7XG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgKF9hID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIHJlYXNvbik7XG4gICAgfVxuICB9XG4gIGhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHNpZCwgcGFydGljaXBhbnQpIHtcbiAgICAvLyByZW1vdmUgYW5kIHNlbmQgZXZlbnRcbiAgICB0aGlzLnBhcnRpY2lwYW50cy5kZWxldGUoc2lkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaWRlbnRpdHlUb1NpZC5kZWxldGUocGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gIH1cbiAgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCAhPT0gJ2Jvb2xlYW4nICYmIHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgYXVkaW8gY29udGV4dCB3aXRoIGN1c3RvbSBhdWRpbyBjb250ZXh0IGlmIHN1cHBsaWVkIGJ5IHVzZXJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXguYXVkaW9Db250ZXh0O1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5hdWRpb0NvbnRleHQgfHwgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIC8vIGJ5IHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgaXQgcmVkdWNlcyBsYWcgb24gYXVkaW8gZWxlbWVudHNcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTgxMTQyOS9odG1sNS1hdWRpby10YWctb24tc2FmYXJpLWhhcy1hLWRlbGF5LzU0MTE5ODU0IzU0MTE5ODU0XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gKF9hID0gZ2V0TmV3QXVkaW9Db250ZXh0KCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgLy8gZm9yIGlPUyBhIG5ld2x5IGNyZWF0ZWQgQXVkaW9Db250ZXh0IGlzIGFsd2F5cyBpbiBgc3VzcGVuZGVkYCBzdGF0ZS5cbiAgICAgICAgLy8gd2UgdHJ5IG91ciBiZXN0IHRvIHJlc3VtZSB0aGUgY29udGV4dCBoZXJlLCBpZiB0aGF0IGRvZXNuJ3Qgd29yaywgd2UganVzdCBjb250aW51ZSB3aXRoIHJlZ3VsYXIgcHJvY2Vzc2luZ1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignQ291bGQgbm90IHJlc3VtZSBhdWRpbyBjb250ZXh0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICBjb25zdCBuZXdDb250ZXh0SXNSdW5uaW5nID0gKChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpID09PSAncnVubmluZyc7XG4gICAgICBpZiAobmV3Q29udGV4dElzUnVubmluZyAhPT0gdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgbmV3Q29udGV4dElzUnVubmluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCBpZCwgJycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXgpIHtcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuICAgIGlmICgoX2EgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VJZCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9PdXRwdXQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpZCwgaW5mbykge1xuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50cy5oYXMoaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KGlkKTtcbiAgICB9XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50KGlkLCBpbmZvKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50cy5zZXQoaWQsIHBhcnRpY2lwYW50KTtcbiAgICB0aGlzLmlkZW50aXR5VG9TaWQuc2V0KGluZm8uaWRlbnRpdHksIGluZm8uc2lkKTtcbiAgICAvLyBpZiB3ZSBoYXZlIHZhbGlkIGluZm8gYW5kIHRoZSBwYXJ0aWNpcGFudCB3YXNuJ3QgaW4gdGhlIG1hcCBiZWZvcmUsIHdlIGNhbiBhc3N1bWUgdGhlIHBhcnRpY2lwYW50IGlzIG5ld1xuICAgIC8vIGZpcmluZyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGBQYXJ0aWNpcGFudENvbm5lY3RlZGAgZmlyZXMgYmVmb3JlIHRoZSBpbml0aWFsIHRyYWNrIGV2ZW50c1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgLy8gYWxzbyBmb3J3YXJkIGV2ZW50c1xuICAgIC8vIHRyYWNrUHVibGlzaGVkIGlzIG9ubHkgZmlyZWQgZm9yIHRyYWNrcyBhZGRlZCBhZnRlciBib3RoIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgLy8gYW5kIHJlbW90ZSBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb21cbiAgICBwYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHVibGljYXRpb24pID0+IHtcbiAgICAgIC8vIG1vbml0b3IgcGxheWJhY2sgc3RhdHVzXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5ID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsICh0cmFja1NpZCwgZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pO1xuICAgIC8vIHVwZGF0ZSBpbmZvIGF0IHRoZSBlbmQgYWZ0ZXIgY2FsbGJhY2tzIGhhdmUgYmVlbiBzZXQgdXBcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoKSB7XG4gICAgY29uc3QgcmVtb3RlVHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICBhY2MucHVzaCguLi5wYXJ0aWNpcGFudC5nZXRUcmFja3MoKSk7IC8vIEZJWE1FIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSB0aGlzIHJldHVybiBSZW1vdGVUcmFja1B1YmxpY2F0aW9ucyBkaXJlY3RseSBpbnN0ZWFkIG9mIHRoZSB0eXBlIGNhc3RcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrcygpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9ucyBkaXJlY3RseSBpbnN0ZWFkIG9mIHRoZSB0eXBlIGNhc3RcbiAgICB0aGlzLmVuZ2luZS5zZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpO1xuICB9XG4gIC8qKlxuICAgKiBBZnRlciByZXN1bWluZywgd2UnbGwgbmVlZCB0byBub3RpZnkgdGhlIHNlcnZlciBvZiB0aGUgY3VycmVudFxuICAgKiBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXG4gICAqL1xuICB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocHViLmlzU3Vic2NyaWJlZCAmJiBwdWIgaW5zdGFuY2VvZiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIGxldCBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgIC8vIGVuc3VyZSB3ZSBkaWRuJ3QgdGVhciBpdCBkb3duXG4gICAgICAhdGhpcy5lbmdpbmUgfHxcbiAgICAgIC8vIGVuZ2luZSBkZXRlY3RlZCBjbG9zZSwgYnV0IFJvb20gbWlzc2VkIGl0XG4gICAgICB0aGlzLmVuZ2luZS5pc0Nsb3NlZCB8fFxuICAgICAgLy8gdHJhbnNwb3J0cyBmYWlsZWQgd2l0aG91dCBub3RpZnlpbmcgZW5naW5lXG4gICAgICAhdGhpcy5lbmdpbmUudmVyaWZ5VHJhbnNwb3J0KCkpIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcysrO1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdkZXRlY3RlZCBjb25uZWN0aW9uIHN0YXRlIG1pc21hdGNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgbnVtRmFpbHVyZXM6IGNvbnNlY3V0aXZlRmFpbHVyZXMsXG4gICAgICAgICAgZW5naW5lOiB7XG4gICAgICAgICAgICBjbG9zZWQ6IHRoaXMuZW5naW5lLmlzQ2xvc2VkLFxuICAgICAgICAgICAgdHJhbnNwb3J0c0Nvbm5lY3RlZDogdGhpcy5lbmdpbmUudmVyaWZ5VHJhbnNwb3J0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgIH1cbiAgICB9LCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgLy8gdW5jaGFuZ2VkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVtaXRXaGVuQ29ubmVjdGVkKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gcG9wdWxhdGUgYSByb29tIHdpdGggc2ltdWxhdGVkIHBhcnRpY2lwYW50cy5cbiAgICogTm8gYWN0dWFsIGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIgd2lsbCBiZSBlc3RhYmxpc2hlZCwgYWxsIHN0YXRlIGlzXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNpbXVsYXRlUGFydGljaXBhbnRzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zLnB1Ymxpc2gpO1xuICAgICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNvdW50OiA5LFxuICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhc3BlY3RSYXRpb3M6IFsxLjY2LCAxLjcsIDEuM11cbiAgICAgIH0sIG9wdGlvbnMucGFydGljaXBhbnRzKTtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tJDEoe1xuICAgICAgICBzaWQ6ICdSTV9TSU1VTEFURUQnLFxuICAgICAgICBuYW1lOiAnc2ltdWxhdGVkLXJvb20nLFxuICAgICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICAgIG1heFBhcnRpY2lwYW50czogMCxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBwcm90b0ludDY0LnBhcnNlKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSxcbiAgICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgICBudW1QYXJ0aWNpcGFudHM6IDEsXG4gICAgICAgIG51bVB1Ymxpc2hlcnM6IDEsXG4gICAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICAgIGVuYWJsZWRDb2RlY3M6IFtdLFxuICAgICAgICBhY3RpdmVSZWNvcmRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51cGRhdGVJbmZvKG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJ1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy52aWRlbykge1xuICAgICAgICBjb25zdCBjYW1QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuVmlkZW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgIG5hbWU6ICd2aWRlby1kdW1teSdcbiAgICAgICAgfSksIG5ldyBMb2NhbFZpZGVvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pKS5nZXRWaWRlb1RyYWNrcygpWzBdIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2EgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSwgMTYwLCB0cnVlLCB0cnVlKSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBjYW1QdWIpO1xuICAgICAgfVxuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLkF1ZGlvLCBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgfSksIG5ldyBMb2NhbEF1ZGlvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgYXVkaW86IHRydWVcbiAgICAgICAgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF0gOiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hZGRUcmFja1B1YmxpY2F0aW9uKGF1ZGlvUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2lwYW50T3B0aW9ucy5jb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICBsZXQgaW5mbyA9IG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgaWRlbnRpdHk6IFwic2ltdWxhdGVkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgIGpvaW5lZEF0OiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlWaWRlbyA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9iID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1tpICUgcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvcy5sZW5ndGhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKSwgMTYwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVZpZGVvLCB2aWRlb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVZpZGVvXSkpO1xuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCB2aWRlb1RyYWNrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlUcmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VHJhY2ssIGF1ZGlvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VHJhY2tdKSk7XG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIGF1ZGlvVHJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgLy8gYWN0aXZlIHNwZWFrZXIgdXBkYXRlcyBhcmUgdG9vIHNwYW1teVxuICAgIGlmIChldmVudCAhPT0gUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCkge1xuICAgICAgLy8gb25seSBleHRyYWN0IGxvZ0NvbnRleHQgZnJvbSBhcmd1bWVudHMgaW4gb3JkZXIgdG8gYXZvaWQgbG9nZ2luZyB0aGUgd2hvbGUgb2JqZWN0IHRyZWVcbiAgICAgIGNvbnN0IG1pbmltaXplZEFyZ3MgPSBtYXBBcmdzKGFyZ3MpLmZpbHRlcihhcmcgPT4gYXJnICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJyb29tIGV2ZW50IFwiLmNvbmNhdChldmVudCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgYXJnczogbWluaW1pemVkQXJnc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcEFyZ3MoYXJncykge1xuICByZXR1cm4gYXJncy5tYXAoYXJnID0+IHtcbiAgICBpZiAoIWFyZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICByZXR1cm4gbWFwQXJncyhhcmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAnbG9nQ29udGV4dCcgaW4gYXJnICYmIGFyZy5sb2dDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcbn1cblxudmFyIENoZWNrU3RhdHVzO1xuKGZ1bmN0aW9uIChDaGVja1N0YXR1cykge1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNLSVBQRURcIl0gPSAyXSA9IFwiU0tJUFBFRFwiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNVQ0NFU1NcIl0gPSAzXSA9IFwiU1VDQ0VTU1wiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIkZBSUxFRFwiXSA9IDRdID0gXCJGQUlMRURcIjtcbn0pKENoZWNrU3RhdHVzIHx8IChDaGVja1N0YXR1cyA9IHt9KSk7XG5jbGFzcyBDaGVja2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdGF0dXMgPSBDaGVja1N0YXR1cy5JRExFO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMuZXJyb3JzQXNXYXJuaW5ncyA9IGZhbHNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5yb29tID0gbmV3IFJvb20ob3B0aW9ucy5yb29tT3B0aW9ucyk7XG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdGlvbnMuY29ubmVjdE9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuZXJyb3JzQXNXYXJuaW5ncykge1xuICAgICAgdGhpcy5lcnJvcnNBc1dhcm5pbmdzID0gb3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzO1xuICAgIH1cbiAgfVxuICBydW4ob25Db21wbGV0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IENoZWNrU3RhdHVzLklETEUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NoZWNrIGlzIHJ1bm5pbmcgYWxyZWFkeScpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuUlVOTklORyk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm0oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gc2xlZXAgZm9yIGEgYml0IHRvIGVuc3VyZSBkaXNjb25uZWN0XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IENoZWNrU3RhdHVzLlNLSVBQRUQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXModGhpcy5pc1N1Y2Nlc3MoKSA/IENoZWNrU3RhdHVzLlNVQ0NFU1MgOiBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5mbygpO1xuICAgIH0pO1xuICB9XG4gIGlzU3VjY2VzcygpIHtcbiAgICByZXR1cm4gIXRoaXMubG9ncy5zb21lKGwgPT4gbC5sZXZlbCA9PT0gJ2Vycm9yJyk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucm9vbS5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4pO1xuICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICB9KTtcbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5yb29tICYmIHRoaXMucm9vbS5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJvb20uZGlzY29ubmVjdCgpO1xuICAgICAgICAvLyB3YWl0IGZvciBpdCB0byBnbyB0aHJvdWdoXG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBza2lwKCkge1xuICAgIHRoaXMuc2V0U3RhdHVzKENoZWNrU3RhdHVzLlNLSVBQRUQpO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHRoaXMubG9ncy5wdXNoKHtcbiAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgYXBwZW5kV2FybmluZyhtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGdldCBlbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmdpbmU7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBsb2NhbCB2aWRlbyBhbmQgYXVkaW8gdHJhY2sgYXQgdGhlIHNhbWUgdGltZS4gV2hlbiBhY3F1aXJpbmcgYm90aFxuICogYXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB0b2dldGhlciwgaXQnbGwgZGlzcGxheSBhIHNpbmdsZSBwZXJtaXNzaW9uIHByb21wdCB0b1xuICogdGhlIHVzZXIgaW5zdGVhZCBvZiB0d28gc2VwYXJhdGUgb25lcy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zIHRvIHRydWVcbiAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBvcHRpb25zID0ge307XG4gICAgKF9hID0gb3B0aW9ucy5hdWRpbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0aW9ucy5hdWRpbyA9IHRydWU7XG4gICAgKF9iID0gb3B0aW9ucy52aWRlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogb3B0aW9ucy52aWRlbyA9IHRydWU7XG4gICAgY29uc3Qgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxuICAgIC8vIHdvcmtzIGFyb3VuZCBpT1MgU2FmYXJpIEJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgY29uc3QgbWVkaWFQcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCdhdWRpb2lucHV0JykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgICAgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNldCgndmlkZW9pbnB1dCcsIG1lZGlhUHJvbWlzZSk7XG4gICAgICBtZWRpYVByb21pc2UuY2F0Y2goKCkgPT4gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmRlbGV0ZSgndmlkZW9pbnB1dCcpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtID0geWllbGQgbWVkaWFQcm9taXNlO1xuICAgIHJldHVybiBzdHJlYW0uZ2V0VHJhY2tzKCkubWFwKG1lZGlhU3RyZWFtVHJhY2sgPT4ge1xuICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgIGlzQXVkaW8gPyBvcHRpb25zLmF1ZGlvIDogb3B0aW9ucy52aWRlbztcbiAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgY29uc3QgY29uT3JCb29sID0gaXNBdWRpbyA/IGNvbnN0cmFpbnRzLmF1ZGlvIDogY29uc3RyYWludHMudmlkZW87XG4gICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxuICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggdHJhY2sgcmVzdGFydCAoZS5nLiBtdXRlIC0gdW5tdXRlKSB3aWxsIHRyeSB0byBpbml0aWFsaXplIHRoZSBkZXZpY2UgYWdhaW4gLT4gY2F1c2luZyBhZGRpdGlvbmFsIHBlcm1pc3Npb24gcHJvbXB0c1xuICAgICAgaWYgKHRyYWNrQ29uc3RyYWludHMpIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgZGV2aWNlSWQ6IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMpO1xuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFtbTG9jYWxWaWRlb1RyYWNrXV0gd2l0aCBnZXRVc2VyTWVkaWEoKVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogb3B0aW9ucyxcbiAgICAgIHZpZGVvOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxNygpKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFRyYWNrcztcbiAgfSk7XG59XG5cbmNsYXNzIFB1Ymxpc2hBdWRpb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xuICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIHN0YXQubWVkaWFUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgYXVkaW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUHVibGlzaFZpZGVvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggdmlkZW8nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpO1xuICAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XG4gICAgICBpZiAoIXN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgICAgfVxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiB2aWRlbyBwYWNrZXRzXCIpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdSZXN1bWluZyBjb25uZWN0aW9uIGFmdGVyIGludGVycnVwdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGxldCByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGxldCByZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IHJlY29ubmVjdFJlc29sdmVyO1xuICAgICAgY29uc3QgcmVjb25uZWN0VGltZW91dCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApO1xuICAgICAgICByZWNvbm5lY3RSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIHJvb20ub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgfSkub24oUm9vbUV2ZW50LlJlY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIChfYSA9IHJvb20uZW5naW5lLmNsaWVudC53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICBjb25zdCBvbkNsb3NlID0gcm9vbS5lbmdpbmUuY2xpZW50Lm9uQ2xvc2U7XG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKCcnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICBpZiAoIXJlY29ubmVjdGluZ1RyaWdnZXJlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdyZWNvbm5lY3Rpb24gaXMgb25seSBwb3NzaWJsZSBpbiBSZWRpcy1iYXNlZCBjb25maWd1cmF0aW9ucycpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxuICAgICAgfSk7XG4gICAgICBsZXQgaGFzVExTID0gZmFsc2U7XG4gICAgICBsZXQgaGFzVFVSTiA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1NUVU4gPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGljZVNlcnZlciBvZiBqb2luUmVzLmljZVNlcnZlcnMpIHtcbiAgICAgICAgZm9yIChsZXQgdXJsIG9mIGljZVNlcnZlci51cmxzKSB7XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzVExTID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdzdHVuOicpKSB7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzU1RVTikge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFNUVU4gc2VydmVycyBjb25maWd1cmVkIG9uIHNlcnZlciBzaWRlLicpO1xuICAgICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdUVVJOIGlzIGNvbmZpZ3VyZWQgc2VydmVyIHNpZGUsIGJ1dCBUVVJOL1RMUyBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnRjQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWNlU2VydmVycykgfHwgaGFzVFVSTikge1xuICAgICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICAgIHJ0Y0NvbmZpZzoge1xuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAncmVsYXknXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gVFVSTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGhhc1RjcCA9IGZhbHNlO1xuICAgICAgbGV0IGhhc0lwdjRVZHAgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZUcmlja2xlID0gdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlO1xuICAgICAgICB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGUgPSAoc2QsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoc2QpO1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiXCIuY29uY2F0KGNhbmRpZGF0ZS5wcm90b2NvbCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUuYWRkcmVzcywgXCI6XCIpLmNvbmNhdChjYW5kaWRhdGUucG9ydCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUudHlwZSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xuICAgICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnIChwYXNzaXZlKSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICAgIHByZXZUcmlja2xlKHNkLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZUVycm9yID0gZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogXCIuY29uY2F0KGV2LmVycm9yQ29kZSwgXCIgXCIpLmNvbmNhdChldi5lcnJvclRleHQsIFwiIFwiKS5jb25jYXQoZXYudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdub3cgdGhlIHJvb20gaXMgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIElDRS9UQ1AnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzcykge1xuICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGlmIChwYXJ0c1swXSA9PT0gJzEwJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE5MicgJiYgcGFydHNbMV0gPT09ICcxNjgnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTcyJykge1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgIGlmIChzZWNvbmQgPj0gMTYgJiYgc2Vjb25kIDw9IDMxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIFdlYlNvY2tldENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3RpbmcgdG8gc2lnbmFsIGNvbm5lY3Rpb24gdmlhIFdlYlNvY2tldCc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ3dzOicpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgaW5zZWN1cmUsIGNsaWVudHMgbWF5IGJsb2NrIGNvbm5lY3Rpb25zIHRvIGl0Jyk7XG4gICAgICB9XG4gICAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgICAgY29uc3Qgam9pblJlcyA9IHlpZWxkIHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gICAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiQ29ubmVjdGVkIHRvIHNlcnZlciwgdmVyc2lvbiBcIi5jb25jYXQoam9pblJlcy5zZXJ2ZXJWZXJzaW9uLCBcIi5cIikpO1xuICAgICAgaWYgKCgoX2EgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lZGl0aW9uKSA9PT0gU2VydmVySW5mb19FZGl0aW9uLkNsb3VkICYmICgoX2IgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpb24pKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkxpdmVLaXQgQ2xvdWQ6IFwiLmNvbmNhdCgoX2MgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWdpb24pKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIENvbm5lY3Rpb25DaGVjayBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0SWQ7XG4gIH1cbiAgdXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKS5ldmVyeShyID0+IHIuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICB9XG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG4gIGNyZWF0ZUFuZFJ1bkNoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgICBjb25zdCB0ZXN0ID0gbmV3IGNoZWNrKHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IGluZm8gPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrKGNoZWNrSWQsIGluZm8pO1xuICAgICAgfTtcbiAgICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0ZXN0LnJ1bigpO1xuICAgICAgdGVzdC5vZmYoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNoZWNrV2Vic29ja2V0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJTb2NrZXRDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tXZWJSVEMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFdlYlJUQ0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1RVUk4oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFJlY29ubmVjdENoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1B1Ymxpc2hBdWRpbygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUHVibGlzaEF1ZGlvQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUHVibGlzaFZpZGVvKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZSB0aGUgYGZhY2luZ01vZGVgIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLCBidXQgd2lsbCBmYWxsIGJhY2sgb24gYSBzdHJpbmctYmFzZWQgYW5hbHlzaXMgb2YgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2sobG9jYWxUcmFjaykge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfYTtcbiAgY29uc3QgdHJhY2sgPSBsb2NhbFRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayA/IGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA6IGxvY2FsVHJhY2s7XG4gIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGZhY2luZ01vZGU6IChfYSA9IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1c2VyJyxcbiAgICBjb25maWRlbmNlOiAnbG93J1xuICB9O1xuICAvLyAxLiBUcnkgdG8gZ2V0IGZhY2luZ01vZGUgZnJvbSB0cmFjayBzZXR0aW5ncy5cbiAgaWYgKCdmYWNpbmdNb2RlJyBpbiB0cmFja1NldHRpbmdzKSB7XG4gICAgY29uc3QgcmF3RmFjaW5nTW9kZSA9IHRyYWNrU2V0dGluZ3MuZmFjaW5nTW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdyYXdGYWNpbmdNb2RlJywge1xuICAgICAgcmF3RmFjaW5nTW9kZVxuICAgIH0pO1xuICAgIGlmIChyYXdGYWNpbmdNb2RlICYmIHR5cGVvZiByYXdGYWNpbmdNb2RlID09PSAnc3RyaW5nJyAmJiBpc0ZhY2luZ01vZGVWYWx1ZShyYXdGYWNpbmdNb2RlKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBmYWNpbmdNb2RlOiByYXdGYWNpbmdNb2RlLFxuICAgICAgICBjb25maWRlbmNlOiAnaGlnaCdcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIDIuIElmIHdlIGRvbid0IGhhdmUgYSBoaWdoIGNvbmZpZGVuY2Ugd2UgdHJ5IHRvIGdldCB0aGUgZmFjaW5nIG1vZGUgZnJvbSB0aGUgZGV2aWNlIGxhYmVsLlxuICBpZiAoWydsb3cnLCAnbWVkaXVtJ10uaW5jbHVkZXMocmVzdWx0LmNvbmZpZGVuY2UpKSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6IChcIi5jb25jYXQodHJhY2subGFiZWwsIFwiKVwiKSk7XG4gICAgY29uc3QgbGFiZWxBbmFseXNpc1Jlc3VsdCA9IGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwodHJhY2subGFiZWwpO1xuICAgIGlmIChsYWJlbEFuYWx5c2lzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGxhYmVsQW5hbHlzaXNSZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXAoW1snb2JzIHZpcnR1YWwgY2FtZXJhJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXAoW1snaXBob25lJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV0sIFsnaXBhZCcsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dXSk7XG4vKipcbiAqIEF0dGVtcHQgdG8gYW5hbHl6ZSB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKGRldmljZUxhYmVsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFiZWwgPSBkZXZpY2VMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gRW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgZGV2aWNlIGxhYmVsIGJ1dCB3ZSBjYW4ndCBpbmZlciBhbnl0aGluZyBmcm9tIGl0LlxuICBpZiAobGFiZWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCB3aWRlbHkga25vd24gZGV2aWNlIGxhYmVscy5cbiAgaWYgKGtub3duRGV2aWNlTGFiZWxzLmhhcyhsYWJlbCkpIHtcbiAgICByZXR1cm4ga25vd25EZXZpY2VMYWJlbHMuZ2V0KGxhYmVsKTtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gKF9hID0gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKF9yZWYgPT4ge1xuICAgIGxldCBbc2VjdGlvbl0gPSBfcmVmO1xuICAgIHJldHVybiBsYWJlbC5pbmNsdWRlcyhzZWN0aW9uKTtcbiAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbn1cbmZ1bmN0aW9uIGlzRmFjaW5nTW9kZVZhbHVlKGl0ZW0pIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndXNlcicsICdlbnZpcm9ubWVudCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgfHwgYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhpdGVtKTtcbn1cblxuZXhwb3J0IHsgQXVkaW9QcmVzZXRzLCBCYXNlS2V5UHJvdmlkZXIsIENvbm5lY3Rpb25DaGVjaywgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uUXVhbGl0eSwgQ29ubmVjdGlvblN0YXRlLCBDcml0aWNhbFRpbWVycywgQ3J5cHRvckV2ZW50LCBEYXRhUGFja2V0X0tpbmQsIERlZmF1bHRSZWNvbm5lY3RQb2xpY3ksIERldmljZVVuc3VwcG9ydGVkRXJyb3IsIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25FdmVudCwgRW5naW5lRXZlbnQsIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyLCBLZXlIYW5kbGVyRXZlbnQsIEtleVByb3ZpZGVyRXZlbnQsIExpdmVraXRFcnJvciwgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFBhcnRpY2lwYW50LCBMb2NhbFRyYWNrLCBMb2NhbFRyYWNrUHVibGljYXRpb24sIExvY2FsVmlkZW9UcmFjaywgTG9nTGV2ZWwsIE1lZGlhRGV2aWNlRmFpbHVyZSwgTmVnb3RpYXRpb25FcnJvciwgUGFydGljaXBhbnQsIFBhcnRpY2lwYW50RXZlbnQsIFB1Ymxpc2hEYXRhRXJyb3IsIFJlbW90ZUF1ZGlvVHJhY2ssIFJlbW90ZVBhcnRpY2lwYW50LCBSZW1vdGVUcmFjaywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgUmVtb3RlVmlkZW9UcmFjaywgUm9vbSwgUm9vbUV2ZW50LCBSb29tU3RhdGUsIFNjcmVlblNoYXJlUHJlc2V0cywgVHJhY2ssIFRyYWNrRXZlbnQsIFRyYWNrSW52YWxpZEVycm9yLCBUcmFja1B1YmxpY2F0aW9uLCBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlLCBVbnN1cHBvcnRlZFNlcnZlciwgVmlkZW9QcmVzZXQsIFZpZGVvUHJlc2V0cywgVmlkZW9QcmVzZXRzNDMsIFZpZGVvUXVhbGl0eSwgYXR0YWNoVG9FbGVtZW50LCBjcmVhdGVBdWRpb0FuYWx5c2VyLCBjcmVhdGVFMkVFS2V5LCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZywgY3JlYXRlTG9jYWxBdWRpb1RyYWNrLCBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcywgY3JlYXRlTG9jYWxUcmFja3MsIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaywgZGVyaXZlS2V5cywgZGV0YWNoVHJhY2ssIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjaywgZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrLCBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2ssIGdldExvZ2dlciwgaW1wb3J0S2V5LCBpc0JhY2t1cENvZGVjLCBpc0Jyb3dzZXJTdXBwb3J0ZWQsIGlzRTJFRVN1cHBvcnRlZCwgaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkLCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCwgaXNWaWRlb0ZyYW1lLCBuZWVkc1Jic3BVbmVzY2FwaW5nLCBwYXJzZVJic3AsIHByb3RvY29sVmVyc2lvbiwgcmF0Y2hldCwgc2V0TG9nRXh0ZW5zaW9uLCBzZXRMb2dMZXZlbCwgc3VwcG9ydHNBVjEsIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0sIHN1cHBvcnRzRHluYWNhc3QsIHN1cHBvcnRzVlA5LCB2ZXJzaW9uLCB2aWRlb0NvZGVjcywgd3JpdGVSYnNwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXZla2l0LWNsaWVudC5lc20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9tZXJnZU5hbWVzcGFjZXMiLCJuIiwibSIsImZvckVhY2giLCJlIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0Iiwia2V5cyIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJsb2dsZXZlbCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyb290IiwiZGVmaW5pdGlvbiIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJhcHBseSIsImFyZ3VtZW50cyIsInRyYWNlRm9ySUUiLCJjb25zb2xlIiwidHJhY2UiLCJyZWFsTWV0aG9kIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5IiwiY3VycmVudExldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwibGV2ZWxzIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJnZXRMZXZlbCIsInNldExldmVsIiwicGVyc2lzdCIsIlNJTEVOVCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJpbml0aWFsTGV2ZWwiLCJkZWZhdWx0TG9nZ2VyIiwiX2xvZ2dlcnNCeU5hbWUiLCJnZXRMb2dnZXIiLCJUeXBlRXJyb3IiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiLCJsb2dsZXZlbEV4cG9ydHMiLCJMb2dMZXZlbCIsIkxvZ2dlck5hbWVzIiwibGl2ZWtpdExvZ2dlciIsImluZm8iLCJzZXRMb2dMZXZlbCIsImVudHJpZXMiLCJmaWx0ZXIiLCJfcmVmIiwibG9nck5hbWUiLCJzdGFydHNXaXRoIiwibWFwIiwiX3JlZjIiLCJsb2dyIiwic2V0TG9nRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwib3JpZ2luYWxGYWN0b3J5IiwiY29uZmlnTGV2ZWwiLCJyYXdNZXRob2QiLCJsb2dMZXZlbCIsIm5lZWRMb2ciLCJzaWxlbnQiLCJtc2ciLCJjb250ZXh0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJ0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsInZhbHVlcyIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUVudW1WYWx1ZSIsInB1c2giLCJmaW5kTmFtZSIsImZpbmROdW1iZXIiLCJtYWtlRW51bSIsImFzc2lnbiIsIk1lc3NhZ2UiLCJlcXVhbHMiLCJvdGhlciIsImdldFR5cGUiLCJydW50aW1lIiwidXRpbCIsImNsb25lIiwiZnJvbUJpbmFyeSIsImJ5dGVzIiwib3B0aW9ucyIsInR5cGUiLCJmb3JtYXQiLCJiaW4iLCJtYWtlUmVhZE9wdGlvbnMiLCJyZWFkTWVzc2FnZSIsInJlYWRlckZhY3RvcnkiLCJieXRlTGVuZ3RoIiwiZnJvbUpzb24iLCJqc29uVmFsdWUiLCJqc29uIiwiZnJvbUpzb25TdHJpbmciLCJqc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiY29uY2F0IiwibWVzc2FnZSIsIlN0cmluZyIsInRvQmluYXJ5IiwibWFrZVdyaXRlT3B0aW9ucyIsIndyaXRlciIsIndyaXRlckZhY3RvcnkiLCJ3cml0ZU1lc3NhZ2UiLCJmaW5pc2giLCJ0b0pzb24iLCJ0b0pzb25TdHJpbmciLCJfYSIsInN0cmluZ2lmeSIsInByZXR0eVNwYWNlcyIsInRvSlNPTiIsImVtaXREZWZhdWx0VmFsdWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIm1ha2VNZXNzYWdlVHlwZSIsImZpZWxkcyIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZGF0YSIsImluaXRGaWVsZHMiLCJpbml0UGFydGlhbCIsInNldFByb3RvdHlwZU9mIiwibmV3RmllbGRMaXN0IiwiYSIsImIiLCJtYWtlUHJvdG9SdW50aW1lIiwic3ludGF4IiwiU2NhbGFyVHlwZSIsIkxvbmdUeXBlIiwidmFyaW50NjRyZWFkIiwibG93Qml0cyIsImhpZ2hCaXRzIiwic2hpZnQiLCJidWYiLCJwb3MiLCJhc3NlcnRCb3VuZHMiLCJtaWRkbGVCeXRlIiwidmFyaW50NjR3cml0ZSIsImxvIiwiaGkiLCJoYXNOZXh0IiwiYnl0ZSIsInNwbGl0Qml0cyIsImhhc01vcmVCaXRzIiwiVFdPX1BXUl8zMl9EQkwiLCJpbnQ2NEZyb21TdHJpbmciLCJkZWMiLCJtaW51cyIsImJhc2UiLCJhZGQxZTZkaWdpdCIsImJlZ2luIiwiZW5kIiwiZGlnaXQxZTYiLCJuZWdhdGUiLCJuZXdCaXRzIiwiaW50NjRUb1N0cmluZyIsImJpdHMiLCJuZWdhdGl2ZSIsInJlc3VsdCIsInVJbnQ2NFRvU3RyaW5nIiwidG9VbnNpZ25lZCIsImxvdyIsIm1pZCIsImhpZ2giLCJkaWdpdEEiLCJkaWdpdEIiLCJkaWdpdEMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyIsImRpZ2l0MWU3IiwicGFydGlhbCIsInZhcmludDMyd3JpdGUiLCJ2YXJpbnQzMnJlYWQiLCJyZWFkQnl0ZXMiLCJtYWtlSW50NjRTdXBwb3J0IiwiZHYiLCJEYXRhVmlldyIsIkFycmF5QnVmZmVyIiwib2siLCJCaWdJbnQiLCJnZXRCaWdJbnQ2NCIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwicHJvY2VzcyIsImVudiIsIkJVRl9CSUdJTlRfRElTQUJMRSIsIk1JTiIsIk1BWCIsIlVNSU4iLCJVTUFYIiwiemVybyIsInN1cHBvcnRlZCIsImJpIiwidVBhcnNlIiwiZW5jIiwiZ2V0SW50MzIiLCJ1RW5jIiwic2V0SW50MzIiLCJ1RGVjIiwiYXNzZXJ0SW50NjRTdHJpbmciLCJhc3NlcnRVSW50NjRTdHJpbmciLCJwcm90b0ludDY0IiwiV2lyZVR5cGUiLCJCaW5hcnlXcml0ZXIiLCJ0ZXh0RW5jb2RlciIsInN0YWNrIiwiVGV4dEVuY29kZXIiLCJjaHVua3MiLCJVaW50OEFycmF5IiwibGVuIiwib2Zmc2V0Iiwic2V0IiwiZm9yayIsImpvaW4iLCJjaHVuayIsInByZXYiLCJwb3AiLCJ1aW50MzIiLCJyYXciLCJ0YWciLCJmaWVsZE5vIiwiaW50MzIiLCJib29sIiwic3RyaW5nIiwiZW5jb2RlIiwiZmxvYXQiLCJidWZmZXIiLCJzZXRGbG9hdDMyIiwiZG91YmxlIiwic2V0RmxvYXQ2NCIsImZpeGVkMzIiLCJzZXRVaW50MzIiLCJzZml4ZWQzMiIsInNpbnQzMiIsInNmaXhlZDY0IiwidmlldyIsInRjIiwiZml4ZWQ2NCIsImludDY0Iiwic2ludDY0Iiwic2lnbiIsInVpbnQ2NCIsIkJpbmFyeVJlYWRlciIsInRleHREZWNvZGVyIiwidmFyaW50NjQiLCJieXRlT2Zmc2V0IiwiVGV4dERlY29kZXIiLCJ3aXJlVHlwZSIsInNraXAiLCJzdGFydCIsIlZhcmludCIsIkJpdDY0IiwiQml0MzIiLCJMZW5ndGhEZWxpbWl0ZWQiLCJTdGFydEdyb3VwIiwiRW5kR3JvdXAiLCJzdWJhcnJheSIsIlJhbmdlRXJyb3IiLCJ6emUiLCJzIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJkZWNvZGUiLCJ3cmFwRmllbGQiLCJmaWVsZFdyYXBwZXIiLCJET1VCTEUiLCJGTE9BVCIsIklOVDY0IiwiVUlOVDY0IiwiSU5UMzIiLCJVSU5UMzIiLCJCT09MIiwiU1RSSU5HIiwiQllURVMiLCJzY2FsYXJFcXVhbHMiLCJGSVhFRDY0IiwiU0ZJWEVENjQiLCJTSU5UNjQiLCJzY2FsYXJEZWZhdWx0VmFsdWUiLCJsb25nVHlwZSIsInNjYWxhclR5cGVJbmZvIiwiaXNVbmRlZmluZWQiLCJpc0ludHJpbnNpY0RlZmF1bHQiLCJGSVhFRDMyIiwiU0ZJWEVEMzIiLCJ0b0xvd2VyQ2FzZSIsInVua25vd25GaWVsZHNTeW1ib2wiLCJyZWFkRGVmYXVsdHMiLCJyZWFkVW5rbm93bkZpZWxkcyIsIndyaXRlRGVmYXVsdHMiLCJ3cml0ZVVua25vd25GaWVsZHMiLCJtYWtlUmVhZE9wdGlvbnMkMSIsIm1ha2VXcml0ZU9wdGlvbnMkMSIsIm1ha2VCaW5hcnlGb3JtYXRDb21tb24iLCJsaXN0VW5rbm93bkZpZWxkcyIsImRpc2NhcmRVbmtub3duRmllbGRzIiwiYyIsImYiLCJvblVua25vd25GaWVsZCIsInJlYWRlciIsImZpZWxkIiwiZmluZCIsInRhcmdldCIsInJlcGVhdGVkIiwib25lb2YiLCJjYXNlIiwia2luZCIsInNjYWxhclR5cGUiLCJUIiwicmVhZCIsInJlYWRTY2FsYXIkMSIsIkwiLCJyZWFkU2NhbGFyTFRTdHJpbmciLCJhcnIiLCJtZXNzYWdlVHlwZSIsInJlYWRNZXNzYWdlRmllbGQiLCJ1bndyYXBGaWVsZCIsIm1hcEtleSIsIm1hcFZhbCIsInJlYWRNYXBFbnRyeSIsImtleSIsInZhbCIsIksiLCJWIiwia2V5UmF3IiwiQklHSU5UIiwiU0lOVDMyIiwid3JpdGVNYXBFbnRyeSIsImtleVZhbHVlIiwicGFyc2VJbnQiLCJ3cml0ZVNjYWxhciQxIiwid3JpdGVNZXNzYWdlRmllbGQiLCJlbWl0SW50cmluc2ljRGVmYXVsdCIsIndyaXRlUGFja2VkIiwibWFrZUJpbmFyeUZvcm1hdFByb3RvMyIsImJ5TnVtYmVyIiwicGFja2VkIiwiaXRlbSIsImVuY1RhYmxlIiwic3BsaXQiLCJkZWNUYWJsZSIsImNoYXJDb2RlQXQiLCJwcm90b0Jhc2U2NCIsImJhc2U2NFN0ciIsImVzIiwiYnl0ZVBvcyIsImdyb3VwUG9zIiwicCIsImJhc2U2NCIsImpzb25SZWFkRGVmYXVsdHMiLCJpZ25vcmVVbmtub3duRmllbGRzIiwianNvbldyaXRlRGVmYXVsdHMiLCJlbnVtQXNJbnRlZ2VyIiwidXNlUHJvdG9GaWVsZE5hbWUiLCJtYWtlSnNvbkZvcm1hdENvbW1vbiIsIm1ha2VXcml0ZUZpZWxkIiwid3JpdGVGaWVsZCIsIndyaXRlRW51bSIsIndyaXRlU2NhbGFyIiwib25lb2ZTZWVuIiwianNvbktleSIsImZpbmRKc29uTmFtZSIsInNlZW4iLCJ0YXJnZXRBcnJheSIsImpzb25JdGVtIiwicmVhZEVudW0iLCJyZWFkU2NhbGFyIiwidGFyZ2V0TWFwIiwianNvbk1hcEtleSIsImpzb25NYXBWYWx1ZSIsImVudW1WYWx1ZSIsIm1lbWJlciIsImJ5TWVtYmVyIiwiZmluZEZpZWxkIiwianNvbk5hbWUiLCJyIiwiZGVidWdKc29uVmFsdWUiLCJOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwidHJpbSIsImlzTmFOIiwibG9uZyIsInVMb25nIiwibWFrZUpzb25Gb3JtYXRQcm90bzMiLCJqc29uT2JqIiwiZW50cnlLZXkiLCJlbnRyeVZhbHVlIiwiZW51bVR5cGUiLCJqc29uQXJyIiwibWFrZVV0aWxDb21tb24iLCJzb3VyY2UiLCJzayIsInNvdXJjZUZpZWxkIiwidG9VOEFyciIsImNvcHkiLCJtdCIsImV2ZXJ5IiwidmEiLCJ2YiIsImFueSIsImNsb25lU2luZ3VsYXJGaWVsZCIsImlucHV0IiwiSW50ZXJuYWxGaWVsZExpc3QiLCJub3JtYWxpemVyIiwiX2ZpZWxkcyIsIl9ub3JtYWxpemVyIiwianNvbk5hbWVzIiwibGlzdCIsImFsbCIsIm51bWJlcnNBc2MiLCJzb3J0IiwibWVtYmVycyIsIm8iLCJsb2NhbEZpZWxkTmFtZSIsInByb3RvTmFtZSIsImluT25lb2YiLCJwcm90b0NhbWVsQ2FzZSIsInNhZmVPYmplY3RQcm9wZXJ0eSIsInNhZmVNZXNzYWdlUHJvcGVydHkiLCJsb2NhbE9uZW9mTmFtZSIsImZpZWxkSnNvbk5hbWUiLCJzbmFrZUNhc2UiLCJjYXBOZXh0IiwiY2hhckF0IiwicmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzIiwiU2V0IiwicmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyIsImZhbGxiYWNrIiwiaGFzIiwiSW50ZXJuYWxPbmVvZkluZm8iLCJkZWZhdWx0IiwiYWRkRmllbGQiLCJfbG9va3VwIiwicHJvdG8zIiwibm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyIsImZpZWxkSW5mb3MiLCJfYiIsIl9jIiwiX2QiLCJvb25hbWUiLCJUaW1lc3RhbXAiLCJzZWNvbmRzIiwibmFub3MiLCJtYXRjaGVzIiwibWF0Y2giLCJtcyIsIkRhdGUiLCJyZXBlYXQiLCJ6IiwibmFub3NTdHIiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJ0b0RhdGUiLCJjZWlsIiwibm93IiwiZnJvbURhdGUiLCJkYXRlIiwiZ2V0VGltZSIsIkF1ZGlvQ29kZWMiLCJWaWRlb0NvZGVjIiwiSW1hZ2VDb2RlYyIsIlRyYWNrVHlwZSIsIlRyYWNrU291cmNlIiwiVmlkZW9RdWFsaXR5IiwiQ29ubmVjdGlvblF1YWxpdHkkMSIsIkNvbm5lY3Rpb25RdWFsaXR5IiwiQ2xpZW50Q29uZmlnU2V0dGluZyIsIkRpc2Nvbm5lY3RSZWFzb24iLCJSZWNvbm5lY3RSZWFzb24iLCJTdWJzY3JpcHRpb25FcnJvciIsIlJvb20kMSIsIlJvb20iLCJzaWQiLCJlbXB0eVRpbWVvdXQiLCJtYXhQYXJ0aWNpcGFudHMiLCJjcmVhdGlvblRpbWUiLCJ0dXJuUGFzc3dvcmQiLCJlbmFibGVkQ29kZWNzIiwibWV0YWRhdGEiLCJudW1QYXJ0aWNpcGFudHMiLCJudW1QdWJsaXNoZXJzIiwiYWN0aXZlUmVjb3JkaW5nIiwiQ29kZWMiLCJtaW1lIiwiZm10cExpbmUiLCJQbGF5b3V0RGVsYXkiLCJlbmFibGVkIiwibWluIiwibWF4IiwiUGFydGljaXBhbnRQZXJtaXNzaW9uIiwiY2FuU3Vic2NyaWJlIiwiY2FuUHVibGlzaCIsImNhblB1Ymxpc2hEYXRhIiwiY2FuUHVibGlzaFNvdXJjZXMiLCJoaWRkZW4iLCJyZWNvcmRlciIsImNhblVwZGF0ZU1ldGFkYXRhIiwiYWdlbnQiLCJQYXJ0aWNpcGFudEluZm8iLCJpZGVudGl0eSIsInN0YXRlIiwiUGFydGljaXBhbnRJbmZvX1N0YXRlIiwiSk9JTklORyIsInRyYWNrcyIsImpvaW5lZEF0IiwidmVyc2lvbiIsInJlZ2lvbiIsImlzUHVibGlzaGVyIiwiVHJhY2tJbmZvIiwiRW5jcnlwdGlvbiIsIkVuY3J5cHRpb25fVHlwZSIsIlNpbXVsY2FzdENvZGVjSW5mbyIsIm1pbWVUeXBlIiwiY2lkIiwibGF5ZXJzIiwiVmlkZW9MYXllciIsIkFVRElPIiwibXV0ZWQiLCJ3aWR0aCIsImhlaWdodCIsInNpbXVsY2FzdCIsImRpc2FibGVEdHgiLCJVTktOT1dOIiwiY29kZWNzIiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImVuY3J5cHRpb24iLCJOT05FIiwic3RyZWFtIiwicXVhbGl0eSIsIkxPVyIsImJpdHJhdGUiLCJzc3JjIiwiRGF0YVBhY2tldCIsIkRhdGFQYWNrZXRfS2luZCIsIlJFTElBQkxFIiwiVXNlclBhY2tldCIsIkFjdGl2ZVNwZWFrZXJVcGRhdGUiLCJzcGVha2VycyIsIlNwZWFrZXJJbmZvIiwiYWN0aXZlIiwicGFydGljaXBhbnRTaWQiLCJwYXJ0aWNpcGFudElkZW50aXR5IiwicGF5bG9hZCIsImRlc3RpbmF0aW9uU2lkcyIsImRlc3RpbmF0aW9uSWRlbnRpdGllcyIsIlBhcnRpY2lwYW50VHJhY2tzIiwidHJhY2tTaWRzIiwiU2VydmVySW5mbyIsImVkaXRpb24iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJTdGFuZGFyZCIsInByb3RvY29sIiwibm9kZUlkIiwiZGVidWdJbmZvIiwiQ2xpZW50SW5mbyIsInNkayIsIkNsaWVudEluZm9fU0RLIiwib3MiLCJvc1ZlcnNpb24iLCJkZXZpY2VNb2RlbCIsImJyb3dzZXIiLCJicm93c2VyVmVyc2lvbiIsImFkZHJlc3MiLCJuZXR3b3JrIiwiQ2xpZW50Q29uZmlndXJhdGlvbiIsInJlc3VtZUNvbm5lY3Rpb24iLCJVTlNFVCIsImZvcmNlUmVsYXkiLCJWaWRlb0NvbmZpZ3VyYXRpb24iLCJEaXNhYmxlZENvZGVjcyIsImhhcmR3YXJlRW5jb2RlciIsInB1Ymxpc2giLCJSVFBEcmlmdCIsImR1cmF0aW9uIiwic3RhcnRUaW1lc3RhbXAiLCJlbmRUaW1lc3RhbXAiLCJydHBDbG9ja1RpY2tzIiwiZHJpZnRTYW1wbGVzIiwiZHJpZnRNcyIsImNsb2NrUmF0ZSIsIlJUUFN0YXRzIiwicGFja2V0cyIsInBhY2tldFJhdGUiLCJoZWFkZXJCeXRlcyIsInBhY2tldHNMb3N0IiwicGFja2V0TG9zc1JhdGUiLCJwYWNrZXRMb3NzUGVyY2VudGFnZSIsInBhY2tldHNEdXBsaWNhdGUiLCJwYWNrZXREdXBsaWNhdGVSYXRlIiwiYnl0ZXNEdXBsaWNhdGUiLCJoZWFkZXJCeXRlc0R1cGxpY2F0ZSIsImJpdHJhdGVEdXBsaWNhdGUiLCJwYWNrZXRzUGFkZGluZyIsInBhY2tldFBhZGRpbmdSYXRlIiwiYnl0ZXNQYWRkaW5nIiwiaGVhZGVyQnl0ZXNQYWRkaW5nIiwiYml0cmF0ZVBhZGRpbmciLCJwYWNrZXRzT3V0T2ZPcmRlciIsImZyYW1lcyIsImZyYW1lUmF0ZSIsImppdHRlckN1cnJlbnQiLCJqaXR0ZXJNYXgiLCJnYXBIaXN0b2dyYW0iLCJuYWNrcyIsIm5hY2tBY2tzIiwibmFja01pc3NlcyIsIm5hY2tSZXBlYXRlZCIsInBsaXMiLCJmaXJzIiwicnR0Q3VycmVudCIsInJ0dE1heCIsImtleUZyYW1lcyIsImxheWVyTG9ja1BsaXMiLCJUaW1lZFZlcnNpb24iLCJ1bml4TWljcm8iLCJ0aWNrcyIsIm1heFJldHJ5RGVsYXkiLCJERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyIsIkRlZmF1bHRSZWNvbm5lY3RQb2xpY3kiLCJyZXRyeURlbGF5cyIsIl9yZXRyeURlbGF5cyIsIm5leHRSZXRyeURlbGF5SW5NcyIsInJldHJ5Q291bnQiLCJyZXRyeURlbGF5IiwicmFuZG9tIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJkb25lIiwidGhlbiIsIl9fdmFsdWVzIiwiaXRlcmF0b3IiLCJfX2FzeW5jVmFsdWVzIiwiYXN5bmNJdGVyYXRvciIsInZlcmIiLCJzZXR0bGUiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJldmVudHMiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiYXJncyIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwid2FybiIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiaW5pdCIsIm9uY2UiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfZ2V0TWF4TGlzdGVuZXJzIiwidGhhdCIsImdldE1heExpc3RlbmVycyIsImVtaXQiLCJkb0Vycm9yIiwiZXIiLCJlcnIiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiaW5kZXgiLCJyZXQiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudHNFeHBvcnRzIiwibG9nRGlzYWJsZWRfIiwiZGVwcmVjYXRpb25XYXJuaW5nc18iLCJleHRyYWN0VmVyc2lvbiIsInVhc3RyaW5nIiwiZXhwciIsIndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50IiwiZXZlbnROYW1lVG9XcmFwIiwid3JhcHBlciIsIlJUQ1BlZXJDb25uZWN0aW9uIiwicHJvdG8iLCJuYXRpdmVBZGRFdmVudExpc3RlbmVyIiwibmF0aXZlRXZlbnROYW1lIiwiY2IiLCJ3cmFwcGVkQ2FsbGJhY2siLCJtb2RpZmllZEV2ZW50IiwiaGFuZGxlRXZlbnQiLCJfZXZlbnRNYXAiLCJNYXAiLCJuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyIiwidW53cmFwcGVkQ2IiLCJkZWxldGUiLCJzaXplIiwiY29uZmlndXJhYmxlIiwiZGlzYWJsZUxvZyIsImRpc2FibGVXYXJuaW5ncyIsImRlcHJlY2F0ZWQiLCJvbGRNZXRob2QiLCJuZXdNZXRob2QiLCJkZXRlY3RCcm93c2VyIiwibW96R2V0VXNlck1lZGlhIiwid2Via2l0R2V0VXNlck1lZGlhIiwiaXNTZWN1cmVDb250ZXh0Iiwid2Via2l0UlRDUGVlckNvbm5lY3Rpb24iLCJzdXBwb3J0c1VuaWZpZWRQbGFuIiwiUlRDUnRwVHJhbnNjZWl2ZXIiLCJpc09iamVjdCIsImNvbXBhY3RPYmplY3QiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImlzT2JqIiwiaXNFbXB0eU9iamVjdCIsIndhbGtTdGF0cyIsInN0YXRzIiwicmVzdWx0U2V0IiwiaWQiLCJlbmRzV2l0aCIsImZpbHRlclN0YXRzIiwidHJhY2siLCJvdXRib3VuZCIsInN0cmVhbVN0YXRzVHlwZSIsImZpbHRlcmVkUmVzdWx0IiwidHJhY2tTdGF0cyIsInRyYWNrSWRlbnRpZmllciIsInRyYWNrU3RhdCIsInRyYWNrSWQiLCJsb2dnaW5nIiwic2hpbUdldFVzZXJNZWRpYSQyIiwiYnJvd3NlckRldGFpbHMiLCJtZWRpYURldmljZXMiLCJjb25zdHJhaW50c1RvQ2hyb21lXyIsIm1hbmRhdG9yeSIsIm9wdGlvbmFsIiwiY2MiLCJpZGVhbCIsImV4YWN0Iiwib2xkbmFtZV8iLCJwcmVmaXgiLCJvYyIsIm1peCIsImFkdmFuY2VkIiwic2hpbUNvbnN0cmFpbnRzXyIsImNvbnN0cmFpbnRzIiwiZnVuYyIsImF1ZGlvIiwicmVtYXAiLCJ2aWRlbyIsImZhY2UiLCJmYWNpbmdNb2RlIiwiZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMiLCJnZXRTdXBwb3J0ZWRDb25zdHJhaW50cyIsImVudW1lcmF0ZURldmljZXMiLCJkZXZpY2VzIiwiZGV2Iiwic29tZSIsImxhYmVsIiwiaW5jbHVkZXMiLCJkZXZpY2VJZCIsInNoaW1FcnJvcl8iLCJQZXJtaXNzaW9uRGVuaWVkRXJyb3IiLCJQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3IiLCJJbnZhbGlkU3RhdGVFcnJvciIsIkRldmljZXNOb3RGb3VuZEVycm9yIiwiQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yIiwiVHJhY2tTdGFydEVycm9yIiwiTWVkaWFEZXZpY2VGYWlsZWREdWVUb1NodXRkb3duIiwiTWVkaWFEZXZpY2VLaWxsU3dpdGNoT24iLCJUYWJDYXB0dXJlRXJyb3IiLCJTY3JlZW5DYXB0dXJlRXJyb3IiLCJEZXZpY2VDYXB0dXJlRXJyb3IiLCJjb25zdHJhaW50IiwiY29uc3RyYWludE5hbWUiLCJnZXRVc2VyTWVkaWFfIiwib25TdWNjZXNzIiwib25FcnJvciIsImdldFVzZXJNZWRpYSIsIm9yaWdHZXRVc2VyTWVkaWEiLCJjcyIsImdldEF1ZGlvVHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJnZXRUcmFja3MiLCJzdG9wIiwiRE9NRXhjZXB0aW9uIiwic2hpbUdldERpc3BsYXlNZWRpYSQxIiwiZ2V0U291cmNlSWQiLCJnZXREaXNwbGF5TWVkaWEiLCJzb3VyY2VJZCIsIndpZHRoU3BlY2lmaWVkIiwiaGVpZ2h0U3BlY2lmaWVkIiwiZnJhbWVSYXRlU3BlY2lmaWVkIiwiY2hyb21lTWVkaWFTb3VyY2UiLCJjaHJvbWVNZWRpYVNvdXJjZUlkIiwibWF4RnJhbWVSYXRlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJzaGltTWVkaWFTdHJlYW0iLCJNZWRpYVN0cmVhbSIsIndlYmtpdE1lZGlhU3RyZWFtIiwic2hpbU9uVHJhY2skMSIsIl9vbnRyYWNrIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfb250cmFja3BvbHkiLCJ0ZSIsImdldFJlY2VpdmVycyIsImV2ZW50IiwiRXZlbnQiLCJ0cmFuc2NlaXZlciIsInN0cmVhbXMiLCJkaXNwYXRjaEV2ZW50Iiwic2hpbUdldFNlbmRlcnNXaXRoRHRtZiIsInNoaW1TZW5kZXJXaXRoRHRtZiIsInBjIiwiZHRtZiIsIl9kdG1mIiwiY3JlYXRlRFRNRlNlbmRlciIsIl9wYyIsImdldFNlbmRlcnMiLCJfc2VuZGVycyIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJpZHgiLCJzcGxpY2UiLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwib3JpZ1JlbW92ZVN0cmVhbSIsInJlbW92ZVN0cmVhbSIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwic2VuZGVycyIsInNoaW1HZXRTdGF0cyIsIm9yaWdHZXRTdGF0cyIsImdldFN0YXRzIiwic2VsZWN0b3IiLCJvblN1Y2MiLCJvbkVyciIsImZpeENocm9tZVN0YXRzXyIsInJlc3BvbnNlIiwic3RhbmRhcmRSZXBvcnQiLCJyZXBvcnRzIiwicmVwb3J0Iiwic3RhbmRhcmRTdGF0cyIsInRpbWVzdGFtcCIsImxvY2FsY2FuZGlkYXRlIiwicmVtb3RlY2FuZGlkYXRlIiwic3RhdCIsIm1ha2VNYXBTdGF0cyIsInN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfIiwic2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMiLCJSVENSdHBSZWNlaXZlciIsIm9yaWdHZXRSZWNlaXZlcnMiLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50IiwiTWVkaWFTdHJlYW1UcmFjayIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsImdldExvY2FsU3RyZWFtcyIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIm5hdGl2ZVN0cmVhbXMiLCJfcmV2ZXJzZVN0cmVhbXMiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUmVnRXhwIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJpc0xlZ2FjeUNhbGwiLCJkZXNjIiwib3JpZ1NldExvY2FsRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib3JpZ0xvY2FsRGVzY3JpcHRpb24iLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiQxIiwiUlRDSWNlQ2FuZGlkYXRlIiwiZml4TmVnb3RpYXRpb25OZWVkZWQiLCJnZXRDb25maWd1cmF0aW9uIiwic2RwU2VtYW50aWNzIiwiY2hyb21lU2hpbSIsIl9fcHJvdG9fXyIsInNoaW1HZXREaXNwbGF5TWVkaWEiLCJzaGltR2V0VXNlck1lZGlhIiwic2hpbU9uVHJhY2siLCJzaGltUGVlckNvbm5lY3Rpb24iLCJzaGltR2V0VXNlck1lZGlhJDEiLCJuYXRpdmVHZXRVc2VyTWVkaWEiLCJnZXRTZXR0aW5ncyIsIm5hdGl2ZUdldFNldHRpbmdzIiwiYXBwbHlDb25zdHJhaW50cyIsIm5hdGl2ZUFwcGx5Q29uc3RyYWludHMiLCJwcmVmZXJyZWRNZWRpYVNvdXJjZSIsImNvZGUiLCJtZWRpYVNvdXJjZSIsIlJUQ1RyYWNrRXZlbnQiLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIm1vZGVyblN0YXRzVHlwZXMiLCJpbmJvdW5kcnRwIiwib3V0Ym91bmRydHAiLCJjYW5kaWRhdGVwYWlyIiwibmF0aXZlR2V0U3RhdHMiLCJzaGltU2VuZGVyR2V0U3RhdHMiLCJzaGltUmVjZWl2ZXJHZXRTdGF0cyIsInNoaW1SZW1vdmVTdHJlYW0iLCJzaGltUlRDRGF0YUNoYW5uZWwiLCJEYXRhQ2hhbm5lbCIsIlJUQ0RhdGFDaGFubmVsIiwic2hpbUFkZFRyYW5zY2VpdmVyIiwib3JpZ0FkZFRyYW5zY2VpdmVyIiwiYWRkVHJhbnNjZWl2ZXIiLCJzZXRQYXJhbWV0ZXJzUHJvbWlzZXMiLCJzZW5kRW5jb2RpbmdzIiwic2hvdWxkUGVyZm9ybUNoZWNrIiwiZW5jb2RpbmdQYXJhbSIsInJpZFJlZ2V4IiwicmlkIiwicGFyc2VGbG9hdCIsInNjYWxlUmVzb2x1dGlvbkRvd25CeSIsIm1heEZyYW1lcmF0ZSIsInBhcmFtcyIsImdldFBhcmFtZXRlcnMiLCJlbmNvZGluZ3MiLCJzZXRQYXJhbWV0ZXJzIiwiY2F0Y2giLCJzaGltR2V0UGFyYW1ldGVycyIsIm9yaWdHZXRQYXJhbWV0ZXJzIiwic2hpbUNyZWF0ZU9mZmVyIiwib3JpZ0NyZWF0ZU9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJmaW5hbGx5Iiwic2hpbUNyZWF0ZUFuc3dlciIsIm9yaWdDcmVhdGVBbnN3ZXIiLCJjcmVhdGVBbnN3ZXIiLCJmaXJlZm94U2hpbSIsInNoaW1Mb2NhbFN0cmVhbXNBUEkiLCJfbG9jYWxTdHJlYW1zIiwiX2FkZFRyYWNrIiwiX2xlbiIsIl9rZXkiLCJzaGltUmVtb3RlU3RyZWFtc0FQSSIsImdldFJlbW90ZVN0cmVhbXMiLCJfcmVtb3RlU3RyZWFtcyIsIl9vbmFkZHN0cmVhbSIsIl9vbmFkZHN0cmVhbXBvbHkiLCJzaGltQ2FsbGJhY2tzQVBJIiwiYWRkSWNlQ2FuZGlkYXRlIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwicHJvbWlzZSIsIndpdGhDYWxsYmFjayIsImNhbmRpZGF0ZSIsIl9nZXRVc2VyTWVkaWEiLCJzaGltQ29uc3RyYWludHMiLCJlcnJjYiIsInNoaW1SVENJY2VTZXJ2ZXJVcmxzIiwiT3JpZ1BlZXJDb25uZWN0aW9uIiwicGNDb25maWciLCJwY0NvbnN0cmFpbnRzIiwiaWNlU2VydmVycyIsIm5ld0ljZVNlcnZlcnMiLCJzZXJ2ZXIiLCJ1cmxzIiwidXJsIiwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZSIsInNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIiLCJzaGltQ3JlYXRlT2ZmZXJMZWdhY3kiLCJvZmZlck9wdGlvbnMiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwiYXVkaW9UcmFuc2NlaXZlciIsImdldFRyYW5zY2VpdmVycyIsImRpcmVjdGlvbiIsInNldERpcmVjdGlvbiIsIm9mZmVyVG9SZWNlaXZlVmlkZW8iLCJ2aWRlb1RyYW5zY2VpdmVyIiwic2hpbUF1ZGlvQ29udGV4dCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNhZmFyaVNoaW0iLCJzZHAkMSIsIlNEUFV0aWxzIiwiZ2VuZXJhdGVJZGVudGlmaWVyIiwibG9jYWxDTmFtZSIsInNwbGl0TGluZXMiLCJibG9iIiwibGluZSIsInNwbGl0U2VjdGlvbnMiLCJwYXJ0cyIsInBhcnQiLCJnZXREZXNjcmlwdGlvbiIsInNlY3Rpb25zIiwiZ2V0TWVkaWFTZWN0aW9ucyIsIm1hdGNoUHJlZml4IiwicGFyc2VDYW5kaWRhdGUiLCJmb3VuZGF0aW9uIiwiY29tcG9uZW50IiwicHJpb3JpdHkiLCJpcCIsInBvcnQiLCJyZWxhdGVkQWRkcmVzcyIsInJlbGF0ZWRQb3J0IiwidGNwVHlwZSIsInVmcmFnIiwidXNlcm5hbWVGcmFnbWVudCIsIndyaXRlQ2FuZGlkYXRlIiwicGFyc2VJY2VPcHRpb25zIiwicGFyc2VSdHBNYXAiLCJwYXJzZWQiLCJwYXlsb2FkVHlwZSIsImNoYW5uZWxzIiwibnVtQ2hhbm5lbHMiLCJ3cml0ZVJ0cE1hcCIsImNvZGVjIiwicHQiLCJwcmVmZXJyZWRQYXlsb2FkVHlwZSIsInBhcnNlRXh0bWFwIiwidXJpIiwiYXR0cmlidXRlcyIsIndyaXRlRXh0bWFwIiwiaGVhZGVyRXh0ZW5zaW9uIiwicHJlZmVycmVkSWQiLCJwYXJzZUZtdHAiLCJrdiIsImoiLCJ3cml0ZUZtdHAiLCJwYXJhbWV0ZXJzIiwicGFyYW0iLCJwYXJzZVJ0Y3BGYiIsInBhcmFtZXRlciIsIndyaXRlUnRjcEZiIiwibGluZXMiLCJydGNwRmVlZGJhY2siLCJmYiIsInBhcnNlU3NyY01lZGlhIiwic3AiLCJjb2xvbiIsImF0dHJpYnV0ZSIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtZWRpYVNlY3Rpb24iLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJwYXJzZUNyeXB0b0xpbmUiLCJjcnlwdG9TdWl0ZSIsImtleVBhcmFtcyIsInNlc3Npb25QYXJhbXMiLCJ3cml0ZUNyeXB0b0xpbmUiLCJ3cml0ZUNyeXB0b0tleVBhcmFtcyIsInBhcnNlQ3J5cHRvS2V5UGFyYW1zIiwia2V5TWV0aG9kIiwia2V5U2FsdCIsImxpZmVUaW1lIiwibWtpVmFsdWUiLCJta2lMZW5ndGgiLCJnZXRDcnlwdG9QYXJhbWV0ZXJzIiwiZ2V0SWNlUGFyYW1ldGVycyIsInB3ZCIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwiaWNlTGl0ZSIsInBhcnNlUnRwUGFyYW1ldGVycyIsImhlYWRlckV4dGVuc2lvbnMiLCJmZWNNZWNoYW5pc21zIiwicnRjcCIsIm1saW5lIiwicHJvZmlsZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndpbGRjYXJkUnRjcEZiIiwiZHVwbGljYXRlIiwiZXhpc3RpbmdGZWVkYmFjayIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsIndyaXRlUnRjcFBhcmFtZXRlcnMiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsInBhcnNlTUxpbmUiLCJtYXhTaXplTGluZSIsIm1heE1lc3NhZ2VTaXplIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm1lZGlhIiwic2N0cCIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwic3Vic3RyIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiLCJzZHBFeHBvcnRzIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZSIsIk5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSIsIm5hdGl2ZUNhbmRpZGF0ZSIsInBhcnNlZENhbmRpZGF0ZSIsInNkcE1pZCIsInNkcE1MaW5lSW5kZXgiLCJ3cml0YWJsZSIsInNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sIiwicmVsYXlQcm90b2NvbCIsInNoaW1NYXhNZXNzYWdlU2l6ZSIsIl9zY3RwIiwic2N0cEluRGVzY3JpcHRpb24iLCJtTGluZSIsImdldFJlbW90ZUZpcmVmb3hWZXJzaW9uIiwiZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplIiwicmVtb3RlSXNGaXJlZm94IiwiY2FuU2VuZE1heE1lc3NhZ2VTaXplIiwiZ2V0TWF4TWVzc2FnZVNpemUiLCJpc0ZpcmVmb3giLCJjYW5TZW5kTU1TIiwicmVtb3RlTU1TIiwic2hpbVNlbmRUaHJvd1R5cGVFcnJvciIsIndyYXBEY1NlbmQiLCJkYyIsIm9yaWdEYXRhQ2hhbm5lbFNlbmQiLCJzZW5kIiwicmVhZHlTdGF0ZSIsIm9yaWdDcmVhdGVEYXRhQ2hhbm5lbCIsImNyZWF0ZURhdGFDaGFubmVsIiwiZGF0YUNoYW5uZWwiLCJjaGFubmVsIiwic2hpbUNvbm5lY3Rpb25TdGF0ZSIsImNvbXBsZXRlZCIsImNoZWNraW5nIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwiX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib3JpZ01ldGhvZCIsIl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5IiwiX2xhc3RDb25uZWN0aW9uU3RhdGUiLCJjb25uZWN0aW9uU3RhdGUiLCJuZXdFdmVudCIsInJlbW92ZUV4dG1hcEFsbG93TWl4ZWQiLCJuYXRpdmVTUkQiLCJzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkiLCJuYXRpdmVBZGRJY2VDYW5kaWRhdGUiLCJzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24iLCJuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIiwiY29tbW9uU2hpbSIsImFkYXB0ZXJGYWN0b3J5Iiwic2hpbUNocm9tZSIsInNoaW1GaXJlZm94Iiwic2hpbVNhZmFyaSIsImFkYXB0ZXIiLCJicm93c2VyU2hpbSIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIkUyRUVfRkxBRyIsIlNBTFQiLCJLRVlfUFJPVklERVJfREVGQVVMVFMiLCJzaGFyZWRLZXkiLCJyYXRjaGV0U2FsdCIsInJhdGNoZXRXaW5kb3dTaXplIiwiZmFpbHVyZVRvbGVyYW5jZSIsIktleVByb3ZpZGVyRXZlbnQiLCJLZXlIYW5kbGVyRXZlbnQiLCJFbmNyeXB0aW9uRXZlbnQiLCJDcnlwdG9yRXZlbnQiLCJpc0UyRUVTdXBwb3J0ZWQiLCJpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQiLCJpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCIsIlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSIsImNyZWF0ZUVuY29kZWRTdHJlYW1zIiwiaXNWaWRlb0ZyYW1lIiwiZnJhbWUiLCJpbXBvcnRLZXkiLCJrZXlCeXRlcyIsInVzYWdlIiwiY3J5cHRvIiwic3VidGxlIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nIiwia2V5TWF0ZXJpYWwiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIiLCJjcnlwdG9CdWZmZXIiLCJnZXRBbGdvT3B0aW9ucyIsImFsZ29yaXRobU5hbWUiLCJzYWx0IiwiZW5jb2RlZFNhbHQiLCJoYXNoIiwiaXRlcmF0aW9ucyIsImRlcml2ZUtleXMiLCJtYXRlcmlhbCIsImFsZ29yaXRobU9wdGlvbnMiLCJlbmNyeXB0aW9uS2V5IiwiZGVyaXZlS2V5IiwiY3JlYXRlRTJFRUtleSIsImdldFJhbmRvbVZhbHVlcyIsInJhdGNoZXQiLCJkZXJpdmVCaXRzIiwibmVlZHNSYnNwVW5lc2NhcGluZyIsImZyYW1lRGF0YSIsInBhcnNlUmJzcCIsImRhdGFPdXQiLCJrWmVyb3NJblN0YXJ0U2VxdWVuY2UiLCJrRW11bGF0aW9uQnl0ZSIsIndyaXRlUmJzcCIsImRhdGFfaW4iLCJudW1Db25zZWN1dGl2ZVplcm9zIiwiQmFzZUtleVByb3ZpZGVyIiwib25LZXlSYXRjaGV0ZWQiLCJrZXlJbmRleCIsImtleUluZm9NYXAiLCJLZXlSYXRjaGV0ZWQiLCJvblNldEVuY3J5cHRpb25LZXkiLCJrZXlJbmZvIiwiU2V0S2V5IiwiZ2V0S2V5cyIsImZyb20iLCJnZXRPcHRpb25zIiwicmF0Y2hldEtleSIsIlJhdGNoZXRSZXF1ZXN0IiwiRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIiLCJvcHRzIiwic2V0S2V5IiwiZGVyaXZlZEtleSIsIkxpdmVraXRFcnJvciIsIkNvbm5lY3Rpb25FcnJvciIsInJlYXNvbiIsInN0YXR1cyIsIkRldmljZVVuc3VwcG9ydGVkRXJyb3IiLCJUcmFja0ludmFsaWRFcnJvciIsIlVuc3VwcG9ydGVkU2VydmVyIiwiVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSIsIk5lZ290aWF0aW9uRXJyb3IiLCJQdWJsaXNoRGF0YUVycm9yIiwiTWVkaWFEZXZpY2VGYWlsdXJlIiwiZ2V0RmFpbHVyZSIsIk5vdEZvdW5kIiwiUGVybWlzc2lvbkRlbmllZCIsIkRldmljZUluVXNlIiwiT3RoZXIiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiaXNJbW1lZGlhdGUiLCJ1IiwiY2FsbGJhY2siLCJtYXhXYWl0IiwibCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJjb21tb25WZXJzaW9uSWRlbnRpZmllciIsImdldEJyb3dzZXIiLCJmb3JjZSIsInVhIiwiYnJvd3NlcnNMaXN0IiwiZGVzY3JpYmUiLCJnZXRNYXRjaCIsImV4cCIsInZlcnNpb24kMSIsInByb3RvY29sVmVyc2lvbiIsIkNyaXRpY2FsVGltZXJzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiVmlkZW9QcmVzZXQiLCJlbmNvZGluZyIsInJlc29sdXRpb24iLCJhc3BlY3RSYXRpbyIsImJhY2t1cENvZGVjcyIsInZpZGVvQ29kZWNzIiwiaXNCYWNrdXBDb2RlYyIsImJhY2t1cCIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsIlZpZGVvUHJlc2V0cyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiVmlkZW9QcmVzZXRzNDMiLCJoMTIwIiwiaDI0MCIsImg0ODAiLCJTY3JlZW5TaGFyZVByZXNldHMiLCJoMzYwZnBzMyIsImgzNjBmcHMxNSIsImg3MjBmcHM1IiwiaDcyMGZwczE1IiwiaDcyMGZwczMwIiwiaDEwODBmcHMxNSIsImgxMDgwZnBzMzAiLCJvcmlnaW5hbCIsIlNpZ25hbFRhcmdldCIsIlN0cmVhbVN0YXRlIiwiQ2FuZGlkYXRlUHJvdG9jb2wiLCJTaWduYWxSZXF1ZXN0IiwiU2Vzc2lvbkRlc2NyaXB0aW9uIiwiVHJpY2tsZVJlcXVlc3QiLCJBZGRUcmFja1JlcXVlc3QiLCJNdXRlVHJhY2tSZXF1ZXN0IiwiVXBkYXRlU3Vic2NyaXB0aW9uIiwiVXBkYXRlVHJhY2tTZXR0aW5ncyIsIkxlYXZlUmVxdWVzdCIsIlVwZGF0ZVZpZGVvTGF5ZXJzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbiIsIlN5bmNTdGF0ZSIsIlNpbXVsYXRlU2NlbmFyaW8iLCJVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIiwiUGluZyIsIlNpZ25hbFJlc3BvbnNlIiwiSm9pblJlc3BvbnNlIiwiUGFydGljaXBhbnRVcGRhdGUiLCJUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIiwiU3BlYWtlcnNDaGFuZ2VkIiwiUm9vbVVwZGF0ZSIsIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwiU3RyZWFtU3RhdGVVcGRhdGUiLCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJUcmFja1VucHVibGlzaGVkUmVzcG9uc2UiLCJSZWNvbm5lY3RSZXNwb25zZSIsIlBvbmciLCJTdWJzY3JpcHRpb25SZXNwb25zZSIsIlNpbXVsY2FzdENvZGVjIiwic2ltdWxjYXN0Q29kZWNzIiwiY2FuZGlkYXRlSW5pdCIsIlBVQkxJU0hFUiIsIm90aGVyUGFydGljaXBhbnRzIiwic2VydmVyVmVyc2lvbiIsInN1YnNjcmliZXJQcmltYXJ5IiwiYWx0ZXJuYXRpdmVVcmwiLCJzZXJ2ZXJSZWdpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInNpZlRyYWlsZXIiLCJJQ0VTZXJ2ZXIiLCJ0cmFja1NpZCIsInBhcnRpY2lwYW50cyIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwiZGlzYWJsZWQiLCJmcHMiLCJjYW5SZWNvbm5lY3QiLCJVTktOT1dOX1JFQVNPTiIsImNyZWRlbnRpYWwiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJQT09SIiwic2NvcmUiLCJ1cGRhdGVzIiwiU3RyZWFtU3RhdGVJbmZvIiwiQUNUSVZFIiwic3RyZWFtU3RhdGVzIiwiU3Vic2NyaWJlZFF1YWxpdHkiLCJTdWJzY3JpYmVkQ29kZWMiLCJxdWFsaXRpZXMiLCJzdWJzY3JpYmVkUXVhbGl0aWVzIiwic3Vic2NyaWJlZENvZGVjcyIsIlRyYWNrUGVybWlzc2lvbiIsImFsbFRyYWNrcyIsImFsbFBhcnRpY2lwYW50cyIsInRyYWNrUGVybWlzc2lvbnMiLCJhbGxvd2VkIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsIkRhdGFDaGFubmVsSW5mbyIsInNjZW5hcmlvIiwicnR0IiwibGFzdFBpbmdUaW1lc3RhbXAiLCJSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnMiLCJSZWdpb25JbmZvIiwiZGlzdGFuY2UiLCJTRV9VTktOT1dOIiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJzdHJlYW1TdGF0ZSIsIkFjdGl2ZSIsImlzSW5CYWNrZ3JvdW5kIiwiX2N1cnJlbnRCaXRyYXRlIiwiYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciIsImJhY2tncm91bmRUaW1lb3V0IiwidmlzaWJpbGl0eVN0YXRlIiwiaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQiLCJsb2dnZXJDb250ZXh0Q2IiLCJfbWVkaWFTdHJlYW1UcmFjayIsIl9tZWRpYVN0cmVhbUlEIiwiU291cmNlIiwiVW5rbm93biIsImxvZ0NvbnRleHQiLCJnZXRMb2dDb250ZXh0RnJvbVRyYWNrIiwiY3VycmVudEJpdHJhdGUiLCJtZWRpYVN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1JRCIsImF0dGFjaCIsImVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIktpbmQiLCJWaWRlbyIsImFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJoYXNBdWRpbyIsInRyIiwicGxheSIsIkF1ZGlvUGxheWJhY2tTdGFydGVkIiwiVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJBdWRpb1BsYXliYWNrRmFpbGVkIiwiVmlkZW9QbGF5YmFja0ZhaWxlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm1vbml0b3JJbnRlcnZhbCIsInVwZGF0ZUxvZ2dlck9wdGlvbnMiLCJIVE1MQXVkaW9FbGVtZW50Iiwic2hvdWxkQ2FjaGUiLCJwYXVzZSIsImlzV2ViIiwibWVkaWFTdHJlYW0iLCJleGlzdGluZ1RyYWNrcyIsImV0IiwiaXNTYWZhcmkiLCJIVE1MVmlkZW9FbGVtZW50IiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsImlzRmlyZUZveCIsIlN0cmVhbVN0YXRlJDEiLCJraW5kVG9Qcm90byIsIkF1ZGlvIiwiVklERU8iLCJEQVRBIiwia2luZEZyb21Qcm90byIsInNvdXJjZVRvUHJvdG8iLCJDYW1lcmEiLCJDQU1FUkEiLCJNaWNyb3Bob25lIiwiTUlDUk9QSE9ORSIsIlNjcmVlblNoYXJlIiwiU0NSRUVOX1NIQVJFIiwiU2NyZWVuU2hhcmVBdWRpbyIsIlNDUkVFTl9TSEFSRV9BVURJTyIsInNvdXJjZUZyb21Qcm90byIsInN0cmVhbVN0YXRlRnJvbVByb3RvIiwiUEFVU0VEIiwiUGF1c2VkIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImF1ZGlvRGVmYXVsdHMiLCJ2aWRlb0RlZmF1bHRzIiwibWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmciLCJtYWluT2JqZWN0Iiwib2JqZWN0VG9NZXJnZSIsImNvbnN0cmFpbnRzRm9yT3B0aW9ucyIsInZpZGVvT3B0aW9ucyIsImRldGVjdFNpbGVuY2UiLCJ0aW1lT2Zmc2V0IiwiY3R4IiwiZ2V0TmV3QXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImZmdFNpemUiLCJidWZmZXJMZW5ndGgiLCJmcmVxdWVuY3lCaW5Db3VudCIsImRhdGFBcnJheSIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsInNsZWVwIiwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhIiwic29tZU5vaXNlIiwic2FtcGxlIiwiY2xvc2UiLCJsYXRlbmN5SGludCIsInNvdXJjZVRvS2luZCIsInNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwiY29udHJvbGxlciIsInNlbGZCcm93c2VyU3VyZmFjZSIsInN1cmZhY2VTd2l0Y2hpbmciLCJzeXN0ZW1BdWRpbyIsIm1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8iLCJpbmZvcyIsInRyYWNrSW5mbyIsInRyYWNrU291cmNlIiwidHJhY2tNdXRlZCIsInRyYWNrRW5hYmxlZCIsInRyYWNrS2luZCIsInRyYWNrTmFtZSIsImlzRW5hYmxlZCIsInRyYWNrRW5jcnlwdGVkIiwiaXNFbmNyeXB0ZWQiLCJ0cmFja01pbWVUeXBlIiwic2VwYXJhdG9yIiwiZGRFeHRlbnNpb25VUkkiLCJ1bnBhY2tTdHJlYW1JZCIsInN1cHBvcnRzVHJhbnNjZWl2ZXIiLCJzdXBwb3J0c0FkZFRyYWNrIiwic3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSIsIlJlc2l6ZU9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJzdXBwb3J0c0R5bmFjYXN0Iiwic3VwcG9ydHNBVjEiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJoYXNBVjEiLCJzdXBwb3J0c1ZQOSIsImNvbXBhcmVWZXJzaW9ucyIsImhhc1ZQOSIsImlzU1ZDQ29kZWMiLCJzdXBwb3J0c1NldFNpbmtJZCIsInNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyIsIkNocm9tZSIsIlNhZmFyaSIsIkZpcmVmb3giLCJzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc0Nocm9taXVtQmFzZWQiLCJpc1NhZmFyaTE3IiwiaXNNb2JpbGUiLCJpc1JlYWN0TmF0aXZlIiwicHJvZHVjdCIsImlzQ2xvdWQiLCJzZXJ2ZXJVcmwiLCJob3N0bmFtZSIsImdldExLUmVhY3ROYXRpdmVJbmZvIiwiTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsIiwiZ2V0UmVhY3ROYXRpdmVPcyIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJ2MSIsInYyIiwicGFydHMxIiwicGFydHMyIiwicDEiLCJwMiIsInJvRGlzcGF0Y2hDYWxsYmFjayIsImVudHJ5IiwiaGFuZGxlUmVzaXplIiwiaW9EaXNwYXRjaENhbGxiYWNrIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQiLCJyZXNpemVPYnNlcnZlciIsImdldFJlc2l6ZU9ic2VydmVyIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3RNYXJnaW4iLCJnZXRDbGllbnRJbmZvIiwiSlMiLCJlbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2siLCJwYWludENvbnRlbnQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJkdW1teVN0cmVhbSIsImNhcHR1cmVTdHJlYW0iLCJkdW1teVRyYWNrIiwiZW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJnYWluIiwiY3JlYXRlR2FpbiIsInNldFZhbHVlQXRUaW1lIiwiZHN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIkZ1dHVyZSIsImZ1dHVyZUJhc2UiLCJvbkZpbmFsbHkiLCJjcmVhdGVBdWRpb0FuYWx5c2VyIiwiY2xvbmVUcmFjayIsInNtb290aGluZ1RpbWVDb25zdGFudCIsIm1pbkRlY2liZWxzIiwibWF4RGVjaWJlbHMiLCJhdWRpb0NvbnRleHQiLCJzdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtU291cmNlIiwiY2FsY3VsYXRlVm9sdW1lIiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJzdW0iLCJhbXBsaXR1ZGUiLCJwb3ciLCJ2b2x1bWUiLCJzcXJ0IiwiY2xlYW51cCIsIk11dGV4IiwiX2xvY2tpbmciLCJfbG9ja3MiLCJpc0xvY2tlZCIsImxvY2siLCJ1bmxvY2tOZXh0Iiwid2lsbExvY2siLCJ3aWxsVW5sb2NrIiwiaXNWaWRlb0NvZGVjIiwibWF5YmVDb2RlYyIsInVud3JhcENvbnN0cmFpbnQiLCJ0b1dlYnNvY2tldFVybCIsInRvSHR0cFVybCIsImRlZmF1bHRJZCIsIkRldmljZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0RGV2aWNlcyIsInJlcXVlc3RQZXJtaXNzaW9ucyIsInVzZXJNZWRpYVByb21pc2VNYXAiLCJoYXNEZXZpY2VJblVzZSIsImlzRHVtbXlEZXZpY2VPckVtcHR5IiwiZGV2aWNlIiwibm9MYWJlbCIsImlzUmVsZXZhbnQiLCJwZXJtaXNzaW9uc1RvQWNxdWlyZSIsIm5vcm1hbGl6ZURldmljZUlkIiwiZ3JvdXBJZCIsIm1lZGlhRGV2aWNlS2luZHMiLCJkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQiLCJMb2NhbFRyYWNrIiwiX2NvbnN0cmFpbnRzIiwidXNlclByb3ZpZGVkVHJhY2siLCJfaXNVcHN0cmVhbVBhdXNlZCIsImhhbmRsZVRyYWNrTXV0ZUV2ZW50IiwiZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciIsInBhdXNlVXBzdHJlYW0iLCJoYW5kbGVUcmFja1VubXV0ZUV2ZW50IiwicmVzdW1lVXBzdHJlYW0iLCJoYW5kbGVFbmRlZCIsInJlYWNxdWlyZVRyYWNrIiwiRW5kZWQiLCJwcm92aWRlZEJ5VXNlciIsIm11dGVMb2NrIiwicGF1c2VVcHN0cmVhbUxvY2siLCJwcm9jZXNzb3JMb2NrIiwic2V0TWVkaWFTdHJlYW1UcmFjayIsImdldENvbnN0cmFpbnRzIiwiZGltZW5zaW9ucyIsImlzVXBzdHJlYW1QYXVzZWQiLCJpc1VzZXJQcm92aWRlZCIsInByb2Nlc3NvciIsInByb2Nlc3NlZFRyYWNrIiwibmV3VHJhY2siLCJlbCIsInByb2Nlc3NvckVsZW1lbnQiLCJyZXN0YXJ0IiwicmVwbGFjZVRyYWNrIiwid2FpdEZvckRpbWVuc2lvbnMiLCJ0aW1lb3V0Iiwic3RhcnRlZCIsImRpbXMiLCJnZXREZXZpY2VJZCIsIm11dGUiLCJzZXRUcmFja011dGVkIiwidW5tdXRlIiwic3RvcFByb2Nlc3NvciIsInN0cmVhbUNvbnN0cmFpbnRzIiwiUmVzdGFydGVkIiwiTXV0ZWQiLCJVbm11dGVkIiwibmVlZHNSZUFjcXVpc2l0aW9uIiwiX3N1cGVyIiwiZGVzdHJveSIsInVubG9jayIsIlVwc3RyZWFtUGF1c2VkIiwiVXBzdHJlYW1SZXN1bWVkIiwiZ2V0UlRDU3RhdHNSZXBvcnQiLCJzdGF0c1JlcG9ydCIsInNldFByb2Nlc3NvciIsInNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5IiwicHJvY2Vzc29yT3B0aW9ucyIsImdldFByb2Nlc3NvciIsInJlbW92ZSIsIkUyRUVNYW5hZ2VyIiwib25Xb3JrZXJNZXNzYWdlIiwiZXYiLCJFbmNyeXB0aW9uRXJyb3IiLCJrZXlQcm92aWRlciIsInBvc3RLZXkiLCJlbmNyeXB0aW9uRW5hYmxlZCIsInJvb20iLCJsb2NhbFBhcnRpY2lwYW50IiwiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCIsInBhcnRpY2lwYW50IiwiZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5Iiwib25Xb3JrZXJFcnJvciIsIndvcmtlciIsInNldHVwIiwic2V0dXBFdmVudExpc3RlbmVycyIsImtleVByb3ZpZGVyT3B0aW9ucyIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJwb3N0TWVzc2FnZSIsInNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQiLCJwb3N0RW5hYmxlIiwic2V0U2lmVHJhaWxlciIsInRyYWlsZXIiLCJwb3N0U2lmVHJhaWxlciIsInNldHVwRW5naW5lIiwiZW5naW5lIiwiUlRQVmlkZW9NYXBVcGRhdGUiLCJydHBNYXAiLCJwb3N0UlRQTWFwIiwiVHJhY2tQdWJsaXNoZWQiLCJwdWIiLCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkIiwiQ29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGVkIiwiVHJhY2tVbnN1YnNjcmliZWQiLCJfIiwiVHJhY2tTdWJzY3JpYmVkIiwic2V0dXBFMkVFUmVjZWl2ZXIiLCJTaWduYWxDb25uZWN0ZWQiLCJpc0UyRUVFbmFibGVkIiwiTG9jYWxUcmFja1B1Ymxpc2hlZCIsInB1YmxpY2F0aW9uIiwic2V0dXBFMkVFU2VuZGVyIiwicGFydGljaXBhbnRJZCIsInBvc3RSYXRjaGV0UmVxdWVzdCIsImVuYWJsZU1zZyIsIlJlZmVyZW5jZUVycm9yIiwicmVtb3RlSWQiLCJoYW5kbGVSZWNlaXZlciIsImhhbmRsZVNlbmRlciIsInRyYW5zZm9ybSIsIndyaXRhYmxlU3RyZWFtIiwicmVhZGFibGUiLCJyZWFkYWJsZVN0cmVhbSIsInJlY2VpdmVyU3RyZWFtcyIsInNlbmRlclN0cmVhbXMiLCJRdWV1ZVRhc2tTdGF0dXMiLCJBc3luY1F1ZXVlIiwicGVuZGluZ1Rhc2tzIiwidGFza011dGV4IiwibmV4dFRhc2tJbmRleCIsInJ1biIsInRhc2siLCJ0YXNrSW5mbyIsImVucXVldWVkQXQiLCJXQUlUSU5HIiwiZXhlY3V0ZWRBdCIsIlJVTk5JTkciLCJDT01QTEVURUQiLCJmbHVzaCIsInNuYXBzaG90IiwicGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMiLCJjYW5QYXNzVGhyb3VnaFF1ZXVlIiwicmVxIiwiY2FuUGFzcyIsIlNpZ25hbENvbm5lY3Rpb25TdGF0ZSIsIlNpZ25hbENsaWVudCIsImN1cnJlbnRTdGF0ZSIsImlzRGlzY29ubmVjdGVkIiwiRElTQ09OTkVDVElORyIsIkRJU0NPTk5FQ1RFRCIsImlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiIsIkNPTk5FQ1RJTkciLCJSRUNPTk5FQ1RJTkciLCJ1c2VKU09OIiwicmVzZXRDYWxsYmFja3MiLCJvbkFuc3dlciIsIm9uTGVhdmUiLCJvbkxvY2FsVHJhY2tQdWJsaXNoZWQiLCJvbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsIm9uTmVnb3RpYXRlUmVxdWVzdGVkIiwib25PZmZlciIsIm9uUmVtb3RlTXV0ZUNoYW5nZWQiLCJvblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwib25Ub2tlblJlZnJlc2giLCJvblRyaWNrbGUiLCJvbkNsb3NlIiwiU2lnbmFsIiwicmVxdWVzdFF1ZXVlIiwicXVldWVkUmVxdWVzdHMiLCJjbG9zaW5nTG9jayIsImNvbm5lY3Rpb25Mb2NrIiwidG9rZW4iLCJhYm9ydFNpZ25hbCIsInJlcyIsInJlY29ubmVjdCIsImNsZWFyUGluZ0ludGVydmFsIiwicmVjb25uZWN0UmVhc29uIiwiY29ubmVjdE9wdGlvbnMiLCJjbGllbnRJbmZvIiwiY3JlYXRlQ29ubmVjdGlvblBhcmFtcyIsImFib3J0SGFuZGxlciIsIndzVGltZW91dCIsIndlYnNvY2tldFRpbWVvdXQiLCJhYm9ydGVkIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwiQ09OTkVDVEVEIiwicmVzcCIsImZldGNoIiwidG9GaXhlZCIsInRleHQiLCJoYW5kbGVXU0Vycm9yIiwic2hvdWxkUHJvY2Vzc01lc3NhZ2UiLCJwaW5nVGltZW91dER1cmF0aW9uIiwicGluZ0ludGVydmFsRHVyYXRpb24iLCJpbnRlcnZhbCIsInN0YXJ0UGluZ0ludGVydmFsIiwic2lnbmFsTGF0ZW5jeSIsImhhbmRsZVNpZ25hbFJlc3BvbnNlIiwib25jbG9zZSIsImhhbmRsZU9uQ2xvc2UiLCJjbG9zZVByb21pc2UiLCJDTE9TSU5HIiwicmFjZSIsInNlbmRPZmZlciIsIm9mZmVyIiwib2ZmZXJTZHAiLCJzZW5kUmVxdWVzdCIsInRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJzZW5kQW5zd2VyIiwiYW5zd2VyIiwiYW5zd2VyU2RwIiwic2VuZEljZUNhbmRpZGF0ZSIsInNlbmRNdXRlVHJhY2siLCJzZW5kQWRkVHJhY2siLCJzZW5kVXBkYXRlTG9jYWxNZXRhZGF0YSIsInNlbmRVcGRhdGVUcmFja1NldHRpbmdzIiwic2V0dGluZ3MiLCJzZW5kVXBkYXRlU3Vic2NyaXB0aW9uIiwic3ViIiwic2VuZFN5bmNTdGF0ZSIsInN5bmMiLCJzZW5kVXBkYXRlVmlkZW9MYXllcnMiLCJzZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJzZW5kU2ltdWxhdGVTY2VuYXJpbyIsInNlbmRQaW5nIiwic2VuZExlYXZlIiwiQ0xJRU5UX0lOSVRJQVRFRCIsImZyb21RdWV1ZSIsImNhblF1ZXVlIiwiT1BFTiIsInBpbmdIYW5kbGVkIiwic2QiLCJmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJvblBhcnRpY2lwYW50VXBkYXRlIiwib25TcGVha2Vyc0NoYW5nZWQiLCJvblJvb21VcGRhdGUiLCJvbkNvbm5lY3Rpb25RdWFsaXR5Iiwib25TdHJlYW1TdGF0ZVVwZGF0ZSIsIm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsIm9uU3Vic2NyaXB0aW9uRXJyb3IiLCJyZXNldFBpbmdUaW1lb3V0IiwibXNnQ2FzZSIsInNldFJlY29ubmVjdGVkIiwib25DbG9zZUNhbGxiYWNrIiwiY2xlYXJQaW5nVGltZW91dCIsInRvVVRDU3RyaW5nIiwicnNkIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXV0b1N1YnNjcmliZSIsInB1Ymxpc2hPbmx5IiwiYWRhcHRpdmVTdHJlYW0iLCJjb25uZWN0aW9uIiwicGFyc2VyJDEiLCJncmFtbWFyJDIiLCJncmFtbWFyJDEiLCJyZWciLCJyYXRlIiwic3VidHlwZSIsImNvbmZpZyIsInNlc3Npb25Db25maWciLCJzdHIiLCJyYWRkciIsInRjcHR5cGUiLCJnZW5lcmF0aW9uIiwiZGlyMiIsImNsa3NyY0V4dCIsIm1lZGlhQ2xvY2tWYWx1ZSIsInJhdGVOdW1lcmF0b3IiLCJyYXRlRGVub21pbmF0b3IiLCJvYmpzIiwiZ3JhbW1hckV4cG9ydHMiLCJ0b0ludElmSW50IiwiYXR0YWNoUHJvcGVydGllcyIsInJhd05hbWUiLCJwYXJzZVJlZyIsImNvbnRlbnQiLCJuZWVkc0JsYW5rIiwia2V5TG9jYXRpb24iLCJncmFtbWFyIiwidmFsaWRMaW5lIiwic2Vzc2lvbiIsInJ0cCIsImZtdHAiLCJwYXJhbVJlZHVjZXIiLCJhY2MiLCJwYXJzZVBhcmFtcyIsInBhcnNlRm10cENvbmZpZyIsInBhcnNlUGF5bG9hZHMiLCJwYXJzZVJlbW90ZUNhbmRpZGF0ZXMiLCJjYW5kaWRhdGVzIiwicGFyc2VJbWFnZUF0dHJpYnV0ZXMiLCJwYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QiLCJzY2lkIiwicGF1c2VkIiwiZm9ybWF0UmVnRXhwIiwiZm9ybWF0U3RyIiwibWFrZUxpbmUiLCJkZWZhdWx0T3V0ZXJPcmRlciIsImRlZmF1bHRJbm5lck9yZGVyIiwid3JpdGVyJDEiLCJwYXlsb2FkcyIsIm91dGVyT3JkZXIiLCJpbm5lck9yZGVyIiwicGFyc2VyIiwid3JpdGUiLCJzdGFydEJpdHJhdGVGb3JTVkMiLCJQQ0V2ZW50cyIsIk5lZ290aWF0aW9uU3RhcnRlZCIsIk5lZ290aWF0aW9uQ29tcGxldGUiLCJSVFBWaWRlb1BheWxvYWRUeXBlcyIsIlBDVHJhbnNwb3J0IiwiY3JlYXRlUEMiLCJtZWRpYUNvbnN0cmFpbnRzIiwicGVuZGluZ0NhbmRpZGF0ZXMiLCJyZXN0YXJ0aW5nSWNlIiwicmVuZWdvdGlhdGUiLCJ0cmFja0JpdHJhdGVzIiwicmVtb3RlU3RlcmVvTWlkcyIsInJlbW90ZU5hY2tNaWRzIiwibmVnb3RpYXRlIiwiY3JlYXRlQW5kU2VuZE9mZmVyIiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UiLCJvbmRhdGFjaGFubmVsIiwib25uZWdvdGlhdGlvbm5lZWRlZCIsIm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UiLCJvbmljZWNhbmRpZGF0ZSIsIm9udHJhY2siLCJvbkljZUNhbmRpZGF0ZSIsIm9uaWNlY2FuZGlkYXRlZXJyb3IiLCJvbkljZUNhbmRpZGF0ZUVycm9yIiwib25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvblNpZ25hbGluZ1N0YXRlY2hhbmdlIiwib25Db25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbkRhdGFDaGFubmVsIiwib25UcmFjayIsImlzSUNFQ29ubmVjdGVkIiwicmVtb3RlRGVzY3JpcHRpb24iLCJtdW5nZWRTRFAiLCJzdGVyZW9NaWRzIiwibmFja01pZHMiLCJleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyIiwic2RwUGFyc2VkIiwidHJhY2ticiIsImNvZGVjUGF5bG9hZCIsImZtdHBGb3VuZCIsImF0dHIiLCJtYXhiciIsInNldE11bmdlZFNEUCIsImljZVJlc3RhcnQiLCJjdXJyZW50U0QiLCJlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8iLCJlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDIiwibXNpZCIsInJvdW5kIiwiY3JlYXRlQW5kU2V0QW5zd2VyIiwiZGF0YUNoYW5uZWxEaWN0IiwidHJhbnNjZWl2ZXJJbml0Iiwic2V0VHJhY2tDb2RlY0JpdHJhdGUiLCJzZXRDb25maWd1cmF0aW9uIiwicnRjQ29uZmlnIiwiY2FuUmVtb3ZlVHJhY2siLCJnZXRDb25uZWN0aW9uU3RhdGUiLCJnZXRJQ0VDb25uZWN0aW9uU3RhdGUiLCJnZXRTaWduYWxsaW5nU3RhdGUiLCJnZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImdldFJlbW90ZURlc2NyaXB0aW9uIiwiZ2V0Q29ubmVjdGVkQWRkcmVzcyIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY2FuZGlkYXRlUGFpcnMiLCJzZWxlY3RlZCIsInNlbGVjdGVkSUQiLCJyZW1vdGVDYW5kaWRhdGVJZCIsIm11bmdlZCIsInJlbW90ZSIsIm9yaWdpbmFsU2RwIiwicmVtb3RlU2RwIiwib3B1c1BheWxvYWQiLCJydGNwRmIiLCJtYXhJRCIsImRkRm91bmQiLCJleHQiLCJkZWZhdWx0VmlkZW9Db2RlYyIsInB1Ymxpc2hEZWZhdWx0cyIsImF1ZGlvQml0cmF0ZSIsImF1ZGlvUHJlc2V0IiwiZHR4IiwicmVkIiwiZm9yY2VTdGVyZW8iLCJzY3JlZW5TaGFyZUVuY29kaW5nIiwic3RvcE1pY1RyYWNrT25NdXRlIiwidmlkZW9Db2RlYyIsImJhY2t1cENvZGVjIiwiYXV0b0dhaW5Db250cm9sIiwiZWNob0NhbmNlbGxhdGlvbiIsIm5vaXNlU3VwcHJlc3Npb24iLCJyb29tT3B0aW9uRGVmYXVsdHMiLCJkeW5hY2FzdCIsInN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2giLCJyZWNvbm5lY3RQb2xpY3kiLCJkaXNjb25uZWN0T25QYWdlTGVhdmUiLCJleHBXZWJBdWRpb01peCIsInJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMiLCJtYXhSZXRyaWVzIiwicGVlckNvbm5lY3Rpb25UaW1lb3V0IiwiUENUcmFuc3BvcnRTdGF0ZSIsIlBDVHJhbnNwb3J0TWFuYWdlciIsIm5lZWRzUHVibGlzaGVyIiwiaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJuZWVkc1N1YnNjcmliZXIiLCJpc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJ1cGRhdGVTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TRUQiLCJORVciLCJvblN0YXRlQ2hhbmdlIiwicHVibGlzaGVyIiwic3Vic2NyaWJlciIsIlBDTWFuYWdlciIsImdvb2dDb25zdHJhaW50cyIsImdvb2dEc2NwIiwiU1VCU0NSSUJFUiIsIm9uUHVibGlzaGVyT2ZmZXIiLCJyZXF1aXJlUHVibGlzaGVyIiwicmVxdWlyZSIsInJlcXVpcmVTdWJzY3JpYmVyIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInVwZGF0ZUNvbmZpZ3VyYXRpb24iLCJlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24iLCJhYm9ydENvbnRyb2xsZXIiLCJ0cmFuc3BvcnQiLCJlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQiLCJuZWdvdGlhdGlvblRpbWVvdXQiLCJzaWduYWwiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsImxvc3N5RGF0YUNoYW5uZWwiLCJyZWxpYWJsZURhdGFDaGFubmVsIiwibWluUmVjb25uZWN0V2FpdCIsImxlYXZlUmVjb25uZWN0IiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsImlzQ2xvc2VkIiwiX2lzQ2xvc2VkIiwiZnVsbFJlY29ubmVjdE9uTmV4dCIsInBjU3RhdGUiLCJOZXciLCJwZW5kaW5nVHJhY2tSZXNvbHZlcnMiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFN0YXJ0IiwiYXR0ZW1wdGluZ1JlY29ubmVjdCIsImpvaW5BdHRlbXB0cyIsIm1heEpvaW5BdHRlbXB0cyIsInNob3VsZEZhaWxOZXh0IiwiaGFuZGxlRGF0YUNoYW5uZWwiLCJyZWxpYWJsZURDU3ViIiwibG9zc3lEQ1N1YiIsImhhbmRsZURhdGFNZXNzYWdlIiwiZGF0YVByb2Nlc3NMb2NrIiwiQmxvYiIsImFycmF5QnVmZmVyIiwiZHAiLCJBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsIkRhdGFQYWNrZXRSZWNlaXZlZCIsImhhbmRsZURhdGFFcnJvciIsImN1cnJlbnRUYXJnZXQiLCJjaGFubmVsS2luZCIsIm1heFJldHJhbnNtaXRzIiwiRXJyb3JFdmVudCIsImhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93IiwiTE9TU1kiLCJ1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMiLCJoYW5kbGVEaXNjb25uZWN0IiwiZGlzY29ubmVjdFJlYXNvbiIsImRpc2Nvbm5lY3QiLCJEaXNjb25uZWN0ZWQiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiZWxhcHNlZE1zIiwiY2xlYXJSZWNvbm5lY3RUaW1lb3V0IiwicmVnaW9uVXJsUHJvdmlkZXIiLCJ1cGRhdGVUb2tlbiIsInJlY29ubmVjdFRpbWVvdXQiLCJhdHRlbXB0UmVjb25uZWN0Iiwid2FpdEZvclJlc3RhcnRlZCIsIm9uUmVzdGFydGVkIiwib25EaXNjb25uZWN0ZWQiLCJpc0J1ZmZlclN0YXR1c0xvdyIsImRjQnVmZmVyU3RhdHVzIiwiRENCdWZmZXJTdGF0dXNDaGFuZ2VkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiYnVmZmVyZWRBbW91bnQiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImhhbmRsZUJyb3dzZXJPbkxpbmUiLCJjbGllbnQiLCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEIiwiRW5naW5lIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJ1cGRhdGUiLCJTdHJlYW1TdGF0ZUNoYW5nZWQiLCJfZSIsIl9mIiwibGF0ZXN0Sm9pblJlc3BvbnNlIiwicm9vbVNpZCIsInNpZ25hbE9wdHMiLCJzZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcyIsImpvaW5SZXNwb25zZSIsInBjTWFuYWdlciIsImNvbmZpZ3VyZSIsImNsaWVudENvbmZpZ3VyYXRpb24iLCJDbG9zaW5nIiwiZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyIiwiY2xlYXJQZW5kaW5nUmVjb25uZWN0IiwiY2xlYW51cFBlZXJDb25uZWN0aW9ucyIsImNsZWFudXBDbGllbnQiLCJkY0NsZWFudXAiLCJvbmJ1ZmZlcmVkYW1vdW50bG93Iiwib25jbG9zaW5nIiwibG9zc3lEQyIsInJlbGlhYmxlREMiLCJwdWJsaWNhdGlvblRpbWVvdXQiLCJ1cGRhdGVNdXRlU3RhdHVzIiwiZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlIiwiZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcyIsInNldFJlZ2lvblVybFByb3ZpZGVyIiwicHJvdmlkZXIiLCJtYWtlUlRDQ29uZmlndXJhdGlvbiIsIlRyYW5zcG9ydHNDcmVhdGVkIiwicHVibGlzaGVyU3RhdGUiLCJzdWJzY3JpYmVyU3RhdGUiLCJzaG91bGRFbWl0IiwiUlJfU1VCU0NSSUJFUl9GQUlMRUQiLCJSUl9QVUJMSVNIRVJfRkFJTEVEIiwiTWVkaWFUcmFja0FkZGVkIiwiY3JlYXRlRGF0YUNoYW5uZWxzIiwiTG9jYWxUcmFja1VucHVibGlzaGVkIiwiUmVtb3RlTXV0ZSIsImxlYXZlIiwic2VydmVyUmVzcG9uc2UiLCJlMmVlRW5hYmxlZCIsImVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyIsInJ0Y0ljZVNlcnZlcnMiLCJpY2VTZXJ2ZXIiLCJydGNJY2VTZXJ2ZXIiLCJFTkFCTEVEIiwiaWNlVHJhbnNwb3J0UG9saWN5IiwiY29udGludWFsR2F0aGVyaW5nUG9saWN5Iiwib3JkZXJlZCIsInNldFByZWZlcnJlZENvZGVjIiwiY2FwIiwibWF0Y2hlZCIsInBhcnRpYWxNYXRjaGVkIiwidW5tYXRjaGVkIiwibWF0Y2hlc1ZpZGVvQ29kZWMiLCJzZHBGbXRwTGluZSIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJjcmVhdGVTZW5kZXIiLCJjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlciIsImNyZWF0ZVJUQ1J0cFNlbmRlciIsImNyZWF0ZVNpbXVsY2FzdFNlbmRlciIsInNpbXVsY2FzdFRyYWNrIiwiY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIiLCJzZXRTaW11bGNhc3RUcmFja1NlbmRlciIsIkRJU0FCTEVEIiwicmVzdGFydENvbm5lY3Rpb24iLCJyZWNvdmVyYWJsZSIsIlNpZ25hbFJlY29ubmVjdEVycm9yIiwiUlJfVU5LTk9XTiIsInJlZ2lvblVybCIsIlJlc3RhcnRpbmciLCJTaWduYWxSZXN0YXJ0ZWQiLCJ3YWl0Rm9yUENSZWNvbm5lY3RlZCIsInJlc2V0QXR0ZW1wdHMiLCJuZXh0UmVnaW9uVXJsIiwiZ2V0TmV4dEJlc3RSZWdpb25VcmwiLCJSZXN1bWluZyIsIlNpZ25hbFJlc3VtZWQiLCJSZXN1bWVkIiwid2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24iLCJSZWNvbm5lY3RpbmciLCJzZW5kRGF0YVBhY2tldCIsInBhY2tldCIsImVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZCIsImVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQiLCJ0cmFuc3BvcnROYW1lIiwidGFyZ2V0Q2hhbm5lbCIsImVuZFRpbWUiLCJ2ZXJpZnlUcmFuc3BvcnQiLCJBYm9ydENvbnRyb2xsZXIiLCJoYW5kbGVDbG9zZWQiLCJhYm9ydCIsInJ0cFR5cGVzIiwicmVtb3RlVHJhY2tzIiwibG9jYWxUcmFja3MiLCJwcmV2aW91c0Fuc3dlciIsInByZXZpb3VzT2ZmZXIiLCJpc0Rlc2lyZWQiLCJzdWJzY3JpcHRpb24iLCJkYXRhQ2hhbm5lbHNJbmZvIiwiZmFpbE5leHQiLCJnZXRJbmZvIiwiUmVnaW9uVXJsUHJvdmlkZXIiLCJsYXN0VXBkYXRlQXQiLCJzZXR0aW5nc0NhY2hlVGltZSIsImF0dGVtcHRlZFJlZ2lvbnMiLCJVUkwiLCJnZXRTZXJ2ZXJVcmwiLCJyZWdpb25TZXR0aW5ncyIsImZldGNoUmVnaW9uU2V0dGluZ3MiLCJyZWdpb25zTGVmdCIsImF0dGVtcHRlZCIsIm5leHRSZWdpb24iLCJyZWdpb25TZXR0aW5nc1Jlc3BvbnNlIiwiZ2V0Q2xvdWRDb25maWdVcmwiLCJoZWFkZXJzIiwiYXV0aG9yaXphdGlvbiIsInN0YXR1c1RleHQiLCJob3N0IiwibW9uaXRvckZyZXF1ZW5jeSIsImNvbXB1dGVCaXRyYXRlIiwiY3VycmVudFN0YXRzIiwicHJldlN0YXRzIiwiYnl0ZXNOb3ciLCJieXRlc1ByZXYiLCJieXRlc1JlY2VpdmVkIiwiYnl0ZXNTZW50IiwiTG9jYWxBdWRpb1RyYWNrIiwic3RvcE9uTXV0ZSIsIm1vbml0b3JTZW5kZXIiLCJnZXRTZW5kZXJTdGF0cyIsImNoZWNrRm9yU2lsZW5jZSIsInNldERldmljZUlkIiwicmVzdGFydFRyYWNrIiwiZGV2aWNlSGFzQ2hhbmdlZCIsInN0YXJ0TW9uaXRvciIsInNldEF1ZGlvQ29udGV4dCIsImF1ZGlvU3RhdHMiLCJwYWNrZXRzU2VudCIsInJvdW5kVHJpcFRpbWUiLCJqaXR0ZXIiLCJ0cmFja0lzU2lsZW50IiwiQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrIiwiTG9jYWxWaWRlb1RyYWNrIiwicHJlc2V0czE2OSIsInByZXNldHM0MyIsInByZXNldHNTY3JlZW5TaGFyZSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5IiwiZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyIsImNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzIiwiZnJvbVByZXNldCIsInZpZGVvUmlkcyIsImNvbXB1dGVWaWRlb0VuY29kaW5ncyIsImlzU2NyZWVuU2hhcmUiLCJ2aWRlb0VuY29kaW5nIiwidXNlU2ltdWxjYXN0Iiwic2NhbGFiaWxpdHlNb2RlIiwiZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyIsInNtIiwiU2NhbGFiaWxpdHlNb2RlIiwic3BhdGlhbCIsInByZXNldHMiLCJzb3J0UHJlc2V0cyIsInNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzIiwiZGVmYXVsdFNpbXVsY2FzdExheWVycyIsInZpZGVvU2ltdWxjYXN0TGF5ZXJzIiwibWlkUHJlc2V0IiwibG93UHJlc2V0IiwiZW5jb2RpbmdzRnJvbVByZXNldHMiLCJjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MiLCJzZXJ2ZXJSZXF1ZXN0ZWQiLCJwcmVzZXRzRm9yUmVzb2x1dGlvbiIsInByZXNldCIsImFzcGVjdCIsImFicyIsImNhblNldFByaW9yaXR5IiwibmV0d29ya1ByaW9yaXR5IiwidG9wRnJhbWVyYXRlIiwibm90aWZ5T25jZSIsImFFbmMiLCJiRW5jIiwicmVzdWx0cyIsInRlbXBvcmFsIiwic3VmZml4IiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsImVfMSIsIl9nIiwic2MiLCJlXzFfMSIsInJldHVybiIsImVfMiIsImVfMl8xIiwiaXRlbXMiLCJ2cyIsImZyYW1lSGVpZ2h0IiwiZnJhbWVXaWR0aCIsImZpckNvdW50IiwicGxpQ291bnQiLCJuYWNrQ291bnQiLCJmcmFtZXNTZW50IiwicmV0cmFuc21pdHRlZFBhY2tldHNTZW50IiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb24iLCJxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzIiwic2V0UHVibGlzaGluZ1F1YWxpdHkiLCJtYXhRdWFsaXR5IiwicSIsIkhJR0giLCJzZXRQdWJsaXNoaW5nTGF5ZXJzIiwiZV8zIiwiZV8zXzEiLCJlXzQiLCJfaCIsImVfNF8xIiwiYWRkU2ltdWxjYXN0VHJhY2siLCJzaW11bGNhc3RDb2RlY0luZm8iLCJzZXRQdWJsaXNoaW5nQ29kZWNzIiwiY29kZWNzXzEiLCJjb2RlY3NfMV8xIiwiZV81IiwiY3VycmVudENvZGVjIiwibmV3Q29kZWNzIiwic2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlciIsImVfNV8xIiwic2VuZGVyRW5jb2RpbmdzIiwiaGFzQ2hhbmdlZCIsImNsb3NhYmxlU3BhdGlhbCIsInZpZGVvUXVhbGl0eUZvclJpZCIsInN1YnNjcmliZWRRdWFsaXR5IiwiTUVESVVNIiwidmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIiwic3ZjIiwiZW5jb2RpbmdTTSIsInNjYWxlIiwiUmVtb3RlVHJhY2siLCJzZXRNdXRlZCIsInNldE1lZGlhU3RyZWFtIiwib25SZW1vdmVUcmFjayIsIm1vbml0b3JSZWNlaXZlciIsIlJlbW90ZUF1ZGlvVHJhY2siLCJhdWRpb091dHB1dCIsImdldFJlY2VpdmVyU3RhdHMiLCJ3ZWJBdWRpb1BsdWdpbk5vZGVzIiwic2lua0lkIiwic2V0Vm9sdW1lIiwiZ2Fpbk5vZGUiLCJzZXRUYXJnZXRBdFRpbWUiLCJfc2V0Vm9sdW1lIiwiZWxlbWVudFZvbHVtZSIsImdldFZvbHVtZSIsImhpZ2hlc3RWb2x1bWUiLCJzZXRTaW5rSWQiLCJuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbiIsImNvbm5lY3RXZWJBdWRpbyIsImRpc2Nvbm5lY3RXZWJBdWRpbyIsInNldFdlYkF1ZGlvUGx1Z2lucyIsIm5vZGVzIiwic291cmNlTm9kZSIsImxhc3ROb2RlIiwibm9kZSIsImRlc3RpbmF0aW9uIiwicmVzdW1lIiwicmVjZWl2ZXJTdGF0cyIsImNvbmNlYWxlZFNhbXBsZXMiLCJjb25jZWFsbWVudEV2ZW50cyIsInNpbGVudENvbmNlYWxlZFNhbXBsZXMiLCJzaWxlbnRDb25jZWFsbWVudEV2ZW50cyIsInRvdGFsQXVkaW9FbmVyZ3kiLCJ0b3RhbFNhbXBsZXNEdXJhdGlvbiIsIlJFQUNUSU9OX0RFTEFZIiwiUmVtb3RlVmlkZW9UcmFjayIsImFkYXB0aXZlU3RyZWFtU2V0dGluZ3MiLCJlbGVtZW50SW5mb3MiLCJkZWJvdW5jZWRIYW5kbGVSZXNpemUiLCJ1cGRhdGVEaW1lbnNpb25zIiwiaXNBZGFwdGl2ZVN0cmVhbSIsImVsZW1lbnRJbmZvIiwiSFRNTEVsZW1lbnRJbmZvIiwib2JzZXJ2ZUVsZW1lbnRJbmZvIiwidXBkYXRlVmlzaWJpbGl0eSIsIm9ic2VydmUiLCJzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8iLCJzdG9wRWxlbWVudEluZm9zIiwic3RvcE9ic2VydmluZyIsImRldGFjaGVkRWxlbWVudHMiLCJzdG9wT2JzZXJ2aW5nRWxlbWVudCIsImdldERlY29kZXJJbXBsZW1lbnRhdGlvbiIsImRlY29kZXJJbXBsZW1lbnRhdGlvbiIsImNvZGVjSUQiLCJjb2RlY0lkIiwiZnJhbWVzRGVjb2RlZCIsImZyYW1lc0Ryb3BwZWQiLCJmcmFtZXNSZWNlaXZlZCIsInBhY2tldHNSZWNlaXZlZCIsImxhc3RWaXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJpbGl0eUNoYW5nZWRBdCIsImJhY2tncm91bmRQYXVzZSIsInBhdXNlVmlkZW9JbkJhY2tncm91bmQiLCJpc1BpUE1vZGUiLCJwaWN0dXJlSW5QaWN0dXJlIiwiaXNWaXNpYmxlIiwidmlzaWJsZSIsImxhc3RWaXNpYmxlIiwiVmlzaWJpbGl0eUNoYW5nZWQiLCJwaXhlbERlbnNpdHkiLCJnZXRQaXhlbERlbnNpdHkiLCJjdXJyZW50RWxlbWVudFdpZHRoIiwiY3VycmVudEVsZW1lbnRIZWlnaHQiLCJsYXN0RGltZW5zaW9ucyIsIlZpZGVvRGltZW5zaW9uc0NoYW5nZWQiLCJpc1BpUCIsImlzSW50ZXJzZWN0aW5nIiwib25WaXNpYmlsaXR5Q2hhbmdlZCIsIm9uRW50ZXJQaVAiLCJvbkxlYXZlUGlQIiwiaXNFbGVtZW50SW5WaWV3cG9ydCIsInBpY3R1cmVJblBpY3R1cmVFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJ1bm9ic2VydmUiLCJ0b3AiLCJvZmZzZXRUb3AiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwib3BhY2l0eSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0UGFyZW50IiwicGFnZVlPZmZzZXQiLCJpbm5lckhlaWdodCIsInBhZ2VYT2Zmc2V0IiwiaW5uZXJXaWR0aCIsIlRyYWNrUHVibGljYXRpb24iLCJtZXRhZGF0YU11dGVkIiwiaGFuZGxlTXV0ZWQiLCJoYW5kbGVVbm11dGVkIiwiUHVibGljYXRpb24iLCJzZXRUcmFjayIsImlzU3Vic2NyaWJlZCIsImF1ZGlvVHJhY2siLCJ2aWRlb1RyYWNrIiwidXBkYXRlSW5mbyIsInNpbXVsY2FzdGVkIiwiU3Vic2NyaXB0aW9uU3RhdHVzIiwiUGVybWlzc2lvblN0YXR1cyIsIkxvY2FsVHJhY2tQdWJsaWNhdGlvbiIsInRpIiwiaGFuZGxlVHJhY2tFbmRlZCIsInF1YWxpdHlGcm9tUHJvdG8iLCJFWENFTExFTlQiLCJFeGNlbGxlbnQiLCJHT09EIiwiR29vZCIsIlBvb3IiLCJMT1NUIiwiTG9zdCIsIlBhcnRpY2lwYW50IiwiaXNBZ2VudCIsInBlcm1pc3Npb25zIiwiYXVkaW9MZXZlbCIsImlzU3BlYWtpbmciLCJfY29ubmVjdGlvblF1YWxpdHkiLCJhdWRpb1RyYWNrcyIsInZpZGVvVHJhY2tzIiwiZ2V0VHJhY2siLCJnZXRUcmFja0J5TmFtZSIsImNvbm5lY3Rpb25RdWFsaXR5IiwiaXNDYW1lcmFFbmFibGVkIiwiaXNNaWNyb3Bob25lRW5hYmxlZCIsImlzU2NyZWVuU2hhcmVFbmFibGVkIiwicGFydGljaXBhbnRJbmZvIiwiX3NldE5hbWUiLCJfc2V0TWV0YWRhdGEiLCJwZXJtaXNzaW9uIiwic2V0UGVybWlzc2lvbnMiLCJtZCIsImNoYW5nZWQiLCJwcmV2TWV0YWRhdGEiLCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIlBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJwcmV2UGVybWlzc2lvbnMiLCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCIsInNldElzU3BlYWtpbmciLCJzcGVha2luZyIsImxhc3RTcG9rZUF0IiwiSXNTcGVha2luZ0NoYW5nZWQiLCJzZXRDb25uZWN0aW9uUXVhbGl0eSIsInByZXZRdWFsaXR5IiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiYWRkVHJhY2tQdWJsaWNhdGlvbiIsIlRyYWNrTXV0ZWQiLCJUcmFja1VubXV0ZWQiLCJ0cmFja1Blcm1pc3Npb25Ub1Byb3RvIiwicGVybXMiLCJhbGxvd0FsbCIsImFsbG93ZWRUcmFja1NpZHMiLCJSZW1vdGVUcmFja1B1YmxpY2F0aW9uIiwiY3VycmVudFZpZGVvUXVhbGl0eSIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJlbWl0VHJhY2tVcGRhdGUiLCJoYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UiLCJ2aWRlb0RpbWVuc2lvbnMiLCJzdWJzY3JpYmVkIiwic2V0U3Vic2NyaWJlZCIsInByZXZTdGF0dXMiLCJzdWJzY3JpcHRpb25TdGF0dXMiLCJwcmV2UGVybWlzc2lvbiIsInBlcm1pc3Npb25TdGF0dXMiLCJlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkIiwiZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQiLCJVbnN1YnNjcmliZWQiLCJEZXNpcmVkIiwiU3Vic2NyaWJlZCIsIkFsbG93ZWQiLCJOb3RBbGxvd2VkIiwic2V0RW5hYmxlZCIsImlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCIsInNldFZpZGVvUXVhbGl0eSIsInNldFZpZGVvRGltZW5zaW9ucyIsInNldFZpZGVvRlBTIiwidmlkZW9RdWFsaXR5IiwicHJldlRyYWNrIiwic2V0QWxsb3dlZCIsInNldFN1YnNjcmlwdGlvbkVycm9yIiwiU3Vic2NyaXB0aW9uRmFpbGVkIiwicHJldk1ldGFkYXRhTXV0ZWQiLCJwcmV2aW91c1N0YXR1cyIsImN1cnJlbnRTdGF0dXMiLCJTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkIiwicHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzIiwiY3VycmVudFBlcm1pc3Npb25TdGF0dXMiLCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCIsIlVwZGF0ZVNldHRpbmdzIiwiUmVtb3RlUGFydGljaXBhbnQiLCJmcm9tUGFydGljaXBhbnRJbmZvIiwicGkiLCJ2b2x1bWVNYXAiLCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkIiwicHJldmlvdXNUcmFjayIsIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkIiwiYXVkaW9QdWJsaWNhdGlvbiIsImFkZFN1YnNjcmliZWRNZWRpYVRyYWNrIiwidHJpZXNMZWZ0IiwiZ2V0VHJhY2tQdWJsaWNhdGlvbiIsImlzVmlkZW8iLCJoYXNNZXRhZGF0YSIsInZhbGlkVHJhY2tzIiwibmV3VHJhY2tzIiwiZXhpc3RpbmdUcmFja09mU291cmNlIiwicHVibGlzaGVkVHJhY2siLCJvbGRUcmFjayIsInVucHVibGlzaFRyYWNrIiwic2VuZFVucHVibGlzaCIsIlRyYWNrVW5wdWJsaXNoZWQiLCJzZXRBdWRpb091dHB1dCIsInByb21pc2VzIiwiTG9jYWxQYXJ0aWNpcGFudCIsInBlbmRpbmdQdWJsaXNoaW5nIiwicGVuZGluZ1B1Ymxpc2hQcm9taXNlcyIsInBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyIsImFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSIsImVuY3J5cHRpb25UeXBlIiwiaGFuZGxlUmVjb25uZWN0aW5nIiwicmVjb25uZWN0RnV0dXJlIiwiaGFuZGxlUmVjb25uZWN0ZWQiLCJ1cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwiaGFuZGxlRGlzY29ubmVjdGVkIiwiYWxsUGFydGljaXBhbnRzQWxsb3dlZCIsIm9uVHJhY2tVbm11dGVkIiwib25UcmFja011dGVkIiwib25UcmFja1Vwc3RyZWFtUGF1c2VkIiwib25UcmFja1Vwc3RyZWFtUmVzdW1lZCIsImhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwicm9vbU9wdGlvbnMiLCJuZXdDb2RlY3NfMSIsIm5ld0NvZGVjc18xXzEiLCJwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2siLCJoYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQiLCJ1bnB1Ymxpc2hlZCIsImN1cnJlbnRQZXJtaXNzaW9ucyIsInF1ZXJ5Iiwib25jaGFuZ2UiLCJhY3RpdmVEZXZpY2VNYXAiLCJsYXN0Q2FtZXJhRXJyb3IiLCJjYW1lcmFFcnJvciIsImxhc3RNaWNyb3Bob25lRXJyb3IiLCJtaWNyb3Bob25lRXJyb3IiLCJzZXRNZXRhZGF0YSIsInNldE5hbWUiLCJzZXRDYW1lcmFFbmFibGVkIiwicHVibGlzaE9wdGlvbnMiLCJzZXRUcmFja0VuYWJsZWQiLCJzZXRNaWNyb3Bob25lRW5hYmxlZCIsInNldFNjcmVlblNoYXJlRW5hYmxlZCIsInNldEUyRUVFbmFibGVkIiwiR0NNIiwicmVwdWJsaXNoQWxsVHJhY2tzIiwiYWRkIiwiY3JlYXRlVHJhY2tzIiwiY3JlYXRlU2NyZWVuVHJhY2tzIiwicHVibGlzaFByb21pc2VzIiwibG9jYWxUcmFjayIsInB1Ymxpc2hUcmFjayIsInB1Ymxpc2hlZFRyYWNrcyIsIk1lZGlhRGV2aWNlc0Vycm9yIiwic2NyZWVuQXVkaW9UcmFjayIsImVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUiLCJhdWRpb0NhcHR1cmVEZWZhdWx0cyIsInZpZGVvQ2FwdHVyZURlZmF1bHRzIiwiQXVkaW9TdHJlYW1BY3F1aXJlZCIsImlzQXVkaW8iLCJ0cmFja0NvbnN0cmFpbnRzIiwiY29uT3JCb29sIiwic2NyZWVuVmlkZW8iLCJjb250ZW50SGludCIsInNjcmVlbkF1ZGlvIiwiZGVmYXVsdENvbnN0cmFpbnRzIiwiZGV2aWNlS2luZCIsImV4aXN0aW5nUHVibGljYXRpb24iLCJpc1N0ZXJlb0lucHV0IiwiY2hhbm5lbENvdW50IiwiaXNTdGVyZW8iLCJlMmVlIiwicHVibGlzaFByb21pc2UiLCJfaiIsIl9rIiwiX2wiLCJfbSIsIl9vIiwiZGVmYXVsdFJlcyIsInByaW1hcnlDb2RlY01pbWUiLCJ1cGRhdGVkQ29kZWMiLCJ0cmFja1RyYW5zY2VpdmVyIiwic3RvcE9uVW5wdWJsaXNoIiwiZ2V0UHVibGljYXRpb25Gb3JUcmFjayIsInB1YkxvZ0NvbnRleHQiLCJuZWdvdGlhdGlvbk5lZWRlZCIsInRyYWNrU2VuZGVyIiwiY2xlYXIiLCJ1bnB1Ymxpc2hUcmFja3MiLCJyZXN0YXJ0VHJhY2tzIiwibG9jYWxQdWJzIiwicHVibGlzaERhdGEiLCJ0b3BpYyIsInNldFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJtdXRlZE9uU2VydmVyIiwiY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSIsIlJvb21TdGF0ZSIsIl90aGlzIiwiYWN0aXZlU3BlYWtlcnMiLCJhdWRpb0VuYWJsZWQiLCJpc1ZpZGVvUGxheWJhY2tCbG9ja2VkIiwidW5sb2NrRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RMb2NrIiwiY29ubmVjdEZ1dHVyZSIsInNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0aW5nIiwiY29ubmVjdEZuIiwiYXR0ZW1wdENvbm5lY3Rpb24iLCJuZXh0VXJsIiwiY2xlYXJDb25uZWN0aW9uRnV0dXJlcyIsImNvbm5lY3RTaWduYWwiLCJlMmVlTWFuYWdlciIsInNlcnZlckluZm8iLCJhcHBseUpvaW5SZXNwb25zZSIsImhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyIsImhhbmRsZVJvb21VcGRhdGUiLCJyZWNyZWF0ZUVuZ2luZSIsIm1heWJlQ3JlYXRlRW5naW5lIiwiYWNxdWlyZUF1ZGlvQ29udGV4dCIsImNvbm5PcHRpb25zIiwic2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzIiwicmVzdWx0aW5nRXJyb3IiLCJvblBhZ2VMZWF2ZSIsImhhbmRsZURldmljZUNoYW5nZSIsInJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSIsInN0b3BUcmFja3MiLCJzdGFydEF1ZGlvIiwiZWxlbWVudHMiLCJhdWRpb0lkIiwiZHVtbXlBdWRpb0VsIiwiZ2V0RWxlbWVudEJ5SWQiLCJib2R5IiwiYXBwZW5kIiwiaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQiLCJoYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkIiwic3RhcnRWaWRlbyIsImhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkIiwiaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCIsImhhbmRsZVJlc3RhcnRpbmciLCJjbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUiLCJoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCIsImhhbmRsZVNpZ25hbFJlc3RhcnRlZCIsImNhY2hlZFBhcnRpY2lwYW50U2lkcyIsIl9wIiwiUmVjb25uZWN0ZWQiLCJQYXJ0aWNpcGFudENvbm5lY3RlZCIsInBhcnRpY2lwYW50SW5mb3MiLCJpZGVudGl0eVRvU2lkIiwicmVtb3RlUGFydGljaXBhbnQiLCJpc05ld1BhcnRpY2lwYW50IiwiZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudCIsImhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlIiwic2VlblNpZHMiLCJzcGVha2VyIiwiZW1pdFdoZW5Db25uZWN0ZWQiLCJBY3RpdmVTcGVha2Vyc0NoYW5nZWQiLCJoYW5kbGVTcGVha2Vyc0NoYW5nZWQiLCJzcGVha2VyVXBkYXRlcyIsImxhc3RTcGVha2VycyIsImhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlIiwic3RyZWFtU3RhdGVVcGRhdGUiLCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCIsImhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJoYW5kbGVTdWJzY3JpcHRpb25FcnJvciIsImhhbmRsZURhdGFQYWNrZXQiLCJ1c2VyUGFja2V0IiwiRGF0YVJlY2VpdmVkIiwiY2FuUGxheWJhY2tBdWRpbyIsIkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkIiwiVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQiLCJNZWRpYURldmljZXNDaGFuZ2VkIiwib2xkUm9vbSIsInJvb21JbmZvIiwiUm9vbU1ldGFkYXRhQ2hhbmdlZCIsIlJlY29yZGluZ1N0YXR1c0NoYW5nZWQiLCJoYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwib25Mb2NhbFRyYWNrTXV0ZWQiLCJvbkxvY2FsVHJhY2tVbm11dGVkIiwiX3EiLCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIiwiQWN0aXZlRGV2aWNlQ2hhbmdlZCIsIm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJvbk1lZGlhRGV2aWNlc0Vycm9yIiwib25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic3dpdGNoQWN0aXZlRGV2aWNlIiwic2V0dXBFMkVFIiwiaXNSZWNvcmRpbmciLCJvblRyYWNrQWRkZWQiLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwiZGlmZlBhcnRpY2lwYW50cyIsImdldExvY2FsRGV2aWNlcyIsInByZXBhcmVDb25uZWN0aW9uIiwic2ltdWxhdGVTY2VuYXJpbyIsInBvc3RBY3Rpb24iLCJjYW5QbGF5YmFja1ZpZGVvIiwiZ2V0QWN0aXZlQXVkaW9PdXRwdXREZXZpY2UiLCJnZXRBY3RpdmVEZXZpY2UiLCJzdWNjZXNzIiwiZGV2aWNlQ29uc3RyYWludCIsInByZXZEZXZpY2VJZCIsInJlY29ubmVjdGVkSGFuZGxlciIsInNob3VsZFN0b3BUcmFja3MiLCJQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCIsIm5ld0NvbnRleHRJc1J1bm5pbmciLCJjcmVhdGVQYXJ0aWNpcGFudCIsInRyYWNrUHVibGljYXRpb24iLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJjbG9zZWQiLCJ0cmFuc3BvcnRzQ29ubmVjdGVkIiwiU1RBVEVfTUlTTUFUQ0giLCJzaW11bGF0ZVBhcnRpY2lwYW50cyIsInVzZVJlYWxUcmFja3MiLCJwYXJ0aWNpcGFudE9wdGlvbnMiLCJhc3BlY3RSYXRpb3MiLCJjYW1QdWIiLCJhdWRpb1B1YiIsImR1bW15VmlkZW8iLCJfbGVuMiIsIl9rZXkyIiwibWluaW1pemVkQXJncyIsIm1hcEFyZ3MiLCJDaGVja1N0YXR1cyIsIkNoZWNrZXIiLCJJRExFIiwibG9ncyIsImVycm9yc0FzV2FybmluZ3MiLCJvbkNvbXBsZXRlIiwic2V0U3RhdHVzIiwicGVyZm9ybSIsImFwcGVuZFdhcm5pbmciLCJhcHBlbmRFcnJvciIsIlNLSVBQRUQiLCJpc1N1Y2Nlc3MiLCJTVUNDRVNTIiwiYXBwZW5kTWVzc2FnZSIsImNyZWF0ZUxvY2FsVHJhY2tzIiwibWVkaWFQcm9taXNlIiwiY3JlYXRlTG9jYWxWaWRlb1RyYWNrIiwiY3JlYXRlTG9jYWxBdWRpb1RyYWNrIiwiY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MiLCJQdWJsaXNoQXVkaW9DaGVjayIsIm51bVBhY2tldHMiLCJtZWRpYVR5cGUiLCJQdWJsaXNoVmlkZW9DaGVjayIsIlJlY29ubmVjdENoZWNrIiwicmVjb25uZWN0aW5nVHJpZ2dlcmVkIiwicmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RSZXNvbHZlciIsIlRVUk5DaGVjayIsImpvaW5SZXMiLCJoYXNUTFMiLCJoYXNUVVJOIiwiaGFzU1RVTiIsIldlYlJUQ0NoZWNrIiwiaGFzVGNwIiwiaGFzSXB2NFVkcCIsInByZXZUcmlja2xlIiwiaXNJUFByaXZhdGUiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJzZWNvbmQiLCJXZWJTb2NrZXRDaGVjayIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiZGVmYXVsdEZhY2luZ01vZGUiLCJjb25maWRlbmNlIiwicmF3RmFjaW5nTW9kZSIsImlzRmFjaW5nTW9kZVZhbHVlIiwibGFiZWxBbmFseXNpc1Jlc3VsdCIsImZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwiLCJrbm93bkRldmljZUxhYmVscyIsImtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyIsImRldmljZUxhYmVsIiwic2VjdGlvbiIsImFsbG93ZWRWYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/livekit-client/dist/livekit-client.esm.mjs\n',
      );

      /***/
    },
};
